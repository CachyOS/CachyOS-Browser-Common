
# HG changeset patch
# User stransky <stransky@redhat.com>
# Date 1655720081 0
# Node ID f1c03c3b716c8a011228d0d76376d0d8f569ea9f
# Parent  0c6d39a1c5d119771af7cb45dfc03f01442bb476
Bug 1774075 [Linux] Don't use EGL_MESA_image_dma_buf_export on mesa/radeonsi driver r=jgilbert

Don't use EGL_MESA_image_dma_buf_export on Mesa/radeonsi driver due to multi-thread crash there (https://gitlab.freedesktop.org/mesa/mesa/-/issues/6666)

Differential Revision: https://phabricator.services.mozilla.com/D149238

diff --git a/gfx/config/gfxVars.h b/gfx/config/gfxVars.h
--- a/gfx/config/gfxVars.h
+++ b/gfx/config/gfxVars.h
@@ -86,17 +86,18 @@ class gfxVarReceiver;
   _(UseDMABuf, bool, false)                                        \
   _(UseVAAPI, bool, false)                                         \
   _(WebRenderRequiresHardwareDriver, bool, false)                  \
   _(SupportsThreadsafeGL, bool, false)                             \
   _(OffscreenCanvasDomainAllowlist, nsCString, nsCString())        \
   _(AllowWebGPU, bool, false)                                      \
   _(UseVP8HwDecode, bool, false)                                   \
   _(UseVP9HwDecode, bool, false)                                   \
-  _(HwDecodedVideoZeroCopy, bool, false)
+  _(HwDecodedVideoZeroCopy, bool, false)                           \
+  _(UseDMABufSurfaceExport, bool, true)
 
 /* Add new entries above this line. */
 
 // Some graphics settings are computed on the UI process and must be
 // communicated to content and GPU processes. gfxVars helps facilitate
 // this. Its function is similar to StaticPrefs, except rather than hold
 // user preferences, it holds dynamically computed values.
 //
diff --git a/gfx/gl/SharedSurfaceDMABUF.cpp b/gfx/gl/SharedSurfaceDMABUF.cpp
--- a/gfx/gl/SharedSurfaceDMABUF.cpp
+++ b/gfx/gl/SharedSurfaceDMABUF.cpp
@@ -4,16 +4,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "SharedSurfaceDMABUF.h"
 
 #include "gfxPlatform.h"
 #include "GLContextEGL.h"
 #include "MozFramebuffer.h"
 #include "mozilla/layers/LayersSurfaces.h"  // for SurfaceDescriptor, etc
+#include "mozilla/gfx/gfxVars.h"
 
 namespace mozilla::gl {
 
 static bool HasDmaBufExtensions(const GLContextEGL* gl) {
   const auto& egl = *(gl->mEgl);
   return egl.IsExtensionSupported(EGLExtension::EXT_image_dma_buf_import) &&
          egl.IsExtensionSupported(
              EGLExtension::EXT_image_dma_buf_import_modifiers) &&
@@ -22,32 +23,49 @@ static bool HasDmaBufExtensions(const GL
 
 /*static*/
 UniquePtr<SharedSurface_DMABUF> SharedSurface_DMABUF::Create(
     const SharedSurfaceDesc& desc) {
   const auto& gle = GLContextEGL::Cast(desc.gl);
   const auto& context = gle->mContext;
   const auto& egl = *(gle->mEgl);
 
-  if (!HasDmaBufExtensions(gle)) {
-    return nullptr;
-  }
-
-  auto fb = MozFramebuffer::Create(desc.gl, desc.size, 0, false);
-  if (!fb) return nullptr;
+  RefPtr<DMABufSurface> surface;
+  UniquePtr<MozFramebuffer> fb;
 
-  const auto buffer = reinterpret_cast<EGLClientBuffer>(fb->ColorTex());
-  const auto image =
-      egl.fCreateImage(context, LOCAL_EGL_GL_TEXTURE_2D, buffer, nullptr);
-  if (!image) return nullptr;
+  if (!HasDmaBufExtensions(gle) || !gfx::gfxVars::UseDMABufSurfaceExport()) {
+    // Using MESA_image_dma_buf_export is not supported or it's broken.
+    // Create dmabuf surface directly via GBM and create
+    // EGLImage/framebuffer over it.
+    const auto flags = static_cast<DMABufSurfaceFlags>(
+        DMABUF_TEXTURE | DMABUF_USE_MODIFIERS | DMABUF_ALPHA);
+    surface = DMABufSurfaceRGBA::CreateDMABufSurface(desc.size.width,
+                                                     desc.size.height, flags);
+    if (!surface || !surface->CreateTexture(desc.gl)) {
+      return nullptr;
+    }
+    const auto tex = surface->GetTexture();
+    fb = MozFramebuffer::CreateForBacking(desc.gl, desc.size, 0, false,
+                                          LOCAL_GL_TEXTURE_2D, tex);
+    if (!fb) return nullptr;
+  } else {
+    // Use MESA_image_dma_buf_export to create EGLImage/framebuffer directly
+    // and derive dmabuf from it.
+    fb = MozFramebuffer::Create(desc.gl, desc.size, 0, false);
+    if (!fb) return nullptr;
 
-  const RefPtr<DMABufSurface> surface = DMABufSurfaceRGBA::CreateDMABufSurface(
-      desc.gl, image, desc.size.width, desc.size.height);
-  if (!surface) return nullptr;
+    const auto buffer = reinterpret_cast<EGLClientBuffer>(fb->ColorTex());
+    const auto image =
+        egl.fCreateImage(context, LOCAL_EGL_GL_TEXTURE_2D, buffer, nullptr);
+    if (!image) return nullptr;
 
+    surface = DMABufSurfaceRGBA::CreateDMABufSurface(
+        desc.gl, image, desc.size.width, desc.size.height);
+    if (!surface) return nullptr;
+  }
   return AsUnique(new SharedSurface_DMABUF(desc, std::move(fb), surface));
 }
 
 SharedSurface_DMABUF::SharedSurface_DMABUF(const SharedSurfaceDesc& desc,
                                            UniquePtr<MozFramebuffer> fb,
                                            const RefPtr<DMABufSurface> surface)
     : SharedSurface(desc, std::move(fb)), mSurface(surface) {}
 
diff --git a/gfx/thebes/gfxPlatform.cpp b/gfx/thebes/gfxPlatform.cpp
--- a/gfx/thebes/gfxPlatform.cpp
+++ b/gfx/thebes/gfxPlatform.cpp
@@ -2856,16 +2856,27 @@ void gfxPlatform::InitWebGLConfig() {
     // Don't enable robust buffer access on Adreno 630 devices.
     // It causes the linking of some shaders to fail. See bug 1485441.
     nsAutoString renderer;
     gfxInfo->GetAdapterDeviceID(renderer);
     if (renderer.Find("Adreno (TM) 630") != -1) {
       gfxVars::SetAllowEglRbab(false);
     }
   }
+
+  if (kIsWayland || kIsX11) {
+    // Disable EGL_MESA_image_dma_buf_export on mesa/radeonsi due to
+    // https://gitlab.freedesktop.org/mesa/mesa/-/issues/6666
+    nsString adapterDriverVendor;
+    gfxInfo->GetAdapterDriverVendor(adapterDriverVendor);
+    if (adapterDriverVendor.Find("mesa") != -1 &&
+        adapterDriverVendor.Find("radeonsi") != -1) {
+      gfxVars::SetUseDMABufSurfaceExport(false);
+    }
+  }
 }
 
 void gfxPlatform::InitWebGPUConfig() {
   if (!XRE_IsParentProcess()) {
     return;
   }
 
   FeatureState& feature = gfxConfig::GetFeature(Feature::WEBGPU);

