From 2980ff1160bfff794c78be62a3d04905a3839771 Mon Sep 17 00:00:00 2001
From: Peter Jung <admin@ptr1337.dev>
Date: Wed, 1 Jun 2022 20:30:02 +0200
Subject: [PATCH] kde-unity

Signed-off-by: Peter Jung <admin@ptr1337.dev>
---
 browser/base/content/browser-menubar.inc      |    7 +-
 browser/base/content/browser.js               |    7 +
 browser/base/content/browser.js.orig          | 9962 +++++++++++++++++
 .../components/places/content/places.xhtml    |    1 +
 .../places/content/places.xhtml.orig          |  413 +
 dom/xul/XULPopupElement.cpp                   |    9 +
 dom/xul/moz.build                             |    5 +
 layout/build/moz.build                        |    4 +
 modules/libpref/Preferences.cpp               |   14 +-
 modules/libpref/init/all.js                   |    3 +
 modules/libpref/init/all.js.orig              | 4587 ++++++++
 modules/libpref/moz.build                     |    4 +
 python/mozbuild/mozpack/chrome/flags.py       |    1 +
 python/mozbuild/mozpack/chrome/manifest.py    |    1 +
 toolkit/components/downloads/moz.build        |    4 +
 toolkit/content/xul.css                       |    7 +
 toolkit/content/xul.css.orig                  |  631 ++
 toolkit/mozapps/downloads/HelperAppDlg.jsm    |   70 +-
 .../unixproxy/nsUnixSystemProxySettings.cpp   |   32 +
 .../nsUnixSystemProxySettings.cpp.orig        |  397 +
 toolkit/xre/moz.build                         |    2 +
 toolkit/xre/nsKDEUtils.cpp                    |  321 +
 toolkit/xre/nsKDEUtils.h                      |   48 +
 uriloader/exthandler/HandlerServiceParent.cpp |    6 +-
 uriloader/exthandler/moz.build                |    3 +
 .../exthandler/unix/nsCommonRegistry.cpp      |   53 +
 uriloader/exthandler/unix/nsCommonRegistry.h  |   28 +
 uriloader/exthandler/unix/nsKDERegistry.cpp   |   89 +
 uriloader/exthandler/unix/nsKDERegistry.h     |   34 +
 uriloader/exthandler/unix/nsMIMEInfoUnix.cpp  |   30 +-
 .../exthandler/unix/nsOSHelperAppService.cpp  |   10 +-
 widget/gtk/NativeMenuSupport.cpp              |   11 +-
 widget/gtk/NativeMenuSupport.h                |   31 +
 widget/gtk/components.conf                    |    8 +
 widget/gtk/components.conf.orig               |  158 +
 widget/gtk/moz.build                          |   11 +
 widget/gtk/moz.build.orig                     |  202 +
 widget/gtk/nsDbusmenu.cpp                     |   61 +
 widget/gtk/nsDbusmenu.h                       |  101 +
 widget/gtk/nsFilePicker.cpp                   |  258 +-
 widget/gtk/nsFilePicker.h                     |    6 +
 widget/gtk/nsMenu.cpp                         |  795 ++
 widget/gtk/nsMenu.h                           |  123 +
 widget/gtk/nsMenuBar.cpp                      |  548 +
 widget/gtk/nsMenuBar.h                        |  111 +
 widget/gtk/nsMenuContainer.cpp                |  170 +
 widget/gtk/nsMenuContainer.h                  |   70 +
 widget/gtk/nsMenuItem.cpp                     |  766 ++
 widget/gtk/nsMenuItem.h                       |   80 +
 widget/gtk/nsMenuObject.cpp                   |  664 ++
 widget/gtk/nsMenuObject.h                     |  169 +
 widget/gtk/nsMenuSeparator.cpp                |   82 +
 widget/gtk/nsMenuSeparator.h                  |   37 +
 widget/gtk/nsNativeMenuDocListener.cpp        |  347 +
 widget/gtk/nsNativeMenuDocListener.h          |  152 +
 widget/gtk/nsNativeMenuService.cpp            |  478 +
 widget/gtk/nsNativeMenuService.h              |   85 +
 widget/gtk/nsWindow.cpp                       |    4 +
 widget/gtk/nsWindow.cpp.orig                  | 9361 ++++++++++++++++
 widget/gtk/nsWindow.h                         |    6 +
 widget/gtk/nsWindow.h.orig                    |  923 ++
 widget/moz.build                              |    5 +
 widget/nsINativeMenuService.h                 |   39 +
 widget/nsWidgetsCID.h                         |    8 +
 xpcom/components/ManifestParser.cpp           |   11 +-
 xpcom/components/moz.build                    |    1 +
 xpcom/ds/NativeMenuAtoms.py                   |    9 +
 xpcom/ds/StaticAtoms.py                       |    3 +-
 xpcom/ds/StaticAtoms.py.orig                  | 2615 +++++
 xpcom/io/nsLocalFileUnix.cpp                  |   21 +-
 xpfe/appshell/AppWindow.cpp                   |    2 +-
 71 files changed, 35273 insertions(+), 42 deletions(-)
 create mode 100644 browser/base/content/browser.js.orig
 create mode 100644 browser/components/places/content/places.xhtml.orig
 create mode 100644 modules/libpref/init/all.js.orig
 create mode 100644 toolkit/content/xul.css.orig
 create mode 100644 toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp.orig
 create mode 100644 toolkit/xre/nsKDEUtils.cpp
 create mode 100644 toolkit/xre/nsKDEUtils.h
 create mode 100644 uriloader/exthandler/unix/nsCommonRegistry.cpp
 create mode 100644 uriloader/exthandler/unix/nsCommonRegistry.h
 create mode 100644 uriloader/exthandler/unix/nsKDERegistry.cpp
 create mode 100644 uriloader/exthandler/unix/nsKDERegistry.h
 create mode 100644 widget/gtk/NativeMenuSupport.h
 create mode 100644 widget/gtk/components.conf.orig
 create mode 100644 widget/gtk/moz.build.orig
 create mode 100644 widget/gtk/nsDbusmenu.cpp
 create mode 100644 widget/gtk/nsDbusmenu.h
 create mode 100644 widget/gtk/nsMenu.cpp
 create mode 100644 widget/gtk/nsMenu.h
 create mode 100644 widget/gtk/nsMenuBar.cpp
 create mode 100644 widget/gtk/nsMenuBar.h
 create mode 100644 widget/gtk/nsMenuContainer.cpp
 create mode 100644 widget/gtk/nsMenuContainer.h
 create mode 100644 widget/gtk/nsMenuItem.cpp
 create mode 100644 widget/gtk/nsMenuItem.h
 create mode 100644 widget/gtk/nsMenuObject.cpp
 create mode 100644 widget/gtk/nsMenuObject.h
 create mode 100644 widget/gtk/nsMenuSeparator.cpp
 create mode 100644 widget/gtk/nsMenuSeparator.h
 create mode 100644 widget/gtk/nsNativeMenuDocListener.cpp
 create mode 100644 widget/gtk/nsNativeMenuDocListener.h
 create mode 100644 widget/gtk/nsNativeMenuService.cpp
 create mode 100644 widget/gtk/nsNativeMenuService.h
 create mode 100644 widget/gtk/nsWindow.cpp.orig
 create mode 100644 widget/gtk/nsWindow.h.orig
 create mode 100644 widget/nsINativeMenuService.h
 create mode 100644 xpcom/ds/NativeMenuAtoms.py
 create mode 100644 xpcom/ds/StaticAtoms.py.orig

diff --git a/browser/base/content/browser-menubar.inc b/browser/base/content/browser-menubar.inc
index 1adea92456..9cb91a4bef 100644
--- a/browser/base/content/browser-menubar.inc
+++ b/browser/base/content/browser-menubar.inc
@@ -7,7 +7,12 @@
 # On macOS, we don't track whether activation of the native menubar happened
 # with the keyboard.
 #ifndef XP_MACOSX
-                onpopupshowing="if (event.target.parentNode.parentNode == this)
+                onpopupshowing="if (event.target.parentNode.parentNode == this &amp;&amp;
+#ifdef MOZ_WIDGET_GTK
+                                    document.documentElement.getAttribute('shellshowingmenubar') != 'true')
+#else
+                                    true)
+#endif
                                   this.setAttribute('openedwithkey',
                                                     event.target.parentNode.openedWithKey);"
 #endif
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
index 6d276924bf..fb60df7195 100644
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -6482,11 +6482,18 @@ function onViewToolbarsPopupShowing(aEvent, aInsertPoint) {
   MozXULElement.insertFTLIfNeeded("browser/toolbarContextMenu.ftl");
   let firstMenuItem = aInsertPoint || popup.firstElementChild;
   let toolbarNodes = gNavToolbox.querySelectorAll("toolbar");
+
+  let shellShowingMenubar = document.documentElement.getAttribute("shellshowingmenubar") == "true";
+
   for (let toolbar of toolbarNodes) {
     if (!toolbar.hasAttribute("toolbarname")) {
       continue;
     }
 
+    if (shellShowingMenubar && toolbar.id == "toolbar-menubar") {
+      continue;
+    }
+
     if (toolbar.id == "PersonalToolbar") {
       let menu = BookmarkingUI.buildBookmarksToolbarSubmenu(toolbar);
       popup.insertBefore(menu, firstMenuItem);
diff --git a/browser/base/content/browser.js.orig b/browser/base/content/browser.js.orig
new file mode 100644
index 0000000000..6d276924bf
--- /dev/null
+++ b/browser/base/content/browser.js.orig
@@ -0,0 +1,9962 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+var { XPCOMUtils } = ChromeUtils.import(
+  "resource://gre/modules/XPCOMUtils.jsm"
+);
+var { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
+var { AppConstants } = ChromeUtils.import(
+  "resource://gre/modules/AppConstants.jsm"
+);
+ChromeUtils.import("resource://gre/modules/NotificationDB.jsm");
+
+// lazy module getters
+
+XPCOMUtils.defineLazyModuleGetters(this, {
+  AboutNewTab: "resource:///modules/AboutNewTab.jsm",
+  AboutReaderParent: "resource:///actors/AboutReaderParent.jsm",
+  AddonManager: "resource://gre/modules/AddonManager.jsm",
+  AMTelemetry: "resource://gre/modules/AddonManager.jsm",
+  NewTabPagePreloading: "resource:///modules/NewTabPagePreloading.jsm",
+  BrowserSearchTelemetry: "resource:///modules/BrowserSearchTelemetry.jsm",
+  BrowserUsageTelemetry: "resource:///modules/BrowserUsageTelemetry.jsm",
+  BrowserTelemetryUtils: "resource://gre/modules/BrowserTelemetryUtils.jsm",
+  BrowserUIUtils: "resource:///modules/BrowserUIUtils.jsm",
+  BrowserWindowTracker: "resource:///modules/BrowserWindowTracker.jsm",
+  CFRPageActions: "resource://activity-stream/lib/CFRPageActions.jsm",
+  Color: "resource://gre/modules/Color.jsm",
+  ContextualIdentityService:
+    "resource://gre/modules/ContextualIdentityService.jsm",
+  CustomizableUI: "resource:///modules/CustomizableUI.jsm",
+  Deprecated: "resource://gre/modules/Deprecated.jsm",
+  DevToolsSocketStatus:
+    "resource://devtools/shared/security/DevToolsSocketStatus.jsm",
+  DownloadsCommon: "resource:///modules/DownloadsCommon.jsm",
+  DownloadUtils: "resource://gre/modules/DownloadUtils.jsm",
+  E10SUtils: "resource://gre/modules/E10SUtils.jsm",
+  NimbusFeatures: "resource://nimbus/ExperimentAPI.jsm",
+  ExtensionsUI: "resource:///modules/ExtensionsUI.jsm",
+  HomePage: "resource:///modules/HomePage.jsm",
+  LightweightThemeConsumer:
+    "resource://gre/modules/LightweightThemeConsumer.jsm",
+  Log: "resource://gre/modules/Log.jsm",
+  LoginHelper: "resource://gre/modules/LoginHelper.jsm",
+  LoginManagerParent: "resource://gre/modules/LoginManagerParent.jsm",
+  MigrationUtils: "resource:///modules/MigrationUtils.jsm",
+  NetUtil: "resource://gre/modules/NetUtil.jsm",
+  NewTabUtils: "resource://gre/modules/NewTabUtils.jsm",
+  OpenInTabsUtils: "resource:///modules/OpenInTabsUtils.jsm",
+  PageActions: "resource:///modules/PageActions.jsm",
+  PageThumbs: "resource://gre/modules/PageThumbs.jsm",
+  PanelMultiView: "resource:///modules/PanelMultiView.jsm",
+  PanelView: "resource:///modules/PanelMultiView.jsm",
+  PictureInPicture: "resource://gre/modules/PictureInPicture.jsm",
+  PlacesUtils: "resource://gre/modules/PlacesUtils.jsm",
+  PlacesUIUtils: "resource:///modules/PlacesUIUtils.jsm",
+  PlacesTransactions: "resource://gre/modules/PlacesTransactions.jsm",
+  PluralForm: "resource://gre/modules/PluralForm.jsm",
+  Pocket: "chrome://pocket/content/Pocket.jsm",
+  PrivateBrowsingUtils: "resource://gre/modules/PrivateBrowsingUtils.jsm",
+  ProcessHangMonitor: "resource:///modules/ProcessHangMonitor.jsm",
+  PromiseUtils: "resource://gre/modules/PromiseUtils.jsm",
+  PromptUtils: "resource://gre/modules/SharedPromptUtils.jsm",
+  // TODO (Bug 1529552): Remove once old urlbar code goes away.
+  ReaderMode: "resource://gre/modules/ReaderMode.jsm",
+  RFPHelper: "resource://gre/modules/RFPHelper.jsm",
+  SafeBrowsing: "resource://gre/modules/SafeBrowsing.jsm",
+  Sanitizer: "resource:///modules/Sanitizer.jsm",
+  SaveToPocket: "chrome://pocket/content/SaveToPocket.jsm",
+  ScreenshotsUtils: "resource:///modules/ScreenshotsUtils.jsm",
+  SessionStartup: "resource:///modules/sessionstore/SessionStartup.jsm",
+  SessionStore: "resource:///modules/sessionstore/SessionStore.jsm",
+  ShortcutUtils: "resource://gre/modules/ShortcutUtils.jsm",
+  SiteDataManager: "resource:///modules/SiteDataManager.jsm",
+  SitePermissions: "resource:///modules/SitePermissions.jsm",
+  SubDialog: "resource://gre/modules/SubDialog.jsm",
+  SubDialogManager: "resource://gre/modules/SubDialog.jsm",
+  TabModalPrompt: "chrome://global/content/tabprompts.jsm",
+  TabCrashHandler: "resource:///modules/ContentCrashHandlers.jsm",
+  TelemetryEnvironment: "resource://gre/modules/TelemetryEnvironment.jsm",
+  Translation: "resource:///modules/translation/TranslationParent.jsm",
+  UITour: "resource:///modules/UITour.jsm",
+  UpdateUtils: "resource://gre/modules/UpdateUtils.jsm",
+  UrlbarInput: "resource:///modules/UrlbarInput.jsm",
+  UrlbarPrefs: "resource:///modules/UrlbarPrefs.jsm",
+  UrlbarProviderSearchTips: "resource:///modules/UrlbarProviderSearchTips.jsm",
+  UrlbarTokenizer: "resource:///modules/UrlbarTokenizer.jsm",
+  UrlbarUtils: "resource:///modules/UrlbarUtils.jsm",
+  UrlbarValueFormatter: "resource:///modules/UrlbarValueFormatter.jsm",
+  Weave: "resource://services-sync/main.js",
+  WebNavigationFrames: "resource://gre/modules/WebNavigationFrames.jsm",
+  fxAccounts: "resource://gre/modules/FxAccounts.jsm",
+  webrtcUI: "resource:///modules/webrtcUI.jsm",
+  WebsiteFilter: "resource:///modules/policies/WebsiteFilter.jsm",
+  ZoomUI: "resource:///modules/ZoomUI.jsm",
+});
+
+if (AppConstants.MOZ_CRASHREPORTER) {
+  ChromeUtils.defineModuleGetter(
+    this,
+    "PluginCrashReporter",
+    "resource:///modules/ContentCrashHandlers.jsm"
+  );
+}
+
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "PlacesTreeView",
+  "chrome://browser/content/places/treeView.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  ["PlacesInsertionPoint", "PlacesController", "PlacesControllerDragHelper"],
+  "chrome://browser/content/places/controller.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "PrintUtils",
+  "chrome://global/content/printUtils.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "ZoomManager",
+  "chrome://global/content/viewZoomOverlay.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "FullZoom",
+  "chrome://browser/content/browser-fullZoom.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "PanelUI",
+  "chrome://browser/content/customizableui/panelUI.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "gViewSourceUtils",
+  "chrome://global/content/viewSourceUtils.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "gTabsPanel",
+  "chrome://browser/content/browser-allTabsMenu.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  ["BrowserAddonUI", "gExtensionsNotifications", "gXPInstallObserver"],
+  "chrome://browser/content/browser-addons.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "ctrlTab",
+  "chrome://browser/content/browser-ctrlTab.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  ["CustomizationHandler", "AutoHideMenubar"],
+  "chrome://browser/content/browser-customization.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  ["PointerLock", "FullScreen"],
+  "chrome://browser/content/browser-fullScreenAndPointerLock.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "gIdentityHandler",
+  "chrome://browser/content/browser-siteIdentity.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "gPermissionPanel",
+  "chrome://browser/content/browser-sitePermissionPanel.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "gProtectionsHandler",
+  "chrome://browser/content/browser-siteProtections.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  ["gGestureSupport", "gHistorySwipeAnimation"],
+  "chrome://browser/content/browser-gestureSupport.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "gSafeBrowsing",
+  "chrome://browser/content/browser-safebrowsing.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "gSync",
+  "chrome://browser/content/browser-sync.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "gBrowserThumbnails",
+  "chrome://browser/content/browser-thumbnails.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  ["openContextMenu", "nsContextMenu"],
+  "chrome://browser/content/nsContextMenu.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  [
+    "DownloadsPanel",
+    "DownloadsOverlayLoader",
+    "DownloadsView",
+    "DownloadsViewUI",
+    "DownloadsViewController",
+    "DownloadsSummary",
+    "DownloadsFooter",
+    "DownloadsBlockedSubview",
+  ],
+  "chrome://browser/content/downloads/downloads.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  ["DownloadsButton", "DownloadsIndicatorView"],
+  "chrome://browser/content/downloads/indicator.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "gEditItemOverlay",
+  "chrome://browser/content/places/instantEditBookmark.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "gGfxUtils",
+  "chrome://browser/content/browser-graphics-utils.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "pktUI",
+  "chrome://pocket/content/pktUI.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "ToolbarKeyboardNavigator",
+  "chrome://browser/content/browser-toolbarKeyNav.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "A11yUtils",
+  "chrome://browser/content/browser-a11yUtils.js"
+);
+XPCOMUtils.defineLazyScriptGetter(
+  this,
+  "gSharedTabWarning",
+  "chrome://browser/content/browser-webrtc.js"
+);
+
+// lazy service getters
+
+XPCOMUtils.defineLazyServiceGetters(this, {
+  ContentPrefService2: [
+    "@mozilla.org/content-pref/service;1",
+    "nsIContentPrefService2",
+  ],
+  classifierService: [
+    "@mozilla.org/url-classifier/dbservice;1",
+    "nsIURIClassifier",
+  ],
+  Favicons: ["@mozilla.org/browser/favicon-service;1", "nsIFaviconService"],
+  gDNSService: ["@mozilla.org/network/dns-service;1", "nsIDNSService"],
+  gSerializationHelper: [
+    "@mozilla.org/network/serialization-helper;1",
+    "nsISerializationHelper",
+  ],
+  WindowsUIUtils: ["@mozilla.org/windows-ui-utils;1", "nsIWindowsUIUtils"],
+  BrowserHandler: ["@mozilla.org/browser/clh;1", "nsIBrowserHandler"],
+});
+
+if (AppConstants.MOZ_CRASHREPORTER) {
+  XPCOMUtils.defineLazyServiceGetter(
+    this,
+    "gCrashReporter",
+    "@mozilla.org/xre/app-info;1",
+    "nsICrashReporter"
+  );
+}
+
+if (AppConstants.ENABLE_WEBDRIVER) {
+  XPCOMUtils.defineLazyServiceGetter(
+    this,
+    "Marionette",
+    "@mozilla.org/remote/marionette;1",
+    "nsIMarionette"
+  );
+
+  XPCOMUtils.defineLazyServiceGetter(
+    this,
+    "RemoteAgent",
+    "@mozilla.org/remote/agent;1",
+    "nsIRemoteAgent"
+  );
+} else {
+  this.Marionette = { running: false };
+  this.RemoteAgent = { running: false };
+}
+
+XPCOMUtils.defineLazyGetter(this, "RTL_UI", () => {
+  return Services.locale.isAppLocaleRTL;
+});
+
+XPCOMUtils.defineLazyGetter(this, "gBrandBundle", () => {
+  return Services.strings.createBundle(
+    "chrome://branding/locale/brand.properties"
+  );
+});
+
+XPCOMUtils.defineLazyGetter(this, "gBrowserBundle", () => {
+  return Services.strings.createBundle(
+    "chrome://browser/locale/browser.properties"
+  );
+});
+
+XPCOMUtils.defineLazyGetter(this, "gTabBrowserBundle", () => {
+  return Services.strings.createBundle(
+    "chrome://browser/locale/tabbrowser.properties"
+  );
+});
+
+XPCOMUtils.defineLazyGetter(this, "gCustomizeMode", () => {
+  let { CustomizeMode } = ChromeUtils.import(
+    "resource:///modules/CustomizeMode.jsm"
+  );
+  return new CustomizeMode(window);
+});
+
+XPCOMUtils.defineLazyGetter(this, "gNavToolbox", () => {
+  return document.getElementById("navigator-toolbox");
+});
+
+XPCOMUtils.defineLazyGetter(this, "gURLBar", () => {
+  let urlbar = new UrlbarInput({
+    textbox: document.getElementById("urlbar"),
+    eventTelemetryCategory: "urlbar",
+  });
+
+  let beforeFocusOrSelect = event => {
+    // In customize mode, the url bar is disabled. If a new tab is opened or the
+    // user switches to a different tab, this function gets called before we've
+    // finished leaving customize mode, and the url bar will still be disabled.
+    // We can't focus it when it's disabled, so we need to re-run ourselves when
+    // we've finished leaving customize mode.
+    if (
+      CustomizationHandler.isCustomizing() ||
+      CustomizationHandler.isExitingCustomizeMode
+    ) {
+      gNavToolbox.addEventListener(
+        "aftercustomization",
+        () => {
+          if (event.type == "beforeselect") {
+            gURLBar.select();
+          } else {
+            gURLBar.focus();
+          }
+        },
+        {
+          once: true,
+        }
+      );
+      event.preventDefault();
+      return;
+    }
+
+    if (window.fullScreen) {
+      FullScreen.showNavToolbox();
+    }
+  };
+  urlbar.addEventListener("beforefocus", beforeFocusOrSelect);
+  urlbar.addEventListener("beforeselect", beforeFocusOrSelect);
+
+  return urlbar;
+});
+
+XPCOMUtils.defineLazyGetter(this, "ReferrerInfo", () =>
+  Components.Constructor(
+    "@mozilla.org/referrer-info;1",
+    "nsIReferrerInfo",
+    "init"
+  )
+);
+
+// High priority notification bars shown at the top of the window.
+XPCOMUtils.defineLazyGetter(this, "gNotificationBox", () => {
+  return new MozElements.NotificationBox(element => {
+    element.classList.add("global-notificationbox");
+    element.setAttribute("notificationside", "top");
+    element.setAttribute("prepend-notifications", true);
+    // Notification messages use the CSS box model. When using
+    // negative margins on those notification messages to animate them in or out,
+    // if the ancestry of that node is all using the XUL box model, strange glitches
+    // arise. We sidestep this by containing the global notification box within a
+    // <div> that has CSS block layout.
+    let outer = document.createElement("div");
+    outer.appendChild(element);
+    let tabNotifications = document.getElementById("tab-notification-deck");
+    gNavToolbox.insertBefore(outer, tabNotifications);
+  });
+});
+
+XPCOMUtils.defineLazyGetter(this, "InlineSpellCheckerUI", () => {
+  let { InlineSpellChecker } = ChromeUtils.import(
+    "resource://gre/modules/InlineSpellChecker.jsm"
+  );
+  return new InlineSpellChecker();
+});
+
+XPCOMUtils.defineLazyGetter(this, "PageMenuParent", () => {
+  // eslint-disable-next-line no-shadow
+  let { PageMenuParent } = ChromeUtils.import(
+    "resource://gre/modules/PageMenu.jsm"
+  );
+  return new PageMenuParent();
+});
+
+XPCOMUtils.defineLazyGetter(this, "PopupNotifications", () => {
+  // eslint-disable-next-line no-shadow
+  let { PopupNotifications } = ChromeUtils.import(
+    "resource://gre/modules/PopupNotifications.jsm"
+  );
+  try {
+    // Hide all PopupNotifications while the URL is being edited and the
+    // address bar has focus, including the virtual focus in the results popup.
+    let shouldSuppress = () =>
+      (gURLBar.getAttribute("pageproxystate") != "valid" && gURLBar.focused) ||
+      shouldSuppressPopupNotifications();
+    return new PopupNotifications(
+      gBrowser,
+      document.getElementById("notification-popup"),
+      document.getElementById("notification-popup-box"),
+      { shouldSuppress }
+    );
+  } catch (ex) {
+    Cu.reportError(ex);
+    return null;
+  }
+});
+
+XPCOMUtils.defineLazyGetter(this, "MacUserActivityUpdater", () => {
+  if (AppConstants.platform != "macosx") {
+    return null;
+  }
+
+  return Cc["@mozilla.org/widget/macuseractivityupdater;1"].getService(
+    Ci.nsIMacUserActivityUpdater
+  );
+});
+
+XPCOMUtils.defineLazyGetter(this, "Win7Features", () => {
+  if (AppConstants.platform != "win") {
+    return null;
+  }
+
+  const WINTASKBAR_CONTRACTID = "@mozilla.org/windows-taskbar;1";
+  if (
+    WINTASKBAR_CONTRACTID in Cc &&
+    Cc[WINTASKBAR_CONTRACTID].getService(Ci.nsIWinTaskbar).available
+  ) {
+    let { AeroPeek } = ChromeUtils.import(
+      "resource:///modules/WindowsPreviewPerTab.jsm"
+    );
+    return {
+      onOpenWindow() {
+        AeroPeek.onOpenWindow(window);
+        this.handledOpening = true;
+      },
+      onCloseWindow() {
+        if (this.handledOpening) {
+          AeroPeek.onCloseWindow(window);
+        }
+      },
+      handledOpening: false,
+    };
+  }
+  return null;
+});
+
+XPCOMUtils.defineLazyPreferenceGetter(
+  this,
+  "gToolbarKeyNavEnabled",
+  "browser.toolbars.keyboard_navigation",
+  false,
+  (aPref, aOldVal, aNewVal) => {
+    if (window.closed) {
+      return;
+    }
+    if (aNewVal) {
+      ToolbarKeyboardNavigator.init();
+    } else {
+      ToolbarKeyboardNavigator.uninit();
+    }
+  }
+);
+
+XPCOMUtils.defineLazyPreferenceGetter(
+  this,
+  "gBookmarksToolbarVisibility",
+  "browser.toolbars.bookmarks.visibility",
+  "newtab"
+);
+
+XPCOMUtils.defineLazyPreferenceGetter(
+  this,
+  "gFxaToolbarEnabled",
+  "identity.fxaccounts.toolbar.enabled",
+  false,
+  (aPref, aOldVal, aNewVal) => {
+    updateFxaToolbarMenu(aNewVal);
+  }
+);
+
+XPCOMUtils.defineLazyPreferenceGetter(
+  this,
+  "gFxaToolbarAccessed",
+  "identity.fxaccounts.toolbar.accessed",
+  false,
+  (aPref, aOldVal, aNewVal) => {
+    updateFxaToolbarMenu(gFxaToolbarEnabled);
+  }
+);
+
+XPCOMUtils.defineLazyPreferenceGetter(
+  this,
+  "gAddonAbuseReportEnabled",
+  "extensions.abuseReport.enabled",
+  false
+);
+
+/* Temporary pref while the dust settles around the updated tooltip design
+   for tabs and bookmarks toolbar. This is a bit of an orphan from the
+   proton project. We should figure out what happens with this in
+   bug 1746909. */
+XPCOMUtils.defineLazyPreferenceGetter(
+  this,
+  "gProtonPlacesTooltip",
+  "browser.proton.places-tooltip.enabled",
+  false
+);
+
+customElements.setElementCreationCallback("translation-notification", () => {
+  Services.scriptloader.loadSubScript(
+    "chrome://browser/content/translation-notification.js",
+    window
+  );
+});
+
+customElements.setElementCreationCallback("screenshots-buttons", () => {
+  Services.scriptloader.loadSubScript(
+    "chrome://browser/content/screenshots/screenshots-buttons.js",
+    window
+  );
+});
+
+var gBrowser;
+var gContextMenu = null; // nsContextMenu instance
+var gMultiProcessBrowser = window.docShell.QueryInterface(Ci.nsILoadContext)
+  .useRemoteTabs;
+var gFissionBrowser = window.docShell.QueryInterface(Ci.nsILoadContext)
+  .useRemoteSubframes;
+
+var gBrowserAllowScriptsToCloseInitialTabs = false;
+
+if (AppConstants.platform != "macosx") {
+  var gEditUIVisible = true;
+}
+
+Object.defineProperty(this, "gReduceMotion", {
+  enumerable: true,
+  get() {
+    return typeof gReduceMotionOverride == "boolean"
+      ? gReduceMotionOverride
+      : gReduceMotionSetting;
+  },
+});
+// Reduce motion during startup. The setting will be reset later.
+let gReduceMotionSetting = true;
+// This is for tests to set.
+var gReduceMotionOverride;
+
+// Smart getter for the findbar.  If you don't wish to force the creation of
+// the findbar, check gFindBarInitialized first.
+
+Object.defineProperty(this, "gFindBar", {
+  enumerable: true,
+  get() {
+    return gBrowser.getCachedFindBar();
+  },
+});
+
+Object.defineProperty(this, "gFindBarInitialized", {
+  enumerable: true,
+  get() {
+    return gBrowser.isFindBarInitialized();
+  },
+});
+
+Object.defineProperty(this, "gFindBarPromise", {
+  enumerable: true,
+  get() {
+    return gBrowser.getFindBar();
+  },
+});
+
+function shouldSuppressPopupNotifications() {
+  // We have to hide notifications explicitly when the window is
+  // minimized because of the effects of the "noautohide" attribute on Linux.
+  // This can be removed once bug 545265 and bug 1320361 are fixed.
+  // Hide popup notifications when system tab prompts are shown so they
+  // don't cover up the prompt.
+  return (
+    window.windowState == window.STATE_MINIMIZED ||
+    gBrowser?.selectedBrowser.hasAttribute("tabmodalChromePromptShowing") ||
+    gBrowser?.selectedBrowser.hasAttribute("tabDialogShowing") ||
+    gDialogBox?.isOpen
+  );
+}
+
+async function gLazyFindCommand(cmd, ...args) {
+  let fb = await gFindBarPromise;
+  // We could be closed by now, or the tab with XBL binding could have gone away:
+  if (fb && fb[cmd]) {
+    fb[cmd].apply(fb, args);
+  }
+}
+
+var gPageIcons = {
+  "about:home": "chrome://branding/content/icon32.png",
+  "about:myfirefox": "chrome://branding/content/icon32.png",
+  "about:newtab": "chrome://branding/content/icon32.png",
+  "about:welcome": "chrome://branding/content/icon32.png",
+  "about:privatebrowsing": "chrome://browser/skin/privatebrowsing/favicon.svg",
+};
+
+var gInitialPages = [
+  "about:blank",
+  "about:home",
+  ...(AppConstants.NIGHTLY_BUILD ? ["about:myfirefox"] : []),
+  "about:newtab",
+  "about:privatebrowsing",
+  "about:sessionrestore",
+  "about:welcome",
+  "about:welcomeback",
+];
+
+function isInitialPage(url) {
+  if (!(url instanceof Ci.nsIURI)) {
+    try {
+      url = Services.io.newURI(url);
+    } catch (ex) {
+      return false;
+    }
+  }
+
+  let nonQuery = url.prePath + url.filePath;
+  return gInitialPages.includes(nonQuery) || nonQuery == BROWSER_NEW_TAB_URL;
+}
+
+function browserWindows() {
+  return Services.wm.getEnumerator("navigator:browser");
+}
+
+// This is a stringbundle-like interface to gBrowserBundle, formerly a getter for
+// the "bundle_browser" element.
+var gNavigatorBundle = {
+  getString(key) {
+    return gBrowserBundle.GetStringFromName(key);
+  },
+  getFormattedString(key, array) {
+    return gBrowserBundle.formatStringFromName(key, array);
+  },
+};
+
+function updateFxaToolbarMenu(enable, isInitialUpdate = false) {
+  // We only show the Firefox Account toolbar menu if the feature is enabled and
+  // if sync is enabled.
+  const syncEnabled = Services.prefs.getBoolPref(
+    "identity.fxaccounts.enabled",
+    false
+  );
+
+  const mainWindowEl = document.documentElement;
+  const fxaPanelEl = PanelMultiView.getViewNode(document, "PanelUI-fxa");
+
+  // To minimize the toolbar button flickering or appearing/disappearing during startup,
+  // we use this pref to anticipate the likely FxA status.
+  const statusGuess = !!Services.prefs.getStringPref(
+    "identity.fxaccounts.account.device.name",
+    ""
+  );
+  mainWindowEl.setAttribute(
+    "fxastatus",
+    statusGuess ? "signed_in" : "not_configured"
+  );
+
+  fxaPanelEl.addEventListener("ViewShowing", gSync.updateSendToDeviceTitle);
+
+  Services.telemetry.setEventRecordingEnabled("fxa_app_menu", true);
+
+  if (enable && syncEnabled) {
+    mainWindowEl.setAttribute("fxatoolbarmenu", "visible");
+
+    // We have to manually update the sync state UI when toggling the FxA toolbar
+    // because it could show an invalid icon if the user is logged in and no sync
+    // event was performed yet.
+    if (!isInitialUpdate) {
+      gSync.maybeUpdateUIState();
+    }
+
+    Services.telemetry.setEventRecordingEnabled("fxa_avatar_menu", true);
+  } else {
+    mainWindowEl.removeAttribute("fxatoolbarmenu");
+  }
+}
+
+function UpdateBackForwardCommands(aWebNavigation) {
+  var backCommand = document.getElementById("Browser:Back");
+  var forwardCommand = document.getElementById("Browser:Forward");
+
+  // Avoid setting attributes on commands if the value hasn't changed!
+  // Remember, guys, setting attributes on elements is expensive!  They
+  // get inherited into anonymous content, broadcast to other widgets, etc.!
+  // Don't do it if the value hasn't changed! - dwh
+
+  var backDisabled = backCommand.hasAttribute("disabled");
+  var forwardDisabled = forwardCommand.hasAttribute("disabled");
+  if (backDisabled == aWebNavigation.canGoBack) {
+    if (backDisabled) {
+      backCommand.removeAttribute("disabled");
+    } else {
+      backCommand.setAttribute("disabled", true);
+    }
+  }
+
+  if (forwardDisabled == aWebNavigation.canGoForward) {
+    if (forwardDisabled) {
+      forwardCommand.removeAttribute("disabled");
+    } else {
+      forwardCommand.setAttribute("disabled", true);
+    }
+  }
+}
+
+/**
+ * Click-and-Hold implementation for the Back and Forward buttons
+ * XXXmano: should this live in toolbarbutton.js?
+ */
+function SetClickAndHoldHandlers() {
+  // Bug 414797: Clone the back/forward buttons' context menu into both buttons.
+  let popup = document.getElementById("backForwardMenu").cloneNode(true);
+  popup.removeAttribute("id");
+  // Prevent the back/forward buttons' context attributes from being inherited.
+  popup.setAttribute("context", "");
+
+  let backButton = document.getElementById("back-button");
+  backButton.setAttribute("type", "menu");
+  backButton.prepend(popup);
+  gClickAndHoldListenersOnElement.add(backButton);
+
+  let forwardButton = document.getElementById("forward-button");
+  popup = popup.cloneNode(true);
+  forwardButton.setAttribute("type", "menu");
+  forwardButton.prepend(popup);
+  gClickAndHoldListenersOnElement.add(forwardButton);
+}
+
+const gClickAndHoldListenersOnElement = {
+  _timers: new Map(),
+
+  _mousedownHandler(aEvent) {
+    if (
+      aEvent.button != 0 ||
+      aEvent.currentTarget.open ||
+      aEvent.currentTarget.disabled
+    ) {
+      return;
+    }
+
+    // Prevent the menupopup from opening immediately
+    aEvent.currentTarget.menupopup.hidden = true;
+
+    aEvent.currentTarget.addEventListener("mouseout", this);
+    aEvent.currentTarget.addEventListener("mouseup", this);
+    this._timers.set(
+      aEvent.currentTarget,
+      setTimeout(b => this._openMenu(b), 500, aEvent.currentTarget)
+    );
+  },
+
+  _clickHandler(aEvent) {
+    if (
+      aEvent.button == 0 &&
+      aEvent.target == aEvent.currentTarget &&
+      !aEvent.currentTarget.open &&
+      !aEvent.currentTarget.disabled
+    ) {
+      let cmdEvent = document.createEvent("xulcommandevent");
+      cmdEvent.initCommandEvent(
+        "command",
+        true,
+        true,
+        window,
+        0,
+        aEvent.ctrlKey,
+        aEvent.altKey,
+        aEvent.shiftKey,
+        aEvent.metaKey,
+        0,
+        null,
+        aEvent.mozInputSource
+      );
+      aEvent.currentTarget.dispatchEvent(cmdEvent);
+
+      // This is here to cancel the XUL default event
+      // dom.click() triggers a command even if there is a click handler
+      // however this can now be prevented with preventDefault().
+      aEvent.preventDefault();
+    }
+  },
+
+  _openMenu(aButton) {
+    this._cancelHold(aButton);
+    aButton.firstElementChild.hidden = false;
+    aButton.open = true;
+  },
+
+  _mouseoutHandler(aEvent) {
+    let buttonRect = aEvent.currentTarget.getBoundingClientRect();
+    if (
+      aEvent.clientX >= buttonRect.left &&
+      aEvent.clientX <= buttonRect.right &&
+      aEvent.clientY >= buttonRect.bottom
+    ) {
+      this._openMenu(aEvent.currentTarget);
+    } else {
+      this._cancelHold(aEvent.currentTarget);
+    }
+  },
+
+  _mouseupHandler(aEvent) {
+    this._cancelHold(aEvent.currentTarget);
+  },
+
+  _cancelHold(aButton) {
+    clearTimeout(this._timers.get(aButton));
+    aButton.removeEventListener("mouseout", this);
+    aButton.removeEventListener("mouseup", this);
+  },
+
+  _keypressHandler(aEvent) {
+    if (aEvent.key == " " || aEvent.key == "Enter") {
+      // Normally, command events get fired for keyboard activation. However,
+      // we've set type="menu", so that doesn't happen. Handle this the same
+      // way we handle clicks.
+      aEvent.target.click();
+    }
+  },
+
+  handleEvent(e) {
+    switch (e.type) {
+      case "mouseout":
+        this._mouseoutHandler(e);
+        break;
+      case "mousedown":
+        this._mousedownHandler(e);
+        break;
+      case "click":
+        this._clickHandler(e);
+        break;
+      case "mouseup":
+        this._mouseupHandler(e);
+        break;
+      case "keypress":
+        this._keypressHandler(e);
+        break;
+    }
+  },
+
+  remove(aButton) {
+    aButton.removeEventListener("mousedown", this, true);
+    aButton.removeEventListener("click", this, true);
+    aButton.removeEventListener("keypress", this, true);
+  },
+
+  add(aElm) {
+    this._timers.delete(aElm);
+
+    aElm.addEventListener("mousedown", this, true);
+    aElm.addEventListener("click", this, true);
+    aElm.addEventListener("keypress", this, true);
+  },
+};
+
+const gSessionHistoryObserver = {
+  observe(subject, topic, data) {
+    if (topic != "browser:purge-session-history") {
+      return;
+    }
+
+    var backCommand = document.getElementById("Browser:Back");
+    backCommand.setAttribute("disabled", "true");
+    var fwdCommand = document.getElementById("Browser:Forward");
+    fwdCommand.setAttribute("disabled", "true");
+
+    // Clear undo history of the URL bar
+    gURLBar.editor.transactionManager.clear();
+  },
+};
+
+const gStoragePressureObserver = {
+  _lastNotificationTime: -1,
+
+  async observe(subject, topic, data) {
+    if (topic != "QuotaManager::StoragePressure") {
+      return;
+    }
+
+    const NOTIFICATION_VALUE = "storage-pressure-notification";
+    if (gNotificationBox.getNotificationWithValue(NOTIFICATION_VALUE)) {
+      // Do not display the 2nd notification when there is already one
+      return;
+    }
+
+    // Don't display notification twice within the given interval.
+    // This is because
+    //   - not to annoy user
+    //   - give user some time to clean space.
+    //     Even user sees notification and starts acting, it still takes some time.
+    const MIN_NOTIFICATION_INTERVAL_MS = Services.prefs.getIntPref(
+      "browser.storageManager.pressureNotification.minIntervalMS"
+    );
+    let duration = Date.now() - this._lastNotificationTime;
+    if (duration <= MIN_NOTIFICATION_INTERVAL_MS) {
+      return;
+    }
+    this._lastNotificationTime = Date.now();
+
+    MozXULElement.insertFTLIfNeeded("branding/brand.ftl");
+    MozXULElement.insertFTLIfNeeded("browser/preferences/preferences.ftl");
+
+    const BYTES_IN_GIGABYTE = 1073741824;
+    const USAGE_THRESHOLD_BYTES =
+      BYTES_IN_GIGABYTE *
+      Services.prefs.getIntPref(
+        "browser.storageManager.pressureNotification.usageThresholdGB"
+      );
+    let messageFragment = document.createDocumentFragment();
+    let message = document.createElement("span");
+
+    let buttons = [{ supportPage: "storage-permissions" }];
+    let usage = subject.QueryInterface(Ci.nsISupportsPRUint64).data;
+    if (usage < USAGE_THRESHOLD_BYTES) {
+      // The firefox-used space < 5GB, then warn user to free some disk space.
+      // This is because this usage is small and not the main cause for space issue.
+      // In order to avoid the bad and wrong impression among users that
+      // firefox eats disk space a lot, indicate users to clean up other disk space.
+      document.l10n.setAttributes(message, "space-alert-under-5gb-message2");
+    } else {
+      // The firefox-used space >= 5GB, then guide users to about:preferences
+      // to clear some data stored on firefox by websites.
+      document.l10n.setAttributes(message, "space-alert-over-5gb-message2");
+      buttons.push({
+        "l10n-id": "space-alert-over-5gb-settings-button",
+        callback(notificationBar, button) {
+          // The advanced subpanes are only supported in the old organization, which will
+          // be removed by bug 1349689.
+          openPreferences("privacy-sitedata");
+        },
+      });
+    }
+    messageFragment.appendChild(message);
+
+    gNotificationBox.appendNotification(
+      NOTIFICATION_VALUE,
+      {
+        label: messageFragment,
+        priority: gNotificationBox.PRIORITY_WARNING_HIGH,
+      },
+      buttons
+    );
+
+    // This seems to be necessary to get the buttons to display correctly
+    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1504216
+    document.l10n.translateFragment(gNotificationBox.currentNotification);
+  },
+};
+
+var gPopupBlockerObserver = {
+  handleEvent(aEvent) {
+    if (aEvent.originalTarget != gBrowser.selectedBrowser) {
+      return;
+    }
+
+    gPermissionPanel.refreshPermissionIcons();
+
+    let popupCount = gBrowser.selectedBrowser.popupBlocker.getBlockedPopupCount();
+
+    if (!popupCount) {
+      // Hide the notification box (if it's visible).
+      let notificationBox = gBrowser.getNotificationBox();
+      let notification = notificationBox.getNotificationWithValue(
+        "popup-blocked"
+      );
+      if (notification) {
+        notificationBox.removeNotification(notification, false);
+      }
+      return;
+    }
+
+    // Only show the notification again if we've not already shown it. Since
+    // notifications are per-browser, we don't need to worry about re-adding
+    // it.
+    if (gBrowser.selectedBrowser.popupBlocker.shouldShowNotification) {
+      if (Services.prefs.getBoolPref("privacy.popups.showBrowserMessage")) {
+        var brandBundle = document.getElementById("bundle_brand");
+        var brandShortName = brandBundle.getString("brandShortName");
+
+        var stringKey =
+          AppConstants.platform == "win"
+            ? "popupWarningButton"
+            : "popupWarningButtonUnix";
+
+        var popupButtonText = gNavigatorBundle.getString(stringKey);
+        var popupButtonAccesskey = gNavigatorBundle.getString(
+          stringKey + ".accesskey"
+        );
+
+        let messageBase;
+        if (popupCount < this.maxReportedPopups) {
+          messageBase = gNavigatorBundle.getString("popupWarning.message");
+        } else {
+          messageBase = gNavigatorBundle.getString(
+            "popupWarning.exceeded.message"
+          );
+        }
+
+        var message = PluralForm.get(popupCount, messageBase)
+          .replace("#1", brandShortName)
+          .replace("#2", popupCount);
+
+        let notificationBox = gBrowser.getNotificationBox();
+        let notification = notificationBox.getNotificationWithValue(
+          "popup-blocked"
+        );
+        if (notification) {
+          notification.label = message;
+        } else {
+          var buttons = [
+            {
+              label: popupButtonText,
+              accessKey: popupButtonAccesskey,
+              popup: "blockedPopupOptions",
+              callback: null,
+            },
+          ];
+
+          const priority = notificationBox.PRIORITY_INFO_MEDIUM;
+          notificationBox.appendNotification(
+            "popup-blocked",
+            {
+              label: message,
+              image: "chrome://browser/skin/notification-icons/popup.svg",
+              priority,
+            },
+            buttons
+          );
+        }
+      }
+
+      // Record the fact that we've reported this blocked popup, so we don't
+      // show it again.
+      gBrowser.selectedBrowser.popupBlocker.didShowNotification();
+    }
+  },
+
+  toggleAllowPopupsForSite(aEvent) {
+    var pm = Services.perms;
+    var shouldBlock = aEvent.target.getAttribute("block") == "true";
+    var perm = shouldBlock ? pm.DENY_ACTION : pm.ALLOW_ACTION;
+    pm.addFromPrincipal(gBrowser.contentPrincipal, "popup", perm);
+
+    if (!shouldBlock) {
+      gBrowser.selectedBrowser.popupBlocker.unblockAllPopups();
+    }
+
+    gBrowser.getNotificationBox().removeCurrentNotification();
+  },
+
+  fillPopupList(aEvent) {
+    // XXXben - rather than using |currentURI| here, which breaks down on multi-framed sites
+    //          we should really walk the blockedPopups and create a list of "allow for <host>"
+    //          menuitems for the common subset of hosts present in the report, this will
+    //          make us frame-safe.
+    //
+    // XXXjst - Note that when this is fixed to work with multi-framed sites,
+    //          also back out the fix for bug 343772 where
+    //          nsGlobalWindow::CheckOpenAllow() was changed to also
+    //          check if the top window's location is allow-listed.
+    let browser = gBrowser.selectedBrowser;
+    var uriOrPrincipal = browser.contentPrincipal.isContentPrincipal
+      ? browser.contentPrincipal
+      : browser.currentURI;
+    var blockedPopupAllowSite = document.getElementById(
+      "blockedPopupAllowSite"
+    );
+    try {
+      blockedPopupAllowSite.removeAttribute("hidden");
+      let uriHost = uriOrPrincipal.asciiHost
+        ? uriOrPrincipal.host
+        : uriOrPrincipal.spec;
+      var pm = Services.perms;
+      if (
+        pm.testPermissionFromPrincipal(browser.contentPrincipal, "popup") ==
+        pm.ALLOW_ACTION
+      ) {
+        // Offer an item to block popups for this site, if an allow-list entry exists
+        // already for it.
+        document.l10n.setAttributes(
+          blockedPopupAllowSite,
+          "popups-infobar-block",
+          { uriHost }
+        );
+        blockedPopupAllowSite.setAttribute("block", "true");
+      } else {
+        // Offer an item to allow popups for this site
+        document.l10n.setAttributes(
+          blockedPopupAllowSite,
+          "popups-infobar-allow",
+          { uriHost }
+        );
+        blockedPopupAllowSite.removeAttribute("block");
+      }
+    } catch (e) {
+      blockedPopupAllowSite.hidden = true;
+    }
+
+    let blockedPopupDontShowMessage = document.getElementById(
+      "blockedPopupDontShowMessage"
+    );
+    let showMessage = Services.prefs.getBoolPref(
+      "privacy.popups.showBrowserMessage"
+    );
+    blockedPopupDontShowMessage.setAttribute("checked", !showMessage);
+
+    let blockedPopupsSeparator = document.getElementById(
+      "blockedPopupsSeparator"
+    );
+    blockedPopupsSeparator.hidden = true;
+
+    browser.popupBlocker.getBlockedPopups().then(blockedPopups => {
+      let foundUsablePopupURI = false;
+      if (blockedPopups) {
+        for (let i = 0; i < blockedPopups.length; i++) {
+          let blockedPopup = blockedPopups[i];
+
+          // popupWindowURI will be null if the file picker popup is blocked.
+          // xxxdz this should make the option say "Show file picker" and do it (Bug 590306)
+          if (!blockedPopup.popupWindowURISpec) {
+            continue;
+          }
+
+          var popupURIspec = blockedPopup.popupWindowURISpec;
+
+          // Sometimes the popup URI that we get back from the blockedPopup
+          // isn't useful (for instance, netscape.com's popup URI ends up
+          // being "http://www.netscape.com", which isn't really the URI of
+          // the popup they're trying to show).  This isn't going to be
+          // useful to the user, so we won't create a menu item for it.
+          if (
+            popupURIspec == "" ||
+            popupURIspec == "about:blank" ||
+            popupURIspec == "<self>" ||
+            popupURIspec == uriOrPrincipal.spec
+          ) {
+            continue;
+          }
+
+          // Because of the short-circuit above, we may end up in a situation
+          // in which we don't have any usable popup addresses to show in
+          // the menu, and therefore we shouldn't show the separator.  However,
+          // since we got past the short-circuit, we must've found at least
+          // one usable popup URI and thus we'll turn on the separator later.
+          foundUsablePopupURI = true;
+
+          var menuitem = document.createXULElement("menuitem");
+          var label = gNavigatorBundle.getFormattedString(
+            "popupShowPopupPrefix",
+            [popupURIspec]
+          );
+          menuitem.setAttribute("label", label);
+          menuitem.setAttribute(
+            "oncommand",
+            "gPopupBlockerObserver.showBlockedPopup(event);"
+          );
+          menuitem.setAttribute("popupReportIndex", i);
+          menuitem.setAttribute(
+            "popupInnerWindowId",
+            blockedPopup.innerWindowId
+          );
+          menuitem.browsingContext = blockedPopup.browsingContext;
+          menuitem.popupReportBrowser = browser;
+          aEvent.target.appendChild(menuitem);
+        }
+      }
+
+      // Show the separator if we added any
+      // showable popup addresses to the menu.
+      if (foundUsablePopupURI) {
+        blockedPopupsSeparator.removeAttribute("hidden");
+      }
+    }, null);
+  },
+
+  onPopupHiding(aEvent) {
+    let item = aEvent.target.lastElementChild;
+    while (item && item.id != "blockedPopupsSeparator") {
+      let next = item.previousElementSibling;
+      item.remove();
+      item = next;
+    }
+  },
+
+  showBlockedPopup(aEvent) {
+    let target = aEvent.target;
+    let browsingContext = target.browsingContext;
+    let innerWindowId = target.getAttribute("popupInnerWindowId");
+    let popupReportIndex = target.getAttribute("popupReportIndex");
+    let browser = target.popupReportBrowser;
+    browser.popupBlocker.unblockPopup(
+      browsingContext,
+      innerWindowId,
+      popupReportIndex
+    );
+  },
+
+  editPopupSettings() {
+    openPreferences("privacy-permissions-block-popups");
+  },
+
+  dontShowMessage() {
+    var showMessage = Services.prefs.getBoolPref(
+      "privacy.popups.showBrowserMessage"
+    );
+    Services.prefs.setBoolPref(
+      "privacy.popups.showBrowserMessage",
+      !showMessage
+    );
+    gBrowser.getNotificationBox().removeCurrentNotification();
+  },
+};
+
+XPCOMUtils.defineLazyPreferenceGetter(
+  gPopupBlockerObserver,
+  "maxReportedPopups",
+  "privacy.popups.maxReported"
+);
+
+var gKeywordURIFixup = {
+  check(browser, { fixedURI, keywordProviderName, preferredURI }) {
+    // We get called irrespective of whether we did a keyword search, or
+    // whether the original input would be vaguely interpretable as a URL,
+    // so figure that out first.
+    if (
+      !keywordProviderName ||
+      !fixedURI ||
+      !fixedURI.host ||
+      UrlbarPrefs.get("browser.fixup.dns_first_for_single_words") ||
+      UrlbarPrefs.get("dnsResolveSingleWordsAfterSearch") == 0
+    ) {
+      return;
+    }
+
+    let contentPrincipal = browser.contentPrincipal;
+
+    // At this point we're still only just about to load this URI.
+    // When the async DNS lookup comes back, we may be in any of these states:
+    // 1) still on the previous URI, waiting for the preferredURI (keyword
+    //    search) to respond;
+    // 2) at the keyword search URI (preferredURI)
+    // 3) at some other page because the user stopped navigation.
+    // We keep track of the currentURI to detect case (1) in the DNS lookup
+    // callback.
+    let previousURI = browser.currentURI;
+
+    // now swap for a weak ref so we don't hang on to browser needlessly
+    // even if the DNS query takes forever
+    let weakBrowser = Cu.getWeakReference(browser);
+    browser = null;
+
+    // Additionally, we need the host of the parsed url
+    let hostName = fixedURI.displayHost;
+    // and the ascii-only host for the pref:
+    let asciiHost = fixedURI.asciiHost;
+
+    let isIPv4Address = host => {
+      let parts = host.split(".");
+      if (parts.length != 4) {
+        return false;
+      }
+      return parts.every(part => {
+        let n = parseInt(part, 10);
+        return n >= 0 && n <= 255;
+      });
+    };
+    // Avoid showing fixup information if we're suggesting an IP. Note that
+    // decimal representations of IPs are normalized to a 'regular'
+    // dot-separated IP address by network code, but that only happens for
+    // numbers that don't overflow. Longer numbers do not get normalized,
+    // but still work to access IP addresses. So for instance,
+    // 1097347366913 (ff7f000001) gets resolved by using the final bytes,
+    // making it the same as 7f000001, which is 127.0.0.1 aka localhost.
+    // While 2130706433 would get normalized by network, 1097347366913
+    // does not, and we have to deal with both cases here:
+    if (isIPv4Address(asciiHost) || /^(?:\d+|0x[a-f0-9]+)$/i.test(asciiHost)) {
+      return;
+    }
+
+    let onLookupCompleteListener = {
+      onLookupComplete(request, record, status) {
+        let browserRef = weakBrowser.get();
+        if (!Components.isSuccessCode(status) || !browserRef) {
+          return;
+        }
+
+        let currentURI = browserRef.currentURI;
+        // If we're in case (3) (see above), don't show an info bar.
+        if (
+          !currentURI.equals(previousURI) &&
+          !currentURI.equals(preferredURI)
+        ) {
+          return;
+        }
+
+        // show infobar offering to visit the host
+        let notificationBox = gBrowser.getNotificationBox(browserRef);
+        if (notificationBox.getNotificationWithValue("keyword-uri-fixup")) {
+          return;
+        }
+
+        let displayHostName = "http://" + hostName + "/";
+        let message = gNavigatorBundle.getFormattedString(
+          "keywordURIFixup.message",
+          [displayHostName]
+        );
+        let yesMessage = gNavigatorBundle.getFormattedString(
+          "keywordURIFixup.goTo",
+          [displayHostName]
+        );
+
+        let buttons = [
+          {
+            label: yesMessage,
+            accessKey: gNavigatorBundle.getString(
+              "keywordURIFixup.goTo.accesskey"
+            ),
+            callback() {
+              // Do not set this preference while in private browsing.
+              if (!PrivateBrowsingUtils.isWindowPrivate(window)) {
+                let prefHost = asciiHost;
+                // Normalize out a single trailing dot - NB: not using endsWith/lastIndexOf
+                // because we need to be sure this last dot is the *only* dot, too.
+                // More generally, this is used for the pref and should stay in sync with
+                // the code in URIFixup::KeywordURIFixup .
+                if (prefHost.indexOf(".") == prefHost.length - 1) {
+                  prefHost = prefHost.slice(0, -1);
+                }
+                let pref = "browser.fixup.domainwhitelist." + prefHost;
+                Services.prefs.setBoolPref(pref, true);
+              }
+              openTrustedLinkIn(fixedURI.spec, "current");
+            },
+          },
+        ];
+        let notification = notificationBox.appendNotification(
+          "keyword-uri-fixup",
+          {
+            label: message,
+            priority: notificationBox.PRIORITY_INFO_HIGH,
+          },
+          buttons
+        );
+        notification.persistence = 1;
+      },
+    };
+
+    // For dotless hostnames, we want to ensure this ends with a '.' but don't
+    // want the . showing up in the UI if we end up notifying the user, so we
+    // use a separate variable.
+    let lookupName = hostName;
+    if (
+      UrlbarPrefs.get("dnsResolveFullyQualifiedNames") &&
+      !lookupName.includes(".")
+    ) {
+      lookupName += ".";
+    }
+    try {
+      gDNSService.asyncResolve(
+        lookupName,
+        Ci.nsIDNSService.RESOLVE_TYPE_DEFAULT,
+        0,
+        null,
+        onLookupCompleteListener,
+        Services.tm.mainThread,
+        contentPrincipal.originAttributes
+      );
+    } catch (ex) {
+      // Do nothing if the URL is invalid (we don't want to show a notification in that case).
+      if (ex.result != Cr.NS_ERROR_UNKNOWN_HOST) {
+        // ... otherwise, report:
+        Cu.reportError(ex);
+      }
+    }
+  },
+
+  observe(fixupInfo, topic, data) {
+    fixupInfo.QueryInterface(Ci.nsIURIFixupInfo);
+
+    let browser = fixupInfo.consumer?.top?.embedderElement;
+    if (!browser || browser.ownerGlobal != window) {
+      return;
+    }
+
+    this.check(browser, fixupInfo);
+  },
+};
+
+function serializeInputStream(aStream) {
+  let data = {
+    content: NetUtil.readInputStreamToString(aStream, aStream.available()),
+  };
+
+  if (aStream instanceof Ci.nsIMIMEInputStream) {
+    data.headers = new Map();
+    aStream.visitHeaders((name, value) => {
+      data.headers.set(name, value);
+    });
+  }
+
+  return data;
+}
+
+/**
+ * Handles URIs when we want to deal with them in chrome code rather than pass
+ * them down to a content browser. This can avoid unnecessary process switching
+ * for the browser.
+ * @param aBrowser the browser that is attempting to load the URI
+ * @param aUri the nsIURI that is being loaded
+ * @returns true if the URI is handled, otherwise false
+ */
+function handleUriInChrome(aBrowser, aUri) {
+  if (aUri.scheme == "file") {
+    try {
+      let mimeType = Cc["@mozilla.org/mime;1"]
+        .getService(Ci.nsIMIMEService)
+        .getTypeFromURI(aUri);
+      if (mimeType == "application/x-xpinstall") {
+        let systemPrincipal = Services.scriptSecurityManager.getSystemPrincipal();
+        AddonManager.getInstallForURL(aUri.spec, {
+          telemetryInfo: { source: "file-url" },
+        }).then(install => {
+          AddonManager.installAddonFromWebpage(
+            mimeType,
+            aBrowser,
+            systemPrincipal,
+            install
+          );
+        });
+        return true;
+      }
+    } catch (e) {
+      return false;
+    }
+  }
+
+  return false;
+}
+
+/* Creates a null principal using the userContextId
+   from the current selected tab or a passed in tab argument */
+function _createNullPrincipalFromTabUserContextId(tab = gBrowser.selectedTab) {
+  let userContextId;
+  if (tab.hasAttribute("usercontextid")) {
+    userContextId = tab.getAttribute("usercontextid");
+  }
+  return Services.scriptSecurityManager.createNullPrincipal({
+    userContextId,
+  });
+}
+
+// A shared function used by both remote and non-remote browser XBL bindings to
+// load a URI or redirect it to the correct process.
+function _loadURI(browser, uri, params = {}) {
+  if (!uri) {
+    uri = "about:blank";
+  }
+
+  let {
+    triggeringPrincipal,
+    referrerInfo,
+    postData,
+    userContextId,
+    csp,
+    remoteTypeOverride,
+  } = params || {};
+  let loadFlags =
+    params.loadFlags || params.flags || Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
+  let hasValidUserGestureActivation =
+    document.hasValidTransientUserGestureActivation;
+  if (!triggeringPrincipal) {
+    throw new Error("Must load with a triggering Principal");
+  }
+
+  if (userContextId && userContextId != browser.getAttribute("usercontextid")) {
+    throw new Error("Cannot load with mismatched userContextId");
+  }
+
+  // Attempt to perform URI fixup to see if we can handle this URI in chrome.
+  try {
+    let fixupFlags = Ci.nsIURIFixup.FIXUP_FLAG_NONE;
+    if (loadFlags & Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP) {
+      fixupFlags |= Ci.nsIURIFixup.FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP;
+    }
+    if (loadFlags & Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS) {
+      fixupFlags |= Ci.nsIURIFixup.FIXUP_FLAG_FIX_SCHEME_TYPOS;
+    }
+    if (PrivateBrowsingUtils.isBrowserPrivate(browser)) {
+      fixupFlags |= Ci.nsIURIFixup.FIXUP_FLAG_PRIVATE_CONTEXT;
+    }
+
+    let uriObject = Services.uriFixup.getFixupURIInfo(uri, fixupFlags)
+      .preferredURI;
+    if (uriObject && handleUriInChrome(browser, uriObject)) {
+      // If we've handled the URI in Chrome, then just return here.
+      return;
+    }
+  } catch (e) {
+    // getFixupURIInfo may throw. Gracefully recover and try to load the URI normally.
+  }
+
+  // XXX(nika): Is `browser.isNavigating` necessary anymore?
+  browser.isNavigating = true;
+  let loadURIOptions = {
+    triggeringPrincipal,
+    csp,
+    loadFlags,
+    referrerInfo,
+    postData,
+    hasValidUserGestureActivation,
+    remoteTypeOverride,
+  };
+  try {
+    browser.webNavigation.loadURI(uri, loadURIOptions);
+  } finally {
+    browser.isNavigating = false;
+  }
+}
+
+let _resolveDelayedStartup;
+var delayedStartupPromise = new Promise(resolve => {
+  _resolveDelayedStartup = resolve;
+});
+
+var gBrowserInit = {
+  delayedStartupFinished: false,
+  idleTasksFinishedPromise: null,
+  idleTaskPromiseResolve: null,
+  domContentLoaded: false,
+
+  _tabToAdopt: undefined,
+
+  getTabToAdopt() {
+    if (this._tabToAdopt !== undefined) {
+      return this._tabToAdopt;
+    }
+
+    if (window.arguments && window.arguments[0] instanceof window.XULElement) {
+      this._tabToAdopt = window.arguments[0];
+
+      // Clear the reference of the tab being adopted from the arguments.
+      window.arguments[0] = null;
+    } else {
+      // There was no tab to adopt in the arguments, set _tabToAdopt to null
+      // to avoid checking it again.
+      this._tabToAdopt = null;
+    }
+
+    return this._tabToAdopt;
+  },
+
+  _clearTabToAdopt() {
+    this._tabToAdopt = null;
+  },
+
+  // Used to check if the new window is still adopting an existing tab as its first tab
+  // (e.g. from the WebExtensions internals).
+  isAdoptingTab() {
+    return !!this.getTabToAdopt();
+  },
+
+  onBeforeInitialXULLayout() {
+    BookmarkingUI.updateEmptyToolbarMessage();
+    setToolbarVisibility(
+      BookmarkingUI.toolbar,
+      gBookmarksToolbarVisibility,
+      false,
+      false
+    );
+
+    // Set a sane starting width/height for all resolutions on new profiles.
+    if (Services.prefs.getBoolPref("privacy.resistFingerprinting")) {
+      // When the fingerprinting resistance is enabled, making sure that we don't
+      // have a maximum window to interfere with generating rounded window dimensions.
+      document.documentElement.setAttribute("sizemode", "normal");
+    } else if (!document.documentElement.hasAttribute("width")) {
+      const TARGET_WIDTH = 1280;
+      const TARGET_HEIGHT = 1040;
+      let width = Math.min(screen.availWidth * 0.9, TARGET_WIDTH);
+      let height = Math.min(screen.availHeight * 0.9, TARGET_HEIGHT);
+
+      document.documentElement.setAttribute("width", width);
+      document.documentElement.setAttribute("height", height);
+
+      if (width < TARGET_WIDTH && height < TARGET_HEIGHT) {
+        document.documentElement.setAttribute("sizemode", "maximized");
+      }
+    }
+    if (AppConstants.MENUBAR_CAN_AUTOHIDE) {
+      const toolbarMenubar = document.getElementById("toolbar-menubar");
+      // set a default value
+      if (!toolbarMenubar.hasAttribute("autohide")) {
+        toolbarMenubar.setAttribute("autohide", true);
+      }
+      toolbarMenubar.setAttribute(
+        "data-l10n-id",
+        "toolbar-context-menu-menu-bar-cmd"
+      );
+      toolbarMenubar.setAttribute("data-l10n-attrs", "toolbarname");
+    }
+
+    // Run menubar initialization first, to avoid TabsInTitlebar code picking
+    // up mutations from it and causing a reflow.
+    AutoHideMenubar.init();
+    // Update the chromemargin attribute so the window can be sized correctly.
+    window.TabBarVisibility.update();
+    TabsInTitlebar.init();
+
+    new LightweightThemeConsumer(document);
+
+    if (AppConstants.platform == "win") {
+      if (
+        window.matchMedia("(-moz-platform: windows-win8)").matches &&
+        window.matchMedia("(-moz-windows-default-theme)").matches
+      ) {
+        let windowFrameColor = new Color(
+          ...ChromeUtils.import(
+            "resource:///modules/Windows8WindowFrameColor.jsm"
+          ).Windows8WindowFrameColor.get()
+        );
+        // Default to black for foreground text.
+        if (!windowFrameColor.isContrastRatioAcceptable(new Color(0, 0, 0))) {
+          document.documentElement.setAttribute("darkwindowframe", "true");
+        }
+      } else if (AppConstants.isPlatformAndVersionAtLeast("win", "10")) {
+        TelemetryEnvironment.onInitialized().then(() => {
+          // 17763 is the build number of Windows 10 version 1809
+          if (
+            TelemetryEnvironment.currentEnvironment.system.os
+              .windowsBuildNumber < 17763
+          ) {
+            document.documentElement.setAttribute(
+              "always-use-accent-color-for-window-border",
+              ""
+            );
+          }
+        });
+      }
+    }
+
+    if (
+      Services.prefs.getBoolPref(
+        "toolkit.legacyUserProfileCustomizations.windowIcon",
+        false
+      )
+    ) {
+      document.documentElement.setAttribute("icon", "main-window");
+    }
+
+    // Call this after we set attributes that might change toolbars' computed
+    // text color.
+    ToolbarIconColor.init();
+  },
+
+  onDOMContentLoaded() {
+    // This needs setting up before we create the first remote browser.
+    window.docShell.treeOwner
+      .QueryInterface(Ci.nsIInterfaceRequestor)
+      .getInterface(Ci.nsIAppWindow).XULBrowserWindow = window.XULBrowserWindow;
+    window.browserDOMWindow = new nsBrowserAccess();
+
+    gBrowser = window._gBrowser;
+    delete window._gBrowser;
+    gBrowser.init();
+
+    BrowserWindowTracker.track(window);
+
+    gNavToolbox.palette = document.getElementById(
+      "BrowserToolbarPalette"
+    ).content;
+    let areas = CustomizableUI.areas;
+    areas.splice(areas.indexOf(CustomizableUI.AREA_FIXED_OVERFLOW_PANEL), 1);
+    for (let area of areas) {
+      let node = document.getElementById(area);
+      CustomizableUI.registerToolbarNode(node);
+    }
+    BrowserSearch.initPlaceHolder();
+
+    // Hack to ensure that the various initial pages favicon is loaded
+    // instantaneously, to avoid flickering and improve perceived performance.
+    this._callWithURIToLoad(uriToLoad => {
+      let url;
+      try {
+        url = Services.io.newURI(uriToLoad);
+      } catch (e) {
+        return;
+      }
+      let nonQuery = url.prePath + url.filePath;
+      if (nonQuery in gPageIcons) {
+        gBrowser.setIcon(gBrowser.selectedTab, gPageIcons[nonQuery]);
+      }
+    });
+
+    updateFxaToolbarMenu(gFxaToolbarEnabled, true);
+
+    // Setting the focus will cause a style flush, it's preferable to call anything
+    // that will modify the DOM from within this function before this call.
+    this._setInitialFocus();
+
+    this.domContentLoaded = true;
+  },
+
+  onLoad() {
+    gBrowser.addEventListener("DOMUpdateBlockedPopups", gPopupBlockerObserver);
+
+    window.addEventListener("AppCommand", HandleAppCommandEvent, true);
+
+    // These routines add message listeners. They must run before
+    // loading the frame script to ensure that we don't miss any
+    // message sent between when the frame script is loaded and when
+    // the listener is registered.
+    CaptivePortalWatcher.init();
+    ZoomUI.init(window);
+
+    if (!gMultiProcessBrowser) {
+      // There is a Content:Click message manually sent from content.
+      Services.els.addSystemEventListener(
+        gBrowser.tabpanels,
+        "click",
+        contentAreaClick,
+        true
+      );
+    }
+
+    // hook up UI through progress listener
+    gBrowser.addProgressListener(window.XULBrowserWindow);
+    gBrowser.addTabsProgressListener(window.TabsProgressListener);
+
+    SidebarUI.init();
+
+    // We do this in onload because we want to ensure the button's state
+    // doesn't flicker as the window is being shown.
+    DownloadsButton.init();
+
+    // Certain kinds of automigration rely on this notification to complete
+    // their tasks BEFORE the browser window is shown. SessionStore uses it to
+    // restore tabs into windows AFTER important parts like gMultiProcessBrowser
+    // have been initialized.
+    Services.obs.notifyObservers(window, "browser-window-before-show");
+
+    if (!window.toolbar.visible) {
+      // adjust browser UI for popups
+      gURLBar.readOnly = true;
+    }
+
+    // Misc. inits.
+    gUIDensity.init();
+    TabletModeUpdater.init();
+    CombinedStopReload.ensureInitialized();
+    gPrivateBrowsingUI.init();
+    BrowserSearch.init();
+    BrowserPageActions.init();
+    gAccessibilityServiceIndicator.init();
+    if (gToolbarKeyNavEnabled) {
+      ToolbarKeyboardNavigator.init();
+    }
+
+    // Update UI if browser is under remote control.
+    gRemoteControl.updateVisualCue();
+
+    // If we are given a tab to swap in, take care of it before first paint to
+    // avoid an about:blank flash.
+    let tabToAdopt = this.getTabToAdopt();
+    if (tabToAdopt) {
+      let evt = new CustomEvent("before-initial-tab-adopted", {
+        bubbles: true,
+      });
+      gBrowser.tabpanels.dispatchEvent(evt);
+
+      // Stop the about:blank load
+      gBrowser.stop();
+      // make sure it has a docshell
+      gBrowser.docShell;
+
+      // Remove the speculative focus from the urlbar to let the url be formatted.
+      gURLBar.removeAttribute("focused");
+
+      let swapBrowsers = () => {
+        try {
+          gBrowser.swapBrowsersAndCloseOther(gBrowser.selectedTab, tabToAdopt);
+        } catch (e) {
+          Cu.reportError(e);
+        }
+
+        // Clear the reference to the tab once its adoption has been completed.
+        this._clearTabToAdopt();
+      };
+      if (tabToAdopt.linkedBrowser.isRemoteBrowser) {
+        // For remote browsers, wait for the paint event, otherwise the tabs
+        //  are not yet ready and focus gets confused because the browser swaps
+        // out while tabs are switching.
+        addEventListener("MozAfterPaint", swapBrowsers, { once: true });
+      } else {
+        swapBrowsers();
+      }
+    }
+
+    // Wait until chrome is painted before executing code not critical to making the window visible
+    this._boundDelayedStartup = this._delayedStartup.bind(this);
+    window.addEventListener("MozAfterPaint", this._boundDelayedStartup);
+
+    if (!PrivateBrowsingUtils.enabled) {
+      document.getElementById("Tools:PrivateBrowsing").hidden = true;
+      // Setting disabled doesn't disable the shortcut, so we just remove
+      // the keybinding.
+      document.getElementById("key_privatebrowsing").remove();
+    }
+
+    if (BrowserUIUtils.quitShortcutDisabled) {
+      document.getElementById("key_quitApplication").remove();
+      document.getElementById("menu_FileQuitItem").removeAttribute("key");
+
+      PanelMultiView.getViewNode(
+        document,
+        "appMenu-quit-button2"
+      )?.removeAttribute("key");
+    }
+
+    this._loadHandled = true;
+  },
+
+  _cancelDelayedStartup() {
+    window.removeEventListener("MozAfterPaint", this._boundDelayedStartup);
+    this._boundDelayedStartup = null;
+  },
+
+  _delayedStartup() {
+    let { TelemetryTimestamps } = ChromeUtils.import(
+      "resource://gre/modules/TelemetryTimestamps.jsm"
+    );
+    TelemetryTimestamps.add("delayedStartupStarted");
+
+    this._cancelDelayedStartup();
+
+    // Bug 1531854 - The hidden window is force-created here
+    // until all of its dependencies are handled.
+    Services.appShell.hiddenDOMWindow;
+
+    gBrowser.addEventListener(
+      "PermissionStateChange",
+      function() {
+        gIdentityHandler.refreshIdentityBlock();
+        gPermissionPanel.updateSharingIndicator();
+      },
+      true
+    );
+
+    this._handleURIToLoad();
+
+    Services.obs.addObserver(gIdentityHandler, "perm-changed");
+    Services.obs.addObserver(gRemoteControl, "devtools-socket");
+    Services.obs.addObserver(gRemoteControl, "marionette-listening");
+    Services.obs.addObserver(gRemoteControl, "remote-listening");
+    Services.obs.addObserver(
+      gSessionHistoryObserver,
+      "browser:purge-session-history"
+    );
+    Services.obs.addObserver(
+      gStoragePressureObserver,
+      "QuotaManager::StoragePressure"
+    );
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-disabled");
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-started");
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-blocked");
+    Services.obs.addObserver(
+      gXPInstallObserver,
+      "addon-install-fullscreen-blocked"
+    );
+    Services.obs.addObserver(
+      gXPInstallObserver,
+      "addon-install-origin-blocked"
+    );
+    Services.obs.addObserver(
+      gXPInstallObserver,
+      "addon-install-webapi-blocked-policy"
+    );
+    Services.obs.addObserver(
+      gXPInstallObserver,
+      "addon-install-webapi-blocked"
+    );
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-failed");
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-confirmation");
+    Services.obs.addObserver(gXPInstallObserver, "addon-install-complete");
+    Services.obs.addObserver(gKeywordURIFixup, "keyword-uri-fixup");
+
+    BrowserOffline.init();
+    IndexedDBPromptHelper.init();
+    CanvasPermissionPromptHelper.init();
+    WebAuthnPromptHelper.init();
+
+    // Initialize the full zoom setting.
+    // We do this before the session restore service gets initialized so we can
+    // apply full zoom settings to tabs restored by the session restore service.
+    FullZoom.init();
+    PanelUI.init(shouldSuppressPopupNotifications);
+
+    UpdateUrlbarSearchSplitterState();
+
+    BookmarkingUI.init();
+    BrowserSearch.delayedStartupInit();
+    gProtectionsHandler.init();
+    HomePage.delayedStartup().catch(Cu.reportError);
+
+    let safeMode = document.getElementById("helpSafeMode");
+    if (Services.appinfo.inSafeMode) {
+      document.l10n.setAttributes(safeMode, "menu-help-exit-troubleshoot-mode");
+      safeMode.setAttribute(
+        "appmenu-data-l10n-id",
+        "appmenu-help-exit-troubleshoot-mode"
+      );
+    }
+
+    // BiDi UI
+    gBidiUI = isBidiEnabled();
+    if (gBidiUI) {
+      document.getElementById("documentDirection-separator").hidden = false;
+      document.getElementById("documentDirection-swap").hidden = false;
+      document.getElementById("textfieldDirection-separator").hidden = false;
+      document.getElementById("textfieldDirection-swap").hidden = false;
+    }
+
+    // Setup click-and-hold gestures access to the session history
+    // menus if global click-and-hold isn't turned on
+    if (!Services.prefs.getBoolPref("ui.click_hold_context_menus", false)) {
+      SetClickAndHoldHandlers();
+    }
+
+    function initBackForwardButtonTooltip(tooltipId, l10nId, shortcutId) {
+      let shortcut = document.getElementById(shortcutId);
+      shortcut = ShortcutUtils.prettifyShortcut(shortcut);
+
+      let tooltip = document.getElementById(tooltipId);
+      document.l10n.setAttributes(tooltip, l10nId, { shortcut });
+    }
+
+    initBackForwardButtonTooltip(
+      "back-button-tooltip-description",
+      "navbar-tooltip-back-2",
+      "goBackKb"
+    );
+
+    initBackForwardButtonTooltip(
+      "forward-button-tooltip-description",
+      "navbar-tooltip-forward-2",
+      "goForwardKb"
+    );
+
+    PlacesToolbarHelper.init();
+
+    ctrlTab.readPref();
+    Services.prefs.addObserver(ctrlTab.prefName, ctrlTab);
+
+    // The object handling the downloads indicator is initialized here in the
+    // delayed startup function, but the actual indicator element is not loaded
+    // unless there are downloads to be displayed.
+    DownloadsButton.initializeIndicator();
+
+    if (AppConstants.platform != "macosx") {
+      updateEditUIVisibility();
+      let placesContext = document.getElementById("placesContext");
+      placesContext.addEventListener("popupshowing", updateEditUIVisibility);
+      placesContext.addEventListener("popuphiding", updateEditUIVisibility);
+    }
+
+    FullScreen.init();
+
+    if (AppConstants.isPlatformAndVersionAtLeast("win", "10")) {
+      MenuTouchModeObserver.init();
+    }
+
+    if (AppConstants.MOZ_DATA_REPORTING) {
+      gDataNotificationInfoBar.init();
+    }
+
+    if (!AppConstants.MOZILLA_OFFICIAL) {
+      DevelopmentHelpers.init();
+    }
+
+    gExtensionsNotifications.init();
+
+    let wasMinimized = window.windowState == window.STATE_MINIMIZED;
+    window.addEventListener("sizemodechange", () => {
+      let isMinimized = window.windowState == window.STATE_MINIMIZED;
+      if (wasMinimized != isMinimized) {
+        wasMinimized = isMinimized;
+        UpdatePopupNotificationsVisibility();
+      }
+    });
+
+    window.addEventListener("mousemove", MousePosTracker);
+    window.addEventListener("dragover", MousePosTracker);
+
+    gNavToolbox.addEventListener("customizationstarting", CustomizationHandler);
+    gNavToolbox.addEventListener("aftercustomization", CustomizationHandler);
+
+    SessionStore.promiseInitialized.then(() => {
+      // Bail out if the window has been closed in the meantime.
+      if (window.closed) {
+        return;
+      }
+
+      // Enable the Restore Last Session command if needed
+      RestoreLastSessionObserver.init();
+
+      SidebarUI.startDelayedLoad();
+
+      PanicButtonNotifier.init();
+    });
+
+    if (BrowserHandler.kiosk) {
+      // We don't modify popup windows for kiosk mode
+      if (!gURLBar.readOnly) {
+        window.fullScreen = true;
+      }
+    }
+
+    if (Services.policies.status === Services.policies.ACTIVE) {
+      if (!Services.policies.isAllowed("hideShowMenuBar")) {
+        document
+          .getElementById("toolbar-menubar")
+          .removeAttribute("toolbarname");
+      }
+      let policies = Services.policies.getActivePolicies();
+      if ("ManagedBookmarks" in policies) {
+        let managedBookmarks = policies.ManagedBookmarks;
+        let children = managedBookmarks.filter(
+          child => !("toplevel_name" in child)
+        );
+        if (children.length) {
+          let managedBookmarksButton = document.createXULElement(
+            "toolbarbutton"
+          );
+          managedBookmarksButton.setAttribute("id", "managed-bookmarks");
+          managedBookmarksButton.setAttribute("class", "bookmark-item");
+          let toplevel = managedBookmarks.find(
+            element => "toplevel_name" in element
+          );
+          if (toplevel) {
+            managedBookmarksButton.setAttribute(
+              "label",
+              toplevel.toplevel_name
+            );
+          } else {
+            managedBookmarksButton.setAttribute(
+              "data-l10n-id",
+              "managed-bookmarks"
+            );
+          }
+          managedBookmarksButton.setAttribute("context", "placesContext");
+          managedBookmarksButton.setAttribute("container", "true");
+          managedBookmarksButton.setAttribute("removable", "false");
+          managedBookmarksButton.setAttribute("type", "menu");
+
+          let managedBookmarksPopup = document.createXULElement("menupopup");
+          managedBookmarksPopup.setAttribute("id", "managed-bookmarks-popup");
+          managedBookmarksPopup.setAttribute(
+            "oncommand",
+            "PlacesToolbarHelper.openManagedBookmark(event);"
+          );
+          managedBookmarksPopup.setAttribute(
+            "ondragover",
+            "event.dataTransfer.effectAllowed='none';"
+          );
+          managedBookmarksPopup.setAttribute(
+            "ondragstart",
+            "PlacesToolbarHelper.onDragStartManaged(event);"
+          );
+          managedBookmarksPopup.setAttribute(
+            "onpopupshowing",
+            "PlacesToolbarHelper.populateManagedBookmarks(this);"
+          );
+          managedBookmarksPopup.setAttribute("placespopup", "true");
+          managedBookmarksPopup.setAttribute("is", "places-popup");
+          managedBookmarksButton.appendChild(managedBookmarksPopup);
+
+          gNavToolbox.palette.appendChild(managedBookmarksButton);
+
+          CustomizableUI.ensureWidgetPlacedInWindow(
+            "managed-bookmarks",
+            window
+          );
+
+          // Add button if it doesn't exist
+          if (!CustomizableUI.getPlacementOfWidget("managed-bookmarks")) {
+            CustomizableUI.addWidgetToArea(
+              "managed-bookmarks",
+              CustomizableUI.AREA_BOOKMARKS,
+              0
+            );
+          }
+        }
+      }
+    }
+
+    CaptivePortalWatcher.delayedStartup();
+
+    SessionStore.promiseAllWindowsRestored.then(() => {
+      this._schedulePerWindowIdleTasks();
+      document.documentElement.setAttribute("sessionrestored", "true");
+    });
+
+    this.delayedStartupFinished = true;
+    _resolveDelayedStartup();
+    Services.obs.notifyObservers(window, "browser-delayed-startup-finished");
+    TelemetryTimestamps.add("delayedStartupFinished");
+    // We've announced that delayed startup has finished. Do not add code past this point.
+  },
+
+  /**
+   * Resolved on the first MozAfterPaint in the first content window.
+   */
+  get firstContentWindowPaintPromise() {
+    return this._firstContentWindowPaintDeferred.promise;
+  },
+
+  _setInitialFocus() {
+    let initiallyFocusedElement = document.commandDispatcher.focusedElement;
+
+    // To prevent startup flicker, the urlbar has the 'focused' attribute set
+    // by default. If we are not sure the urlbar will be focused in this
+    // window, we need to remove the attribute before first paint.
+    // TODO (bug 1629956): The urlbar having the 'focused' attribute by default
+    // isn't a useful optimization anymore since UrlbarInput needs layout
+    // information to focus the urlbar properly.
+    let shouldRemoveFocusedAttribute = true;
+
+    this._callWithURIToLoad(uriToLoad => {
+      // Check if user is enrolled in an aboutWelcome experiment that has skipFocus
+      // property set to true, if yes remove focus from urlbar for about:welcome
+      const aboutWelcomeSkipUrlBarFocus =
+        uriToLoad == "about:welcome" &&
+        NimbusFeatures.aboutwelcome.getVariable("skipFocus");
+
+      if (
+        (isBlankPageURL(uriToLoad) && !aboutWelcomeSkipUrlBarFocus) ||
+        uriToLoad == "about:privatebrowsing" ||
+        this.getTabToAdopt()?.isEmpty
+      ) {
+        gURLBar.select();
+        shouldRemoveFocusedAttribute = false;
+        return;
+      }
+
+      if (gBrowser.selectedBrowser.isRemoteBrowser) {
+        // If the initial browser is remote, in order to optimize for first paint,
+        // we'll defer switching focus to that browser until it has painted.
+        this._firstContentWindowPaintDeferred.promise.then(() => {
+          // If focus didn't move while we were waiting for first paint, we're okay
+          // to move to the browser.
+          if (
+            document.commandDispatcher.focusedElement == initiallyFocusedElement
+          ) {
+            gBrowser.selectedBrowser.focus();
+          }
+        });
+      } else {
+        // If the initial browser is not remote, we can focus the browser
+        // immediately with no paint performance impact.
+        gBrowser.selectedBrowser.focus();
+      }
+    });
+
+    // Delay removing the attribute using requestAnimationFrame to avoid
+    // invalidating styles multiple times in a row if uriToLoadPromise
+    // resolves before first paint.
+    if (shouldRemoveFocusedAttribute) {
+      window.requestAnimationFrame(() => {
+        if (shouldRemoveFocusedAttribute) {
+          gURLBar.removeAttribute("focused");
+        }
+      });
+    }
+  },
+
+  _handleURIToLoad() {
+    this._callWithURIToLoad(uriToLoad => {
+      if (!uriToLoad) {
+        // We don't check whether window.arguments[5] (userContextId) is set
+        // because tabbrowser.js takes care of that for the initial tab.
+        return;
+      }
+
+      // We don't check if uriToLoad is a XULElement because this case has
+      // already been handled before first paint, and the argument cleared.
+      if (Array.isArray(uriToLoad)) {
+        // This function throws for certain malformed URIs, so use exception handling
+        // so that we don't disrupt startup
+        try {
+          gBrowser.loadTabs(uriToLoad, {
+            inBackground: false,
+            replace: true,
+            // See below for the semantics of window.arguments. Only the minimum is supported.
+            userContextId: window.arguments[5],
+            triggeringPrincipal:
+              window.arguments[8] ||
+              Services.scriptSecurityManager.getSystemPrincipal(),
+            allowInheritPrincipal: window.arguments[9],
+            csp: window.arguments[10],
+            fromExternal: true,
+          });
+        } catch (e) {}
+      } else if (window.arguments.length >= 3) {
+        // window.arguments[1]: unused (bug 871161)
+        //                 [2]: referrerInfo (nsIReferrerInfo)
+        //                 [3]: postData (nsIInputStream)
+        //                 [4]: allowThirdPartyFixup (bool)
+        //                 [5]: userContextId (int)
+        //                 [6]: originPrincipal (nsIPrincipal)
+        //                 [7]: originStoragePrincipal (nsIPrincipal)
+        //                 [8]: triggeringPrincipal (nsIPrincipal)
+        //                 [9]: allowInheritPrincipal (bool)
+        //                 [10]: csp (nsIContentSecurityPolicy)
+        //                 [11]: nsOpenWindowInfo
+        let userContextId =
+          window.arguments[5] != undefined
+            ? window.arguments[5]
+            : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+        loadURI(
+          uriToLoad,
+          window.arguments[2] || null,
+          window.arguments[3] || null,
+          window.arguments[4] || false,
+          userContextId,
+          // pass the origin principal (if any) and force its use to create
+          // an initial about:blank viewer if present:
+          window.arguments[6],
+          window.arguments[7],
+          !!window.arguments[6],
+          window.arguments[8],
+          // TODO fix allowInheritPrincipal to default to false.
+          // Default to true unless explicitly set to false because of bug 1475201.
+          window.arguments[9] !== false,
+          window.arguments[10]
+        );
+        window.focus();
+      } else {
+        // Note: loadOneOrMoreURIs *must not* be called if window.arguments.length >= 3.
+        // Such callers expect that window.arguments[0] is handled as a single URI.
+        loadOneOrMoreURIs(
+          uriToLoad,
+          Services.scriptSecurityManager.getSystemPrincipal(),
+          null
+        );
+      }
+    });
+  },
+
+  /**
+   * Use this function as an entry point to schedule tasks that
+   * need to run once per window after startup, and can be scheduled
+   * by using an idle callback.
+   *
+   * The functions scheduled here will fire from idle callbacks
+   * once every window has finished being restored by session
+   * restore, and after the equivalent only-once tasks
+   * have run (from _scheduleStartupIdleTasks in BrowserGlue.jsm).
+   */
+  _schedulePerWindowIdleTasks() {
+    // Bail out if the window has been closed in the meantime.
+    if (window.closed) {
+      return;
+    }
+
+    function scheduleIdleTask(func, options) {
+      requestIdleCallback(function idleTaskRunner() {
+        if (!window.closed) {
+          func();
+        }
+      }, options);
+    }
+
+    scheduleIdleTask(() => {
+      // Initialize the Sync UI
+      gSync.init();
+    });
+
+    scheduleIdleTask(() => {
+      // Read prefers-reduced-motion setting
+      let reduceMotionQuery = window.matchMedia(
+        "(prefers-reduced-motion: reduce)"
+      );
+      function readSetting() {
+        gReduceMotionSetting = reduceMotionQuery.matches;
+      }
+      reduceMotionQuery.addListener(readSetting);
+      readSetting();
+    });
+
+    scheduleIdleTask(() => {
+      // setup simple gestures support
+      gGestureSupport.init(true);
+
+      // setup history swipe animation
+      gHistorySwipeAnimation.init();
+    });
+
+    scheduleIdleTask(() => {
+      gBrowserThumbnails.init();
+    });
+
+    scheduleIdleTask(
+      () => {
+        // Initialize the download manager some time after the app starts so that
+        // auto-resume downloads begin (such as after crashing or quitting with
+        // active downloads) and speeds up the first-load of the download manager UI.
+        // If the user manually opens the download manager before the timeout, the
+        // downloads will start right away, and initializing again won't hurt.
+        try {
+          DownloadsCommon.initializeAllDataLinks();
+          ChromeUtils.import(
+            "resource:///modules/DownloadsTaskbar.jsm"
+          ).DownloadsTaskbar.registerIndicator(window);
+          if (AppConstants.platform == "macosx") {
+            ChromeUtils.import(
+              "resource:///modules/DownloadsMacFinderProgress.jsm"
+            ).DownloadsMacFinderProgress.register();
+          }
+          Services.telemetry.setEventRecordingEnabled("downloads", true);
+        } catch (ex) {
+          Cu.reportError(ex);
+        }
+      },
+      { timeout: 10000 }
+    );
+
+    if (Win7Features) {
+      scheduleIdleTask(() => Win7Features.onOpenWindow());
+    }
+
+    scheduleIdleTask(async () => {
+      NewTabPagePreloading.maybeCreatePreloadedBrowser(window);
+    });
+
+    scheduleIdleTask(() => {
+      gGfxUtils.init();
+    });
+
+    // This should always go last, since the idle tasks (except for the ones with
+    // timeouts) should execute in order. Note that this observer notification is
+    // not guaranteed to fire, since the window could close before we get here.
+    scheduleIdleTask(() => {
+      this.idleTaskPromiseResolve();
+      Services.obs.notifyObservers(
+        window,
+        "browser-idle-startup-tasks-finished"
+      );
+    });
+  },
+
+  // Returns the URI(s) to load at startup if it is immediately known, or a
+  // promise resolving to the URI to load.
+  get uriToLoadPromise() {
+    delete this.uriToLoadPromise;
+    return (this.uriToLoadPromise = (function() {
+      // window.arguments[0]: URI to load (string), or an nsIArray of
+      //                      nsISupportsStrings to load, or a xul:tab of
+      //                      a tabbrowser, which will be replaced by this
+      //                      window (for this case, all other arguments are
+      //                      ignored).
+      let uri = window.arguments?.[0];
+      if (!uri || uri instanceof window.XULElement) {
+        return null;
+      }
+
+      let defaultArgs = BrowserHandler.defaultArgs;
+
+      // If the given URI is different from the homepage, we want to load it.
+      if (uri != defaultArgs) {
+        AboutNewTab.noteNonDefaultStartup();
+
+        if (uri instanceof Ci.nsIArray) {
+          // Transform the nsIArray of nsISupportsString's into a JS Array of
+          // JS strings.
+          return Array.from(
+            uri.enumerate(Ci.nsISupportsString),
+            supportStr => supportStr.data
+          );
+        } else if (uri instanceof Ci.nsISupportsString) {
+          return uri.data;
+        }
+        return uri;
+      }
+
+      // The URI appears to be the the homepage. We want to load it only if
+      // session restore isn't about to override the homepage.
+      let willOverride = SessionStartup.willOverrideHomepage;
+      if (typeof willOverride == "boolean") {
+        return willOverride ? null : uri;
+      }
+      return willOverride.then(willOverrideHomepage =>
+        willOverrideHomepage ? null : uri
+      );
+    })());
+  },
+
+  // Calls the given callback with the URI to load at startup.
+  // Synchronously if possible, or after uriToLoadPromise resolves otherwise.
+  _callWithURIToLoad(callback) {
+    let uriToLoad = this.uriToLoadPromise;
+    if (uriToLoad && uriToLoad.then) {
+      uriToLoad.then(callback);
+    } else {
+      callback(uriToLoad);
+    }
+  },
+
+  onUnload() {
+    gUIDensity.uninit();
+
+    TabsInTitlebar.uninit();
+
+    ToolbarIconColor.uninit();
+
+    // In certain scenarios it's possible for unload to be fired before onload,
+    // (e.g. if the window is being closed after browser.js loads but before the
+    // load completes). In that case, there's nothing to do here.
+    if (!this._loadHandled) {
+      return;
+    }
+
+    // First clean up services initialized in gBrowserInit.onLoad (or those whose
+    // uninit methods don't depend on the services having been initialized).
+
+    CombinedStopReload.uninit();
+
+    gGestureSupport.init(false);
+
+    gHistorySwipeAnimation.uninit();
+
+    FullScreen.uninit();
+
+    gSync.uninit();
+
+    gExtensionsNotifications.uninit();
+
+    try {
+      gBrowser.removeProgressListener(window.XULBrowserWindow);
+      gBrowser.removeTabsProgressListener(window.TabsProgressListener);
+    } catch (ex) {}
+
+    PlacesToolbarHelper.uninit();
+
+    BookmarkingUI.uninit();
+
+    TabletModeUpdater.uninit();
+
+    gTabletModePageCounter.finish();
+
+    CaptivePortalWatcher.uninit();
+
+    SidebarUI.uninit();
+
+    DownloadsButton.uninit();
+
+    gAccessibilityServiceIndicator.uninit();
+
+    if (gToolbarKeyNavEnabled) {
+      ToolbarKeyboardNavigator.uninit();
+    }
+
+    BrowserSearch.uninit();
+
+    NewTabPagePreloading.removePreloadedBrowser(window);
+
+    // Now either cancel delayedStartup, or clean up the services initialized from
+    // it.
+    if (this._boundDelayedStartup) {
+      this._cancelDelayedStartup();
+    } else {
+      if (Win7Features) {
+        Win7Features.onCloseWindow();
+      }
+      Services.prefs.removeObserver(ctrlTab.prefName, ctrlTab);
+      ctrlTab.uninit();
+      gBrowserThumbnails.uninit();
+      gProtectionsHandler.uninit();
+      FullZoom.destroy();
+
+      Services.obs.removeObserver(gIdentityHandler, "perm-changed");
+      Services.obs.removeObserver(gRemoteControl, "devtools-socket");
+      Services.obs.removeObserver(gRemoteControl, "marionette-listening");
+      Services.obs.removeObserver(gRemoteControl, "remote-listening");
+      Services.obs.removeObserver(
+        gSessionHistoryObserver,
+        "browser:purge-session-history"
+      );
+      Services.obs.removeObserver(
+        gStoragePressureObserver,
+        "QuotaManager::StoragePressure"
+      );
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-disabled");
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-started");
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-blocked");
+      Services.obs.removeObserver(
+        gXPInstallObserver,
+        "addon-install-fullscreen-blocked"
+      );
+      Services.obs.removeObserver(
+        gXPInstallObserver,
+        "addon-install-origin-blocked"
+      );
+      Services.obs.removeObserver(
+        gXPInstallObserver,
+        "addon-install-webapi-blocked-policy"
+      );
+      Services.obs.removeObserver(
+        gXPInstallObserver,
+        "addon-install-webapi-blocked"
+      );
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-failed");
+      Services.obs.removeObserver(
+        gXPInstallObserver,
+        "addon-install-confirmation"
+      );
+      Services.obs.removeObserver(gXPInstallObserver, "addon-install-complete");
+      Services.obs.removeObserver(gKeywordURIFixup, "keyword-uri-fixup");
+
+      if (AppConstants.isPlatformAndVersionAtLeast("win", "10")) {
+        MenuTouchModeObserver.uninit();
+      }
+      BrowserOffline.uninit();
+      IndexedDBPromptHelper.uninit();
+      CanvasPermissionPromptHelper.uninit();
+      WebAuthnPromptHelper.uninit();
+      PanelUI.uninit();
+    }
+
+    // Final window teardown, do this last.
+    gBrowser.destroy();
+    window.XULBrowserWindow = null;
+    window.docShell.treeOwner
+      .QueryInterface(Ci.nsIInterfaceRequestor)
+      .getInterface(Ci.nsIAppWindow).XULBrowserWindow = null;
+    window.browserDOMWindow = null;
+  },
+};
+
+XPCOMUtils.defineLazyGetter(
+  gBrowserInit,
+  "_firstContentWindowPaintDeferred",
+  () => PromiseUtils.defer()
+);
+
+gBrowserInit.idleTasksFinishedPromise = new Promise(resolve => {
+  gBrowserInit.idleTaskPromiseResolve = resolve;
+});
+
+function HandleAppCommandEvent(evt) {
+  switch (evt.command) {
+    case "Back":
+      BrowserBack();
+      break;
+    case "Forward":
+      BrowserForward();
+      break;
+    case "Reload":
+      BrowserReloadSkipCache();
+      break;
+    case "Stop":
+      if (XULBrowserWindow.stopCommand.getAttribute("disabled") != "true") {
+        BrowserStop();
+      }
+      break;
+    case "Search":
+      BrowserSearch.webSearch();
+      break;
+    case "Bookmarks":
+      SidebarUI.toggle("viewBookmarksSidebar");
+      break;
+    case "Home":
+      BrowserHome();
+      break;
+    case "New":
+      BrowserOpenTab();
+      break;
+    case "Close":
+      BrowserCloseTabOrWindow();
+      break;
+    case "Find":
+      gLazyFindCommand("onFindCommand");
+      break;
+    case "Help":
+      openHelpLink("firefox-help");
+      break;
+    case "Open":
+      BrowserOpenFileWindow();
+      break;
+    case "Print":
+      PrintUtils.startPrintWindow(gBrowser.selectedBrowser.browsingContext);
+      break;
+    case "Save":
+      saveBrowser(gBrowser.selectedBrowser);
+      break;
+    case "SendMail":
+      MailIntegration.sendLinkForBrowser(gBrowser.selectedBrowser);
+      break;
+    default:
+      return;
+  }
+  evt.stopPropagation();
+  evt.preventDefault();
+}
+
+function gotoHistoryIndex(aEvent) {
+  aEvent = getRootEvent(aEvent);
+
+  let index = aEvent.target.getAttribute("index");
+  if (!index) {
+    return false;
+  }
+
+  let where = whereToOpenLink(aEvent);
+
+  if (where == "current") {
+    // Normal click. Go there in the current tab and update session history.
+
+    try {
+      gBrowser.gotoIndex(index);
+    } catch (ex) {
+      return false;
+    }
+    return true;
+  }
+  // Modified click. Go there in a new tab/window.
+
+  let historyindex = aEvent.target.getAttribute("historyindex");
+  duplicateTabIn(gBrowser.selectedTab, where, Number(historyindex));
+  return true;
+}
+
+function BrowserForward(aEvent) {
+  let where = whereToOpenLink(aEvent, false, true);
+
+  if (where == "current") {
+    try {
+      gBrowser.goForward();
+    } catch (ex) {}
+  } else {
+    duplicateTabIn(gBrowser.selectedTab, where, 1);
+  }
+}
+
+function BrowserBack(aEvent) {
+  let where = whereToOpenLink(aEvent, false, true);
+
+  if (where == "current") {
+    try {
+      gBrowser.goBack();
+    } catch (ex) {}
+  } else {
+    duplicateTabIn(gBrowser.selectedTab, where, -1);
+  }
+}
+
+function BrowserHandleBackspace() {
+  switch (Services.prefs.getIntPref("browser.backspace_action")) {
+    case 0:
+      BrowserBack();
+      break;
+    case 1:
+      goDoCommand("cmd_scrollPageUp");
+      break;
+  }
+}
+
+function BrowserHandleShiftBackspace() {
+  switch (Services.prefs.getIntPref("browser.backspace_action")) {
+    case 0:
+      BrowserForward();
+      break;
+    case 1:
+      goDoCommand("cmd_scrollPageDown");
+      break;
+  }
+}
+
+function BrowserStop() {
+  gBrowser.webNavigation.stop(Ci.nsIWebNavigation.STOP_ALL);
+}
+
+function BrowserReloadOrDuplicate(aEvent) {
+  aEvent = getRootEvent(aEvent);
+  let accelKeyPressed =
+    AppConstants.platform == "macosx" ? aEvent.metaKey : aEvent.ctrlKey;
+  var backgroundTabModifier = aEvent.button == 1 || accelKeyPressed;
+
+  if (aEvent.shiftKey && !backgroundTabModifier) {
+    BrowserReloadSkipCache();
+    return;
+  }
+
+  let where = whereToOpenLink(aEvent, false, true);
+  if (where == "current") {
+    BrowserReload();
+  } else {
+    duplicateTabIn(gBrowser.selectedTab, where);
+  }
+}
+
+function BrowserReload() {
+  if (gBrowser.currentURI.schemeIs("view-source")) {
+    // Bug 1167797: For view source, we always skip the cache
+    return BrowserReloadSkipCache();
+  }
+  const reloadFlags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
+  BrowserReloadWithFlags(reloadFlags);
+}
+
+const kSkipCacheFlags =
+  Ci.nsIWebNavigation.LOAD_FLAGS_BYPASS_PROXY |
+  Ci.nsIWebNavigation.LOAD_FLAGS_BYPASS_CACHE;
+function BrowserReloadSkipCache() {
+  // Bypass proxy and cache.
+  BrowserReloadWithFlags(kSkipCacheFlags);
+}
+
+function BrowserHome(aEvent) {
+  if (aEvent && "button" in aEvent && aEvent.button == 2) {
+    // right-click: do nothing
+    return;
+  }
+
+  var homePage = HomePage.get(window);
+  var where = whereToOpenLink(aEvent, false, true);
+  var urls;
+  var notifyObservers;
+
+  // Home page should open in a new tab when current tab is an app tab
+  if (where == "current" && gBrowser && gBrowser.selectedTab.pinned) {
+    where = "tab";
+  }
+
+  // openTrustedLinkIn in utilityOverlay.js doesn't handle loading multiple pages
+  switch (where) {
+    case "current":
+      // If we're going to load an initial page in the current tab as the
+      // home page, we set initialPageLoadedFromURLBar so that the URL
+      // bar is cleared properly (even during a remoteness flip).
+      if (isInitialPage(homePage)) {
+        gBrowser.selectedBrowser.initialPageLoadedFromUserAction = homePage;
+      }
+      loadOneOrMoreURIs(
+        homePage,
+        Services.scriptSecurityManager.getSystemPrincipal(),
+        null
+      );
+      if (isBlankPageURL(homePage)) {
+        gURLBar.select();
+      } else {
+        gBrowser.selectedBrowser.focus();
+      }
+      notifyObservers = true;
+      aEvent?.preventDefault();
+      break;
+    case "tabshifted":
+    case "tab":
+      urls = homePage.split("|");
+      var loadInBackground = Services.prefs.getBoolPref(
+        "browser.tabs.loadBookmarksInBackground",
+        false
+      );
+      // The homepage observer event should only be triggered when the homepage opens
+      // in the foreground. This is mostly to support the homepage changed by extension
+      // doorhanger which doesn't currently support background pages. This may change in
+      // bug 1438396.
+      notifyObservers = !loadInBackground;
+      gBrowser.loadTabs(urls, {
+        inBackground: loadInBackground,
+        triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+        csp: null,
+      });
+      if (!loadInBackground) {
+        if (isBlankPageURL(homePage)) {
+          gURLBar.select();
+        } else {
+          gBrowser.selectedBrowser.focus();
+        }
+      }
+      aEvent?.preventDefault();
+      break;
+    case "window":
+      // OpenBrowserWindow will trigger the observer event, so no need to do so here.
+      notifyObservers = false;
+      OpenBrowserWindow();
+      aEvent?.preventDefault();
+      break;
+  }
+  if (notifyObservers) {
+    // A notification for when a user has triggered their homepage. This is used
+    // to display a doorhanger explaining that an extension has modified the
+    // homepage, if necessary. Observers are only notified if the homepage
+    // becomes the active page.
+    Services.obs.notifyObservers(null, "browser-open-homepage-start");
+  }
+}
+
+function loadOneOrMoreURIs(aURIString, aTriggeringPrincipal, aCsp) {
+  // we're not a browser window, pass the URI string to a new browser window
+  if (window.location.href != AppConstants.BROWSER_CHROME_URL) {
+    window.openDialog(
+      AppConstants.BROWSER_CHROME_URL,
+      "_blank",
+      "all,dialog=no",
+      aURIString
+    );
+    return;
+  }
+
+  // This function throws for certain malformed URIs, so use exception handling
+  // so that we don't disrupt startup
+  try {
+    gBrowser.loadTabs(aURIString.split("|"), {
+      inBackground: false,
+      replace: true,
+      triggeringPrincipal: aTriggeringPrincipal,
+      csp: aCsp,
+    });
+  } catch (e) {}
+}
+
+function openLocation(event) {
+  if (window.location.href == AppConstants.BROWSER_CHROME_URL) {
+    gURLBar.select();
+    gURLBar.view.autoOpen({ event });
+    return;
+  }
+
+  // If there's an open browser window, redirect the command there.
+  let win = getTopWin();
+  if (win) {
+    win.focus();
+    win.openLocation();
+    return;
+  }
+
+  // There are no open browser windows; open a new one.
+  window.openDialog(
+    AppConstants.BROWSER_CHROME_URL,
+    "_blank",
+    "chrome,all,dialog=no",
+    BROWSER_NEW_TAB_URL
+  );
+}
+
+function BrowserOpenTab(event) {
+  let where = "tab";
+  let relatedToCurrent = false;
+
+  if (event) {
+    where = whereToOpenLink(event, false, true);
+
+    switch (where) {
+      case "tab":
+      case "tabshifted":
+        // When accel-click or middle-click are used, open the new tab as
+        // related to the current tab.
+        relatedToCurrent = true;
+        break;
+      case "current":
+        where = "tab";
+        break;
+    }
+  }
+
+  // A notification intended to be useful for modular peformance tracking
+  // starting as close as is reasonably possible to the time when the user
+  // expressed the intent to open a new tab.  Since there are a lot of
+  // entry points, this won't catch every single tab created, but most
+  // initiated by the user should go through here.
+  //
+  // Note 1: This notification gets notified with a promise that resolves
+  //         with the linked browser when the tab gets created
+  // Note 2: This is also used to notify a user that an extension has changed
+  //         the New Tab page.
+  Services.obs.notifyObservers(
+    {
+      wrappedJSObject: new Promise(resolve => {
+        openTrustedLinkIn(BROWSER_NEW_TAB_URL, where, {
+          relatedToCurrent,
+          resolveOnNewTabCreated: resolve,
+        });
+      }),
+    },
+    "browser-open-newtab-start"
+  );
+}
+
+var gLastOpenDirectory = {
+  _lastDir: null,
+  get path() {
+    if (!this._lastDir || !this._lastDir.exists()) {
+      try {
+        this._lastDir = Services.prefs.getComplexValue(
+          "browser.open.lastDir",
+          Ci.nsIFile
+        );
+        if (!this._lastDir.exists()) {
+          this._lastDir = null;
+        }
+      } catch (e) {}
+    }
+    return this._lastDir;
+  },
+  set path(val) {
+    try {
+      if (!val || !val.isDirectory()) {
+        return;
+      }
+    } catch (e) {
+      return;
+    }
+    this._lastDir = val.clone();
+
+    // Don't save the last open directory pref inside the Private Browsing mode
+    if (!PrivateBrowsingUtils.isWindowPrivate(window)) {
+      Services.prefs.setComplexValue(
+        "browser.open.lastDir",
+        Ci.nsIFile,
+        this._lastDir
+      );
+    }
+  },
+  reset() {
+    this._lastDir = null;
+  },
+};
+
+function BrowserOpenFileWindow() {
+  // Get filepicker component.
+  try {
+    const nsIFilePicker = Ci.nsIFilePicker;
+    let fp = Cc["@mozilla.org/filepicker;1"].createInstance(nsIFilePicker);
+    let fpCallback = function fpCallback_done(aResult) {
+      if (aResult == nsIFilePicker.returnOK) {
+        try {
+          if (fp.file) {
+            gLastOpenDirectory.path = fp.file.parent.QueryInterface(Ci.nsIFile);
+          }
+        } catch (ex) {}
+        openTrustedLinkIn(fp.fileURL.spec, "current");
+      }
+    };
+
+    fp.init(
+      window,
+      gNavigatorBundle.getString("openFile"),
+      nsIFilePicker.modeOpen
+    );
+    fp.appendFilters(
+      nsIFilePicker.filterAll |
+        nsIFilePicker.filterText |
+        nsIFilePicker.filterImages |
+        nsIFilePicker.filterXML |
+        nsIFilePicker.filterHTML
+    );
+    fp.displayDirectory = gLastOpenDirectory.path;
+    fp.open(fpCallback);
+  } catch (ex) {}
+}
+
+function BrowserCloseTabOrWindow(event) {
+  // If we're not a browser window, just close the window.
+  if (window.location.href != AppConstants.BROWSER_CHROME_URL) {
+    closeWindow(true);
+    return;
+  }
+
+  // In a multi-select context, close all selected tabs
+  if (gBrowser.multiSelectedTabsCount) {
+    gBrowser.removeMultiSelectedTabs();
+    return;
+  }
+
+  // Keyboard shortcuts that would close a tab that is pinned select the first
+  // unpinned tab instead.
+  if (
+    event &&
+    (event.ctrlKey || event.metaKey || event.altKey) &&
+    gBrowser.selectedTab.pinned
+  ) {
+    if (gBrowser.visibleTabs.length > gBrowser._numPinnedTabs) {
+      gBrowser.tabContainer.selectedIndex = gBrowser._numPinnedTabs;
+    }
+    return;
+  }
+
+  // If the current tab is the last one, this will close the window.
+  gBrowser.removeCurrentTab({ animate: true });
+}
+
+function BrowserTryToCloseWindow(event) {
+  if (WindowIsClosing(event)) {
+    window.close();
+  } // WindowIsClosing does all the necessary checks
+}
+
+function loadURI(
+  uri,
+  referrerInfo,
+  postData,
+  allowThirdPartyFixup,
+  userContextId,
+  originPrincipal,
+  originStoragePrincipal,
+  forceAboutBlankViewerInCurrent,
+  triggeringPrincipal,
+  allowInheritPrincipal = false,
+  csp = null
+) {
+  if (!triggeringPrincipal) {
+    throw new Error("Must load with a triggering Principal");
+  }
+
+  try {
+    openLinkIn(uri, "current", {
+      referrerInfo,
+      postData,
+      allowThirdPartyFixup,
+      userContextId,
+      originPrincipal,
+      originStoragePrincipal,
+      triggeringPrincipal,
+      csp,
+      forceAboutBlankViewerInCurrent,
+      allowInheritPrincipal,
+    });
+  } catch (e) {
+    Cu.reportError(e);
+  }
+}
+
+function getLoadContext() {
+  return window.docShell.QueryInterface(Ci.nsILoadContext);
+}
+
+function readFromClipboard() {
+  var url;
+
+  try {
+    // Create transferable that will transfer the text.
+    var trans = Cc["@mozilla.org/widget/transferable;1"].createInstance(
+      Ci.nsITransferable
+    );
+    trans.init(getLoadContext());
+
+    trans.addDataFlavor("text/unicode");
+
+    // If available, use selection clipboard, otherwise global one
+    if (Services.clipboard.supportsSelectionClipboard()) {
+      Services.clipboard.getData(trans, Services.clipboard.kSelectionClipboard);
+    } else {
+      Services.clipboard.getData(trans, Services.clipboard.kGlobalClipboard);
+    }
+
+    var data = {};
+    trans.getTransferData("text/unicode", data);
+
+    if (data) {
+      data = data.value.QueryInterface(Ci.nsISupportsString);
+      url = data.data;
+    }
+  } catch (ex) {}
+
+  return url;
+}
+
+/**
+ * Open the View Source dialog.
+ *
+ * @param args
+ *        An object with the following properties:
+ *
+ *        URL (required):
+ *          A string URL for the page we'd like to view the source of.
+ *        browser (optional):
+ *          The browser containing the document that we would like to view the
+ *          source of. This is required if outerWindowID is passed.
+ *        outerWindowID (optional):
+ *          The outerWindowID of the content window containing the document that
+ *          we want to view the source of. You only need to provide this if you
+ *          want to attempt to retrieve the document source from the network
+ *          cache.
+ *        lineNumber (optional):
+ *          The line number to focus on once the source is loaded.
+ */
+async function BrowserViewSourceOfDocument(args) {
+  // Check if external view source is enabled.  If so, try it.  If it fails,
+  // fallback to internal view source.
+  if (Services.prefs.getBoolPref("view_source.editor.external")) {
+    try {
+      await top.gViewSourceUtils.openInExternalEditor(args);
+      return;
+    } catch (data) {}
+  }
+
+  let tabBrowser = gBrowser;
+  let preferredRemoteType;
+  let initialBrowsingContextGroupId;
+  if (args.browser) {
+    preferredRemoteType = args.browser.remoteType;
+    initialBrowsingContextGroupId = args.browser.browsingContext.group.id;
+  } else {
+    if (!tabBrowser) {
+      throw new Error(
+        "BrowserViewSourceOfDocument should be passed the " +
+          "subject browser if called from a window without " +
+          "gBrowser defined."
+      );
+    }
+    // Some internal URLs (such as specific chrome: and about: URLs that are
+    // not yet remote ready) cannot be loaded in a remote browser.  View
+    // source in tab expects the new view source browser's remoteness to match
+    // that of the original URL, so disable remoteness if necessary for this
+    // URL.
+    var oa = E10SUtils.predictOriginAttributes({ window });
+    preferredRemoteType = E10SUtils.getRemoteTypeForURI(
+      args.URL,
+      gMultiProcessBrowser,
+      gFissionBrowser,
+      E10SUtils.DEFAULT_REMOTE_TYPE,
+      null,
+      oa
+    );
+  }
+
+  // In the case of popups, we need to find a non-popup browser window.
+  if (!tabBrowser || !window.toolbar.visible) {
+    // This returns only non-popup browser windows by default.
+    let browserWindow = BrowserWindowTracker.getTopWindow();
+    tabBrowser = browserWindow.gBrowser;
+  }
+
+  const inNewWindow = !Services.prefs.getBoolPref("view_source.tab");
+
+  // `viewSourceInBrowser` will load the source content from the page
+  // descriptor for the tab (when possible) or fallback to the network if
+  // that fails.  Either way, the view source module will manage the tab's
+  // location, so use "about:blank" here to avoid unnecessary redundant
+  // requests.
+  let tab = tabBrowser.loadOneTab("about:blank", {
+    relatedToCurrent: true,
+    inBackground: inNewWindow,
+    skipAnimation: inNewWindow,
+    preferredRemoteType,
+    initialBrowsingContextGroupId,
+    triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+    skipLoad: true,
+  });
+  args.viewSourceBrowser = tabBrowser.getBrowserForTab(tab);
+  top.gViewSourceUtils.viewSourceInBrowser(args);
+
+  if (inNewWindow) {
+    tabBrowser.hideTab(tab);
+    tabBrowser.replaceTabWithWindow(tab);
+  }
+}
+
+/**
+ * Opens the View Source dialog for the source loaded in the root
+ * top-level document of the browser. This is really just a
+ * convenience wrapper around BrowserViewSourceOfDocument.
+ *
+ * @param browser
+ *        The browser that we want to load the source of.
+ */
+function BrowserViewSource(browser) {
+  BrowserViewSourceOfDocument({
+    browser,
+    outerWindowID: browser.outerWindowID,
+    URL: browser.currentURI.spec,
+  });
+}
+
+// documentURL - URL of the document to view, or null for this window's document
+// initialTab - name of the initial tab to display, or null for the first tab
+// imageElement - image to load in the Media Tab of the Page Info window; can be null/omitted
+// browsingContext - the browsingContext of the frame that we want to view information about; can be null/omitted
+// browser - the browser containing the document we're interested in inspecting; can be null/omitted
+function BrowserPageInfo(
+  documentURL,
+  initialTab,
+  imageElement,
+  browsingContext,
+  browser
+) {
+  if (documentURL instanceof HTMLDocument) {
+    Deprecated.warning(
+      "Please pass the location URL instead of the document " +
+        "to BrowserPageInfo() as the first argument.",
+      "https://bugzilla.mozilla.org/show_bug.cgi?id=1238180"
+    );
+    documentURL = documentURL.location;
+  }
+
+  let args = { initialTab, imageElement, browsingContext, browser };
+
+  documentURL = documentURL || window.gBrowser.selectedBrowser.currentURI.spec;
+
+  // Check for windows matching the url
+  for (let currentWindow of Services.wm.getEnumerator("Browser:page-info")) {
+    if (currentWindow.closed) {
+      continue;
+    }
+    if (
+      currentWindow.document.documentElement.getAttribute("relatedUrl") ==
+      documentURL
+    ) {
+      currentWindow.focus();
+      currentWindow.resetPageInfo(args);
+      return currentWindow;
+    }
+  }
+
+  // We didn't find a matching window, so open a new one.
+  return openDialog(
+    "chrome://browser/content/pageinfo/pageInfo.xhtml",
+    "",
+    "chrome,toolbar,dialog=no,resizable",
+    args
+  );
+}
+
+function UpdateUrlbarSearchSplitterState() {
+  var splitter = document.getElementById("urlbar-search-splitter");
+  var urlbar = document.getElementById("urlbar-container");
+  var searchbar = document.getElementById("search-container");
+
+  if (document.documentElement.getAttribute("customizing") == "true") {
+    if (splitter) {
+      splitter.remove();
+    }
+    return;
+  }
+
+  // If the splitter is already in the right place, we don't need to do anything:
+  if (
+    splitter &&
+    ((splitter.nextElementSibling == searchbar &&
+      splitter.previousElementSibling == urlbar) ||
+      (splitter.nextElementSibling == urlbar &&
+        splitter.previousElementSibling == searchbar))
+  ) {
+    return;
+  }
+
+  var ibefore = null;
+  if (urlbar && searchbar) {
+    if (urlbar.nextElementSibling == searchbar) {
+      ibefore = searchbar;
+    } else if (searchbar.nextElementSibling == urlbar) {
+      ibefore = urlbar;
+    }
+  }
+
+  if (ibefore) {
+    if (!splitter) {
+      splitter = document.createXULElement("splitter");
+      splitter.id = "urlbar-search-splitter";
+      splitter.setAttribute("resizebefore", "flex");
+      splitter.setAttribute("resizeafter", "flex");
+      splitter.setAttribute("skipintoolbarset", "true");
+      splitter.setAttribute("overflows", "false");
+      splitter.className = "chromeclass-toolbar-additional";
+    }
+    urlbar.parentNode.insertBefore(splitter, ibefore);
+  } else if (splitter) {
+    splitter.remove();
+  }
+}
+
+function UpdatePopupNotificationsVisibility() {
+  // Only need to update PopupNotifications if it has already been initialized
+  // for this window (i.e. its getter no longer exists).
+  if (!Object.getOwnPropertyDescriptor(window, "PopupNotifications").get) {
+    // Notify PopupNotifications that the visible anchors may have changed. This
+    // also checks the suppression state according to the "shouldSuppress"
+    // function defined earlier in this file.
+    PopupNotifications.anchorVisibilityChange();
+  }
+
+  // This is similar to the above, but for notifications attached to the
+  // hamburger menu icon (such as update notifications and add-on install
+  // notifications.)
+  PanelUI?.updateNotifications();
+}
+
+function PageProxyClickHandler(aEvent) {
+  if (aEvent.button == 1 && Services.prefs.getBoolPref("middlemouse.paste")) {
+    middleMousePaste(aEvent);
+  }
+}
+
+/**
+ * Handle command events bubbling up from error page content
+ * or from about:newtab or from remote error pages that invoke
+ * us via async messaging.
+ */
+var BrowserOnClick = {
+  ignoreWarningLink(reason, blockedInfo, browsingContext) {
+    let triggeringPrincipal =
+      blockedInfo.triggeringPrincipal ||
+      _createNullPrincipalFromTabUserContextId();
+
+    // Allow users to override and continue through to the site,
+    // but add a notify bar as a reminder, so that they don't lose
+    // track after, e.g., tab switching.
+    browsingContext.loadURI(blockedInfo.uri, {
+      triggeringPrincipal,
+      flags: Ci.nsIWebNavigation.LOAD_FLAGS_BYPASS_CLASSIFIER,
+    });
+
+    // We can't use browser.contentPrincipal which is principal of about:blocked
+    // Create one from uri with current principal origin attributes
+    let principal = Services.scriptSecurityManager.createContentPrincipal(
+      Services.io.newURI(blockedInfo.uri),
+      browsingContext.currentWindowGlobal.documentPrincipal.originAttributes
+    );
+    Services.perms.addFromPrincipal(
+      principal,
+      "safe-browsing",
+      Ci.nsIPermissionManager.ALLOW_ACTION,
+      Ci.nsIPermissionManager.EXPIRE_SESSION
+    );
+
+    let buttons = [
+      {
+        label: gNavigatorBundle.getString(
+          "safebrowsing.getMeOutOfHereButton.label"
+        ),
+        accessKey: gNavigatorBundle.getString(
+          "safebrowsing.getMeOutOfHereButton.accessKey"
+        ),
+        callback() {
+          getMeOutOfHere(browsingContext);
+        },
+      },
+    ];
+
+    let title;
+    if (reason === "malware") {
+      let reportUrl = gSafeBrowsing.getReportURL("MalwareMistake", blockedInfo);
+      title = gNavigatorBundle.getString("safebrowsing.reportedAttackSite");
+      // There's no button if we can not get report url, for example if the provider
+      // of blockedInfo is not Google
+      if (reportUrl) {
+        buttons[1] = {
+          label: gNavigatorBundle.getString(
+            "safebrowsing.notAnAttackButton.label"
+          ),
+          accessKey: gNavigatorBundle.getString(
+            "safebrowsing.notAnAttackButton.accessKey"
+          ),
+          callback() {
+            openTrustedLinkIn(reportUrl, "tab");
+          },
+        };
+      }
+    } else if (reason === "phishing") {
+      let reportUrl = gSafeBrowsing.getReportURL("PhishMistake", blockedInfo);
+      title = gNavigatorBundle.getString("safebrowsing.deceptiveSite");
+      // There's no button if we can not get report url, for example if the provider
+      // of blockedInfo is not Google
+      if (reportUrl) {
+        buttons[1] = {
+          label: gNavigatorBundle.getString(
+            "safebrowsing.notADeceptiveSiteButton.label"
+          ),
+          accessKey: gNavigatorBundle.getString(
+            "safebrowsing.notADeceptiveSiteButton.accessKey"
+          ),
+          callback() {
+            openTrustedLinkIn(reportUrl, "tab");
+          },
+        };
+      }
+    } else if (reason === "unwanted") {
+      title = gNavigatorBundle.getString("safebrowsing.reportedUnwantedSite");
+      // There is no button for reporting errors since Google doesn't currently
+      // provide a URL endpoint for these reports.
+    } else if (reason === "harmful") {
+      title = gNavigatorBundle.getString("safebrowsing.reportedHarmfulSite");
+      // There is no button for reporting errors since Google doesn't currently
+      // provide a URL endpoint for these reports.
+    }
+
+    SafeBrowsingNotificationBox.show(title, buttons);
+  },
+};
+
+/**
+ * Re-direct the browser to a known-safe page.  This function is
+ * used when, for example, the user browses to a known malware page
+ * and is presented with about:blocked.  The "Get me out of here!"
+ * button should take the user to the default start page so that even
+ * when their own homepage is infected, we can get them somewhere safe.
+ */
+function getMeOutOfHere(browsingContext) {
+  browsingContext.top.loadURI(getDefaultHomePage(), {
+    triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(), // Also needs to load homepage
+  });
+}
+
+/**
+ * Return the default start page for the cases when the user's own homepage is
+ * infected, so we can get them somewhere safe.
+ */
+function getDefaultHomePage() {
+  let url = BROWSER_NEW_TAB_URL;
+  if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+    return url;
+  }
+  url = HomePage.getDefault();
+  // If url is a pipe-delimited set of pages, just take the first one.
+  if (url.includes("|")) {
+    url = url.split("|")[0];
+  }
+  return url;
+}
+
+function BrowserFullScreen() {
+  window.fullScreen = !window.fullScreen || BrowserHandler.kiosk;
+}
+
+function BrowserReloadWithFlags(reloadFlags) {
+  let unchangedRemoteness = [];
+
+  for (let tab of gBrowser.selectedTabs) {
+    let browser = tab.linkedBrowser;
+    let url = browser.currentURI.spec;
+    // We need to cache the content principal here because the browser will be
+    // reconstructed when the remoteness changes and the content prinicpal will
+    // be cleared after reconstruction.
+    let principal = tab.linkedBrowser.contentPrincipal;
+    if (gBrowser.updateBrowserRemotenessByURL(browser, url)) {
+      // If the remoteness has changed, the new browser doesn't have any
+      // information of what was loaded before, so we need to load the previous
+      // URL again.
+      if (tab.linkedPanel) {
+        loadBrowserURI(browser, url, principal);
+      } else {
+        // Shift to fully loaded browser and make
+        // sure load handler is instantiated.
+        tab.addEventListener(
+          "SSTabRestoring",
+          () => loadBrowserURI(browser, url, principal),
+          { once: true }
+        );
+        gBrowser._insertBrowser(tab);
+      }
+    } else {
+      unchangedRemoteness.push(tab);
+    }
+  }
+
+  if (!unchangedRemoteness.length) {
+    return;
+  }
+
+  // Reset temporary permissions on the remaining tabs to reload.
+  // This is done here because we only want to reset
+  // permissions on user reload.
+  for (let tab of unchangedRemoteness) {
+    SitePermissions.clearTemporaryBlockPermissions(tab.linkedBrowser);
+    // Also reset DOS mitigations for the basic auth prompt on reload.
+    delete tab.linkedBrowser.authPromptAbuseCounter;
+  }
+  gIdentityHandler.hidePopup();
+  gPermissionPanel.hidePopup();
+
+  let handlingUserInput = document.hasValidTransientUserGestureActivation;
+
+  for (let tab of unchangedRemoteness) {
+    if (tab.linkedPanel) {
+      sendReloadMessage(tab);
+    } else {
+      // Shift to fully loaded browser and make
+      // sure load handler is instantiated.
+      tab.addEventListener("SSTabRestoring", () => sendReloadMessage(tab), {
+        once: true,
+      });
+      gBrowser._insertBrowser(tab);
+    }
+  }
+
+  function loadBrowserURI(browser, url, principal) {
+    browser.loadURI(url, {
+      flags: reloadFlags,
+      triggeringPrincipal: principal,
+    });
+  }
+
+  function sendReloadMessage(tab) {
+    tab.linkedBrowser.sendMessageToActor(
+      "Browser:Reload",
+      { flags: reloadFlags, handlingUserInput },
+      "BrowserTab"
+    );
+  }
+}
+
+function getSecurityInfo(securityInfoAsString) {
+  if (!securityInfoAsString) {
+    return null;
+  }
+
+  let securityInfo = gSerializationHelper.deserializeObject(
+    securityInfoAsString
+  );
+  securityInfo.QueryInterface(Ci.nsITransportSecurityInfo);
+
+  return securityInfo;
+}
+
+// TODO: can we pull getPEMString in from pippki.js instead of
+// duplicating them here?
+function getPEMString(cert) {
+  var derb64 = cert.getBase64DERString();
+  // Wrap the Base64 string into lines of 64 characters,
+  // with CRLF line breaks (as specified in RFC 1421).
+  var wrapped = derb64.replace(/(\S{64}(?!$))/g, "$1\r\n");
+  return (
+    "-----BEGIN CERTIFICATE-----\r\n" +
+    wrapped +
+    "\r\n-----END CERTIFICATE-----\r\n"
+  );
+}
+
+var browserDragAndDrop = {
+  canDropLink: aEvent => Services.droppedLinkHandler.canDropLink(aEvent, true),
+
+  dragOver(aEvent) {
+    if (this.canDropLink(aEvent)) {
+      aEvent.preventDefault();
+    }
+  },
+
+  getTriggeringPrincipal(aEvent) {
+    return Services.droppedLinkHandler.getTriggeringPrincipal(aEvent);
+  },
+
+  getCSP(aEvent) {
+    return Services.droppedLinkHandler.getCSP(aEvent);
+  },
+
+  validateURIsForDrop(aEvent, aURIs) {
+    return Services.droppedLinkHandler.validateURIsForDrop(aEvent, aURIs);
+  },
+
+  dropLinks(aEvent, aDisallowInherit) {
+    return Services.droppedLinkHandler.dropLinks(aEvent, aDisallowInherit);
+  },
+};
+
+var homeButtonObserver = {
+  onDrop(aEvent) {
+    // disallow setting home pages that inherit the principal
+    let links = browserDragAndDrop.dropLinks(aEvent, true);
+    if (links.length) {
+      let urls = [];
+      for (let link of links) {
+        if (link.url.includes("|")) {
+          urls.push(...link.url.split("|"));
+        } else {
+          urls.push(link.url);
+        }
+      }
+
+      try {
+        browserDragAndDrop.validateURIsForDrop(aEvent, urls);
+      } catch (e) {
+        return;
+      }
+
+      setTimeout(openHomeDialog, 0, urls.join("|"));
+    }
+  },
+
+  onDragOver(aEvent) {
+    if (HomePage.locked) {
+      return;
+    }
+    browserDragAndDrop.dragOver(aEvent);
+    aEvent.dropEffect = "link";
+  },
+};
+
+function openHomeDialog(aURL) {
+  var promptTitle = gNavigatorBundle.getString("droponhometitle");
+  var promptMsg;
+  if (aURL.includes("|")) {
+    promptMsg = gNavigatorBundle.getString("droponhomemsgMultiple");
+  } else {
+    promptMsg = gNavigatorBundle.getString("droponhomemsg");
+  }
+
+  var pressedVal = Services.prompt.confirmEx(
+    window,
+    promptTitle,
+    promptMsg,
+    Services.prompt.STD_YES_NO_BUTTONS,
+    null,
+    null,
+    null,
+    null,
+    { value: 0 }
+  );
+
+  if (pressedVal == 0) {
+    HomePage.set(aURL).catch(Cu.reportError);
+  }
+}
+
+var newTabButtonObserver = {
+  onDragOver(aEvent) {
+    browserDragAndDrop.dragOver(aEvent);
+  },
+  async onDrop(aEvent) {
+    let links = browserDragAndDrop.dropLinks(aEvent);
+    if (
+      links.length >=
+      Services.prefs.getIntPref("browser.tabs.maxOpenBeforeWarn")
+    ) {
+      // Sync dialog cannot be used inside drop event handler.
+      let answer = await OpenInTabsUtils.promiseConfirmOpenInTabs(
+        links.length,
+        window
+      );
+      if (!answer) {
+        return;
+      }
+    }
+
+    let where = aEvent.shiftKey ? "tabshifted" : "tab";
+    let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(aEvent);
+    let csp = browserDragAndDrop.getCSP(aEvent);
+    for (let link of links) {
+      if (link.url) {
+        let data = await UrlbarUtils.getShortcutOrURIAndPostData(link.url);
+        // Allow third-party services to fixup this URL.
+        openLinkIn(data.url, where, {
+          postData: data.postData,
+          allowThirdPartyFixup: true,
+          triggeringPrincipal,
+          csp,
+        });
+      }
+    }
+  },
+};
+
+var newWindowButtonObserver = {
+  onDragOver(aEvent) {
+    browserDragAndDrop.dragOver(aEvent);
+  },
+  async onDrop(aEvent) {
+    let links = browserDragAndDrop.dropLinks(aEvent);
+    if (
+      links.length >=
+      Services.prefs.getIntPref("browser.tabs.maxOpenBeforeWarn")
+    ) {
+      // Sync dialog cannot be used inside drop event handler.
+      let answer = await OpenInTabsUtils.promiseConfirmOpenInTabs(
+        links.length,
+        window
+      );
+      if (!answer) {
+        return;
+      }
+    }
+
+    let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(aEvent);
+    let csp = browserDragAndDrop.getCSP(aEvent);
+    for (let link of links) {
+      if (link.url) {
+        let data = await UrlbarUtils.getShortcutOrURIAndPostData(link.url);
+        // Allow third-party services to fixup this URL.
+        openLinkIn(data.url, "window", {
+          // TODO fix allowInheritPrincipal
+          // (this is required by javascript: drop to the new window) Bug 1475201
+          allowInheritPrincipal: true,
+          postData: data.postData,
+          allowThirdPartyFixup: true,
+          triggeringPrincipal,
+          csp,
+        });
+      }
+    }
+  },
+};
+
+const BrowserSearch = {
+  _searchInitComplete: false,
+
+  init() {
+    Services.obs.addObserver(this, "browser-search-engine-modified");
+  },
+
+  delayedStartupInit() {
+    // Asynchronously initialize the search service if necessary, to get the
+    // current engine for working out the placeholder.
+    this._updateURLBarPlaceholderFromDefaultEngine(
+      PrivateBrowsingUtils.isWindowPrivate(window),
+      // Delay the update for this until so that we don't change it while
+      // the user is looking at it / isn't expecting it.
+      true
+    ).then(() => {
+      this._searchInitComplete = true;
+    });
+  },
+
+  uninit() {
+    Services.obs.removeObserver(this, "browser-search-engine-modified");
+  },
+
+  observe(engine, topic, data) {
+    // There are two kinds of search engine objects, nsISearchEngine objects and
+    // plain { uri, title, icon } objects.  `engine` in this method is the
+    // former.  The browser.engines and browser.hiddenEngines arrays are the
+    // latter, and they're the engines offered by the the page in the browser.
+    //
+    // The two types of engines are currently related by their titles/names,
+    // although that may change; see bug 335102.
+    let engineName = engine.wrappedJSObject.name;
+    switch (data) {
+      case "engine-removed":
+        // An engine was removed from the search service.  If a page is offering
+        // the engine, then the engine needs to be added back to the corresponding
+        // browser's offered engines.
+        this._addMaybeOfferedEngine(engineName);
+        break;
+      case "engine-added":
+        // An engine was added to the search service.  If a page is offering the
+        // engine, then the engine needs to be removed from the corresponding
+        // browser's offered engines.
+        this._removeMaybeOfferedEngine(engineName);
+        break;
+      case "engine-default":
+        if (
+          this._searchInitComplete &&
+          !PrivateBrowsingUtils.isWindowPrivate(window)
+        ) {
+          this._updateURLBarPlaceholder(engineName, false);
+        }
+        break;
+      case "engine-default-private":
+        if (
+          this._searchInitComplete &&
+          PrivateBrowsingUtils.isWindowPrivate(window)
+        ) {
+          this._updateURLBarPlaceholder(engineName, true);
+        }
+        break;
+    }
+  },
+
+  _addMaybeOfferedEngine(engineName) {
+    let selectedBrowserOffersEngine = false;
+    for (let browser of gBrowser.browsers) {
+      for (let i = 0; i < (browser.hiddenEngines || []).length; i++) {
+        if (browser.hiddenEngines[i].title == engineName) {
+          if (!browser.engines) {
+            browser.engines = [];
+          }
+          browser.engines.push(browser.hiddenEngines[i]);
+          browser.hiddenEngines.splice(i, 1);
+          if (browser == gBrowser.selectedBrowser) {
+            selectedBrowserOffersEngine = true;
+          }
+          break;
+        }
+      }
+    }
+    if (selectedBrowserOffersEngine) {
+      this.updateOpenSearchBadge();
+    }
+  },
+
+  _removeMaybeOfferedEngine(engineName) {
+    let selectedBrowserOffersEngine = false;
+    for (let browser of gBrowser.browsers) {
+      for (let i = 0; i < (browser.engines || []).length; i++) {
+        if (browser.engines[i].title == engineName) {
+          if (!browser.hiddenEngines) {
+            browser.hiddenEngines = [];
+          }
+          browser.hiddenEngines.push(browser.engines[i]);
+          browser.engines.splice(i, 1);
+          if (browser == gBrowser.selectedBrowser) {
+            selectedBrowserOffersEngine = true;
+          }
+          break;
+        }
+      }
+    }
+    if (selectedBrowserOffersEngine) {
+      this.updateOpenSearchBadge();
+    }
+  },
+
+  /**
+   * Initializes the urlbar placeholder to the pre-saved engine name. We do this
+   * via a preference, to avoid needing to synchronously init the search service.
+   *
+   * This should be called around the time of DOMContentLoaded, so that it is
+   * initialized quickly before the user sees anything.
+   *
+   * Note: If the preference doesn't exist, we don't do anything as the default
+   * placeholder is a string which doesn't have the engine name; however, this
+   * can be overridden using the `force` parameter.
+   *
+   * @param {Boolean} force If true and the preference doesn't exist, the
+   *                        placeholder will be set to the default version
+   *                        without an engine name ("Search or enter address").
+   */
+  initPlaceHolder(force = false) {
+    const prefName =
+      "browser.urlbar.placeholderName" +
+      (PrivateBrowsingUtils.isWindowPrivate(window) ? ".private" : "");
+    let engineName = Services.prefs.getStringPref(prefName, "");
+    if (engineName || force) {
+      // We can do this directly, since we know we're at DOMContentLoaded.
+      this._setURLBarPlaceholder(engineName);
+    }
+  },
+
+  /**
+   * This is a wrapper around '_updateURLBarPlaceholder' that uses the
+   * appropriate default engine to get the engine name.
+   *
+   * @param {Boolean} isPrivate      Set to true if this is a private window.
+   * @param {Boolean} [delayUpdate]  Set to true, to delay update until the
+   *                                 placeholder is not displayed.
+   */
+  async _updateURLBarPlaceholderFromDefaultEngine(
+    isPrivate,
+    delayUpdate = false
+  ) {
+    const getDefault = isPrivate
+      ? Services.search.getDefaultPrivate
+      : Services.search.getDefault;
+    let defaultEngine = await getDefault();
+
+    this._updateURLBarPlaceholder(defaultEngine.name, isPrivate, delayUpdate);
+  },
+
+  /**
+   * Updates the URLBar placeholder for the specified engine, delaying the
+   * update if required. This also saves the current engine name in preferences
+   * for the next restart.
+   *
+   * Note: The engine name will only be displayed for built-in engines, as we
+   * know they should have short names.
+   *
+   * @param {String}  engineName     The search engine name to use for the update.
+   * @param {Boolean} isPrivate      Set to true if this is a private window.
+   * @param {Boolean} [delayUpdate]  Set to true, to delay update until the
+   *                                 placeholder is not displayed.
+   */
+  _updateURLBarPlaceholder(engineName, isPrivate, delayUpdate = false) {
+    if (!engineName) {
+      throw new Error("Expected an engineName to be specified");
+    }
+
+    const engine = Services.search.getEngineByName(engineName);
+    const prefName =
+      "browser.urlbar.placeholderName" + (isPrivate ? ".private" : "");
+    if (engine.isAppProvided) {
+      Services.prefs.setStringPref(prefName, engineName);
+    } else {
+      Services.prefs.clearUserPref(prefName);
+      // Set the engine name to an empty string for non-default engines, which'll
+      // make sure we display the default placeholder string.
+      engineName = "";
+    }
+
+    // Only delay if requested, and we're not displaying text in the URL bar
+    // currently.
+    if (delayUpdate && !gURLBar.value) {
+      // Delays changing the URL Bar placeholder until the user is not going to be
+      // seeing it, e.g. when there is a value entered in the bar, or if there is
+      // a tab switch to a tab which has a url loaded. We delay the update until
+      // the user is out of search mode since an alternative placeholder is used
+      // in search mode.
+      let placeholderUpdateListener = () => {
+        if (gURLBar.value && !gURLBar.searchMode) {
+          // By the time the user has switched, they may have changed the engine
+          // again, so we need to call this function again but with the
+          // new engine name.
+          // No need to await for this to finish, we're in a listener here anyway.
+          this._updateURLBarPlaceholderFromDefaultEngine(isPrivate, false);
+          gURLBar.removeEventListener("input", placeholderUpdateListener);
+          gBrowser.tabContainer.removeEventListener(
+            "TabSelect",
+            placeholderUpdateListener
+          );
+        }
+      };
+
+      gURLBar.addEventListener("input", placeholderUpdateListener);
+      gBrowser.tabContainer.addEventListener(
+        "TabSelect",
+        placeholderUpdateListener
+      );
+    } else if (!gURLBar.searchMode) {
+      this._setURLBarPlaceholder(engineName);
+    }
+  },
+
+  /**
+   * Sets the URLBar placeholder to either something based on the engine name,
+   * or the default placeholder.
+   *
+   * @param {String} name The name of the engine to use, an empty string if to
+   *                      use the default placeholder.
+   */
+  _setURLBarPlaceholder(name) {
+    document.l10n.setAttributes(
+      gURLBar.inputField,
+      name ? "urlbar-placeholder-with-name" : "urlbar-placeholder",
+      name ? { name } : undefined
+    );
+  },
+
+  addEngine(browser, engine, uri) {
+    if (!this._searchInitComplete) {
+      // We haven't finished initialising search yet. This means we can't
+      // call getEngineByName here. Since this is only on start-up and unlikely
+      // to happen in the normal case, we'll just return early rather than
+      // trying to handle it asynchronously.
+      return;
+    }
+    // Check to see whether we've already added an engine with this title
+    if (browser.engines) {
+      if (browser.engines.some(e => e.title == engine.title)) {
+        return;
+      }
+    }
+
+    var hidden = false;
+    // If this engine (identified by title) is already in the list, add it
+    // to the list of hidden engines rather than to the main list.
+    // XXX This will need to be changed when engines are identified by URL;
+    // see bug 335102.
+    if (Services.search.getEngineByName(engine.title)) {
+      hidden = true;
+    }
+
+    var engines = (hidden ? browser.hiddenEngines : browser.engines) || [];
+
+    engines.push({
+      uri: engine.href,
+      title: engine.title,
+      get icon() {
+        return browser.mIconURL;
+      },
+    });
+
+    if (hidden) {
+      browser.hiddenEngines = engines;
+    } else {
+      browser.engines = engines;
+      if (browser == gBrowser.selectedBrowser) {
+        this.updateOpenSearchBadge();
+      }
+    }
+  },
+
+  /**
+   * Update the browser UI to show whether or not additional engines are
+   * available when a page is loaded or the user switches tabs to a page that
+   * has search engines.
+   */
+  updateOpenSearchBadge() {
+    gURLBar.addSearchEngineHelper.setEnginesFromBrowser(
+      gBrowser.selectedBrowser
+    );
+
+    var searchBar = this.searchBar;
+    if (!searchBar) {
+      return;
+    }
+
+    var engines = gBrowser.selectedBrowser.engines;
+    if (engines && engines.length) {
+      searchBar.setAttribute("addengines", "true");
+    } else {
+      searchBar.removeAttribute("addengines");
+    }
+  },
+
+  /**
+   * Focuses the search bar if present on the toolbar, or the address bar,
+   * putting it in search mode. Will do so in an existing non-popup browser
+   * window or open a new one if necessary.
+   */
+  webSearch: function BrowserSearch_webSearch() {
+    if (
+      window.location.href != AppConstants.BROWSER_CHROME_URL ||
+      gURLBar.readOnly
+    ) {
+      let win = getTopWin({ skipPopups: true });
+      if (win) {
+        // If there's an open browser window, it should handle this command
+        win.focus();
+        win.BrowserSearch.webSearch();
+      } else {
+        // If there are no open browser windows, open a new one
+        var observer = function(subject, topic, data) {
+          if (subject == win) {
+            BrowserSearch.webSearch();
+            Services.obs.removeObserver(
+              observer,
+              "browser-delayed-startup-finished"
+            );
+          }
+        };
+        win = window.openDialog(
+          AppConstants.BROWSER_CHROME_URL,
+          "_blank",
+          "chrome,all,dialog=no",
+          "about:blank"
+        );
+        Services.obs.addObserver(observer, "browser-delayed-startup-finished");
+      }
+      return;
+    }
+
+    let focusUrlBarIfSearchFieldIsNotActive = function(aSearchBar) {
+      if (!aSearchBar || document.activeElement != aSearchBar.textbox) {
+        // Limit the results to search suggestions, like the search bar.
+        gURLBar.searchModeShortcut();
+      }
+    };
+
+    let searchBar = this.searchBar;
+    let placement = CustomizableUI.getPlacementOfWidget("search-container");
+    let focusSearchBar = () => {
+      searchBar = this.searchBar;
+      searchBar.select();
+      focusUrlBarIfSearchFieldIsNotActive(searchBar);
+    };
+    if (
+      placement &&
+      searchBar &&
+      ((searchBar.parentNode.getAttribute("overflowedItem") == "true" &&
+        placement.area == CustomizableUI.AREA_NAVBAR) ||
+        placement.area == CustomizableUI.AREA_FIXED_OVERFLOW_PANEL)
+    ) {
+      let navBar = document.getElementById(CustomizableUI.AREA_NAVBAR);
+      navBar.overflowable.show().then(focusSearchBar);
+      return;
+    }
+    if (searchBar) {
+      if (window.fullScreen) {
+        FullScreen.showNavToolbox();
+      }
+      searchBar.select();
+    }
+    focusUrlBarIfSearchFieldIsNotActive(searchBar);
+  },
+
+  /**
+   * Loads a search results page, given a set of search terms. Uses the current
+   * engine if the search bar is visible, or the default engine otherwise.
+   *
+   * @param searchText
+   *        The search terms to use for the search.
+   * @param where
+   *        String indicating where the search should load. Most commonly used
+   *        are 'tab' or 'window', defaults to 'current'.
+   * @param usePrivate
+   *        Whether to use the Private Browsing mode default search engine.
+   *        Defaults to `false`.
+   * @param purpose [optional]
+   *        A string meant to indicate the context of the search request. This
+   *        allows the search service to provide a different nsISearchSubmission
+   *        depending on e.g. where the search is triggered in the UI.
+   * @param triggeringPrincipal
+   *        The principal to use for a new window or tab.
+   * @param csp
+   *        The content security policy to use for a new window or tab.
+   * @param inBackground [optional]
+   *        Set to true for the tab to be loaded in the background, default false.
+   * @param engine [optional]
+   *        The search engine to use for the search.
+   * @param tab [optional]
+   *        The tab to show the search result.
+   *
+   * @return engine The search engine used to perform a search, or null if no
+   *                search was performed.
+   */
+  async _loadSearch(
+    searchText,
+    where,
+    usePrivate,
+    purpose,
+    triggeringPrincipal,
+    csp,
+    inBackground = false,
+    engine = null,
+    tab = null
+  ) {
+    if (!triggeringPrincipal) {
+      throw new Error(
+        "Required argument triggeringPrincipal missing within _loadSearch"
+      );
+    }
+
+    if (!engine) {
+      engine = usePrivate
+        ? await Services.search.getDefaultPrivate()
+        : await Services.search.getDefault();
+    }
+
+    let submission = engine.getSubmission(searchText, null, purpose); // HTML response
+
+    // getSubmission can return null if the engine doesn't have a URL
+    // with a text/html response type.  This is unlikely (since
+    // SearchService._addEngineToStore() should fail for such an engine),
+    // but let's be on the safe side.
+    if (!submission) {
+      return null;
+    }
+
+    openLinkIn(submission.uri.spec, where || "current", {
+      private: usePrivate && !PrivateBrowsingUtils.isWindowPrivate(window),
+      postData: submission.postData,
+      inBackground,
+      relatedToCurrent: true,
+      triggeringPrincipal,
+      csp,
+      targetBrowser: tab?.linkedBrowser,
+    });
+
+    return { engine, url: submission.uri };
+  },
+
+  /**
+   * Perform a search initiated from the context menu.
+   *
+   * This should only be called from the context menu. See
+   * BrowserSearch.loadSearch for the preferred API.
+   */
+  async loadSearchFromContext(
+    terms,
+    usePrivate,
+    triggeringPrincipal,
+    csp,
+    event
+  ) {
+    event = getRootEvent(event);
+    let where = whereToOpenLink(event);
+    if (where == "current") {
+      // override: historically search opens in new tab
+      where = "tab";
+    }
+    if (usePrivate && !PrivateBrowsingUtils.isWindowPrivate(window)) {
+      where = "window";
+    }
+    let inBackground = Services.prefs.getBoolPref(
+      "browser.search.context.loadInBackground"
+    );
+    if (event.button == 1 || event.ctrlKey) {
+      inBackground = !inBackground;
+    }
+
+    let { engine, url } = await BrowserSearch._loadSearch(
+      terms,
+      where,
+      usePrivate,
+      "contextmenu",
+      Services.scriptSecurityManager.createNullPrincipal(
+        triggeringPrincipal.originAttributes
+      ),
+      csp,
+      inBackground
+    );
+
+    if (engine) {
+      BrowserSearchTelemetry.recordSearch(
+        gBrowser.selectedBrowser,
+        engine,
+        "contextmenu",
+        { url }
+      );
+    }
+  },
+
+  /**
+   * Perform a search initiated from the command line.
+   */
+  async loadSearchFromCommandLine(terms, usePrivate, triggeringPrincipal, csp) {
+    let { engine, url } = await BrowserSearch._loadSearch(
+      terms,
+      "current",
+      usePrivate,
+      "system",
+      triggeringPrincipal,
+      csp
+    );
+    if (engine) {
+      BrowserSearchTelemetry.recordSearch(
+        gBrowser.selectedBrowser,
+        engine,
+        "system",
+        { url }
+      );
+    }
+  },
+
+  /**
+   * Perform a search initiated from an extension.
+   */
+  async loadSearchFromExtension(terms, engine, tab, triggeringPrincipal) {
+    const result = await BrowserSearch._loadSearch(
+      terms,
+      tab ? "current" : "tab",
+      PrivateBrowsingUtils.isWindowPrivate(window),
+      "webextension",
+      triggeringPrincipal,
+      null,
+      false,
+      engine,
+      tab
+    );
+
+    BrowserSearchTelemetry.recordSearch(
+      gBrowser.selectedBrowser,
+      result.engine,
+      "webextension",
+      { url: result.url }
+    );
+  },
+
+  pasteAndSearch(event) {
+    BrowserSearch.searchBar.select();
+    goDoCommand("cmd_paste");
+    BrowserSearch.searchBar.handleSearchCommand(event);
+  },
+
+  /**
+   * Returns the search bar element if it is present in the toolbar, null otherwise.
+   */
+  get searchBar() {
+    return document.getElementById("searchbar");
+  },
+
+  get searchEnginesURL() {
+    return formatURL("browser.search.searchEnginesURL", true);
+  },
+
+  loadAddEngines: function BrowserSearch_loadAddEngines() {
+    var newWindowPref = Services.prefs.getIntPref(
+      "browser.link.open_newwindow"
+    );
+    var where = newWindowPref == 3 ? "tab" : "window";
+    openTrustedLinkIn(this.searchEnginesURL, where);
+  },
+
+  /**
+   * Infobar to notify the user's search engine has been removed
+   * and replaced with an application default search engine.
+   *
+   * @param {string} oldEngine
+   *   name of the engine to be moved and replaced.
+   * @param {string} newEngine
+   *   name of the application default engine to replaced the removed engine.
+   */
+  removalOfSearchEngineNotificationBox(oldEngine, newEngine) {
+    let messageFragment = document.createDocumentFragment();
+    let message = document.createElement("span");
+    let link = document.createXULElement("label", {
+      is: "text-link",
+    });
+
+    link.href = Services.urlFormatter.formatURLPref(
+      "browser.search.searchEngineRemoval"
+    );
+    link.setAttribute("data-l10n-name", "remove-search-engine-article");
+    document.l10n.setAttributes(message, "removed-search-engine-message", {
+      oldEngine,
+      newEngine,
+    });
+
+    message.appendChild(link);
+    messageFragment.appendChild(message);
+
+    let button = [
+      {
+        "l10n-id": "remove-search-engine-button",
+        primary: true,
+        callback() {
+          const notificationBox = gNotificationBox.getNotificationWithValue(
+            "search-engine-removal"
+          );
+          gNotificationBox.removeNotification(notificationBox);
+        },
+      },
+    ];
+
+    gNotificationBox.appendNotification(
+      "search-engine-removal",
+      {
+        label: messageFragment,
+        priority: gNotificationBox.PRIORITY_SYSTEM,
+      },
+      button
+    );
+
+    // Update engine name in the placeholder to the new default engine name.
+    this._updateURLBarPlaceholderFromDefaultEngine(
+      PrivateBrowsingUtils.isWindowPrivate(window),
+      false
+    ).catch(Cu.reportError);
+  },
+};
+
+XPCOMUtils.defineConstant(this, "BrowserSearch", BrowserSearch);
+
+function CreateContainerTabMenu(event) {
+  createUserContextMenu(event, {
+    useAccessKeys: false,
+    showDefaultTab: true,
+  });
+}
+
+function FillHistoryMenu(aParent) {
+  // Lazily add the hover listeners on first showing and never remove them
+  if (!aParent.hasStatusListener) {
+    // Show history item's uri in the status bar when hovering, and clear on exit
+    aParent.addEventListener("DOMMenuItemActive", function(aEvent) {
+      // Only the current page should have the checked attribute, so skip it
+      if (!aEvent.target.hasAttribute("checked")) {
+        XULBrowserWindow.setOverLink(aEvent.target.getAttribute("uri"));
+      }
+    });
+    aParent.addEventListener("DOMMenuItemInactive", function() {
+      XULBrowserWindow.setOverLink("");
+    });
+
+    aParent.hasStatusListener = true;
+  }
+
+  // Remove old entries if any
+  let children = aParent.children;
+  for (var i = children.length - 1; i >= 0; --i) {
+    if (children[i].hasAttribute("index")) {
+      aParent.removeChild(children[i]);
+    }
+  }
+
+  const MAX_HISTORY_MENU_ITEMS = 15;
+
+  const tooltipBack = gNavigatorBundle.getString("tabHistory.goBack");
+  const tooltipCurrent = gNavigatorBundle.getString("tabHistory.current");
+  const tooltipForward = gNavigatorBundle.getString("tabHistory.goForward");
+
+  function updateSessionHistory(sessionHistory, initial, ssInParent) {
+    let count = ssInParent
+      ? sessionHistory.count
+      : sessionHistory.entries.length;
+
+    if (!initial) {
+      if (count <= 1) {
+        // if there is only one entry now, close the popup.
+        aParent.hidePopup();
+        return;
+      } else if (aParent.id != "backForwardMenu" && !aParent.parentNode.open) {
+        // if the popup wasn't open before, but now needs to be, reopen the menu.
+        // It should trigger FillHistoryMenu again. This might happen with the
+        // delay from click-and-hold menus but skip this for the context menu
+        // (backForwardMenu) rather than figuring out how the menu should be
+        // positioned and opened as it is an extreme edgecase.
+        aParent.parentNode.open = true;
+        return;
+      }
+    }
+
+    let index = sessionHistory.index;
+    let half_length = Math.floor(MAX_HISTORY_MENU_ITEMS / 2);
+    let start = Math.max(index - half_length, 0);
+    let end = Math.min(
+      start == 0 ? MAX_HISTORY_MENU_ITEMS : index + half_length + 1,
+      count
+    );
+    if (end == count) {
+      start = Math.max(count - MAX_HISTORY_MENU_ITEMS, 0);
+    }
+
+    let existingIndex = 0;
+
+    for (let j = end - 1; j >= start; j--) {
+      let entry = ssInParent
+        ? sessionHistory.getEntryAtIndex(j)
+        : sessionHistory.entries[j];
+      // Explicitly check for "false" to stay backwards-compatible with session histories
+      // from before the hasUserInteraction was implemented.
+      if (
+        BrowserUtils.navigationRequireUserInteraction &&
+        entry.hasUserInteraction === false &&
+        // Always allow going to the first and last navigation points.
+        j != end - 1 &&
+        j != start
+      ) {
+        continue;
+      }
+      let uri = ssInParent ? entry.URI.spec : entry.url;
+
+      let item =
+        existingIndex < children.length
+          ? children[existingIndex]
+          : document.createXULElement("menuitem");
+
+      item.setAttribute("uri", uri);
+      item.setAttribute("label", entry.title || uri);
+      item.setAttribute("index", j);
+
+      // Cache this so that gotoHistoryIndex doesn't need the original index
+      item.setAttribute("historyindex", j - index);
+
+      if (j != index) {
+        // Use list-style-image rather than the image attribute in order to
+        // allow CSS to override this.
+        item.style.listStyleImage = `url(page-icon:${uri})`;
+      }
+
+      if (j < index) {
+        item.className =
+          "unified-nav-back menuitem-iconic menuitem-with-favicon";
+        item.setAttribute("tooltiptext", tooltipBack);
+      } else if (j == index) {
+        item.setAttribute("type", "radio");
+        item.setAttribute("checked", "true");
+        item.className = "unified-nav-current";
+        item.setAttribute("tooltiptext", tooltipCurrent);
+      } else {
+        item.className =
+          "unified-nav-forward menuitem-iconic menuitem-with-favicon";
+        item.setAttribute("tooltiptext", tooltipForward);
+      }
+
+      if (!item.parentNode) {
+        aParent.appendChild(item);
+      }
+
+      existingIndex++;
+    }
+
+    if (!initial) {
+      let existingLength = children.length;
+      while (existingIndex < existingLength) {
+        aParent.removeChild(aParent.lastElementChild);
+        existingIndex++;
+      }
+    }
+  }
+
+  // If session history in parent is available, use it. Otherwise, get the session history
+  // from session store.
+  let sessionHistory = gBrowser.selectedBrowser.browsingContext.sessionHistory;
+  if (sessionHistory?.count) {
+    // Don't show the context menu if there is only one item.
+    if (sessionHistory.count <= 1) {
+      return false;
+    }
+
+    updateSessionHistory(sessionHistory, true, true);
+  } else {
+    sessionHistory = SessionStore.getSessionHistory(
+      gBrowser.selectedTab,
+      updateSessionHistory
+    );
+    updateSessionHistory(sessionHistory, true, false);
+  }
+
+  return true;
+}
+
+function BrowserDownloadsUI() {
+  if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+    openTrustedLinkIn("about:downloads", "tab");
+  } else {
+    PlacesCommandHook.showPlacesOrganizer("Downloads");
+  }
+}
+
+function toOpenWindowByType(inType, uri, features) {
+  var topWindow = Services.wm.getMostRecentWindow(inType);
+
+  if (topWindow) {
+    topWindow.focus();
+  } else if (features) {
+    window.open(uri, "_blank", features);
+  } else {
+    window.open(
+      uri,
+      "_blank",
+      "chrome,extrachrome,menubar,resizable,scrollbars,status,toolbar"
+    );
+  }
+}
+
+/**
+ * Open a new browser window.
+ *
+ * @param {Object} options
+ *        {
+ *          private: A boolean indicating if the window should be
+ *                   private
+ *          remote:  A boolean indicating if the window should run
+ *                   remote browser tabs or not. If omitted, the window
+ *                   will choose the profile default state.
+ *          fission: A boolean indicating if the window should run
+ *                   with fission enabled or not. If omitted, the window
+ *                   will choose the profile default state.
+ *        }
+ * @return a reference to the new window.
+ */
+function OpenBrowserWindow(options) {
+  var telemetryObj = {};
+  TelemetryStopwatch.start("FX_NEW_WINDOW_MS", telemetryObj);
+
+  var defaultArgs = BrowserHandler.defaultArgs;
+  var wintype = document.documentElement.getAttribute("windowtype");
+
+  var extraFeatures = "";
+  if (options && options.private && PrivateBrowsingUtils.enabled) {
+    extraFeatures = ",private";
+    if (!PrivateBrowsingUtils.permanentPrivateBrowsing) {
+      // Force the new window to load about:privatebrowsing instead of the default home page
+      defaultArgs = "about:privatebrowsing";
+    }
+  } else {
+    extraFeatures = ",non-private";
+  }
+
+  if (options && options.remote) {
+    extraFeatures += ",remote";
+  } else if (options && options.remote === false) {
+    extraFeatures += ",non-remote";
+  }
+
+  if (options && options.fission) {
+    extraFeatures += ",fission";
+  } else if (options && options.fission === false) {
+    extraFeatures += ",non-fission";
+  }
+
+  // If the window is maximized, we want to skip the animation, since we're
+  // going to be taking up most of the screen anyways, and we want to optimize
+  // for showing the user a useful window as soon as possible.
+  if (window.windowState == window.STATE_MAXIMIZED) {
+    extraFeatures += ",suppressanimation";
+  }
+
+  // if and only if the current window is a browser window and it has a document with a character
+  // set, then extract the current charset menu setting from the current document and use it to
+  // initialize the new browser window...
+  var win;
+  if (
+    window &&
+    wintype == "navigator:browser" &&
+    window.content &&
+    window.content.document
+  ) {
+    var DocCharset = window.content.document.characterSet;
+    let charsetArg = "charset=" + DocCharset;
+
+    // we should "inherit" the charset menu setting in a new window
+    win = window.openDialog(
+      AppConstants.BROWSER_CHROME_URL,
+      "_blank",
+      "chrome,all,dialog=no" + extraFeatures,
+      defaultArgs,
+      charsetArg
+    );
+  } else {
+    // forget about the charset information.
+    win = window.openDialog(
+      AppConstants.BROWSER_CHROME_URL,
+      "_blank",
+      "chrome,all,dialog=no" + extraFeatures,
+      defaultArgs
+    );
+  }
+
+  win.addEventListener(
+    "MozAfterPaint",
+    () => {
+      TelemetryStopwatch.finish("FX_NEW_WINDOW_MS", telemetryObj);
+      if (
+        Services.prefs.getIntPref("browser.startup.page") == 1 &&
+        defaultArgs == HomePage.get()
+      ) {
+        // A notification for when a user has triggered their homepage. This is used
+        // to display a doorhanger explaining that an extension has modified the
+        // homepage, if necessary.
+        Services.obs.notifyObservers(win, "browser-open-homepage-start");
+      }
+    },
+    { once: true }
+  );
+
+  return win;
+}
+
+/**
+ * Update the global flag that tracks whether or not any edit UI (the Edit menu,
+ * edit-related items in the context menu, and edit-related toolbar buttons
+ * is visible, then update the edit commands' enabled state accordingly.  We use
+ * this flag to skip updating the edit commands on focus or selection changes
+ * when no UI is visible to improve performance (including pageload performance,
+ * since focus changes when you load a new page).
+ *
+ * If UI is visible, we use goUpdateGlobalEditMenuItems to set the commands'
+ * enabled state so the UI will reflect it appropriately.
+ *
+ * If the UI isn't visible, we enable all edit commands so keyboard shortcuts
+ * still work and just lazily disable them as needed when the user presses a
+ * shortcut.
+ *
+ * This doesn't work on Mac, since Mac menus flash when users press their
+ * keyboard shortcuts, so edit UI is essentially always visible on the Mac,
+ * and we need to always update the edit commands.  Thus on Mac this function
+ * is a no op.
+ */
+function updateEditUIVisibility() {
+  if (AppConstants.platform == "macosx") {
+    return;
+  }
+
+  let editMenuPopupState = document.getElementById("menu_EditPopup").state;
+  let contextMenuPopupState = document.getElementById("contentAreaContextMenu")
+    .state;
+  let placesContextMenuPopupState = document.getElementById("placesContext")
+    .state;
+
+  let oldVisible = gEditUIVisible;
+
+  // The UI is visible if the Edit menu is opening or open, if the context menu
+  // is open, or if the toolbar has been customized to include the Cut, Copy,
+  // or Paste toolbar buttons.
+  gEditUIVisible =
+    editMenuPopupState == "showing" ||
+    editMenuPopupState == "open" ||
+    contextMenuPopupState == "showing" ||
+    contextMenuPopupState == "open" ||
+    placesContextMenuPopupState == "showing" ||
+    placesContextMenuPopupState == "open";
+  const kOpenPopupStates = ["showing", "open"];
+  if (!gEditUIVisible) {
+    // Now check the edit-controls toolbar buttons.
+    let placement = CustomizableUI.getPlacementOfWidget("edit-controls");
+    let areaType = placement ? CustomizableUI.getAreaType(placement.area) : "";
+    if (areaType == CustomizableUI.TYPE_MENU_PANEL) {
+      let customizablePanel = PanelUI.overflowPanel;
+      gEditUIVisible = kOpenPopupStates.includes(customizablePanel.state);
+    } else if (
+      areaType == CustomizableUI.TYPE_TOOLBAR &&
+      window.toolbar.visible
+    ) {
+      // The edit controls are on a toolbar, so they are visible,
+      // unless they're in a panel that isn't visible...
+      if (placement.area == "nav-bar") {
+        let editControls = document.getElementById("edit-controls");
+        gEditUIVisible =
+          !editControls.hasAttribute("overflowedItem") ||
+          kOpenPopupStates.includes(
+            document.getElementById("widget-overflow").state
+          );
+      } else {
+        gEditUIVisible = true;
+      }
+    }
+  }
+
+  // Now check the main menu panel
+  if (!gEditUIVisible) {
+    gEditUIVisible = kOpenPopupStates.includes(PanelUI.panel.state);
+  }
+
+  // No need to update commands if the edit UI visibility has not changed.
+  if (gEditUIVisible == oldVisible) {
+    return;
+  }
+
+  // If UI is visible, update the edit commands' enabled state to reflect
+  // whether or not they are actually enabled for the current focus/selection.
+  if (gEditUIVisible) {
+    goUpdateGlobalEditMenuItems();
+  } else {
+    // Otherwise, enable all commands, so that keyboard shortcuts still work,
+    // then lazily determine their actual enabled state when the user presses
+    // a keyboard shortcut.
+    goSetCommandEnabled("cmd_undo", true);
+    goSetCommandEnabled("cmd_redo", true);
+    goSetCommandEnabled("cmd_cut", true);
+    goSetCommandEnabled("cmd_copy", true);
+    goSetCommandEnabled("cmd_paste", true);
+    goSetCommandEnabled("cmd_selectAll", true);
+    goSetCommandEnabled("cmd_delete", true);
+    goSetCommandEnabled("cmd_switchTextDirection", true);
+  }
+}
+
+let gFileMenu = {
+  /**
+   * Updates User Context Menu Item UI visibility depending on
+   * privacy.userContext.enabled pref state.
+   */
+  updateUserContextUIVisibility() {
+    let menu = document.getElementById("menu_newUserContext");
+    menu.hidden = !Services.prefs.getBoolPref(
+      "privacy.userContext.enabled",
+      false
+    );
+    // Visibility of File menu item shouldn't change frequently.
+    if (PrivateBrowsingUtils.isWindowPrivate(window)) {
+      menu.setAttribute("disabled", "true");
+    }
+  },
+
+  /**
+   * Updates the enabled state of the "Import From Another Browser" command
+   * depending on the DisableProfileImport policy.
+   */
+  updateImportCommandEnabledState() {
+    if (!Services.policies.isAllowed("profileImport")) {
+      document
+        .getElementById("cmd_file_importFromAnotherBrowser")
+        .setAttribute("disabled", "true");
+    }
+  },
+
+  /**
+   * Updates the "Close tab" command to reflect the number of selected tabs,
+   * when applicable.
+   */
+  updateTabCloseCountState() {
+    document.l10n.setAttributes(
+      document.getElementById("menu_close"),
+      "menu-file-close-tab",
+      { tabCount: gBrowser.selectedTabs.length }
+    );
+  },
+
+  onPopupShowing(event) {
+    // We don't care about submenus:
+    if (event.target.id != "menu_FilePopup") {
+      return;
+    }
+    this.updateUserContextUIVisibility();
+    this.updateImportCommandEnabledState();
+    this.updateTabCloseCountState();
+    if (AppConstants.platform == "macosx") {
+      gShareUtils.updateShareURLMenuItem(
+        gBrowser.selectedBrowser,
+        document.getElementById("menu_savePage")
+      );
+    }
+    PrintUtils.updatePrintSetupMenuHiddenState();
+  },
+};
+
+let gShareUtils = {
+  /**
+   * Updates a sharing item in a given menu, creating it if necessary.
+   */
+  updateShareURLMenuItem(browser, insertAfterEl) {
+    // We only support "share URL" on macOS and on Windows 10:
+    if (
+      AppConstants.platform != "macosx" &&
+      // Windows 10's internal NT version number was initially 6.4
+      !AppConstants.isPlatformAndVersionAtLeast("win", "6.4")
+    ) {
+      return;
+    }
+
+    let shareURL = insertAfterEl.nextElementSibling;
+    if (!shareURL?.matches(".share-tab-url-item")) {
+      shareURL = this._createShareURLMenuItem(insertAfterEl);
+    }
+
+    shareURL.browserToShare = Cu.getWeakReference(browser);
+    if (AppConstants.platform == "win") {
+      // We disable the item on Windows, as there's no submenu.
+      // On macOS, we handle this inside the menupopup.
+      shareURL.hidden = !BrowserUtils.isShareableURL(browser.currentURI);
+    }
+  },
+
+  /**
+   * Creates and returns the "Share" menu item.
+   */
+  _createShareURLMenuItem(insertAfterEl) {
+    let menu = insertAfterEl.parentNode;
+    let shareURL = null;
+    if (AppConstants.platform == "win") {
+      shareURL = this._buildShareURLItem(menu.id);
+    } else if (AppConstants.platform == "macosx") {
+      shareURL = this._buildShareURLMenu(menu.id);
+    }
+    shareURL.className = "share-tab-url-item";
+
+    let l10nID =
+      menu.id == "tabContextMenu"
+        ? "tab-context-share-url"
+        : "menu-file-share-url";
+    document.l10n.setAttributes(shareURL, l10nID);
+
+    menu.insertBefore(shareURL, insertAfterEl.nextSibling);
+    return shareURL;
+  },
+
+  /**
+   * Returns a menu item specifically for accessing Windows sharing services.
+   */
+  _buildShareURLItem() {
+    let shareURLMenuItem = document.createXULElement("menuitem");
+    shareURLMenuItem.addEventListener("command", this);
+    return shareURLMenuItem;
+  },
+
+  /**
+   * Returns a menu specifically for accessing macOSx sharing services .
+   */
+  _buildShareURLMenu() {
+    let menu = document.createXULElement("menu");
+    let menuPopup = document.createXULElement("menupopup");
+    menuPopup.addEventListener("popupshowing", this);
+    menu.appendChild(menuPopup);
+    return menu;
+  },
+
+  /**
+   * Get the sharing data for a given DOM node.
+   */
+  getDataToShare(node) {
+    let browser = node.browserToShare?.get();
+    let urlToShare = null;
+    let titleToShare = null;
+
+    if (browser && BrowserUtils.isShareableURL(browser.currentURI)) {
+      urlToShare = browser.currentURI;
+      titleToShare = browser.contentTitle;
+    }
+    return { urlToShare, titleToShare };
+  },
+
+  /**
+   * Populates the "Share" menupopup on macOSx.
+   */
+  initializeShareURLPopup(menuPopup) {
+    if (AppConstants.platform != "macosx") {
+      return;
+    }
+
+    // Empty menupopup
+    while (menuPopup.firstChild) {
+      menuPopup.firstChild.remove();
+    }
+
+    let { urlToShare } = this.getDataToShare(menuPopup.parentNode);
+
+    // If we can't share the current URL, we display the items disabled,
+    // but enable the "more..." item at the bottom, to allow the user to
+    // change sharing preferences in the system dialog.
+    let shouldEnable = !!urlToShare;
+    if (!urlToShare) {
+      // Fake it so we can ask the sharing service for services:
+      urlToShare = makeURI("https://mozilla.org/");
+    }
+
+    let sharingService = gBrowser.MacSharingService;
+    let currentURI = gURLBar.makeURIReadable(urlToShare).displaySpec;
+    let services = sharingService.getSharingProviders(currentURI);
+
+    services.forEach(share => {
+      let item = document.createXULElement("menuitem");
+      item.classList.add("menuitem-iconic");
+      item.setAttribute("label", share.menuItemTitle);
+      item.setAttribute("share-name", share.name);
+      item.setAttribute("image", share.image);
+      if (!shouldEnable) {
+        item.setAttribute("disabled", "true");
+      }
+      menuPopup.appendChild(item);
+    });
+    menuPopup.appendChild(document.createXULElement("menuseparator"));
+    let moreItem = document.createXULElement("menuitem");
+    document.l10n.setAttributes(moreItem, "menu-share-more");
+    moreItem.classList.add("menuitem-iconic", "share-more-button");
+    menuPopup.appendChild(moreItem);
+
+    menuPopup.addEventListener("command", this);
+    menuPopup.parentNode
+      .closest("menupopup")
+      .addEventListener("popuphiding", this);
+    menuPopup.setAttribute("data-initialized", true);
+  },
+
+  onShareURLCommand(event) {
+    // Only call sharing services for the "Share" menu item. These services
+    // are accessed from a submenu popup for MacOS or the "Share" menu item
+    // for Windows. Use .closest() as a hack to find either the item itself
+    // or a parent with the right class.
+    let target = event.target.closest(".share-tab-url-item");
+    if (!target) {
+      return;
+    }
+
+    // urlToShare/titleToShare may be null, in which case only the "more"
+    // item is enabled, so handle that case first:
+    if (event.target.classList.contains("share-more-button")) {
+      gBrowser.MacSharingService.openSharingPreferences();
+      return;
+    }
+
+    let { urlToShare, titleToShare } = this.getDataToShare(target);
+    let currentURI = gURLBar.makeURIReadable(urlToShare).displaySpec;
+
+    if (AppConstants.platform == "win") {
+      WindowsUIUtils.shareUrl(currentURI, titleToShare);
+      return;
+    }
+
+    // On macOSX platforms
+    let shareName = event.target.getAttribute("share-name");
+
+    if (shareName) {
+      gBrowser.MacSharingService.shareUrl(shareName, currentURI, titleToShare);
+    }
+  },
+
+  onPopupHiding(event) {
+    // We don't want to rebuild the contents of the "Share" menupopup if only its submenu is
+    // hidden. So bail if this isn't the top menupopup in the DOM tree:
+    if (event.target.parentNode.closest("menupopup")) {
+      return;
+    }
+    // Otherwise, clear its "data-initialized" attribute.
+    let menupopup = event.target.querySelector(".share-tab-url-item")
+      ?.menupopup;
+    menupopup?.removeAttribute("data-initialized");
+
+    event.target.removeEventListener("popuphiding", this);
+  },
+
+  onPopupShowing(event) {
+    if (!event.target.hasAttribute("data-initialized")) {
+      this.initializeShareURLPopup(event.target);
+    }
+  },
+
+  handleEvent(aEvent) {
+    switch (aEvent.type) {
+      case "command":
+        this.onShareURLCommand(aEvent);
+        break;
+      case "popuphiding":
+        this.onPopupHiding(aEvent);
+        break;
+      case "popupshowing":
+        this.onPopupShowing(aEvent);
+        break;
+    }
+  },
+};
+
+/**
+ * Opens a new tab with the userContextId specified as an attribute of
+ * sourceEvent. This attribute is propagated to the top level originAttributes
+ * living on the tab's docShell.
+ *
+ * @param event
+ *        A click event on a userContext File Menu option
+ */
+function openNewUserContextTab(event) {
+  openTrustedLinkIn(BROWSER_NEW_TAB_URL, "tab", {
+    userContextId: parseInt(event.target.getAttribute("data-usercontextid")),
+  });
+}
+
+/**
+ * Updates the User Context UI indicators if the browser is in a non-default context
+ */
+function updateUserContextUIIndicator() {
+  function replaceContainerClass(classType, element, value) {
+    let prefix = "identity-" + classType + "-";
+    if (value && element.classList.contains(prefix + value)) {
+      return;
+    }
+    for (let className of element.classList) {
+      if (className.startsWith(prefix)) {
+        element.classList.remove(className);
+      }
+    }
+    if (value) {
+      element.classList.add(prefix + value);
+    }
+  }
+
+  let hbox = document.getElementById("userContext-icons");
+
+  let userContextId = gBrowser.selectedBrowser.getAttribute("usercontextid");
+  if (!userContextId) {
+    replaceContainerClass("color", hbox, "");
+    hbox.hidden = true;
+    return;
+  }
+
+  let identity = ContextualIdentityService.getPublicIdentityFromId(
+    userContextId
+  );
+  if (!identity) {
+    replaceContainerClass("color", hbox, "");
+    hbox.hidden = true;
+    return;
+  }
+
+  replaceContainerClass("color", hbox, identity.color);
+
+  let label = ContextualIdentityService.getUserContextLabel(userContextId);
+  document.getElementById("userContext-label").setAttribute("value", label);
+  // Also set the container label as the tooltip so we can only show the icon
+  // in small windows.
+  hbox.setAttribute("tooltiptext", label);
+
+  let indicator = document.getElementById("userContext-indicator");
+  replaceContainerClass("icon", indicator, identity.icon);
+
+  hbox.hidden = false;
+}
+
+var XULBrowserWindow = {
+  // Stored Status, Link and Loading values
+  status: "",
+  defaultStatus: "",
+  overLink: "",
+  startTime: 0,
+  isBusy: false,
+  busyUI: false,
+
+  QueryInterface: ChromeUtils.generateQI([
+    "nsIWebProgressListener",
+    "nsIWebProgressListener2",
+    "nsISupportsWeakReference",
+    "nsIXULBrowserWindow",
+  ]),
+
+  get stopCommand() {
+    delete this.stopCommand;
+    return (this.stopCommand = document.getElementById("Browser:Stop"));
+  },
+  get reloadCommand() {
+    delete this.reloadCommand;
+    return (this.reloadCommand = document.getElementById("Browser:Reload"));
+  },
+  get _elementsForTextBasedTypes() {
+    delete this._elementsForTextBasedTypes;
+    return (this._elementsForTextBasedTypes = [
+      document.getElementById("pageStyleMenu"),
+      document.getElementById("context-viewpartialsource-selection"),
+      document.getElementById("context-print-selection"),
+    ]);
+  },
+  get _elementsForFind() {
+    delete this._elementsForFind;
+    return (this._elementsForFind = [
+      document.getElementById("cmd_find"),
+      document.getElementById("cmd_findAgain"),
+      document.getElementById("cmd_findPrevious"),
+    ]);
+  },
+  get _elementsForViewSource() {
+    delete this._elementsForViewSource;
+    return (this._elementsForViewSource = [
+      document.getElementById("context-viewsource"),
+      document.getElementById("View:PageSource"),
+    ]);
+  },
+  get _menuItemForRepairTextEncoding() {
+    delete this._menuItemForRepairTextEncoding;
+    return (this._menuItemForRepairTextEncoding = document.getElementById(
+      "repair-text-encoding"
+    ));
+  },
+
+  setDefaultStatus(status) {
+    this.defaultStatus = status;
+    StatusPanel.update();
+  },
+
+  setOverLink(url) {
+    if (url) {
+      url = Services.textToSubURI.unEscapeURIForUI(url);
+
+      // Encode bidirectional formatting characters.
+      // (RFC 3987 sections 3.2 and 4.1 paragraph 6)
+      url = url.replace(
+        /[\u200e\u200f\u202a\u202b\u202c\u202d\u202e]/g,
+        encodeURIComponent
+      );
+
+      if (UrlbarPrefs.get("trimURLs")) {
+        url = BrowserUIUtils.trimURL(url);
+      }
+    }
+
+    this.overLink = url;
+    LinkTargetDisplay.update();
+  },
+
+  showTooltip(xDevPix, yDevPix, tooltip, direction, browser) {
+    if (
+      Cc["@mozilla.org/widget/dragservice;1"]
+        .getService(Ci.nsIDragService)
+        .getCurrentSession()
+    ) {
+      return;
+    }
+
+    let elt = document.getElementById("remoteBrowserTooltip");
+    elt.label = tooltip;
+    elt.style.direction = direction;
+    elt.openPopupAtScreen(
+      xDevPix / window.devicePixelRatio,
+      yDevPix / window.devicePixelRatio,
+      false,
+      null
+    );
+  },
+
+  hideTooltip() {
+    let elt = document.getElementById("remoteBrowserTooltip");
+    elt.hidePopup();
+  },
+
+  getTabCount() {
+    return gBrowser.tabs.length;
+  },
+
+  onProgressChange(
+    aWebProgress,
+    aRequest,
+    aCurSelfProgress,
+    aMaxSelfProgress,
+    aCurTotalProgress,
+    aMaxTotalProgress
+  ) {
+    // Do nothing.
+  },
+
+  onProgressChange64(
+    aWebProgress,
+    aRequest,
+    aCurSelfProgress,
+    aMaxSelfProgress,
+    aCurTotalProgress,
+    aMaxTotalProgress
+  ) {
+    return this.onProgressChange(
+      aWebProgress,
+      aRequest,
+      aCurSelfProgress,
+      aMaxSelfProgress,
+      aCurTotalProgress,
+      aMaxTotalProgress
+    );
+  },
+
+  // This function fires only for the currently selected tab.
+  onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {
+    const nsIWebProgressListener = Ci.nsIWebProgressListener;
+
+    let browser = gBrowser.selectedBrowser;
+    gProtectionsHandler.onStateChange(aWebProgress, aStateFlags);
+
+    if (
+      aStateFlags & nsIWebProgressListener.STATE_START &&
+      aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK
+    ) {
+      if (aRequest && aWebProgress.isTopLevel) {
+        // clear out search-engine data
+        browser.engines = null;
+      }
+
+      this.isBusy = true;
+
+      if (!(aStateFlags & nsIWebProgressListener.STATE_RESTORING)) {
+        this.busyUI = true;
+
+        // XXX: This needs to be based on window activity...
+        this.stopCommand.removeAttribute("disabled");
+        CombinedStopReload.switchToStop(aRequest, aWebProgress);
+      }
+    } else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {
+      // This (thanks to the filter) is a network stop or the last
+      // request stop outside of loading the document, stop throbbers
+      // and progress bars and such
+      if (aRequest) {
+        let msg = "";
+        let location;
+        let canViewSource = true;
+        // Get the URI either from a channel or a pseudo-object
+        if (aRequest instanceof Ci.nsIChannel || "URI" in aRequest) {
+          location = aRequest.URI;
+
+          // For keyword URIs clear the user typed value since they will be changed into real URIs
+          if (location.scheme == "keyword" && aWebProgress.isTopLevel) {
+            gBrowser.userTypedValue = null;
+          }
+
+          canViewSource = location.scheme != "view-source";
+
+          if (location.spec != "about:blank") {
+            switch (aStatus) {
+              case Cr.NS_ERROR_NET_TIMEOUT:
+                msg = gNavigatorBundle.getString("nv_timeout");
+                break;
+            }
+          }
+        }
+
+        this.status = "";
+        this.setDefaultStatus(msg);
+
+        // Disable View Source menu entries for images, enable otherwise
+        let isText =
+          browser.documentContentType &&
+          BrowserUtils.mimeTypeIsTextBased(browser.documentContentType);
+        for (let element of this._elementsForViewSource) {
+          if (canViewSource && isText) {
+            element.removeAttribute("disabled");
+          } else {
+            element.setAttribute("disabled", "true");
+          }
+        }
+
+        this._updateElementsForContentType();
+
+        // Update Override Text Encoding state.
+        // Can't cache the button, because the presence of the element in the DOM
+        // may change over time.
+        let button = document.getElementById("characterencoding-button");
+        if (browser.mayEnableCharacterEncodingMenu) {
+          this._menuItemForRepairTextEncoding.removeAttribute("disabled");
+          button?.removeAttribute("disabled");
+        } else {
+          this._menuItemForRepairTextEncoding.setAttribute("disabled", "true");
+          button?.setAttribute("disabled", "true");
+        }
+      }
+
+      this.isBusy = false;
+
+      if (this.busyUI) {
+        this.busyUI = false;
+
+        this.stopCommand.setAttribute("disabled", "true");
+        CombinedStopReload.switchToReload(aRequest, aWebProgress);
+      }
+    }
+  },
+
+  /**
+   * An nsIWebProgressListener method called by tabbrowser.  The `aIsSimulated`
+   * parameter is extra and not declared in nsIWebProgressListener, however; see
+   * below.
+   *
+   * @param {nsIWebProgress} aWebProgress
+   *   The nsIWebProgress instance that fired the notification.
+   * @param {nsIRequest} aRequest
+   *   The associated nsIRequest.  This may be null in some cases.
+   * @param {nsIURI} aLocationURI
+   *   The URI of the location that is being loaded.
+   * @param {integer} aFlags
+   *   Flags that indicate the reason the location changed.  See the
+   *   nsIWebProgressListener.LOCATION_CHANGE_* values.
+   * @param {boolean} aIsSimulated
+   *   True when this is called by tabbrowser due to switching tabs and
+   *   undefined otherwise.  This parameter is not declared in
+   *   nsIWebProgressListener.onLocationChange; see bug 1478348.
+   */
+  onLocationChange(aWebProgress, aRequest, aLocationURI, aFlags, aIsSimulated) {
+    var location = aLocationURI ? aLocationURI.spec : "";
+
+    UpdateBackForwardCommands(gBrowser.webNavigation);
+
+    Services.obs.notifyObservers(
+      aWebProgress,
+      "touchbar-location-change",
+      location
+    );
+
+    // For most changes we only need to update the browser UI if the primary
+    // content area was navigated or the selected tab was changed. We don't need
+    // to do anything else if there was a subframe navigation.
+
+    if (!aWebProgress.isTopLevel) {
+      return;
+    }
+
+    this.hideOverLinkImmediately = true;
+    this.setOverLink("");
+    this.hideOverLinkImmediately = false;
+
+    let isSameDocument =
+      aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT;
+    if (
+      (location == "about:blank" &&
+        BrowserUIUtils.checkEmptyPageOrigin(gBrowser.selectedBrowser)) ||
+      location == ""
+    ) {
+      // Second condition is for new tabs, otherwise
+      // reload function is enabled until tab is refreshed.
+      this.reloadCommand.setAttribute("disabled", "true");
+    } else {
+      this.reloadCommand.removeAttribute("disabled");
+    }
+
+    let isSessionRestore = !!(
+      aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SESSION_STORE
+    );
+
+    // We want to update the popup visibility if we received this notification
+    // via simulated locationchange events such as switching between tabs, however
+    // if this is a document navigation then PopupNotifications will be updated
+    // via TabsProgressListener.onLocationChange and we do not want it called twice
+    gURLBar.setURI(aLocationURI, aIsSimulated, isSessionRestore);
+
+    BookmarkingUI.onLocationChange();
+    // If we've actually changed document, update the toolbar visibility.
+    if (!isSameDocument) {
+      let bookmarksToolbar = gNavToolbox.querySelector("#PersonalToolbar");
+      setToolbarVisibility(
+        bookmarksToolbar,
+        gBookmarksToolbarVisibility,
+        false,
+        false
+      );
+    }
+
+    let closeOpenPanels = selector => {
+      for (let panel of document.querySelectorAll(selector)) {
+        if (panel.state != "closed") {
+          panel.hidePopup();
+        }
+      }
+    };
+
+    // If the location is changed due to switching tabs,
+    // ensure we close any open tabspecific panels.
+    if (aIsSimulated) {
+      closeOpenPanels("panel[tabspecific='true']");
+    }
+
+    // Ensure we close any remaining open locationspecific panels
+    if (!isSameDocument) {
+      closeOpenPanels("panel[locationspecific='true']");
+    }
+
+    // About pages other than about:reader are not currently supported by
+    // screenshots (see Bug 1620992).
+    Services.obs.notifyObservers(
+      window,
+      "toggle-screenshot-disable",
+      (aLocationURI.scheme == "about" &&
+        !aLocationURI.spec.startsWith("about:reader")) ||
+        Services.prefs.getBoolPref("extensions.screenshots.disabled")
+    );
+
+    gPermissionPanel.onLocationChange();
+
+    gProtectionsHandler.onLocationChange();
+
+    BrowserPageActions.onLocationChange();
+
+    SafeBrowsingNotificationBox.onLocationChange(aLocationURI);
+
+    SaveToPocket.onLocationChange(window);
+
+    UrlbarProviderSearchTips.onLocationChange(
+      window,
+      aLocationURI,
+      aWebProgress,
+      aFlags
+    );
+
+    gTabletModePageCounter.inc();
+
+    this._updateElementsForContentType();
+
+    this._updateMacUserActivity(window, aLocationURI, aWebProgress);
+
+    // Unconditionally disable the Text Encoding button during load to
+    // keep the UI calm when navigating from one modern page to another and
+    // the toolbar button is visible.
+    // Can't cache the button, because the presence of the element in the DOM
+    // may change over time.
+    let button = document.getElementById("characterencoding-button");
+    this._menuItemForRepairTextEncoding.setAttribute("disabled", "true");
+    button?.setAttribute("disabled", "true");
+
+    // Try not to instantiate gCustomizeMode as much as possible,
+    // so don't use CustomizeMode.jsm to check for URI or customizing.
+    if (
+      location == "about:blank" &&
+      gBrowser.selectedTab.hasAttribute("customizemode")
+    ) {
+      gCustomizeMode.enter();
+    } else if (
+      CustomizationHandler.isEnteringCustomizeMode ||
+      CustomizationHandler.isCustomizing()
+    ) {
+      gCustomizeMode.exit();
+    }
+
+    CFRPageActions.updatePageActions(gBrowser.selectedBrowser);
+
+    AboutReaderParent.updateReaderButton(gBrowser.selectedBrowser);
+
+    if (!gMultiProcessBrowser) {
+      // Bug 1108553 - Cannot rotate images with e10s
+      gGestureSupport.restoreRotationState();
+    }
+
+    // See bug 358202, when tabs are switched during a drag operation,
+    // timers don't fire on windows (bug 203573)
+    if (aRequest) {
+      setTimeout(function() {
+        XULBrowserWindow.asyncUpdateUI();
+      }, 0);
+    } else {
+      this.asyncUpdateUI();
+    }
+
+    if (AppConstants.MOZ_CRASHREPORTER && aLocationURI) {
+      let uri = aLocationURI;
+      try {
+        // If the current URI contains a username/password, remove it.
+        uri = aLocationURI
+          .mutate()
+          .setUserPass("")
+          .finalize();
+      } catch (ex) {
+        /* Ignore failures on about: URIs. */
+      }
+
+      try {
+        gCrashReporter.annotateCrashReport("URL", uri.spec);
+      } catch (ex) {
+        // Don't make noise when the crash reporter is built but not enabled.
+        if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {
+          throw ex;
+        }
+      }
+    }
+  },
+
+  _updateElementsForContentType() {
+    let browser = gBrowser.selectedBrowser;
+
+    let isText =
+      browser.documentContentType &&
+      BrowserUtils.mimeTypeIsTextBased(browser.documentContentType);
+    for (let element of this._elementsForTextBasedTypes) {
+      if (isText) {
+        element.removeAttribute("disabled");
+      } else {
+        element.setAttribute("disabled", "true");
+      }
+    }
+
+    // Always enable find commands in PDF documents, otherwise do it only for
+    // text documents whose location is not in the blacklist.
+    let enableFind =
+      browser.contentPrincipal?.spec == "resource://pdf.js/web/viewer.html" ||
+      (isText && BrowserUtils.canFindInPage(gBrowser.currentURI.spec));
+    for (let element of this._elementsForFind) {
+      if (enableFind) {
+        element.removeAttribute("disabled");
+      } else {
+        element.setAttribute("disabled", "true");
+      }
+    }
+  },
+
+  /**
+   * Updates macOS platform code with the current URI and page title.
+   * From there, we update the current NSUserActivity, enabling Handoff to other
+   * Apple devices.
+   * @param {Window} window
+   *   The window in which the navigation occurred.
+   * @param {nsIURI} uri
+   *   The URI pointing to the current page.
+   * @param {nsIWebProgress} webProgress
+   *   The nsIWebProgress instance that fired a onLocationChange notification.
+   */
+  _updateMacUserActivity(win, uri, webProgress) {
+    if (!webProgress.isTopLevel || AppConstants.platform != "macosx") {
+      return;
+    }
+
+    let url = uri.spec;
+    if (PrivateBrowsingUtils.isWindowPrivate(win)) {
+      // Passing an empty string to MacUserActivityUpdater will invalidate the
+      // current user activity.
+      url = "";
+    }
+    let baseWin = win.docShell.treeOwner.QueryInterface(Ci.nsIBaseWindow);
+    MacUserActivityUpdater.updateLocation(
+      url,
+      win.gBrowser.contentTitle,
+      baseWin
+    );
+  },
+
+  asyncUpdateUI() {
+    BrowserSearch.updateOpenSearchBadge();
+  },
+
+  onStatusChange(aWebProgress, aRequest, aStatus, aMessage) {
+    this.status = aMessage;
+    StatusPanel.update();
+  },
+
+  // Properties used to cache security state used to update the UI
+  _state: null,
+  _lastLocation: null,
+  _event: null,
+  _lastLocationForEvent: null,
+  // _isSecureContext can change without the state/location changing, due to security
+  // error pages that intercept certain loads. For example this happens sometimes
+  // with the the HTTPS-Only Mode error page (more details in bug 1656027)
+  _isSecureContext: null,
+
+  // This is called in multiple ways:
+  //  1. Due to the nsIWebProgressListener.onContentBlockingEvent notification.
+  //  2. Called by tabbrowser.xml when updating the current browser.
+  //  3. Called directly during this object's initializations.
+  //  4. Due to the nsIWebProgressListener.onLocationChange notification.
+  // aRequest will be null always in case 2 and 3, and sometimes in case 1 (for
+  // instance, there won't be a request when STATE_BLOCKED_TRACKING_CONTENT or
+  // other blocking events are observed).
+  onContentBlockingEvent(aWebProgress, aRequest, aEvent, aIsSimulated) {
+    // Don't need to do anything if the data we use to update the UI hasn't
+    // changed
+    let uri = gBrowser.currentURI;
+    let spec = uri.spec;
+    if (this._event == aEvent && this._lastLocationForEvent == spec) {
+      return;
+    }
+    this._lastLocationForEvent = spec;
+
+    if (
+      typeof aIsSimulated != "boolean" &&
+      typeof aIsSimulated != "undefined"
+    ) {
+      throw new Error(
+        "onContentBlockingEvent: aIsSimulated receieved an unexpected type"
+      );
+    }
+
+    gProtectionsHandler.onContentBlockingEvent(
+      aEvent,
+      aWebProgress,
+      aIsSimulated,
+      this._event // previous content blocking event
+    );
+
+    // We need the state of the previous content blocking event, so update
+    // event after onContentBlockingEvent is called.
+    this._event = aEvent;
+  },
+
+  // This is called in multiple ways:
+  //  1. Due to the nsIWebProgressListener.onSecurityChange notification.
+  //  2. Called by tabbrowser.xml when updating the current browser.
+  //  3. Called directly during this object's initializations.
+  // aRequest will be null always in case 2 and 3, and sometimes in case 1.
+  onSecurityChange(aWebProgress, aRequest, aState, aIsSimulated) {
+    // Don't need to do anything if the data we use to update the UI hasn't
+    // changed
+    let uri = gBrowser.currentURI;
+    let spec = uri.spec;
+    let isSecureContext = gBrowser.securityUI.isSecureContext;
+    if (
+      this._state == aState &&
+      this._lastLocation == spec &&
+      this._isSecureContext === isSecureContext
+    ) {
+      // Switching to a tab of the same URL doesn't change most security
+      // information, but tab specific permissions may be different.
+      gIdentityHandler.refreshIdentityBlock();
+      return;
+    }
+    this._state = aState;
+    this._lastLocation = spec;
+    this._isSecureContext = isSecureContext;
+
+    // Make sure the "https" part of the URL is striked out or not,
+    // depending on the current mixed active content blocking state.
+    gURLBar.formatValue();
+
+    try {
+      uri = Services.io.createExposableURI(uri);
+    } catch (e) {}
+    gIdentityHandler.updateIdentity(this._state, uri);
+  },
+
+  // simulate all change notifications after switching tabs
+  onUpdateCurrentBrowser: function XWB_onUpdateCurrentBrowser(
+    aStateFlags,
+    aStatus,
+    aMessage,
+    aTotalProgress
+  ) {
+    if (FullZoom.updateBackgroundTabs) {
+      FullZoom.onLocationChange(gBrowser.currentURI, true);
+    }
+
+    CombinedStopReload.onTabSwitch();
+
+    // Docshell should normally take care of hiding the tooltip, but we need to do it
+    // ourselves for tabswitches.
+    this.hideTooltip();
+
+    // Also hide tooltips for content loaded in the parent process:
+    document.getElementById("aHTMLTooltip").hidePopup();
+
+    var nsIWebProgressListener = Ci.nsIWebProgressListener;
+    var loadingDone = aStateFlags & nsIWebProgressListener.STATE_STOP;
+    // use a pseudo-object instead of a (potentially nonexistent) channel for getting
+    // a correct error message - and make sure that the UI is always either in
+    // loading (STATE_START) or done (STATE_STOP) mode
+    this.onStateChange(
+      gBrowser.webProgress,
+      { URI: gBrowser.currentURI },
+      loadingDone
+        ? nsIWebProgressListener.STATE_STOP
+        : nsIWebProgressListener.STATE_START,
+      aStatus
+    );
+    // status message and progress value are undefined if we're done with loading
+    if (loadingDone) {
+      return;
+    }
+    this.onStatusChange(gBrowser.webProgress, null, 0, aMessage);
+  },
+};
+
+var LinkTargetDisplay = {
+  get DELAY_SHOW() {
+    delete this.DELAY_SHOW;
+    return (this.DELAY_SHOW = Services.prefs.getIntPref(
+      "browser.overlink-delay"
+    ));
+  },
+
+  DELAY_HIDE: 250,
+  _timer: 0,
+
+  get _contextMenu() {
+    delete this._contextMenu;
+    return (this._contextMenu = document.getElementById(
+      "contentAreaContextMenu"
+    ));
+  },
+
+  update() {
+    if (
+      this._contextMenu.state == "open" ||
+      this._contextMenu.state == "showing"
+    ) {
+      this._contextMenu.addEventListener("popuphidden", () => this.update(), {
+        once: true,
+      });
+      return;
+    }
+
+    clearTimeout(this._timer);
+    window.removeEventListener("mousemove", this, true);
+
+    if (!XULBrowserWindow.overLink) {
+      if (XULBrowserWindow.hideOverLinkImmediately) {
+        this._hide();
+      } else {
+        this._timer = setTimeout(this._hide.bind(this), this.DELAY_HIDE);
+      }
+      return;
+    }
+
+    if (StatusPanel.isVisible) {
+      StatusPanel.update();
+    } else {
+      // Let the display appear when the mouse doesn't move within the delay
+      this._showDelayed();
+      window.addEventListener("mousemove", this, true);
+    }
+  },
+
+  handleEvent(event) {
+    switch (event.type) {
+      case "mousemove":
+        // Restart the delay since the mouse was moved
+        clearTimeout(this._timer);
+        this._showDelayed();
+        break;
+    }
+  },
+
+  _showDelayed() {
+    this._timer = setTimeout(
+      function(self) {
+        StatusPanel.update();
+        window.removeEventListener("mousemove", self, true);
+      },
+      this.DELAY_SHOW,
+      this
+    );
+  },
+
+  _hide() {
+    clearTimeout(this._timer);
+
+    StatusPanel.update();
+  },
+};
+
+var CombinedStopReload = {
+  // Try to initialize. Returns whether initialization was successful, which
+  // may mean we had already initialized.
+  ensureInitialized() {
+    if (this._initialized) {
+      return true;
+    }
+    if (this._destroyed) {
+      return false;
+    }
+
+    let reload = document.getElementById("reload-button");
+    let stop = document.getElementById("stop-button");
+    // It's possible the stop/reload buttons have been moved to the palette.
+    // They may be reinserted later, so we will retry initialization if/when
+    // we get notified of document loads.
+    if (!stop || !reload) {
+      return false;
+    }
+
+    this._initialized = true;
+    if (XULBrowserWindow.stopCommand.getAttribute("disabled") != "true") {
+      reload.setAttribute("displaystop", "true");
+    }
+    stop.addEventListener("click", this);
+
+    // Removing attributes based on the observed command doesn't happen if the button
+    // is in the palette when the command's attribute is removed (cf. bug 309953)
+    for (let button of [stop, reload]) {
+      if (button.hasAttribute("disabled")) {
+        let command = document.getElementById(button.getAttribute("command"));
+        if (!command.hasAttribute("disabled")) {
+          button.removeAttribute("disabled");
+        }
+      }
+    }
+
+    this.reload = reload;
+    this.stop = stop;
+    this.stopReloadContainer = this.reload.parentNode;
+    this.timeWhenSwitchedToStop = 0;
+
+    this.stopReloadContainer.addEventListener("animationend", this);
+    this.stopReloadContainer.addEventListener("animationcancel", this);
+
+    return true;
+  },
+
+  uninit() {
+    this._destroyed = true;
+
+    if (!this._initialized) {
+      return;
+    }
+
+    this._cancelTransition();
+    this.stop.removeEventListener("click", this);
+    this.stopReloadContainer.removeEventListener("animationend", this);
+    this.stopReloadContainer.removeEventListener("animationcancel", this);
+    this.stopReloadContainer = null;
+    this.reload = null;
+    this.stop = null;
+  },
+
+  handleEvent(event) {
+    switch (event.type) {
+      case "click":
+        if (event.button == 0 && !this.stop.disabled) {
+          this._stopClicked = true;
+        }
+        break;
+      case "animationcancel":
+      case "animationend": {
+        if (
+          event.target.classList.contains("toolbarbutton-animatable-image") &&
+          (event.animationName == "reload-to-stop" ||
+            event.animationName == "stop-to-reload")
+        ) {
+          this.stopReloadContainer.removeAttribute("animate");
+        }
+      }
+    }
+  },
+
+  onTabSwitch() {
+    // Reset the time in the event of a tabswitch since the stored time
+    // would have been associated with the previous tab, so the animation will
+    // still run if the page has been loading until long after the tab switch.
+    this.timeWhenSwitchedToStop = window.performance.now();
+  },
+
+  switchToStop(aRequest, aWebProgress) {
+    if (
+      !this.ensureInitialized() ||
+      !this._shouldSwitch(aRequest, aWebProgress)
+    ) {
+      return;
+    }
+
+    // Store the time that we switched to the stop button only if a request
+    // is active. Requests are null if the switch is related to a tabswitch.
+    // This is used to determine if we should show the stop->reload animation.
+    if (aRequest instanceof Ci.nsIRequest) {
+      this.timeWhenSwitchedToStop = window.performance.now();
+    }
+
+    let shouldAnimate =
+      aRequest instanceof Ci.nsIRequest &&
+      aWebProgress.isTopLevel &&
+      aWebProgress.isLoadingDocument &&
+      !gBrowser.tabAnimationsInProgress &&
+      !gReduceMotion &&
+      this.stopReloadContainer.closest("#nav-bar-customization-target");
+
+    this._cancelTransition();
+    if (shouldAnimate) {
+      BrowserUIUtils.setToolbarButtonHeightProperty(this.stopReloadContainer);
+      this.stopReloadContainer.setAttribute("animate", "true");
+    } else {
+      this.stopReloadContainer.removeAttribute("animate");
+    }
+    this.reload.setAttribute("displaystop", "true");
+  },
+
+  switchToReload(aRequest, aWebProgress) {
+    if (!this.ensureInitialized() || !this.reload.hasAttribute("displaystop")) {
+      return;
+    }
+
+    let shouldAnimate =
+      aRequest instanceof Ci.nsIRequest &&
+      aWebProgress.isTopLevel &&
+      !aWebProgress.isLoadingDocument &&
+      !gBrowser.tabAnimationsInProgress &&
+      !gReduceMotion &&
+      this._loadTimeExceedsMinimumForAnimation() &&
+      this.stopReloadContainer.closest("#nav-bar-customization-target");
+
+    if (shouldAnimate) {
+      BrowserUIUtils.setToolbarButtonHeightProperty(this.stopReloadContainer);
+      this.stopReloadContainer.setAttribute("animate", "true");
+    } else {
+      this.stopReloadContainer.removeAttribute("animate");
+    }
+
+    this.reload.removeAttribute("displaystop");
+
+    if (!shouldAnimate || this._stopClicked) {
+      this._stopClicked = false;
+      this._cancelTransition();
+      this.reload.disabled =
+        XULBrowserWindow.reloadCommand.getAttribute("disabled") == "true";
+      return;
+    }
+
+    if (this._timer) {
+      return;
+    }
+
+    // Temporarily disable the reload button to prevent the user from
+    // accidentally reloading the page when intending to click the stop button
+    this.reload.disabled = true;
+    this._timer = setTimeout(
+      function(self) {
+        self._timer = 0;
+        self.reload.disabled =
+          XULBrowserWindow.reloadCommand.getAttribute("disabled") == "true";
+      },
+      650,
+      this
+    );
+  },
+
+  _loadTimeExceedsMinimumForAnimation() {
+    // If the time between switching to the stop button then switching to
+    // the reload button exceeds 150ms, then we will show the animation.
+    // If we don't know when we switched to stop (switchToStop is called
+    // after init but before switchToReload), then we will prevent the
+    // animation from occuring.
+    return (
+      this.timeWhenSwitchedToStop &&
+      window.performance.now() - this.timeWhenSwitchedToStop > 150
+    );
+  },
+
+  _shouldSwitch(aRequest, aWebProgress) {
+    if (
+      aRequest &&
+      aRequest.originalURI &&
+      (aRequest.originalURI.schemeIs("chrome") ||
+        (aRequest.originalURI.schemeIs("about") &&
+          aWebProgress.isTopLevel &&
+          !aRequest.originalURI.spec.startsWith("about:reader")))
+    ) {
+      return false;
+    }
+
+    return true;
+  },
+
+  _cancelTransition() {
+    if (this._timer) {
+      clearTimeout(this._timer);
+      this._timer = 0;
+    }
+  },
+};
+
+var TabsProgressListener = {
+  onStateChange(aBrowser, aWebProgress, aRequest, aStateFlags, aStatus) {
+    // Collect telemetry data about tab load times.
+    if (
+      aWebProgress.isTopLevel &&
+      (!aRequest.originalURI || aRequest.originalURI.scheme != "about")
+    ) {
+      let histogram = "FX_PAGE_LOAD_MS_2";
+      let recordLoadTelemetry = true;
+
+      if (aWebProgress.loadType & Ci.nsIDocShell.LOAD_CMD_RELOAD) {
+        // loadType is constructed by shifting loadFlags, this is why we need to
+        // do the same shifting here.
+        // https://searchfox.org/mozilla-central/rev/11cfa0462a6b5d8c5e2111b8cfddcf78098f0141/docshell/base/nsDocShellLoadTypes.h#22
+        if (aWebProgress.loadType & (kSkipCacheFlags << 16)) {
+          histogram = "FX_PAGE_RELOAD_SKIP_CACHE_MS";
+        } else if (aWebProgress.loadType == Ci.nsIDocShell.LOAD_CMD_RELOAD) {
+          histogram = "FX_PAGE_RELOAD_NORMAL_MS";
+        } else {
+          recordLoadTelemetry = false;
+        }
+      }
+
+      let stopwatchRunning = TelemetryStopwatch.running(histogram, aBrowser);
+      if (aStateFlags & Ci.nsIWebProgressListener.STATE_IS_WINDOW) {
+        if (aStateFlags & Ci.nsIWebProgressListener.STATE_START) {
+          if (stopwatchRunning) {
+            // Oops, we're seeing another start without having noticed the previous stop.
+            if (recordLoadTelemetry) {
+              TelemetryStopwatch.cancel(histogram, aBrowser);
+            }
+          }
+          if (recordLoadTelemetry) {
+            TelemetryStopwatch.start(histogram, aBrowser);
+          }
+          Services.telemetry.getHistogramById("FX_TOTAL_TOP_VISITS").add(true);
+        } else if (
+          aStateFlags & Ci.nsIWebProgressListener.STATE_STOP &&
+          stopwatchRunning /* we won't see STATE_START events for pre-rendered tabs */
+        ) {
+          if (recordLoadTelemetry) {
+            if (aBrowser.browsingContext?.topWindowContext?.hadLazyLoadImage) {
+              let timeElapsed = TelemetryStopwatch.timeElapsed(
+                histogram,
+                aBrowser
+              );
+              Services.telemetry
+                .getHistogramById("FX_LAZYLOAD_IMAGE_PAGE_LOAD_MS")
+                .add(timeElapsed);
+            }
+            TelemetryStopwatch.finish(histogram, aBrowser);
+            BrowserTelemetryUtils.recordSiteOriginTelemetry(browserWindows());
+          }
+        }
+      } else if (
+        aStateFlags & Ci.nsIWebProgressListener.STATE_STOP &&
+        aStatus == Cr.NS_BINDING_ABORTED &&
+        stopwatchRunning /* we won't see STATE_START events for pre-rendered tabs */
+      ) {
+        if (recordLoadTelemetry) {
+          TelemetryStopwatch.cancel(histogram, aBrowser);
+        }
+      }
+    }
+  },
+
+  onLocationChange(aBrowser, aWebProgress, aRequest, aLocationURI, aFlags) {
+    // Filter out location changes caused by anchor navigation
+    // or history.push/pop/replaceState.
+    if (aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT) {
+      // Reader mode cares about history.pushState and friends.
+      // FIXME: The content process should manage this directly (bug 1445351).
+      aBrowser.sendMessageToActor(
+        "Reader:PushState",
+        {
+          isArticle: aBrowser.isArticle,
+        },
+        "AboutReader"
+      );
+      return;
+    }
+
+    // Filter out location changes in sub documents.
+    if (!aWebProgress.isTopLevel) {
+      return;
+    }
+
+    // Only need to call locationChange if the PopupNotifications object
+    // for this window has already been initialized (i.e. its getter no
+    // longer exists)
+    if (!Object.getOwnPropertyDescriptor(window, "PopupNotifications").get) {
+      PopupNotifications.locationChange(aBrowser);
+    }
+
+    let tab = gBrowser.getTabForBrowser(aBrowser);
+    if (tab && tab._sharingState) {
+      gBrowser.resetBrowserSharing(aBrowser);
+    }
+
+    gBrowser.readNotificationBox(aBrowser)?.removeTransientNotifications();
+
+    FullZoom.onLocationChange(aLocationURI, false, aBrowser);
+    CaptivePortalWatcher.onLocationChange(aBrowser);
+  },
+
+  onLinkIconAvailable(browser, dataURI, iconURI) {
+    if (!iconURI) {
+      return;
+    }
+    if (browser == gBrowser.selectedBrowser) {
+      // If the "Add Search Engine" page action is in the urlbar, its image
+      // needs to be set to the new icon, so call updateOpenSearchBadge.
+      BrowserSearch.updateOpenSearchBadge();
+    }
+  },
+};
+
+function nsBrowserAccess() {}
+
+nsBrowserAccess.prototype = {
+  QueryInterface: ChromeUtils.generateQI(["nsIBrowserDOMWindow"]),
+
+  _openURIInNewTab(
+    aURI,
+    aReferrerInfo,
+    aIsPrivate,
+    aIsExternal,
+    aForceNotRemote = false,
+    aUserContextId = Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID,
+    aOpenWindowInfo = null,
+    aOpenerBrowser = null,
+    aTriggeringPrincipal = null,
+    aName = "",
+    aCsp = null,
+    aSkipLoad = false
+  ) {
+    let win, needToFocusWin;
+
+    // try the current window.  if we're in a popup, fall back on the most recent browser window
+    if (window.toolbar.visible) {
+      win = window;
+    } else {
+      win = BrowserWindowTracker.getTopWindow({ private: aIsPrivate });
+      needToFocusWin = true;
+    }
+
+    if (!win) {
+      // we couldn't find a suitable window, a new one needs to be opened.
+      return null;
+    }
+
+    if (aIsExternal && (!aURI || aURI.spec == "about:blank")) {
+      win.BrowserOpenTab(); // this also focuses the location bar
+      win.focus();
+      return win.gBrowser.selectedBrowser;
+    }
+
+    let loadInBackground = Services.prefs.getBoolPref(
+      "browser.tabs.loadDivertedInBackground"
+    );
+
+    let tab = win.gBrowser.loadOneTab(aURI ? aURI.spec : "about:blank", {
+      triggeringPrincipal: aTriggeringPrincipal,
+      referrerInfo: aReferrerInfo,
+      userContextId: aUserContextId,
+      fromExternal: aIsExternal,
+      inBackground: loadInBackground,
+      forceNotRemote: aForceNotRemote,
+      openWindowInfo: aOpenWindowInfo,
+      openerBrowser: aOpenerBrowser,
+      name: aName,
+      csp: aCsp,
+      skipLoad: aSkipLoad,
+    });
+    let browser = win.gBrowser.getBrowserForTab(tab);
+
+    if (needToFocusWin || (!loadInBackground && aIsExternal)) {
+      win.focus();
+    }
+
+    return browser;
+  },
+
+  createContentWindow(
+    aURI,
+    aOpenWindowInfo,
+    aWhere,
+    aFlags,
+    aTriggeringPrincipal,
+    aCsp
+  ) {
+    return this.getContentWindowOrOpenURI(
+      null,
+      aOpenWindowInfo,
+      aWhere,
+      aFlags,
+      aTriggeringPrincipal,
+      aCsp,
+      true
+    );
+  },
+
+  openURI(aURI, aOpenWindowInfo, aWhere, aFlags, aTriggeringPrincipal, aCsp) {
+    if (!aURI) {
+      Cu.reportError("openURI should only be called with a valid URI");
+      throw Components.Exception("", Cr.NS_ERROR_FAILURE);
+    }
+    return this.getContentWindowOrOpenURI(
+      aURI,
+      aOpenWindowInfo,
+      aWhere,
+      aFlags,
+      aTriggeringPrincipal,
+      aCsp,
+      false
+    );
+  },
+
+  getContentWindowOrOpenURI(
+    aURI,
+    aOpenWindowInfo,
+    aWhere,
+    aFlags,
+    aTriggeringPrincipal,
+    aCsp,
+    aSkipLoad
+  ) {
+    var browsingContext = null;
+    var isExternal = !!(aFlags & Ci.nsIBrowserDOMWindow.OPEN_EXTERNAL);
+
+    if (aOpenWindowInfo && isExternal) {
+      Cu.reportError(
+        "nsBrowserAccess.openURI did not expect aOpenWindowInfo to be " +
+          "passed if the context is OPEN_EXTERNAL."
+      );
+      throw Components.Exception("", Cr.NS_ERROR_FAILURE);
+    }
+
+    if (isExternal && aURI && aURI.schemeIs("chrome")) {
+      dump("use --chrome command-line option to load external chrome urls\n");
+      return null;
+    }
+
+    if (aWhere == Ci.nsIBrowserDOMWindow.OPEN_DEFAULTWINDOW) {
+      if (
+        isExternal &&
+        Services.prefs.prefHasUserValue(
+          "browser.link.open_newwindow.override.external"
+        )
+      ) {
+        aWhere = Services.prefs.getIntPref(
+          "browser.link.open_newwindow.override.external"
+        );
+      } else {
+        aWhere = Services.prefs.getIntPref("browser.link.open_newwindow");
+      }
+    }
+
+    let referrerInfo;
+    if (aFlags & Ci.nsIBrowserDOMWindow.OPEN_NO_REFERRER) {
+      referrerInfo = new ReferrerInfo(Ci.nsIReferrerInfo.EMPTY, false, null);
+    } else if (
+      aOpenWindowInfo &&
+      aOpenWindowInfo.parent &&
+      aOpenWindowInfo.parent.window
+    ) {
+      referrerInfo = new ReferrerInfo(
+        aOpenWindowInfo.parent.window.document.referrerInfo.referrerPolicy,
+        true,
+        makeURI(aOpenWindowInfo.parent.window.location.href)
+      );
+    } else {
+      referrerInfo = new ReferrerInfo(Ci.nsIReferrerInfo.EMPTY, true, null);
+    }
+
+    let isPrivate = aOpenWindowInfo
+      ? aOpenWindowInfo.originAttributes.privateBrowsingId != 0
+      : PrivateBrowsingUtils.isWindowPrivate(window);
+
+    switch (aWhere) {
+      case Ci.nsIBrowserDOMWindow.OPEN_NEWWINDOW:
+        // FIXME: Bug 408379. So how come this doesn't send the
+        // referrer like the other loads do?
+        var url = aURI && aURI.spec;
+        let features = "all,dialog=no";
+        if (isPrivate) {
+          features += ",private";
+        }
+        // Pass all params to openDialog to ensure that "url" isn't passed through
+        // loadOneOrMoreURIs, which splits based on "|"
+        try {
+          openDialog(
+            AppConstants.BROWSER_CHROME_URL,
+            "_blank",
+            features,
+            // window.arguments
+            url,
+            null,
+            null,
+            null,
+            null,
+            null,
+            null,
+            null,
+            aTriggeringPrincipal,
+            null,
+            aCsp,
+            aOpenWindowInfo
+          );
+          // At this point, the new browser window is just starting to load, and
+          // hasn't created the content <browser> that we should return.
+          // If the caller of this function is originating in C++, they can pass a
+          // callback in nsOpenWindowInfo and it will be invoked when the browsing
+          // context for a newly opened window is ready.
+          browsingContext = null;
+        } catch (ex) {
+          Cu.reportError(ex);
+        }
+        break;
+      case Ci.nsIBrowserDOMWindow.OPEN_NEWTAB: {
+        // If we have an opener, that means that the caller is expecting access
+        // to the nsIDOMWindow of the opened tab right away. For e10s windows,
+        // this means forcing the newly opened browser to be non-remote so that
+        // we can hand back the nsIDOMWindow. DocumentLoadListener will do the
+        // job of shuttling off the newly opened browser to run in the right
+        // process once it starts loading a URI.
+        let forceNotRemote = aOpenWindowInfo && !aOpenWindowInfo.isRemote;
+        let userContextId = aOpenWindowInfo
+          ? aOpenWindowInfo.originAttributes.userContextId
+          : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+        let browser = this._openURIInNewTab(
+          aURI,
+          referrerInfo,
+          isPrivate,
+          isExternal,
+          forceNotRemote,
+          userContextId,
+          aOpenWindowInfo,
+          aOpenWindowInfo?.parent?.top.embedderElement,
+          aTriggeringPrincipal,
+          "",
+          aCsp,
+          aSkipLoad
+        );
+        if (browser) {
+          browsingContext = browser.browsingContext;
+        }
+        break;
+      }
+      case Ci.nsIBrowserDOMWindow.OPEN_PRINT_BROWSER: {
+        let browser = PrintUtils.handleStaticCloneCreatedForPrint(
+          aOpenWindowInfo
+        );
+        if (browser) {
+          browsingContext = browser.browsingContext;
+        }
+        break;
+      }
+      default:
+        // OPEN_CURRENTWINDOW or an illegal value
+        browsingContext = window.gBrowser.selectedBrowser.browsingContext;
+        if (aURI) {
+          let loadFlags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
+          if (isExternal) {
+            loadFlags |= Ci.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL;
+          } else if (!aTriggeringPrincipal.isSystemPrincipal) {
+            // XXX this code must be reviewed and changed when bug 1616353
+            // lands.
+            loadFlags |= Ci.nsIWebNavigation.LOAD_FLAGS_FIRST_LOAD;
+          }
+          gBrowser.loadURI(aURI.spec, {
+            triggeringPrincipal: aTriggeringPrincipal,
+            csp: aCsp,
+            loadFlags,
+            referrerInfo,
+          });
+        }
+        if (
+          !Services.prefs.getBoolPref("browser.tabs.loadDivertedInBackground")
+        ) {
+          window.focus();
+        }
+    }
+    return browsingContext;
+  },
+
+  createContentWindowInFrame: function browser_createContentWindowInFrame(
+    aURI,
+    aParams,
+    aWhere,
+    aFlags,
+    aName
+  ) {
+    // Passing a null-URI to only create the content window,
+    // and pass true for aSkipLoad to prevent loading of
+    // about:blank
+    return this.getContentWindowOrOpenURIInFrame(
+      null,
+      aParams,
+      aWhere,
+      aFlags,
+      aName,
+      true
+    );
+  },
+
+  openURIInFrame: function browser_openURIInFrame(
+    aURI,
+    aParams,
+    aWhere,
+    aFlags,
+    aName
+  ) {
+    return this.getContentWindowOrOpenURIInFrame(
+      aURI,
+      aParams,
+      aWhere,
+      aFlags,
+      aName,
+      false
+    );
+  },
+
+  getContentWindowOrOpenURIInFrame: function browser_getContentWindowOrOpenURIInFrame(
+    aURI,
+    aParams,
+    aWhere,
+    aFlags,
+    aName,
+    aSkipLoad
+  ) {
+    if (aWhere == Ci.nsIBrowserDOMWindow.OPEN_PRINT_BROWSER) {
+      return PrintUtils.handleStaticCloneCreatedForPrint(
+        aParams.openWindowInfo
+      );
+    }
+
+    if (aWhere != Ci.nsIBrowserDOMWindow.OPEN_NEWTAB) {
+      dump("Error: openURIInFrame can only open in new tabs or print");
+      return null;
+    }
+
+    var isExternal = !!(aFlags & Ci.nsIBrowserDOMWindow.OPEN_EXTERNAL);
+
+    var userContextId =
+      aParams.openerOriginAttributes &&
+      "userContextId" in aParams.openerOriginAttributes
+        ? aParams.openerOriginAttributes.userContextId
+        : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+
+    return this._openURIInNewTab(
+      aURI,
+      aParams.referrerInfo,
+      aParams.isPrivate,
+      isExternal,
+      false,
+      userContextId,
+      aParams.openWindowInfo,
+      aParams.openerBrowser,
+      aParams.triggeringPrincipal,
+      aName,
+      aParams.csp,
+      aSkipLoad
+    );
+  },
+
+  canClose() {
+    return CanCloseWindow();
+  },
+
+  get tabCount() {
+    return gBrowser.tabs.length;
+  },
+};
+
+function showFullScreenViewContextMenuItems(popup) {
+  for (let node of popup.querySelectorAll('[contexttype="fullscreen"]')) {
+    node.hidden = !window.fullScreen;
+  }
+  let autoHide = popup.querySelector(".fullscreen-context-autohide");
+  if (autoHide) {
+    FullScreen.getAutohide(autoHide);
+  }
+}
+
+function onViewToolbarsPopupShowing(aEvent, aInsertPoint) {
+  var popup = aEvent.target;
+  if (popup != aEvent.currentTarget) {
+    return;
+  }
+
+  // Empty the menu
+  for (var i = popup.children.length - 1; i >= 0; --i) {
+    var deadItem = popup.children[i];
+    if (deadItem.hasAttribute("toolbarId")) {
+      popup.removeChild(deadItem);
+    }
+  }
+
+  MozXULElement.insertFTLIfNeeded("browser/toolbarContextMenu.ftl");
+  let firstMenuItem = aInsertPoint || popup.firstElementChild;
+  let toolbarNodes = gNavToolbox.querySelectorAll("toolbar");
+  for (let toolbar of toolbarNodes) {
+    if (!toolbar.hasAttribute("toolbarname")) {
+      continue;
+    }
+
+    if (toolbar.id == "PersonalToolbar") {
+      let menu = BookmarkingUI.buildBookmarksToolbarSubmenu(toolbar);
+      popup.insertBefore(menu, firstMenuItem);
+    } else {
+      let menuItem = document.createXULElement("menuitem");
+      menuItem.setAttribute("id", "toggle_" + toolbar.id);
+      menuItem.setAttribute("toolbarId", toolbar.id);
+      menuItem.setAttribute("type", "checkbox");
+      menuItem.setAttribute("label", toolbar.getAttribute("toolbarname"));
+      let hidingAttribute =
+        toolbar.getAttribute("type") == "menubar" ? "autohide" : "collapsed";
+      menuItem.setAttribute(
+        "checked",
+        toolbar.getAttribute(hidingAttribute) != "true"
+      );
+      menuItem.setAttribute("accesskey", toolbar.getAttribute("accesskey"));
+      if (popup.id != "toolbar-context-menu") {
+        menuItem.setAttribute("key", toolbar.getAttribute("key"));
+      }
+
+      popup.insertBefore(menuItem, firstMenuItem);
+      menuItem.addEventListener("command", onViewToolbarCommand);
+    }
+  }
+
+  let moveToPanel = popup.querySelector(".customize-context-moveToPanel");
+  let removeFromToolbar = popup.querySelector(
+    ".customize-context-removeFromToolbar"
+  );
+  // Show/hide fullscreen context menu items and set the
+  // autohide item's checked state to mirror the autohide pref.
+  showFullScreenViewContextMenuItems(popup);
+  // View -> Toolbars menu doesn't have the moveToPanel or removeFromToolbar items.
+  if (!moveToPanel || !removeFromToolbar) {
+    return;
+  }
+
+  // triggerNode can be a nested child element of a toolbaritem.
+  let toolbarItem = popup.triggerNode;
+
+  if (toolbarItem && toolbarItem.localName == "toolbarpaletteitem") {
+    toolbarItem = toolbarItem.firstElementChild;
+  } else if (toolbarItem && toolbarItem.localName != "toolbar") {
+    while (toolbarItem && toolbarItem.parentElement) {
+      let parent = toolbarItem.parentElement;
+      if (
+        (parent.classList &&
+          parent.classList.contains("customization-target")) ||
+        parent.getAttribute("overflowfortoolbar") || // Needs to work in the overflow list as well.
+        parent.localName == "toolbarpaletteitem" ||
+        parent.localName == "toolbar"
+      ) {
+        break;
+      }
+      toolbarItem = parent;
+    }
+  } else {
+    toolbarItem = null;
+  }
+
+  let showTabStripItems = toolbarItem && toolbarItem.id == "tabbrowser-tabs";
+  for (let node of popup.querySelectorAll(
+    'menuitem[contexttype="toolbaritem"]'
+  )) {
+    node.hidden = showTabStripItems;
+  }
+
+  for (let node of popup.querySelectorAll('menuitem[contexttype="tabbar"]')) {
+    node.hidden = !showTabStripItems;
+  }
+
+  document
+    .getElementById("toolbar-context-menu")
+    .querySelectorAll("[data-lazy-l10n-id]")
+    .forEach(el => {
+      el.setAttribute("data-l10n-id", el.getAttribute("data-lazy-l10n-id"));
+      el.removeAttribute("data-lazy-l10n-id");
+    });
+
+  // The "normal" toolbar items menu separator is hidden because it's unused
+  // when hiding the "moveToPanel" and "removeFromToolbar" items on flexible
+  // space items. But we need to ensure its hidden state is reset in the case
+  // the context menu is subsequently opened on a non-flexible space item.
+  let menuSeparator = document.getElementById("toolbarItemsMenuSeparator");
+  menuSeparator.hidden = false;
+
+  document.getElementById(
+    "toolbarNavigatorItemsMenuSeparator"
+  ).hidden = !showTabStripItems;
+
+  if (
+    !CustomizationHandler.isCustomizing() &&
+    CustomizableUI.isSpecialWidget(toolbarItem?.id || "")
+  ) {
+    moveToPanel.hidden = true;
+    removeFromToolbar.hidden = true;
+    menuSeparator.hidden = !showTabStripItems;
+  }
+
+  if (showTabStripItems) {
+    let multipleTabsSelected = !!gBrowser.multiSelectedTabsCount;
+    document.getElementById(
+      "toolbar-context-bookmarkSelectedTabs"
+    ).hidden = !multipleTabsSelected;
+    document.getElementById(
+      "toolbar-context-bookmarkSelectedTab"
+    ).hidden = multipleTabsSelected;
+    document.getElementById(
+      "toolbar-context-reloadSelectedTabs"
+    ).hidden = !multipleTabsSelected;
+    document.getElementById(
+      "toolbar-context-reloadSelectedTab"
+    ).hidden = multipleTabsSelected;
+    document.getElementById(
+      "toolbar-context-selectAllTabs"
+    ).disabled = gBrowser.allTabsSelected();
+    document.getElementById("toolbar-context-undoCloseTab").disabled =
+      SessionStore.getClosedTabCount(window) == 0;
+    return;
+  }
+
+  let movable =
+    toolbarItem &&
+    toolbarItem.id &&
+    CustomizableUI.isWidgetRemovable(toolbarItem);
+  if (movable) {
+    if (CustomizableUI.isSpecialWidget(toolbarItem.id)) {
+      moveToPanel.setAttribute("disabled", true);
+    } else {
+      moveToPanel.removeAttribute("disabled");
+    }
+    removeFromToolbar.removeAttribute("disabled");
+  } else {
+    moveToPanel.setAttribute("disabled", true);
+    removeFromToolbar.setAttribute("disabled", true);
+  }
+}
+
+function onViewToolbarCommand(aEvent) {
+  let node = aEvent.originalTarget;
+  let menuId;
+  let toolbarId;
+  let isVisible;
+  if (node.dataset.bookmarksToolbarVisibility) {
+    isVisible = node.dataset.visibilityEnum;
+    toolbarId = "PersonalToolbar";
+    menuId = node.parentNode.parentNode.parentNode.id;
+    Services.prefs.setCharPref(
+      "browser.toolbars.bookmarks.visibility",
+      isVisible
+    );
+  } else {
+    menuId = node.parentNode.id;
+    toolbarId = node.getAttribute("toolbarId");
+    isVisible = node.getAttribute("checked") == "true";
+  }
+  CustomizableUI.setToolbarVisibility(toolbarId, isVisible);
+  BrowserUsageTelemetry.recordToolbarVisibility(toolbarId, isVisible, menuId);
+}
+
+function setToolbarVisibility(
+  toolbar,
+  isVisible,
+  persist = true,
+  animated = true
+) {
+  let hidingAttribute;
+  if (toolbar.getAttribute("type") == "menubar") {
+    hidingAttribute = "autohide";
+    if (AppConstants.platform == "linux") {
+      Services.prefs.setBoolPref("ui.key.menuAccessKeyFocuses", !isVisible);
+    }
+  } else {
+    hidingAttribute = "collapsed";
+  }
+
+  // For the bookmarks toolbar, we need to persist state before toggling
+  // the visibility in this window, because the state can be different
+  // (newtab vs never or always) even when that won't change visibility
+  // in this window.
+  if (persist && toolbar.id == "PersonalToolbar") {
+    let prefValue;
+    if (typeof isVisible == "string") {
+      prefValue = isVisible;
+    } else {
+      prefValue = isVisible ? "always" : "never";
+    }
+    Services.prefs.setCharPref(
+      "browser.toolbars.bookmarks.visibility",
+      prefValue
+    );
+  }
+
+  if (typeof isVisible == "string") {
+    switch (isVisible) {
+      case "always":
+        isVisible = true;
+        break;
+      case "never":
+        isVisible = false;
+        break;
+      case "newtab":
+        let currentURI = gBrowser?.currentURI;
+        if (!gBrowserInit.domContentLoaded) {
+          let uriToLoad = gBrowserInit.uriToLoadPromise;
+          if (uriToLoad) {
+            if (Array.isArray(uriToLoad)) {
+              // We only care about the first tab being loaded
+              uriToLoad = uriToLoad[0];
+            }
+            try {
+              currentURI = Services.io.newURI(uriToLoad);
+            } catch (ex) {}
+          }
+        }
+        isVisible =
+          !!currentURI && BookmarkingUI.isOnNewTabPage({ currentURI });
+        break;
+    }
+  }
+
+  if (toolbar.getAttribute(hidingAttribute) == (!isVisible).toString()) {
+    // If this call will not result in a visibility change, return early
+    // since dispatching toolbarvisibilitychange will cause views to get rebuilt.
+    return;
+  }
+
+  toolbar.classList.toggle("instant", !animated);
+  toolbar.setAttribute(hidingAttribute, !isVisible);
+  // For the bookmarks toolbar, we will have saved state above. For other
+  // toolbars, we need to do it after setting the attribute, or we might
+  // save the wrong state.
+  if (persist && toolbar.id != "PersonalToolbar") {
+    Services.xulStore.persist(toolbar, hidingAttribute);
+  }
+
+  let eventParams = {
+    detail: {
+      visible: isVisible,
+    },
+    bubbles: true,
+  };
+  let event = new CustomEvent("toolbarvisibilitychange", eventParams);
+  toolbar.dispatchEvent(event);
+}
+
+function updateToggleControlLabel(control) {
+  if (!control.hasAttribute("label-checked")) {
+    return;
+  }
+
+  if (!control.hasAttribute("label-unchecked")) {
+    control.setAttribute("label-unchecked", control.getAttribute("label"));
+  }
+  let prefix = control.getAttribute("checked") == "true" ? "" : "un";
+  control.setAttribute("label", control.getAttribute(`label-${prefix}checked`));
+}
+
+var TabletModeUpdater = {
+  init() {
+    if (AppConstants.isPlatformAndVersionAtLeast("win", "10")) {
+      this.update(WindowsUIUtils.inTabletMode);
+      Services.obs.addObserver(this, "tablet-mode-change");
+    }
+  },
+
+  uninit() {
+    if (AppConstants.isPlatformAndVersionAtLeast("win", "10")) {
+      Services.obs.removeObserver(this, "tablet-mode-change");
+    }
+  },
+
+  observe(subject, topic, data) {
+    this.update(data == "tablet-mode");
+  },
+
+  update(isInTabletMode) {
+    let wasInTabletMode = document.documentElement.hasAttribute("tabletmode");
+    if (isInTabletMode) {
+      document.documentElement.setAttribute("tabletmode", "true");
+    } else {
+      document.documentElement.removeAttribute("tabletmode");
+    }
+    if (wasInTabletMode != isInTabletMode) {
+      gUIDensity.update();
+    }
+  },
+};
+
+var gTabletModePageCounter = {
+  enabled: false,
+  inc() {
+    this.enabled = AppConstants.isPlatformAndVersionAtLeast("win", "10.0");
+    if (!this.enabled) {
+      this.inc = () => {};
+      return;
+    }
+    this.inc = this._realInc;
+    this.inc();
+  },
+
+  _desktopCount: 0,
+  _tabletCount: 0,
+  _realInc() {
+    let inTabletMode = document.documentElement.hasAttribute("tabletmode");
+    this[inTabletMode ? "_tabletCount" : "_desktopCount"]++;
+  },
+
+  finish() {
+    if (this.enabled) {
+      let histogram = Services.telemetry.getKeyedHistogramById(
+        "FX_TABLETMODE_PAGE_LOAD"
+      );
+      histogram.add("tablet", this._tabletCount);
+      histogram.add("desktop", this._desktopCount);
+    }
+  },
+};
+
+function displaySecurityInfo() {
+  BrowserPageInfo(null, "securityTab");
+}
+
+// Updates the UI density (for touch and compact mode) based on the uidensity pref.
+var gUIDensity = {
+  MODE_NORMAL: 0,
+  MODE_COMPACT: 1,
+  MODE_TOUCH: 2,
+  uiDensityPref: "browser.uidensity",
+  autoTouchModePref: "browser.touchmode.auto",
+
+  init() {
+    this.update();
+    Services.prefs.addObserver(this.uiDensityPref, this);
+    Services.prefs.addObserver(this.autoTouchModePref, this);
+  },
+
+  uninit() {
+    Services.prefs.removeObserver(this.uiDensityPref, this);
+    Services.prefs.removeObserver(this.autoTouchModePref, this);
+  },
+
+  observe(aSubject, aTopic, aPrefName) {
+    if (
+      aTopic != "nsPref:changed" ||
+      (aPrefName != this.uiDensityPref && aPrefName != this.autoTouchModePref)
+    ) {
+      return;
+    }
+
+    this.update();
+  },
+
+  getCurrentDensity() {
+    // Automatically override the uidensity to touch in Windows tablet mode.
+    if (
+      AppConstants.isPlatformAndVersionAtLeast("win", "10") &&
+      WindowsUIUtils.inTabletMode &&
+      Services.prefs.getBoolPref(this.autoTouchModePref)
+    ) {
+      return { mode: this.MODE_TOUCH, overridden: true };
+    }
+    return {
+      mode: Services.prefs.getIntPref(this.uiDensityPref),
+      overridden: false,
+    };
+  },
+
+  update(mode) {
+    if (mode == null) {
+      mode = this.getCurrentDensity().mode;
+    }
+
+    let docs = [document.documentElement];
+    let shouldUpdateSidebar = SidebarUI.initialized && SidebarUI.isOpen;
+    if (shouldUpdateSidebar) {
+      docs.push(SidebarUI.browser.contentDocument.documentElement);
+    }
+    for (let doc of docs) {
+      switch (mode) {
+        case this.MODE_COMPACT:
+          doc.setAttribute("uidensity", "compact");
+          break;
+        case this.MODE_TOUCH:
+          doc.setAttribute("uidensity", "touch");
+          break;
+        default:
+          doc.removeAttribute("uidensity");
+          break;
+      }
+    }
+    if (shouldUpdateSidebar) {
+      let tree = SidebarUI.browser.contentDocument.querySelector(
+        ".sidebar-placesTree"
+      );
+      if (tree) {
+        // Tree items don't update their styles without changing some property on the
+        // parent tree element, like background-color or border. See bug 1407399.
+        tree.style.border = "1px";
+        tree.style.border = "";
+      }
+    }
+
+    gBrowser.tabContainer.uiDensityChanged();
+    gURLBar.updateLayoutBreakout();
+  },
+};
+
+const nodeToTooltipMap = {
+  "bookmarks-menu-button": "bookmarksMenuButton.tooltip",
+  "context-reload": "reloadButton.tooltip",
+  "context-stop": "stopButton.tooltip",
+  "downloads-button": "downloads.tooltip",
+  "fullscreen-button": "fullscreenButton.tooltip",
+  "appMenu-fullscreen-button2": "fullscreenButton.tooltip",
+  "new-window-button": "newWindowButton.tooltip",
+  "new-tab-button": "newTabButton.tooltip",
+  "tabs-newtab-button": "newTabButton.tooltip",
+  "reload-button": "reloadButton.tooltip",
+  "stop-button": "stopButton.tooltip",
+  "urlbar-zoom-button": "urlbar-zoom-button.tooltip",
+  "appMenu-zoomEnlarge-button2": "zoomEnlarge-button.tooltip",
+  "appMenu-zoomReset-button2": "zoomReset-button.tooltip",
+  "appMenu-zoomReduce-button2": "zoomReduce-button.tooltip",
+  "reader-mode-button": "reader-mode-button.tooltip",
+  "reader-mode-button-icon": "reader-mode-button.tooltip",
+};
+const nodeToShortcutMap = {
+  "bookmarks-menu-button": "manBookmarkKb",
+  "context-reload": "key_reload",
+  "context-stop": "key_stop",
+  "downloads-button": "key_openDownloads",
+  "fullscreen-button": "key_fullScreen",
+  "appMenu-fullscreen-button2": "key_fullScreen",
+  "new-window-button": "key_newNavigator",
+  "new-tab-button": "key_newNavigatorTab",
+  "tabs-newtab-button": "key_newNavigatorTab",
+  "reload-button": "key_reload",
+  "stop-button": "key_stop",
+  "urlbar-zoom-button": "key_fullZoomReset",
+  "appMenu-zoomEnlarge-button2": "key_fullZoomEnlarge",
+  "appMenu-zoomReset-button2": "key_fullZoomReset",
+  "appMenu-zoomReduce-button2": "key_fullZoomReduce",
+  "reader-mode-button": "key_toggleReaderMode",
+  "reader-mode-button-icon": "key_toggleReaderMode",
+};
+
+const gDynamicTooltipCache = new Map();
+function GetDynamicShortcutTooltipText(nodeId) {
+  if (!gDynamicTooltipCache.has(nodeId) && nodeId in nodeToTooltipMap) {
+    let strId = nodeToTooltipMap[nodeId];
+    let args = [];
+    if (nodeId in nodeToShortcutMap) {
+      let shortcutId = nodeToShortcutMap[nodeId];
+      let shortcut = document.getElementById(shortcutId);
+      if (shortcut) {
+        args.push(ShortcutUtils.prettifyShortcut(shortcut));
+      }
+    }
+    gDynamicTooltipCache.set(
+      nodeId,
+      gNavigatorBundle.getFormattedString(strId, args)
+    );
+  }
+  return gDynamicTooltipCache.get(nodeId);
+}
+
+function UpdateDynamicShortcutTooltipText(aTooltip) {
+  let nodeId =
+    aTooltip.triggerNode.id || aTooltip.triggerNode.getAttribute("anonid");
+  aTooltip.setAttribute("label", GetDynamicShortcutTooltipText(nodeId));
+}
+
+/*
+ * - [ Dependencies ] ---------------------------------------------------------
+ *  utilityOverlay.js:
+ *    - gatherTextUnder
+ */
+
+/**
+ * Extracts linkNode and href for the current click target.
+ *
+ * @param event
+ *        The click event.
+ * @return [href, linkNode].
+ *
+ * @note linkNode will be null if the click wasn't on an anchor
+ *       element (or XLink).
+ */
+function hrefAndLinkNodeForClickEvent(event) {
+  function isHTMLLink(aNode) {
+    // Be consistent with what nsContextMenu.js does.
+    return (
+      (aNode instanceof HTMLAnchorElement && aNode.href) ||
+      (aNode instanceof HTMLAreaElement && aNode.href) ||
+      aNode instanceof HTMLLinkElement
+    );
+  }
+
+  let node = event.composedTarget;
+  while (node && !isHTMLLink(node)) {
+    node = node.flattenedTreeParentNode;
+  }
+
+  if (node) {
+    return [node.href, node];
+  }
+
+  // If there is no linkNode, try simple XLink.
+  let href, baseURI;
+  node = event.composedTarget;
+  while (node && !href) {
+    if (
+      node.nodeType == Node.ELEMENT_NODE &&
+      (node.localName == "a" ||
+        node.namespaceURI == "http://www.w3.org/1998/Math/MathML")
+    ) {
+      href =
+        node.getAttribute("href") ||
+        node.getAttributeNS("http://www.w3.org/1999/xlink", "href");
+
+      if (href) {
+        baseURI = node.baseURI;
+        break;
+      }
+    }
+    node = node.flattenedTreeParentNode;
+  }
+
+  // In case of XLink, we don't return the node we got href from since
+  // callers expect <a>-like elements.
+  return [href ? makeURLAbsolute(baseURI, href) : null, null];
+}
+
+/**
+ * Called whenever the user clicks in the content area.
+ *
+ * @param event
+ *        The click event.
+ * @param isPanelClick
+ *        Whether the event comes from an extension panel.
+ * @note default event is prevented if the click is handled.
+ */
+function contentAreaClick(event, isPanelClick) {
+  if (!event.isTrusted || event.defaultPrevented || event.button != 0) {
+    return;
+  }
+
+  let [href, linkNode] = hrefAndLinkNodeForClickEvent(event);
+  if (!href) {
+    // Not a link, handle middle mouse navigation.
+    if (
+      event.button == 1 &&
+      Services.prefs.getBoolPref("middlemouse.contentLoadURL") &&
+      !Services.prefs.getBoolPref("general.autoScroll")
+    ) {
+      middleMousePaste(event);
+      event.preventDefault();
+    }
+    return;
+  }
+
+  // This code only applies if we have a linkNode (i.e. clicks on real anchor
+  // elements, as opposed to XLink).
+  if (
+    linkNode &&
+    event.button == 0 &&
+    !event.ctrlKey &&
+    !event.shiftKey &&
+    !event.altKey &&
+    !event.metaKey
+  ) {
+    // An extension panel's links should target the main content area.  Do this
+    // if no modifier keys are down and if there's no target or the target
+    // equals _main (the IE convention) or _content (the Mozilla convention).
+    let target = linkNode.target;
+    let mainTarget = !target || target == "_content" || target == "_main";
+    if (isPanelClick && mainTarget) {
+      // javascript and data links should be executed in the current browser.
+      if (
+        linkNode.getAttribute("onclick") ||
+        href.startsWith("javascript:") ||
+        href.startsWith("data:")
+      ) {
+        return;
+      }
+
+      try {
+        urlSecurityCheck(href, linkNode.ownerDocument.nodePrincipal);
+      } catch (ex) {
+        // Prevent loading unsecure destinations.
+        event.preventDefault();
+        return;
+      }
+
+      loadURI(href, null, null, false);
+      event.preventDefault();
+      return;
+    }
+  }
+
+  handleLinkClick(event, href, linkNode);
+
+  // Mark the page as a user followed link.  This is done so that history can
+  // distinguish automatic embed visits from user activated ones.  For example
+  // pages loaded in frames are embed visits and lost with the session, while
+  // visits across frames should be preserved.
+  try {
+    if (!PrivateBrowsingUtils.isWindowPrivate(window)) {
+      PlacesUIUtils.markPageAsFollowedLink(href);
+    }
+  } catch (ex) {
+    /* Skip invalid URIs. */
+  }
+}
+
+/**
+ * Handles clicks on links.
+ *
+ * @return true if the click event was handled, false otherwise.
+ */
+function handleLinkClick(event, href, linkNode) {
+  if (event.button == 2) {
+    // right click
+    return false;
+  }
+
+  var where = whereToOpenLink(event);
+  if (where == "current") {
+    return false;
+  }
+
+  var doc = event.target.ownerDocument;
+  let referrerInfo = Cc["@mozilla.org/referrer-info;1"].createInstance(
+    Ci.nsIReferrerInfo
+  );
+  if (linkNode) {
+    referrerInfo.initWithElement(linkNode);
+  } else {
+    referrerInfo.initWithDocument(doc);
+  }
+
+  if (where == "save") {
+    saveURL(
+      href,
+      linkNode ? gatherTextUnder(linkNode) : "",
+      null,
+      true,
+      true,
+      referrerInfo,
+      doc.cookieJarSettings,
+      doc
+    );
+    event.preventDefault();
+    return true;
+  }
+
+  let frameID = WebNavigationFrames.getFrameId(doc.defaultView);
+
+  urlSecurityCheck(href, doc.nodePrincipal);
+  let params = {
+    charset: doc.characterSet,
+    referrerInfo,
+    originPrincipal: doc.nodePrincipal,
+    originStoragePrincipal: doc.effectiveStoragePrincipal,
+    triggeringPrincipal: doc.nodePrincipal,
+    csp: doc.csp,
+    frameID,
+  };
+
+  // The new tab/window must use the same userContextId
+  if (doc.nodePrincipal.originAttributes.userContextId) {
+    params.userContextId = doc.nodePrincipal.originAttributes.userContextId;
+  }
+
+  openLinkIn(href, where, params);
+  event.preventDefault();
+  return true;
+}
+
+/**
+ * Handles paste on middle mouse clicks.
+ *
+ * @param event {Event | Object} Event or JSON object.
+ */
+function middleMousePaste(event) {
+  let clipboard = readFromClipboard();
+  if (!clipboard) {
+    return;
+  }
+
+  // Strip embedded newlines and surrounding whitespace, to match the URL
+  // bar's behavior (stripsurroundingwhitespace)
+  clipboard = clipboard.replace(/\s*\n\s*/g, "");
+
+  clipboard = UrlbarUtils.stripUnsafeProtocolOnPaste(clipboard);
+
+  // if it's not the current tab, we don't need to do anything because the
+  // browser doesn't exist.
+  let where = whereToOpenLink(event, true, false);
+  let lastLocationChange;
+  if (where == "current") {
+    lastLocationChange = gBrowser.selectedBrowser.lastLocationChange;
+  }
+
+  UrlbarUtils.getShortcutOrURIAndPostData(clipboard).then(data => {
+    try {
+      makeURI(data.url);
+    } catch (ex) {
+      // Not a valid URI.
+      return;
+    }
+
+    try {
+      UrlbarUtils.addToUrlbarHistory(data.url, window);
+    } catch (ex) {
+      // Things may go wrong when adding url to session history,
+      // but don't let that interfere with the loading of the url.
+      Cu.reportError(ex);
+    }
+
+    if (
+      where != "current" ||
+      lastLocationChange == gBrowser.selectedBrowser.lastLocationChange
+    ) {
+      openUILink(data.url, event, {
+        ignoreButton: true,
+        allowInheritPrincipal: data.mayInheritPrincipal,
+        triggeringPrincipal: gBrowser.selectedBrowser.contentPrincipal,
+        csp: gBrowser.selectedBrowser.csp,
+      });
+    }
+  });
+
+  if (event instanceof Event) {
+    event.stopPropagation();
+  }
+}
+
+// handleDroppedLink has the following 2 overloads:
+//   handleDroppedLink(event, url, name, triggeringPrincipal)
+//   handleDroppedLink(event, links, triggeringPrincipal)
+function handleDroppedLink(
+  event,
+  urlOrLinks,
+  nameOrTriggeringPrincipal,
+  triggeringPrincipal
+) {
+  let links;
+  if (Array.isArray(urlOrLinks)) {
+    links = urlOrLinks;
+    triggeringPrincipal = nameOrTriggeringPrincipal;
+  } else {
+    links = [{ url: urlOrLinks, nameOrTriggeringPrincipal, type: "" }];
+  }
+
+  let lastLocationChange = gBrowser.selectedBrowser.lastLocationChange;
+
+  let userContextId = gBrowser.selectedBrowser.getAttribute("usercontextid");
+
+  // event is null if links are dropped in content process.
+  // inBackground should be false, as it's loading into current browser.
+  let inBackground = false;
+  if (event) {
+    inBackground = Services.prefs.getBoolPref("browser.tabs.loadInBackground");
+    if (event.shiftKey) {
+      inBackground = !inBackground;
+    }
+  }
+
+  (async function() {
+    if (
+      links.length >=
+      Services.prefs.getIntPref("browser.tabs.maxOpenBeforeWarn")
+    ) {
+      // Sync dialog cannot be used inside drop event handler.
+      let answer = await OpenInTabsUtils.promiseConfirmOpenInTabs(
+        links.length,
+        window
+      );
+      if (!answer) {
+        return;
+      }
+    }
+
+    let urls = [];
+    let postDatas = [];
+    for (let link of links) {
+      let data = await UrlbarUtils.getShortcutOrURIAndPostData(link.url);
+      urls.push(data.url);
+      postDatas.push(data.postData);
+    }
+    if (lastLocationChange == gBrowser.selectedBrowser.lastLocationChange) {
+      gBrowser.loadTabs(urls, {
+        inBackground,
+        replace: true,
+        allowThirdPartyFixup: false,
+        postDatas,
+        userContextId,
+        triggeringPrincipal,
+      });
+    }
+  })();
+
+  // If links are dropped in content process, event.preventDefault() should be
+  // called in content process.
+  if (event) {
+    // Keep the event from being handled by the dragDrop listeners
+    // built-in to gecko if they happen to be above us.
+    event.preventDefault();
+  }
+}
+
+function BrowserForceEncodingDetection() {
+  gBrowser.selectedBrowser.forceEncodingDetection();
+  BrowserReloadWithFlags(Ci.nsIWebNavigation.LOAD_FLAGS_CHARSET_CHANGE);
+}
+
+var ToolbarContextMenu = {
+  updateDownloadsAutoHide(popup) {
+    let checkbox = document.getElementById(
+      "toolbar-context-autohide-downloads-button"
+    );
+    let isDownloads =
+      popup.triggerNode &&
+      ["downloads-button", "wrapper-downloads-button"].includes(
+        popup.triggerNode.id
+      );
+    checkbox.hidden = !isDownloads;
+    if (DownloadsButton.autoHideDownloadsButton) {
+      checkbox.setAttribute("checked", "true");
+    } else {
+      checkbox.removeAttribute("checked");
+    }
+  },
+
+  onDownloadsAutoHideChange(event) {
+    let autoHide = event.target.getAttribute("checked") == "true";
+    Services.prefs.setBoolPref("browser.download.autohideButton", autoHide);
+  },
+
+  _getUnwrappedTriggerNode(popup) {
+    // Toolbar buttons are wrapped in customize mode. Unwrap if necessary.
+    let { triggerNode } = popup;
+    if (triggerNode && gCustomizeMode.isWrappedToolbarItem(triggerNode)) {
+      return triggerNode.firstElementChild;
+    }
+    return triggerNode;
+  },
+
+  _getExtensionId(popup) {
+    let node = this._getUnwrappedTriggerNode(popup);
+    return node && node.getAttribute("data-extensionid");
+  },
+
+  async updateExtension(popup) {
+    let removeExtension = popup.querySelector(
+      ".customize-context-removeExtension"
+    );
+    let manageExtension = popup.querySelector(
+      ".customize-context-manageExtension"
+    );
+    let reportExtension = popup.querySelector(
+      ".customize-context-reportExtension"
+    );
+    let separator = reportExtension.nextElementSibling;
+    let id = this._getExtensionId(popup);
+    let addon = id && (await AddonManager.getAddonByID(id));
+
+    for (let element of [removeExtension, manageExtension, separator]) {
+      element.hidden = !addon;
+    }
+
+    reportExtension.hidden = !addon || !gAddonAbuseReportEnabled;
+
+    if (addon) {
+      removeExtension.disabled = !(
+        addon.permissions & AddonManager.PERM_CAN_UNINSTALL
+      );
+    }
+  },
+
+  async removeExtensionForContextAction(popup) {
+    let id = this._getExtensionId(popup);
+
+    await BrowserAddonUI.removeAddon(id, "browserAction");
+  },
+
+  async reportExtensionForContextAction(popup, reportEntryPoint) {
+    let id = this._getExtensionId(popup);
+    let addon = id && (await AddonManager.getAddonByID(id));
+    if (!addon) {
+      return;
+    }
+
+    await BrowserAddonUI.reportAddon(addon.id, reportEntryPoint);
+  },
+
+  openAboutAddonsForContextAction(popup) {
+    let id = this._getExtensionId(popup);
+    if (id) {
+      let viewID = "addons://detail/" + encodeURIComponent(id);
+      BrowserOpenAddonsMgr(viewID);
+      AMTelemetry.recordActionEvent({
+        object: "browserAction",
+        action: "manage",
+        extra: { addonId: id },
+      });
+    }
+  },
+};
+
+var gPageStyleMenu = {
+  // This maps from a <browser> element (or, more specifically, a
+  // browser's permanentKey) to an Object that contains the most recent
+  // information about the browser content's stylesheets. That Object
+  // is populated via the PageStyle:StyleSheets message from the content
+  // process. The Object should have the following structure:
+  //
+  // filteredStyleSheets (Array):
+  //   An Array of objects with a filtered list representing all stylesheets
+  //   that the current page offers. Each object has the following members:
+  //
+  //   title (String):
+  //     The title of the stylesheet
+  //
+  //   disabled (bool):
+  //     Whether or not the stylesheet is currently applied
+  //
+  //   href (String):
+  //     The URL of the stylesheet. Stylesheets loaded via a data URL will
+  //     have this property set to null.
+  //
+  // authorStyleDisabled (bool):
+  //   Whether or not the user currently has "No Style" selected for
+  //   the current page.
+  //
+  // preferredStyleSheetSet (bool):
+  //   Whether or not the user currently has the "Default" style selected
+  //   for the current page.
+  //
+  _pageStyleSheets: new WeakMap(),
+
+  /**
+   * Add/append styleSheets to the _pageStyleSheets weakmap.
+   * @param styleSheets
+   *        The stylesheets to add, including the preferred
+   *        stylesheet set for this document.
+   * @param permanentKey
+   *        The permanent key of the browser that
+   *        these stylesheets come from.
+   */
+  addBrowserStyleSheets(styleSheets, permanentKey) {
+    let sheetData = this._pageStyleSheets.get(permanentKey);
+    if (!sheetData) {
+      this._pageStyleSheets.set(permanentKey, styleSheets);
+      return;
+    }
+    sheetData.filteredStyleSheets.push(...styleSheets.filteredStyleSheets);
+    sheetData.preferredStyleSheetSet =
+      sheetData.preferredStyleSheetSet || styleSheets.preferredStyleSheetSet;
+  },
+
+  clearBrowserStyleSheets(permanentKey) {
+    this._pageStyleSheets.delete(permanentKey);
+  },
+
+  _getStyleSheetInfo(browser) {
+    let data = this._pageStyleSheets.get(browser.permanentKey);
+    if (!data) {
+      return {
+        filteredStyleSheets: [],
+        authorStyleDisabled: false,
+        preferredStyleSheetSet: true,
+      };
+    }
+
+    return data;
+  },
+
+  fillPopup(menuPopup) {
+    let styleSheetInfo = this._getStyleSheetInfo(gBrowser.selectedBrowser);
+    var noStyle = menuPopup.firstElementChild;
+    var persistentOnly = noStyle.nextElementSibling;
+    var sep = persistentOnly.nextElementSibling;
+    while (sep.nextElementSibling) {
+      menuPopup.removeChild(sep.nextElementSibling);
+    }
+
+    let styleSheets = styleSheetInfo.filteredStyleSheets;
+    var currentStyleSheets = {};
+    var styleDisabled = styleSheetInfo.authorStyleDisabled;
+    var haveAltSheets = false;
+    var altStyleSelected = false;
+
+    for (let currentStyleSheet of styleSheets) {
+      if (!currentStyleSheet.disabled) {
+        altStyleSelected = true;
+      }
+
+      haveAltSheets = true;
+
+      let lastWithSameTitle = null;
+      if (currentStyleSheet.title in currentStyleSheets) {
+        lastWithSameTitle = currentStyleSheets[currentStyleSheet.title];
+      }
+
+      if (!lastWithSameTitle) {
+        let menuItem = document.createXULElement("menuitem");
+        menuItem.setAttribute("type", "radio");
+        menuItem.setAttribute("label", currentStyleSheet.title);
+        menuItem.setAttribute("data", currentStyleSheet.title);
+        menuItem.setAttribute(
+          "checked",
+          !currentStyleSheet.disabled && !styleDisabled
+        );
+        menuItem.setAttribute(
+          "oncommand",
+          "gPageStyleMenu.switchStyleSheet(this.getAttribute('data'));"
+        );
+        menuPopup.appendChild(menuItem);
+        currentStyleSheets[currentStyleSheet.title] = menuItem;
+      } else if (currentStyleSheet.disabled) {
+        lastWithSameTitle.removeAttribute("checked");
+      }
+    }
+
+    noStyle.setAttribute("checked", styleDisabled);
+    persistentOnly.setAttribute("checked", !altStyleSelected && !styleDisabled);
+    persistentOnly.hidden = styleSheetInfo.preferredStyleSheetSet
+      ? haveAltSheets
+      : false;
+    sep.hidden = (noStyle.hidden && persistentOnly.hidden) || !haveAltSheets;
+  },
+
+  /**
+   * Send a message to all PageStyleParents by walking the BrowsingContext tree.
+   * @param message
+   *        The string message to send to each PageStyleChild.
+   * @param data
+   *        The data to send to each PageStyleChild within the message.
+   */
+  _sendMessageToAll(message, data) {
+    let contextsToVisit = [gBrowser.selectedBrowser.browsingContext];
+    while (contextsToVisit.length) {
+      let currentContext = contextsToVisit.pop();
+      let global = currentContext.currentWindowGlobal;
+
+      if (!global) {
+        continue;
+      }
+
+      let actor = global.getActor("PageStyle");
+      actor.sendAsyncMessage(message, data);
+
+      contextsToVisit.push(...currentContext.children);
+    }
+  },
+
+  /**
+   * Switch the stylesheet of all documents in the current browser.
+   * @param title The title of the stylesheet to switch to.
+   */
+  switchStyleSheet(title) {
+    let { permanentKey } = gBrowser.selectedBrowser;
+    let sheetData = this._pageStyleSheets.get(permanentKey);
+    if (sheetData && sheetData.filteredStyleSheets) {
+      sheetData.authorStyleDisabled = false;
+      for (let sheet of sheetData.filteredStyleSheets) {
+        sheet.disabled = sheet.title !== title;
+      }
+    }
+    this._sendMessageToAll("PageStyle:Switch", { title });
+  },
+
+  /**
+   * Disable all stylesheets. Called with View > Page Style > No Style.
+   */
+  disableStyle() {
+    let { permanentKey } = gBrowser.selectedBrowser;
+    let sheetData = this._pageStyleSheets.get(permanentKey);
+    if (sheetData) {
+      sheetData.authorStyleDisabled = true;
+    }
+    this._sendMessageToAll("PageStyle:Disable", {});
+  },
+};
+
+// Note that this is also called from non-browser windows on OSX, which do
+// share menu items but not much else. See nonbrowser-mac.js.
+var BrowserOffline = {
+  _inited: false,
+
+  // BrowserOffline Public Methods
+  init() {
+    if (!this._uiElement) {
+      this._uiElement = document.getElementById("cmd_toggleOfflineStatus");
+    }
+
+    Services.obs.addObserver(this, "network:offline-status-changed");
+
+    this._updateOfflineUI(Services.io.offline);
+
+    this._inited = true;
+  },
+
+  uninit() {
+    if (this._inited) {
+      Services.obs.removeObserver(this, "network:offline-status-changed");
+    }
+  },
+
+  toggleOfflineStatus() {
+    var ioService = Services.io;
+
+    if (!ioService.offline && !this._canGoOffline()) {
+      this._updateOfflineUI(false);
+      return;
+    }
+
+    ioService.offline = !ioService.offline;
+  },
+
+  // nsIObserver
+  observe(aSubject, aTopic, aState) {
+    if (aTopic != "network:offline-status-changed") {
+      return;
+    }
+
+    // This notification is also received because of a loss in connectivity,
+    // which we ignore by updating the UI to the current value of io.offline
+    this._updateOfflineUI(Services.io.offline);
+  },
+
+  // BrowserOffline Implementation Methods
+  _canGoOffline() {
+    try {
+      var cancelGoOffline = Cc["@mozilla.org/supports-PRBool;1"].createInstance(
+        Ci.nsISupportsPRBool
+      );
+      Services.obs.notifyObservers(cancelGoOffline, "offline-requested");
+
+      // Something aborted the quit process.
+      if (cancelGoOffline.data) {
+        return false;
+      }
+    } catch (ex) {}
+
+    return true;
+  },
+
+  _uiElement: null,
+  _updateOfflineUI(aOffline) {
+    var offlineLocked = Services.prefs.prefIsLocked("network.online");
+    if (offlineLocked) {
+      this._uiElement.setAttribute("disabled", "true");
+    }
+
+    this._uiElement.setAttribute("checked", aOffline);
+  },
+};
+
+var IndexedDBPromptHelper = {
+  _permissionsPrompt: "indexedDB-permissions-prompt",
+  _permissionsResponse: "indexedDB-permissions-response",
+
+  _notificationIcon: "indexedDB-notification-icon",
+
+  init: function IndexedDBPromptHelper_init() {
+    Services.obs.addObserver(this, this._permissionsPrompt);
+  },
+
+  uninit: function IndexedDBPromptHelper_uninit() {
+    Services.obs.removeObserver(this, this._permissionsPrompt);
+  },
+
+  observe: function IndexedDBPromptHelper_observe(subject, topic, data) {
+    if (topic != this._permissionsPrompt) {
+      throw new Error("Unexpected topic!");
+    }
+
+    var request = subject.QueryInterface(Ci.nsIIDBPermissionsRequest);
+
+    var browser = request.browserElement;
+    if (browser.ownerGlobal != window) {
+      // Only listen for notifications for browsers in our chrome window.
+      return;
+    }
+
+    // Get the host name if available or the file path otherwise.
+    var host = browser.currentURI.asciiHost || browser.currentURI.pathQueryRef;
+
+    var message;
+    var responseTopic;
+    if (topic == this._permissionsPrompt) {
+      message = gNavigatorBundle.getFormattedString("offlineApps.available3", [
+        host,
+      ]);
+      responseTopic = this._permissionsResponse;
+    }
+
+    var observer = request.responseObserver;
+
+    var mainAction = {
+      label: gNavigatorBundle.getString("offlineApps.allow.label"),
+      accessKey: gNavigatorBundle.getString("offlineApps.allow.accesskey"),
+      callback() {
+        observer.observe(
+          null,
+          responseTopic,
+          Ci.nsIPermissionManager.ALLOW_ACTION
+        );
+      },
+    };
+
+    var secondaryActions = [
+      {
+        label: gNavigatorBundle.getString("offlineApps.block.label"),
+        accessKey: gNavigatorBundle.getString("offlineApps.block.accesskey"),
+        callback() {
+          observer.observe(
+            null,
+            responseTopic,
+            Ci.nsIPermissionManager.DENY_ACTION
+          );
+        },
+      },
+    ];
+
+    PopupNotifications.show(
+      browser,
+      topic,
+      message,
+      this._notificationIcon,
+      mainAction,
+      secondaryActions,
+      {
+        persistent: true,
+        hideClose: true,
+      }
+    );
+  },
+};
+
+var CanvasPermissionPromptHelper = {
+  _permissionsPrompt: "canvas-permissions-prompt",
+  _permissionsPromptHideDoorHanger: "canvas-permissions-prompt-hide-doorhanger",
+  _notificationIcon: "canvas-notification-icon",
+
+  init() {
+    Services.obs.addObserver(this, this._permissionsPrompt);
+    Services.obs.addObserver(this, this._permissionsPromptHideDoorHanger);
+  },
+
+  uninit() {
+    Services.obs.removeObserver(this, this._permissionsPrompt);
+    Services.obs.removeObserver(this, this._permissionsPromptHideDoorHanger);
+  },
+
+  // aSubject is an nsIBrowser (e10s) or an nsIDOMWindow (non-e10s).
+  // aData is an Origin string.
+  observe(aSubject, aTopic, aData) {
+    if (
+      aTopic != this._permissionsPrompt &&
+      aTopic != this._permissionsPromptHideDoorHanger
+    ) {
+      return;
+    }
+
+    let browser;
+    if (aSubject instanceof Ci.nsIDOMWindow) {
+      browser = aSubject.docShell.chromeEventHandler;
+    } else {
+      browser = aSubject;
+    }
+
+    if (gBrowser.selectedBrowser !== browser) {
+      // Must belong to some other window.
+      return;
+    }
+
+    let message = gNavigatorBundle.getFormattedString(
+      "canvas.siteprompt2",
+      ["<>"],
+      1
+    );
+
+    let principal = Services.scriptSecurityManager.createContentPrincipalFromOrigin(
+      aData
+    );
+
+    function setCanvasPermission(aPerm, aPersistent) {
+      Services.perms.addFromPrincipal(
+        principal,
+        "canvas",
+        aPerm,
+        aPersistent
+          ? Ci.nsIPermissionManager.EXPIRE_NEVER
+          : Ci.nsIPermissionManager.EXPIRE_SESSION
+      );
+    }
+
+    let mainAction = {
+      label: gNavigatorBundle.getString("canvas.allow2"),
+      accessKey: gNavigatorBundle.getString("canvas.allow2.accesskey"),
+      callback(state) {
+        setCanvasPermission(
+          Ci.nsIPermissionManager.ALLOW_ACTION,
+          state && state.checkboxChecked
+        );
+      },
+    };
+
+    let secondaryActions = [
+      {
+        label: gNavigatorBundle.getString("canvas.block"),
+        accessKey: gNavigatorBundle.getString("canvas.block.accesskey"),
+        callback(state) {
+          setCanvasPermission(
+            Ci.nsIPermissionManager.DENY_ACTION,
+            state && state.checkboxChecked
+          );
+        },
+      },
+    ];
+
+    let checkbox = {
+      // In PB mode, we don't want the "always remember" checkbox
+      show: !PrivateBrowsingUtils.isWindowPrivate(window),
+    };
+    if (checkbox.show) {
+      checkbox.checked = true;
+      checkbox.label = gBrowserBundle.GetStringFromName("canvas.remember2");
+    }
+
+    let options = {
+      checkbox,
+      name: principal.host,
+      learnMoreURL:
+        Services.urlFormatter.formatURLPref("app.support.baseURL") +
+        "fingerprint-permission",
+      dismissed: aTopic == this._permissionsPromptHideDoorHanger,
+      eventCallback(e) {
+        if (e == "showing") {
+          this.browser.ownerDocument.getElementById(
+            "canvas-permissions-prompt-warning"
+          ).textContent = gBrowserBundle.GetStringFromName(
+            "canvas.siteprompt2.warning"
+          );
+        }
+      },
+    };
+    PopupNotifications.show(
+      browser,
+      this._permissionsPrompt,
+      message,
+      this._notificationIcon,
+      mainAction,
+      secondaryActions,
+      options
+    );
+  },
+};
+
+var WebAuthnPromptHelper = {
+  _icon: "webauthn-notification-icon",
+  _topic: "webauthn-prompt",
+
+  // The current notification, if any. The U2F manager is a singleton, we will
+  // never allow more than one active request. And thus we'll never have more
+  // than one notification either.
+  _current: null,
+
+  // The current transaction ID. Will be checked when we're notified of the
+  // cancellation of an ongoing WebAuthhn request.
+  _tid: 0,
+
+  init() {
+    Services.obs.addObserver(this, this._topic);
+  },
+
+  uninit() {
+    Services.obs.removeObserver(this, this._topic);
+  },
+
+  observe(aSubject, aTopic, aData) {
+    let mgr = aSubject.QueryInterface(Ci.nsIU2FTokenManager);
+    let data = JSON.parse(aData);
+
+    // If we receive a cancel, it might be a WebAuthn prompt starting in another
+    // window, and the other window's browsing context will send out the
+    // cancellations, so any cancel action we get should prompt us to cancel.
+    if (data.action == "cancel") {
+      this.cancel(data);
+    }
+
+    if (
+      data.browsingContextId !== gBrowser.selectedBrowser.browsingContext.id
+    ) {
+      // Must belong to some other window.
+      return;
+    }
+
+    if (data.action == "register") {
+      this.register(mgr, data);
+    } else if (data.action == "register-direct") {
+      this.registerDirect(mgr, data);
+    } else if (data.action == "sign") {
+      this.sign(mgr, data);
+    }
+  },
+
+  register(mgr, { origin, tid }) {
+    let mainAction = this.buildCancelAction(mgr, tid);
+    this.show(tid, "register", "webauthn.registerPrompt2", origin, mainAction);
+  },
+
+  registerDirect(mgr, { origin, tid }) {
+    let mainAction = this.buildProceedAction(mgr, tid);
+    let secondaryActions = [this.buildCancelAction(mgr, tid)];
+
+    let learnMoreURL =
+      Services.urlFormatter.formatURLPref("app.support.baseURL") +
+      "webauthn-direct-attestation";
+
+    let options = {
+      learnMoreURL,
+      checkbox: {
+        label: gNavigatorBundle.getString("webauthn.anonymize"),
+      },
+      hintText: "webauthn.registerDirectPromptHint",
+    };
+    this.show(
+      tid,
+      "register-direct",
+      "webauthn.registerDirectPrompt3",
+      origin,
+      mainAction,
+      secondaryActions,
+      options
+    );
+  },
+
+  sign(mgr, { origin, tid }) {
+    let mainAction = this.buildCancelAction(mgr, tid);
+    this.show(tid, "sign", "webauthn.signPrompt2", origin, mainAction);
+  },
+
+  show(
+    tid,
+    id,
+    stringId,
+    origin,
+    mainAction,
+    secondaryActions = [],
+    options = {}
+  ) {
+    this.reset();
+
+    try {
+      origin = Services.io.newURI(origin).asciiHost;
+    } catch (e) {
+      /* Might fail for arbitrary U2F RP IDs. */
+    }
+
+    let brandShortName = document
+      .getElementById("bundle_brand")
+      .getString("brandShortName");
+    let message = gNavigatorBundle.getFormattedString(stringId, [
+      "<>",
+      brandShortName,
+    ]);
+    if (options.hintText) {
+      options.hintText = gNavigatorBundle.getFormattedString(options.hintText, [
+        brandShortName,
+      ]);
+    }
+
+    options.name = origin;
+    options.hideClose = true;
+    options.persistent = true;
+    options.eventCallback = event => {
+      if (event == "removed") {
+        this._current = null;
+        this._tid = 0;
+      }
+    };
+
+    this._tid = tid;
+    this._current = PopupNotifications.show(
+      gBrowser.selectedBrowser,
+      `webauthn-prompt-${id}`,
+      message,
+      this._icon,
+      mainAction,
+      secondaryActions,
+      options
+    );
+  },
+
+  cancel({ tid }) {
+    if (this._tid == tid) {
+      this.reset();
+    }
+  },
+
+  reset() {
+    if (this._current) {
+      this._current.remove();
+    }
+  },
+
+  buildProceedAction(mgr, tid) {
+    return {
+      label: gNavigatorBundle.getString("webauthn.proceed"),
+      accessKey: gNavigatorBundle.getString("webauthn.proceed.accesskey"),
+      callback(state) {
+        mgr.resumeRegister(tid, state.checkboxChecked);
+      },
+    };
+  },
+
+  buildCancelAction(mgr, tid) {
+    return {
+      label: gNavigatorBundle.getString("webauthn.cancel"),
+      accessKey: gNavigatorBundle.getString("webauthn.cancel.accesskey"),
+      callback() {
+        mgr.cancel(tid);
+      },
+    };
+  },
+};
+
+function CanCloseWindow() {
+  // Avoid redundant calls to canClose from showing multiple
+  // PermitUnload dialogs.
+  if (Services.startup.shuttingDown || window.skipNextCanClose) {
+    return true;
+  }
+
+  for (let browser of gBrowser.browsers) {
+    // Don't instantiate lazy browsers.
+    if (!browser.isConnected) {
+      continue;
+    }
+
+    let { permitUnload } = browser.permitUnload();
+    if (!permitUnload) {
+      return false;
+    }
+  }
+  return true;
+}
+
+function WindowIsClosing(event) {
+  let source;
+  if (event) {
+    let target = event.sourceEvent?.target;
+    if (target?.id?.startsWith("menu_")) {
+      source = "menuitem";
+    } else if (target?.nodeName == "toolbarbutton") {
+      source = "close-button";
+    } else {
+      let key = AppConstants.platform == "macosx" ? "metaKey" : "ctrlKey";
+      source = event[key] ? "shortcut" : "OS";
+    }
+  }
+  if (!closeWindow(false, warnAboutClosingWindow, source)) {
+    return false;
+  }
+
+  // In theory we should exit here and the Window's internal Close
+  // method should trigger canClose on nsBrowserAccess. However, by
+  // that point it's too late to be able to show a prompt for
+  // PermitUnload. So we do it here, when we still can.
+  if (CanCloseWindow()) {
+    // This flag ensures that the later canClose call does nothing.
+    // It's only needed to make tests pass, since they detect the
+    // prompt even when it's not actually shown.
+    window.skipNextCanClose = true;
+    return true;
+  }
+
+  return false;
+}
+
+/**
+ * Checks if this is the last full *browser* window around. If it is, this will
+ * be communicated like quitting. Otherwise, we warn about closing multiple tabs.
+ *
+ * @param source where the request to close came from (used for telemetry)
+ * @returns true if closing can proceed, false if it got cancelled.
+ */
+function warnAboutClosingWindow(source) {
+  // Popups aren't considered full browser windows; we also ignore private windows.
+  let isPBWindow =
+    PrivateBrowsingUtils.isWindowPrivate(window) &&
+    !PrivateBrowsingUtils.permanentPrivateBrowsing;
+
+  let closingTabs = gBrowser.tabs.length - gBrowser._removingTabs.length;
+
+  if (!isPBWindow && !toolbar.visible) {
+    return gBrowser.warnAboutClosingTabs(
+      closingTabs,
+      gBrowser.closingTabsEnum.ALL,
+      source
+    );
+  }
+
+  // Figure out if there's at least one other browser window around.
+  let otherPBWindowExists = false;
+  let otherWindowExists = false;
+  for (let win of browserWindows()) {
+    if (!win.closed && win != window) {
+      otherWindowExists = true;
+      if (isPBWindow && PrivateBrowsingUtils.isWindowPrivate(win)) {
+        otherPBWindowExists = true;
+      }
+      // If the current window is not in private browsing mode we don't need to
+      // look for other pb windows, we can leave the loop when finding the
+      // first non-popup window. If however the current window is in private
+      // browsing mode then we need at least one other pb and one non-popup
+      // window to break out early.
+      if (!isPBWindow || otherPBWindowExists) {
+        break;
+      }
+    }
+  }
+
+  if (isPBWindow && !otherPBWindowExists) {
+    let exitingCanceled = Cc["@mozilla.org/supports-PRBool;1"].createInstance(
+      Ci.nsISupportsPRBool
+    );
+    exitingCanceled.data = false;
+    Services.obs.notifyObservers(exitingCanceled, "last-pb-context-exiting");
+    if (exitingCanceled.data) {
+      return false;
+    }
+  }
+
+  if (otherWindowExists) {
+    return (
+      isPBWindow ||
+      gBrowser.warnAboutClosingTabs(
+        closingTabs,
+        gBrowser.closingTabsEnum.ALL,
+        source
+      )
+    );
+  }
+
+  let os = Services.obs;
+
+  let closingCanceled = Cc["@mozilla.org/supports-PRBool;1"].createInstance(
+    Ci.nsISupportsPRBool
+  );
+  os.notifyObservers(closingCanceled, "browser-lastwindow-close-requested");
+  if (closingCanceled.data) {
+    return false;
+  }
+
+  os.notifyObservers(null, "browser-lastwindow-close-granted");
+
+  // OS X doesn't quit the application when the last window is closed, but keeps
+  // the session alive. Hence don't prompt users to save tabs, but warn about
+  // closing multiple tabs.
+  return (
+    AppConstants.platform != "macosx" ||
+    isPBWindow ||
+    gBrowser.warnAboutClosingTabs(
+      closingTabs,
+      gBrowser.closingTabsEnum.ALL,
+      source
+    )
+  );
+}
+
+var MailIntegration = {
+  sendLinkForBrowser(aBrowser) {
+    this.sendMessage(
+      gURLBar.makeURIReadable(aBrowser.currentURI).displaySpec,
+      aBrowser.contentTitle
+    );
+  },
+
+  sendMessage(aBody, aSubject) {
+    // generate a mailto url based on the url and the url's title
+    var mailtoUrl = "mailto:";
+    if (aBody) {
+      mailtoUrl += "?body=" + encodeURIComponent(aBody);
+      mailtoUrl += "&subject=" + encodeURIComponent(aSubject);
+    }
+
+    var uri = makeURI(mailtoUrl);
+
+    // now pass this uri to the operating system
+    this._launchExternalUrl(uri);
+  },
+
+  // a generic method which can be used to pass arbitrary urls to the operating
+  // system.
+  // aURL --> a nsIURI which represents the url to launch
+  _launchExternalUrl(aURL) {
+    var extProtocolSvc = Cc[
+      "@mozilla.org/uriloader/external-protocol-service;1"
+    ].getService(Ci.nsIExternalProtocolService);
+    if (extProtocolSvc) {
+      extProtocolSvc.loadURI(
+        aURL,
+        Services.scriptSecurityManager.getSystemPrincipal()
+      );
+    }
+  },
+};
+
+function BrowserOpenAddonsMgr(aView) {
+  return new Promise(resolve => {
+    let emWindow;
+    let browserWindow;
+
+    var receivePong = function(aSubject, aTopic, aData) {
+      let browserWin = aSubject.browsingContext.topChromeWindow;
+      if (!emWindow || browserWin == window /* favor the current window */) {
+        emWindow = aSubject;
+        browserWindow = browserWin;
+      }
+    };
+    Services.obs.addObserver(receivePong, "EM-pong");
+    Services.obs.notifyObservers(null, "EM-ping");
+    Services.obs.removeObserver(receivePong, "EM-pong");
+
+    if (emWindow) {
+      if (aView) {
+        emWindow.loadView(aView);
+      }
+      let tab = browserWindow.gBrowser.getTabForBrowser(
+        emWindow.docShell.chromeEventHandler
+      );
+      browserWindow.gBrowser.selectedTab = tab;
+      emWindow.focus();
+      resolve(emWindow);
+      return;
+    }
+
+    // This must be a new load, else the ping/pong would have
+    // found the window above.
+    switchToTabHavingURI("about:addons", true);
+
+    Services.obs.addObserver(function observer(aSubject, aTopic, aData) {
+      Services.obs.removeObserver(observer, aTopic);
+      if (aView) {
+        aSubject.loadView(aView);
+      }
+      aSubject.focus();
+      resolve(aSubject);
+    }, "EM-loaded");
+  });
+}
+
+function AddKeywordForSearchField() {
+  if (!gContextMenu) {
+    throw new Error("Context menu doesn't seem to be open.");
+  }
+
+  gContextMenu.addKeywordForSearchField();
+}
+
+/**
+ * Re-open a closed tab.
+ * @param aIndex
+ *        The index of the tab (via SessionStore.getClosedTabData)
+ * @returns a reference to the reopened tab.
+ */
+function undoCloseTab(aIndex) {
+  // wallpaper patch to prevent an unnecessary blank tab (bug 343895)
+  let blankTabToRemove = null;
+  if (gBrowser.tabs.length == 1 && gBrowser.selectedTab.isEmpty) {
+    blankTabToRemove = gBrowser.selectedTab;
+  }
+
+  let tab = null;
+  // aIndex is undefined if the function is called without a specific tab to restore.
+  let tabsToRemove =
+    aIndex !== undefined
+      ? [aIndex]
+      : new Array(SessionStore.getLastClosedTabCount(window)).fill(0);
+  for (let index of tabsToRemove) {
+    if (SessionStore.getClosedTabCount(window) > index) {
+      tab = SessionStore.undoCloseTab(window, index);
+
+      if (blankTabToRemove) {
+        gBrowser.removeTab(blankTabToRemove);
+      }
+    }
+  }
+
+  return tab;
+}
+
+/**
+ * Re-open a closed window.
+ * @param aIndex
+ *        The index of the window (via SessionStore.getClosedWindowData)
+ * @returns a reference to the reopened window.
+ */
+function undoCloseWindow(aIndex) {
+  let window = null;
+  if (SessionStore.getClosedWindowCount() > (aIndex || 0)) {
+    window = SessionStore.undoCloseWindow(aIndex || 0);
+  }
+
+  return window;
+}
+
+function ReportFalseDeceptiveSite() {
+  let contextsToVisit = [gBrowser.selectedBrowser.browsingContext];
+  while (contextsToVisit.length) {
+    let currentContext = contextsToVisit.pop();
+    let global = currentContext.currentWindowGlobal;
+
+    if (!global) {
+      continue;
+    }
+    let docURI = global.documentURI;
+    // Ensure the page is an about:blocked pagae before handling.
+    if (docURI && docURI.spec.startsWith("about:blocked?e=deceptiveBlocked")) {
+      let actor = global.getActor("BlockedSite");
+      actor.sendQuery("DeceptiveBlockedDetails").then(data => {
+        let reportUrl = gSafeBrowsing.getReportURL(
+          "PhishMistake",
+          data.blockedInfo
+        );
+        if (reportUrl) {
+          openTrustedLinkIn(reportUrl, "tab");
+        } else {
+          let bundle = Services.strings.createBundle(
+            "chrome://browser/locale/safebrowsing/safebrowsing.properties"
+          );
+          Services.prompt.alert(
+            window,
+            bundle.GetStringFromName("errorReportFalseDeceptiveTitle"),
+            bundle.formatStringFromName("errorReportFalseDeceptiveMessage", [
+              data.blockedInfo.provider,
+            ])
+          );
+        }
+      });
+    }
+
+    contextsToVisit.push(...currentContext.children);
+  }
+}
+
+/**
+ * This is a temporary hack to connect a Help menu item for reporting
+ * site issues to the WebCompat team's Site Compatability Reporter
+ * WebExtension, which ships by default and is enabled on pre-release
+ * channels.
+ *
+ * Once we determine if Help is the right place for it, we'll do something
+ * slightly better than this.
+ *
+ * See bug 1690573.
+ */
+function ReportSiteIssue() {
+  let subject = { wrappedJSObject: gBrowser.selectedTab };
+  Services.obs.notifyObservers(subject, "report-site-issue");
+}
+
+/**
+ * Format a URL
+ * eg:
+ * echo formatURL("https://addons.mozilla.org/%LOCALE%/%APP%/%VERSION%/");
+ * > https://addons.mozilla.org/en-US/firefox/3.0a1/
+ *
+ * Currently supported built-ins are LOCALE, APP, and any value from nsIXULAppInfo, uppercased.
+ */
+function formatURL(aFormat, aIsPref) {
+  return aIsPref
+    ? Services.urlFormatter.formatURLPref(aFormat)
+    : Services.urlFormatter.formatURL(aFormat);
+}
+
+/**
+ * When the browser is being controlled from out-of-process,
+ * e.g. when Marionette or the remote debugging protocol is used,
+ * we add a visual hint to the browser UI to indicate to the user
+ * that the browser session is under remote control.
+ *
+ * This is called when the content browser initialises (from gBrowserInit.onLoad())
+ * and when the "remote-listening" system notification fires.
+ */
+const gRemoteControl = {
+  observe(subject, topic, data) {
+    gRemoteControl.updateVisualCue();
+  },
+
+  updateVisualCue() {
+    const mainWindow = document.documentElement;
+    const remoteControlComponent = this.getRemoteControlComponent();
+    if (remoteControlComponent) {
+      mainWindow.setAttribute("remotecontrol", "true");
+      const remoteControlIcon = document.getElementById("remote-control-icon");
+      document.l10n.setAttributes(
+        remoteControlIcon,
+        "urlbar-remote-control-notification-anchor2",
+        { component: remoteControlComponent }
+      );
+    } else {
+      mainWindow.removeAttribute("remotecontrol");
+    }
+  },
+
+  getRemoteControlComponent() {
+    if (DevToolsSocketStatus.opened) {
+      return "DevTools";
+    }
+
+    if (Marionette.running) {
+      return "Marionette";
+    }
+
+    if (RemoteAgent.running) {
+      return "RemoteAgent";
+    }
+
+    return null;
+  },
+};
+
+const gAccessibilityServiceIndicator = {
+  init() {
+    // Pref to enable accessibility service indicator.
+    Services.prefs.addObserver("accessibility.indicator.enabled", this);
+    // Accessibility service init/shutdown event.
+    Services.obs.addObserver(this, "a11y-init-or-shutdown");
+    this._update(Services.appinfo.accessibilityEnabled);
+  },
+
+  _update(accessibilityEnabled = false) {
+    if (this.enabled && accessibilityEnabled) {
+      this._active = true;
+      document.documentElement.setAttribute("accessibilitymode", "true");
+      [
+        ...document.querySelectorAll(".accessibility-indicator"),
+      ].forEach(indicator =>
+        ["click", "keypress"].forEach(type =>
+          indicator.addEventListener(type, this)
+        )
+      );
+    } else if (this._active) {
+      this._active = false;
+      document.documentElement.removeAttribute("accessibilitymode");
+      [
+        ...document.querySelectorAll(".accessibility-indicator"),
+      ].forEach(indicator =>
+        ["click", "keypress"].forEach(type =>
+          indicator.removeEventListener(type, this)
+        )
+      );
+    }
+  },
+
+  observe(subject, topic, data) {
+    if (
+      topic == "nsPref:changed" &&
+      data === "accessibility.indicator.enabled"
+    ) {
+      this._update(Services.appinfo.accessibilityEnabled);
+    } else if (topic === "a11y-init-or-shutdown") {
+      // When "a11y-init-or-shutdown" event is fired, "1" indicates that
+      // accessibility service is started and "0" that it is shut down.
+      this._update(data === "1");
+    }
+  },
+
+  get enabled() {
+    return Services.prefs.getBoolPref("accessibility.indicator.enabled");
+  },
+
+  handleEvent({ key, type }) {
+    if (
+      (type === "keypress" && [" ", "Enter"].includes(key)) ||
+      type === "click"
+    ) {
+      let a11yServicesSupportURL = Services.urlFormatter.formatURLPref(
+        "accessibility.support.url"
+      );
+      // This is a known URL coming from trusted UI
+      openTrustedLinkIn(a11yServicesSupportURL, "tab");
+      Services.telemetry.scalarSet("a11y.indicator_acted_on", true);
+    }
+  },
+
+  uninit() {
+    Services.prefs.removeObserver("accessibility.indicator.enabled", this);
+    Services.obs.removeObserver(this, "a11y-init-or-shutdown");
+  },
+};
+
+// Note that this is also called from non-browser windows on OSX, which do
+// share menu items but not much else. See nonbrowser-mac.js.
+var gPrivateBrowsingUI = {
+  init: function PBUI_init() {
+    // Do nothing for normal windows
+    if (!PrivateBrowsingUtils.isWindowPrivate(window)) {
+      return;
+    }
+
+    // Disable the Clear Recent History... menu item when in PB mode
+    // temporary fix until bug 463607 is fixed
+    document.getElementById("Tools:Sanitize").setAttribute("disabled", "true");
+
+    if (window.location.href != AppConstants.BROWSER_CHROME_URL) {
+      return;
+    }
+
+    // Adjust the window's title
+    let docElement = document.documentElement;
+    docElement.setAttribute(
+      "privatebrowsingmode",
+      PrivateBrowsingUtils.permanentPrivateBrowsing ? "permanent" : "temporary"
+    );
+    gBrowser.updateTitlebar();
+
+    if (PrivateBrowsingUtils.permanentPrivateBrowsing) {
+      // Adjust the New Window menu entries
+      let newWindow = document.getElementById("menu_newNavigator");
+      let newPrivateWindow = document.getElementById("menu_newPrivateWindow");
+      if (newWindow && newPrivateWindow) {
+        newPrivateWindow.hidden = true;
+        newWindow.label = newPrivateWindow.label;
+        newWindow.accessKey = newPrivateWindow.accessKey;
+        newWindow.command = newPrivateWindow.command;
+      }
+    }
+  },
+};
+
+/**
+ * Switch to a tab that has a given URI, and focuses its browser window.
+ * If a matching tab is in this window, it will be switched to. Otherwise, other
+ * windows will be searched.
+ *
+ * @param aURI
+ *        URI to search for
+ * @param aOpenNew
+ *        True to open a new tab and switch to it, if no existing tab is found.
+ *        If no suitable window is found, a new one will be opened.
+ * @param aOpenParams
+ *        If switching to this URI results in us opening a tab, aOpenParams
+ *        will be the parameter object that gets passed to openTrustedLinkIn. Please
+ *        see the documentation for openTrustedLinkIn to see what parameters can be
+ *        passed via this object.
+ *        This object also allows:
+ *        - 'ignoreFragment' property to be set to true to exclude fragment-portion
+ *        matching when comparing URIs.
+ *          If set to "whenComparing", the fragment will be unmodified.
+ *          If set to "whenComparingAndReplace", the fragment will be replaced.
+ *        - 'ignoreQueryString' boolean property to be set to true to exclude query string
+ *        matching when comparing URIs.
+ *        - 'replaceQueryString' boolean property to be set to true to exclude query string
+ *        matching when comparing URIs and overwrite the initial query string with
+ *        the one from the new URI.
+ *        - 'adoptIntoActiveWindow' boolean property to be set to true to adopt the tab
+ *        into the current window.
+ * @return True if an existing tab was found, false otherwise
+ */
+function switchToTabHavingURI(aURI, aOpenNew, aOpenParams = {}) {
+  // Certain URLs can be switched to irrespective of the source or destination
+  // window being in private browsing mode:
+  const kPrivateBrowsingWhitelist = new Set(["about:addons"]);
+
+  let ignoreFragment = aOpenParams.ignoreFragment;
+  let ignoreQueryString = aOpenParams.ignoreQueryString;
+  let replaceQueryString = aOpenParams.replaceQueryString;
+  let adoptIntoActiveWindow = aOpenParams.adoptIntoActiveWindow;
+
+  // These properties are only used by switchToTabHavingURI and should
+  // not be used as a parameter for the new load.
+  delete aOpenParams.ignoreFragment;
+  delete aOpenParams.ignoreQueryString;
+  delete aOpenParams.replaceQueryString;
+  delete aOpenParams.adoptIntoActiveWindow;
+
+  let isBrowserWindow = !!window.gBrowser;
+
+  // This will switch to the tab in aWindow having aURI, if present.
+  function switchIfURIInWindow(aWindow) {
+    // We can switch tab only if if both the source and destination windows have
+    // the same private-browsing status.
+    if (
+      !kPrivateBrowsingWhitelist.has(aURI.spec) &&
+      PrivateBrowsingUtils.isWindowPrivate(window) !==
+        PrivateBrowsingUtils.isWindowPrivate(aWindow)
+    ) {
+      return false;
+    }
+
+    // Remove the query string, fragment, both, or neither from a given url.
+    function cleanURL(url, removeQuery, removeFragment) {
+      let ret = url;
+      if (removeFragment) {
+        ret = ret.split("#")[0];
+        if (removeQuery) {
+          // This removes a query, if present before the fragment.
+          ret = ret.split("?")[0];
+        }
+      } else if (removeQuery) {
+        // This is needed in case there is a fragment after the query.
+        let fragment = ret.split("#")[1];
+        ret = ret
+          .split("?")[0]
+          .concat(fragment != undefined ? "#".concat(fragment) : "");
+      }
+      return ret;
+    }
+
+    // Need to handle nsSimpleURIs here too (e.g. about:...), which don't
+    // work correctly with URL objects - so treat them as strings
+    let ignoreFragmentWhenComparing =
+      typeof ignoreFragment == "string" &&
+      ignoreFragment.startsWith("whenComparing");
+    let requestedCompare = cleanURL(
+      aURI.displaySpec,
+      ignoreQueryString || replaceQueryString,
+      ignoreFragmentWhenComparing
+    );
+    let browsers = aWindow.gBrowser.browsers;
+    for (let i = 0; i < browsers.length; i++) {
+      let browser = browsers[i];
+      let browserCompare = cleanURL(
+        browser.currentURI.displaySpec,
+        ignoreQueryString || replaceQueryString,
+        ignoreFragmentWhenComparing
+      );
+      if (requestedCompare == browserCompare) {
+        // If adoptIntoActiveWindow is set, and this is a cross-window switch,
+        // adopt the tab into the current window, after the active tab.
+        let doAdopt =
+          adoptIntoActiveWindow && isBrowserWindow && aWindow != window;
+
+        if (doAdopt) {
+          const newTab = window.gBrowser.adoptTab(
+            aWindow.gBrowser.getTabForBrowser(browser),
+            window.gBrowser.tabContainer.selectedIndex + 1,
+            /* aSelectTab = */ true
+          );
+          if (!newTab) {
+            doAdopt = false;
+          }
+        }
+        if (!doAdopt) {
+          aWindow.focus();
+        }
+
+        if (ignoreFragment == "whenComparingAndReplace" || replaceQueryString) {
+          browser.loadURI(aURI.spec, {
+            triggeringPrincipal:
+              aOpenParams.triggeringPrincipal ||
+              _createNullPrincipalFromTabUserContextId(),
+          });
+        }
+
+        if (!doAdopt) {
+          aWindow.gBrowser.tabContainer.selectedIndex = i;
+        }
+
+        return true;
+      }
+    }
+    return false;
+  }
+
+  // This can be passed either nsIURI or a string.
+  if (!(aURI instanceof Ci.nsIURI)) {
+    aURI = Services.io.newURI(aURI);
+  }
+
+  // Prioritise this window.
+  if (isBrowserWindow && switchIfURIInWindow(window)) {
+    return true;
+  }
+
+  for (let browserWin of browserWindows()) {
+    // Skip closed (but not yet destroyed) windows,
+    // and the current window (which was checked earlier).
+    if (browserWin.closed || browserWin == window) {
+      continue;
+    }
+    if (switchIfURIInWindow(browserWin)) {
+      return true;
+    }
+  }
+
+  // No opened tab has that url.
+  if (aOpenNew) {
+    if (isBrowserWindow && gBrowser.selectedTab.isEmpty) {
+      openTrustedLinkIn(aURI.spec, "current", aOpenParams);
+    } else {
+      openTrustedLinkIn(aURI.spec, "tab", aOpenParams);
+    }
+  }
+
+  return false;
+}
+
+var RestoreLastSessionObserver = {
+  init() {
+    if (
+      SessionStore.canRestoreLastSession &&
+      !PrivateBrowsingUtils.isWindowPrivate(window)
+    ) {
+      Services.obs.addObserver(this, "sessionstore-last-session-cleared", true);
+      goSetCommandEnabled("Browser:RestoreLastSession", true);
+    } else if (SessionStore.willAutoRestore) {
+      document.getElementById("Browser:RestoreLastSession").hidden = true;
+    }
+  },
+
+  observe() {
+    // The last session can only be restored once so there's
+    // no way we need to re-enable our menu item.
+    Services.obs.removeObserver(this, "sessionstore-last-session-cleared");
+    goSetCommandEnabled("Browser:RestoreLastSession", false);
+  },
+
+  QueryInterface: ChromeUtils.generateQI([
+    "nsIObserver",
+    "nsISupportsWeakReference",
+  ]),
+};
+
+/* Observes menus and adjusts their size for better
+ * usability when opened via a touch screen. */
+var MenuTouchModeObserver = {
+  init() {
+    window.addEventListener("popupshowing", this, true);
+  },
+
+  handleEvent(event) {
+    let target = event.originalTarget;
+    if (event.mozInputSource == MouseEvent.MOZ_SOURCE_TOUCH) {
+      target.setAttribute("touchmode", "true");
+    } else {
+      target.removeAttribute("touchmode");
+    }
+  },
+
+  uninit() {
+    window.removeEventListener("popupshowing", this, true);
+  },
+};
+
+// Prompt user to restart the browser in safe mode
+function safeModeRestart() {
+  if (Services.appinfo.inSafeMode) {
+    let cancelQuit = Cc["@mozilla.org/supports-PRBool;1"].createInstance(
+      Ci.nsISupportsPRBool
+    );
+    Services.obs.notifyObservers(
+      cancelQuit,
+      "quit-application-requested",
+      "restart"
+    );
+
+    if (cancelQuit.data) {
+      return;
+    }
+
+    Services.startup.quit(
+      Ci.nsIAppStartup.eRestart | Ci.nsIAppStartup.eAttemptQuit
+    );
+    return;
+  }
+
+  Services.obs.notifyObservers(window, "restart-in-safe-mode");
+}
+
+/* duplicateTabIn duplicates tab in a place specified by the parameter |where|.
+ *
+ * |where| can be:
+ *  "tab"         new tab
+ *  "tabshifted"  same as "tab" but in background if default is to select new
+ *                tabs, and vice versa
+ *  "window"      new window
+ *
+ * delta is the offset to the history entry that you want to load.
+ */
+function duplicateTabIn(aTab, where, delta) {
+  switch (where) {
+    case "window":
+      let otherWin = OpenBrowserWindow({
+        private: PrivateBrowsingUtils.isBrowserPrivate(aTab.linkedBrowser),
+      });
+      let delayedStartupFinished = (subject, topic) => {
+        if (
+          topic == "browser-delayed-startup-finished" &&
+          subject == otherWin
+        ) {
+          Services.obs.removeObserver(delayedStartupFinished, topic);
+          let otherGBrowser = otherWin.gBrowser;
+          let otherTab = otherGBrowser.selectedTab;
+          SessionStore.duplicateTab(otherWin, aTab, delta);
+          otherGBrowser.removeTab(otherTab, { animate: false });
+        }
+      };
+
+      Services.obs.addObserver(
+        delayedStartupFinished,
+        "browser-delayed-startup-finished"
+      );
+      break;
+    case "tabshifted":
+      SessionStore.duplicateTab(window, aTab, delta);
+      // A background tab has been opened, nothing else to do here.
+      break;
+    case "tab":
+      SessionStore.duplicateTab(window, aTab, delta, true, {
+        inBackground: false,
+      });
+      break;
+  }
+}
+
+var MousePosTracker = {
+  _listeners: new Set(),
+  _x: 0,
+  _y: 0,
+
+  /**
+   * Registers a listener.
+   *
+   * @param listener (object)
+   *        A listener is expected to expose the following properties:
+   *
+   *        getMouseTargetRect (function)
+   *          Returns the rect that the MousePosTracker needs to alert
+   *          the listener about if the mouse happens to be within it.
+   *
+   *        onMouseEnter (function, optional)
+   *          The function to be called if the mouse enters the rect
+   *          returned by getMouseTargetRect. MousePosTracker always
+   *          runs this inside of a requestAnimationFrame, since it
+   *          assumes that the notification is used to update the DOM.
+   *
+   *        onMouseLeave (function, optional)
+   *          The function to be called if the mouse exits the rect
+   *          returned by getMouseTargetRect. MousePosTracker always
+   *          runs this inside of a requestAnimationFrame, since it
+   *          assumes that the notification is used to update the DOM.
+   */
+  addListener(listener) {
+    if (this._listeners.has(listener)) {
+      return;
+    }
+
+    listener._hover = false;
+    this._listeners.add(listener);
+
+    this._callListener(listener);
+  },
+
+  removeListener(listener) {
+    this._listeners.delete(listener);
+  },
+
+  handleEvent(event) {
+    let fullZoom = window.windowUtils.fullZoom;
+    this._x = event.screenX / fullZoom - window.mozInnerScreenX;
+    this._y = event.screenY / fullZoom - window.mozInnerScreenY;
+
+    this._listeners.forEach(listener => {
+      try {
+        this._callListener(listener);
+      } catch (e) {
+        Cu.reportError(e);
+      }
+    });
+  },
+
+  _callListener(listener) {
+    let rect = listener.getMouseTargetRect();
+    let hover =
+      this._x >= rect.left &&
+      this._x <= rect.right &&
+      this._y >= rect.top &&
+      this._y <= rect.bottom;
+
+    if (hover == listener._hover) {
+      return;
+    }
+
+    listener._hover = hover;
+
+    if (hover) {
+      if (listener.onMouseEnter) {
+        listener.onMouseEnter();
+      }
+    } else if (listener.onMouseLeave) {
+      listener.onMouseLeave();
+    }
+  },
+};
+
+var ToolbarIconColor = {
+  _windowState: {
+    active: false,
+    fullscreen: false,
+    tabsintitlebar: false,
+  },
+  init() {
+    this._initialized = true;
+
+    window.addEventListener("nativethemechange", this);
+    window.addEventListener("activate", this);
+    window.addEventListener("deactivate", this);
+    window.addEventListener("toolbarvisibilitychange", this);
+    window.addEventListener("windowlwthemeupdate", this);
+
+    // If the window isn't active now, we assume that it has never been active
+    // before and will soon become active such that inferFromText will be
+    // called from the initial activate event.
+    if (Services.focus.activeWindow == window) {
+      this.inferFromText("activate");
+    }
+  },
+
+  uninit() {
+    this._initialized = false;
+
+    window.removeEventListener("nativethemechange", this);
+    window.removeEventListener("activate", this);
+    window.removeEventListener("deactivate", this);
+    window.removeEventListener("toolbarvisibilitychange", this);
+    window.removeEventListener("windowlwthemeupdate", this);
+  },
+
+  handleEvent(event) {
+    switch (event.type) {
+      case "activate":
+      case "deactivate":
+      case "nativethemechange":
+      case "windowlwthemeupdate":
+        this.inferFromText(event.type);
+        break;
+      case "toolbarvisibilitychange":
+        this.inferFromText(event.type, event.visible);
+        break;
+    }
+  },
+
+  // a cache of luminance values for each toolbar
+  // to avoid unnecessary calls to getComputedStyle
+  _toolbarLuminanceCache: new Map(),
+
+  inferFromText(reason, reasonValue) {
+    if (!this._initialized) {
+      return;
+    }
+    function parseRGB(aColorString) {
+      let rgb = aColorString.match(/^rgba?\((\d+), (\d+), (\d+)/);
+      rgb.shift();
+      return rgb.map(x => parseInt(x));
+    }
+
+    switch (reason) {
+      case "activate": // falls through
+      case "deactivate":
+        this._windowState.active = reason === "activate";
+        break;
+      case "fullscreen":
+        this._windowState.fullscreen = reasonValue;
+        break;
+      case "nativethemechange":
+      case "windowlwthemeupdate":
+        // theme change, we'll need to recalculate all color values
+        this._toolbarLuminanceCache.clear();
+        break;
+      case "toolbarvisibilitychange":
+        // toolbar changes dont require reset of the cached color values
+        break;
+      case "tabsintitlebar":
+        this._windowState.tabsintitlebar = reasonValue;
+        break;
+    }
+
+    let toolbarSelector = ".browser-toolbar:not([collapsed=true])";
+    if (AppConstants.platform == "macosx") {
+      toolbarSelector += ":not([type=menubar])";
+    }
+
+    // The getComputedStyle calls and setting the brighttext are separated in
+    // two loops to avoid flushing layout and making it dirty repeatedly.
+    let cachedLuminances = this._toolbarLuminanceCache;
+    let luminances = new Map();
+    for (let toolbar of document.querySelectorAll(toolbarSelector)) {
+      // toolbars *should* all have ids, but guard anyway to avoid blowing up
+      let cacheKey =
+        toolbar.id && toolbar.id + JSON.stringify(this._windowState);
+      // lookup cached luminance value for this toolbar in this window state
+      let luminance = cacheKey && cachedLuminances.get(cacheKey);
+      if (isNaN(luminance)) {
+        let [r, g, b] = parseRGB(getComputedStyle(toolbar).color);
+        luminance = 0.2125 * r + 0.7154 * g + 0.0721 * b;
+        if (cacheKey) {
+          cachedLuminances.set(cacheKey, luminance);
+        }
+      }
+      luminances.set(toolbar, luminance);
+    }
+
+    const luminanceThreshold = 127; // In between 0 and 255
+    for (let [toolbar, luminance] of luminances) {
+      if (luminance <= luminanceThreshold) {
+        toolbar.removeAttribute("brighttext");
+      } else {
+        toolbar.setAttribute("brighttext", "true");
+      }
+    }
+  },
+};
+
+var PanicButtonNotifier = {
+  init() {
+    this._initialized = true;
+    if (window.PanicButtonNotifierShouldNotify) {
+      delete window.PanicButtonNotifierShouldNotify;
+      this.notify();
+    }
+  },
+  createPanelIfNeeded() {
+    // Lazy load the panic-button-success-notification panel the first time we need to display it.
+    if (!document.getElementById("panic-button-success-notification")) {
+      let template = document.getElementById("panicButtonNotificationTemplate");
+      template.replaceWith(template.content);
+    }
+  },
+  notify() {
+    if (!this._initialized) {
+      window.PanicButtonNotifierShouldNotify = true;
+      return;
+    }
+    // Display notification panel here...
+    try {
+      this.createPanelIfNeeded();
+      let popup = document.getElementById("panic-button-success-notification");
+      popup.hidden = false;
+      // To close the popup in 3 seconds after the popup is shown but left uninteracted.
+      let onTimeout = () => {
+        PanicButtonNotifier.close();
+        removeListeners();
+      };
+      popup.addEventListener("popupshown", function() {
+        PanicButtonNotifier.timer = setTimeout(onTimeout, 3000);
+      });
+      // To prevent the popup from closing when user tries to interact with the
+      // popup using mouse or keyboard.
+      let onUserInteractsWithPopup = () => {
+        clearTimeout(PanicButtonNotifier.timer);
+        removeListeners();
+      };
+      popup.addEventListener("mouseover", onUserInteractsWithPopup);
+      window.addEventListener("keydown", onUserInteractsWithPopup);
+      let removeListeners = () => {
+        popup.removeEventListener("mouseover", onUserInteractsWithPopup);
+        window.removeEventListener("keydown", onUserInteractsWithPopup);
+        popup.removeEventListener("popuphidden", removeListeners);
+      };
+      popup.addEventListener("popuphidden", removeListeners);
+
+      let widget = CustomizableUI.getWidget("panic-button").forWindow(window);
+      let anchor = widget.anchor.icon;
+      popup.openPopup(anchor, popup.getAttribute("position"));
+    } catch (ex) {
+      Cu.reportError(ex);
+    }
+  },
+  close() {
+    let popup = document.getElementById("panic-button-success-notification");
+    popup.hidePopup();
+  },
+};
+
+const SafeBrowsingNotificationBox = {
+  _currentURIBaseDomain: null,
+  show(title, buttons) {
+    let uri = gBrowser.currentURI;
+
+    // start tracking host so that we know when we leave the domain
+    try {
+      this._currentURIBaseDomain = Services.eTLD.getBaseDomain(uri);
+    } catch (e) {
+      // If we can't get the base domain, fallback to use host instead. However,
+      // host is sometimes empty when the scheme is file. In this case, just use
+      // spec.
+      this._currentURIBaseDomain = uri.asciiHost || uri.asciiSpec;
+    }
+
+    let notificationBox = gBrowser.getNotificationBox();
+    let value = "blocked-badware-page";
+
+    let previousNotification = notificationBox.getNotificationWithValue(value);
+    if (previousNotification) {
+      notificationBox.removeNotification(previousNotification);
+    }
+
+    let notification = notificationBox.appendNotification(
+      value,
+      {
+        label: title,
+        image: "chrome://global/skin/icons/blocked.svg",
+        priority: notificationBox.PRIORITY_CRITICAL_HIGH,
+      },
+      buttons
+    );
+    // Persist the notification until the user removes so it
+    // doesn't get removed on redirects.
+    notification.persistence = -1;
+  },
+  onLocationChange(aLocationURI) {
+    // take this to represent that you haven't visited a bad place
+    if (!this._currentURIBaseDomain) {
+      return;
+    }
+
+    let newURIBaseDomain = Services.eTLD.getBaseDomain(aLocationURI);
+
+    if (newURIBaseDomain !== this._currentURIBaseDomain) {
+      let notificationBox = gBrowser.getNotificationBox();
+      let notification = notificationBox.getNotificationWithValue(
+        "blocked-badware-page"
+      );
+      if (notification) {
+        notificationBox.removeNotification(notification, false);
+      }
+
+      this._currentURIBaseDomain = null;
+    }
+  },
+};
+
+/**
+ * The TabDialogBox supports opening window dialogs as SubDialogs on the tab and content
+ * level. Both tab and content dialogs have their own separate managers.
+ * Dialogs will be queued FIFO and cover the web content.
+ * Dialogs are closed when the user reloads or leaves the page.
+ * While a dialog is open PopupNotifications, such as permission prompts, are
+ * suppressed.
+ */
+class TabDialogBox {
+  constructor(browser) {
+    this._weakBrowserRef = Cu.getWeakReference(browser);
+
+    // Create parent element for tab dialogs
+    let template = document.getElementById("dialogStackTemplate");
+    let dialogStack = template.content.cloneNode(true).firstElementChild;
+    dialogStack.classList.add("tab-prompt-dialog");
+
+    this.browser.parentNode.insertBefore(
+      dialogStack,
+      this.browser.nextElementSibling
+    );
+
+    // Initially the stack only contains the template
+    let dialogTemplate = dialogStack.firstElementChild;
+
+    // Create dialog manager for prompts at the tab level.
+    this._tabDialogManager = new SubDialogManager({
+      dialogStack,
+      dialogTemplate,
+      orderType: SubDialogManager.ORDER_QUEUE,
+      allowDuplicateDialogs: true,
+      dialogOptions: {
+        consumeOutsideClicks: false,
+      },
+    });
+  }
+
+  /**
+   * Open a dialog on tab or content level.
+   * @param {String} aURL - URL of the dialog to load in the tab box.
+   * @param {Object} [aOptions]
+   * @param {String} [aOptions.features] - Comma separated list of window
+   * features.
+   * @param {Boolean} [aOptions.allowDuplicateDialogs] - Whether to allow
+   * showing multiple dialogs with aURL at the same time. If false calls for
+   * duplicate dialogs will be dropped.
+   * @param {String} [aOptions.sizeTo] - Pass "available" to stretch dialog to
+   * roughly content size.
+   * @param {Boolean} [aOptions.keepOpenSameOriginNav] - By default dialogs are
+   * aborted on any navigation.
+   * Set to true to keep the dialog open for same origin navigation.
+   * @param {Number} [aOptions.modalType] - The modal type to create the dialog for.
+   * By default, we show the dialog for tab prompts.
+   * @returns {Object} [result] Returns an object { closedPromise, dialog }.
+   * @returns {Promise} [result.closedPromise] Resolves once the dialog has been closed.
+   * @returns {SubDialog} [result.dialog] A reference to the opened SubDialog.
+   */
+  open(
+    aURL,
+    {
+      features = null,
+      allowDuplicateDialogs = true,
+      sizeTo,
+      keepOpenSameOriginNav,
+      modalType = null,
+      allowFocusCheckbox = false,
+    } = {},
+    ...aParams
+  ) {
+    let resolveClosed;
+    let closedPromise = new Promise(resolve => (resolveClosed = resolve));
+    // Get the dialog manager to open the prompt with.
+    let dialogManager =
+      modalType === Ci.nsIPrompt.MODAL_TYPE_CONTENT
+        ? this.getContentDialogManager()
+        : this._tabDialogManager;
+
+    let hasDialogs = () =>
+      this._tabDialogManager.hasDialogs ||
+      this._contentDialogManager?.hasDialogs;
+
+    if (!hasDialogs()) {
+      this._onFirstDialogOpen();
+    }
+
+    let closingCallback = event => {
+      if (!hasDialogs()) {
+        this._onLastDialogClose();
+      }
+
+      if (allowFocusCheckbox && !event.detail?.abort) {
+        this.maybeSetAllowTabSwitchPermission(event.target);
+      }
+    };
+
+    if (modalType == Ci.nsIPrompt.MODAL_TYPE_CONTENT) {
+      sizeTo = "limitheight";
+    }
+
+    // Open dialog and resolve once it has been closed
+    let dialog = dialogManager.open(
+      aURL,
+      {
+        features,
+        allowDuplicateDialogs,
+        sizeTo,
+        closingCallback,
+        closedCallback: resolveClosed,
+      },
+      ...aParams
+    );
+
+    // Marking the dialog externally, instead of passing it as an option.
+    // The SubDialog(Manager) does not care about navigation.
+    // dialog can be null here if allowDuplicateDialogs = false.
+    if (dialog) {
+      dialog._keepOpenSameOriginNav = keepOpenSameOriginNav;
+    }
+    return { closedPromise, dialog };
+  }
+
+  _onFirstDialogOpen() {
+    // Hide PopupNotifications to prevent them from covering up dialogs.
+    this.browser.setAttribute("tabDialogShowing", true);
+    UpdatePopupNotificationsVisibility();
+
+    // Register listeners
+    this._lastPrincipal = this.browser.contentPrincipal;
+    this.browser.addProgressListener(this, Ci.nsIWebProgress.NOTIFY_LOCATION);
+
+    this.tab?.addEventListener("TabClose", this);
+  }
+
+  _onLastDialogClose() {
+    // Show PopupNotifications again.
+    this.browser.removeAttribute("tabDialogShowing");
+    UpdatePopupNotificationsVisibility();
+
+    // Clean up listeners
+    this.browser.removeProgressListener(this);
+    this._lastPrincipal = null;
+
+    this.tab?.removeEventListener("TabClose", this);
+  }
+
+  _buildContentPromptDialog() {
+    let template = document.getElementById("dialogStackTemplate");
+    let contentDialogStack = template.content.cloneNode(true).firstElementChild;
+    contentDialogStack.classList.add("content-prompt-dialog");
+
+    // Create a dialog manager for content prompts.
+    let tabPromptDialog = this.browser.parentNode.querySelector(
+      ".tab-prompt-dialog"
+    );
+    this.browser.parentNode.insertBefore(contentDialogStack, tabPromptDialog);
+
+    let contentDialogTemplate = contentDialogStack.firstElementChild;
+    this._contentDialogManager = new SubDialogManager({
+      dialogStack: contentDialogStack,
+      dialogTemplate: contentDialogTemplate,
+      orderType: SubDialogManager.ORDER_QUEUE,
+      allowDuplicateDialogs: true,
+      dialogOptions: {
+        consumeOutsideClicks: false,
+      },
+    });
+  }
+
+  handleEvent(event) {
+    if (event.type !== "TabClose") {
+      return;
+    }
+    this.abortAllDialogs();
+  }
+
+  abortAllDialogs() {
+    this._tabDialogManager.abortDialogs();
+    this._contentDialogManager?.abortDialogs();
+  }
+
+  focus() {
+    // Prioritize focusing the dialog manager for tab prompts
+    if (this._tabDialogManager._dialogs.length) {
+      this._tabDialogManager.focusTopDialog();
+      return;
+    }
+    this._contentDialogManager?.focusTopDialog();
+  }
+
+  /**
+   * If the user navigates away or refreshes the page, close all dialogs for
+   * the current browser.
+   */
+  onLocationChange(aWebProgress, aRequest, aLocation, aFlags) {
+    if (
+      !aWebProgress.isTopLevel ||
+      aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT
+    ) {
+      return;
+    }
+
+    // Dialogs can be exempt from closing on same origin location change.
+    let filterFn;
+
+    // Test for same origin location change
+    if (
+      this._lastPrincipal?.isSameOrigin(
+        aLocation,
+        this.browser.browsingContext.usePrivateBrowsing
+      )
+    ) {
+      filterFn = dialog => !dialog._keepOpenSameOriginNav;
+    }
+
+    this._lastPrincipal = this.browser.contentPrincipal;
+
+    this._tabDialogManager.abortDialogs(filterFn);
+    this._contentDialogManager?.abortDialogs(filterFn);
+  }
+
+  get tab() {
+    return gBrowser.getTabForBrowser(this.browser);
+  }
+
+  get browser() {
+    let browser = this._weakBrowserRef.get();
+    if (!browser) {
+      throw new Error("Stale dialog box! The associated browser is gone.");
+    }
+    return browser;
+  }
+
+  getTabDialogManager() {
+    return this._tabDialogManager;
+  }
+
+  getContentDialogManager() {
+    if (!this._contentDialogManager) {
+      this._buildContentPromptDialog();
+    }
+    return this._contentDialogManager;
+  }
+
+  onNextPromptShowAllowFocusCheckboxFor(principal) {
+    this._allowTabFocusByPromptPrincipal = principal;
+  }
+
+  /**
+   * Sets the "focus-tab-by-prompt" permission for the dialog.
+   */
+  maybeSetAllowTabSwitchPermission(dialog) {
+    let checkbox = dialog.querySelector("checkbox");
+
+    if (checkbox.checked) {
+      Services.perms.addFromPrincipal(
+        this._allowTabFocusByPromptPrincipal,
+        "focus-tab-by-prompt",
+        Services.perms.ALLOW_ACTION
+      );
+    }
+
+    // Don't show the "allow tab switch checkbox" for subsequent prompts.
+    this._allowTabFocusByPromptPrincipal = null;
+  }
+}
+
+TabDialogBox.prototype.QueryInterface = ChromeUtils.generateQI([
+  "nsIWebProgressListener",
+  "nsISupportsWeakReference",
+]);
+
+function TabModalPromptBox(browser) {
+  this._weakBrowserRef = Cu.getWeakReference(browser);
+  /*
+   * These WeakMaps holds the TabModalPrompt instances, key to the <tabmodalprompt> prompt
+   * in the DOM. We don't want to hold the instances directly to avoid leaking.
+   *
+   * WeakMap also prevents us from reading back its insertion order.
+   * Order of the elements in the DOM should be the only order to consider.
+   */
+  this._contentPrompts = new WeakMap();
+  this._tabPrompts = new WeakMap();
+}
+
+TabModalPromptBox.prototype = {
+  _promptCloseCallback(
+    onCloseCallback,
+    principalToAllowFocusFor,
+    allowFocusCheckbox,
+    ...args
+  ) {
+    if (
+      principalToAllowFocusFor &&
+      allowFocusCheckbox &&
+      allowFocusCheckbox.checked
+    ) {
+      Services.perms.addFromPrincipal(
+        principalToAllowFocusFor,
+        "focus-tab-by-prompt",
+        Services.perms.ALLOW_ACTION
+      );
+    }
+    onCloseCallback.apply(this, args);
+  },
+
+  getPrompt(promptEl) {
+    if (promptEl.classList.contains("tab-prompt")) {
+      return this._tabPrompts.get(promptEl);
+    }
+    return this._contentPrompts.get(promptEl);
+  },
+
+  appendPrompt(args, onCloseCallback) {
+    let browser = this.browser;
+    let newPrompt = new TabModalPrompt(browser.ownerGlobal);
+
+    if (args.modalType === Ci.nsIPrompt.MODAL_TYPE_TAB) {
+      newPrompt.element.classList.add("tab-prompt");
+      this._tabPrompts.set(newPrompt.element, newPrompt);
+    } else {
+      newPrompt.element.classList.add("content-prompt");
+      this._contentPrompts.set(newPrompt.element, newPrompt);
+    }
+
+    browser.parentNode.insertBefore(
+      newPrompt.element,
+      browser.nextElementSibling
+    );
+    browser.setAttribute("tabmodalPromptShowing", true);
+
+    // Indicate if a tab modal chrome prompt is being shown so that
+    // PopupNotifications are suppressed.
+    if (
+      args.modalType === Ci.nsIPrompt.MODAL_TYPE_TAB &&
+      !browser.hasAttribute("tabmodalChromePromptShowing")
+    ) {
+      browser.setAttribute("tabmodalChromePromptShowing", true);
+      // Notify popup notifications of the UI change so they hide their
+      // notification panels.
+      UpdatePopupNotificationsVisibility();
+    }
+
+    let prompts = this.listPrompts(args.modalType);
+    if (prompts.length > 1) {
+      // Let's hide ourself behind the current prompt.
+      newPrompt.element.hidden = true;
+    }
+
+    let principalToAllowFocusFor = this._allowTabFocusByPromptPrincipal;
+    delete this._allowTabFocusByPromptPrincipal;
+
+    let allowFocusCheckbox; // Define outside the if block so we can bind it into the callback.
+    let hostForAllowFocusCheckbox = "";
+    try {
+      hostForAllowFocusCheckbox = principalToAllowFocusFor.URI.host;
+    } catch (ex) {
+      /* Ignore exceptions for host-less URIs */
+    }
+    if (hostForAllowFocusCheckbox) {
+      let allowFocusRow = document.createElement("div");
+
+      let spacer = document.createElement("div");
+      allowFocusRow.appendChild(spacer);
+
+      allowFocusCheckbox = document.createXULElement("checkbox");
+      document.l10n.setAttributes(
+        allowFocusCheckbox,
+        "tabbrowser-allow-dialogs-to-get-focus",
+        { domain: hostForAllowFocusCheckbox }
+      );
+      allowFocusRow.appendChild(allowFocusCheckbox);
+
+      newPrompt.ui.rows.append(allowFocusRow);
+    }
+
+    let tab = gBrowser.getTabForBrowser(browser);
+    let closeCB = this._promptCloseCallback.bind(
+      null,
+      onCloseCallback,
+      principalToAllowFocusFor,
+      allowFocusCheckbox
+    );
+    newPrompt.init(args, tab, closeCB);
+    return newPrompt;
+  },
+
+  removePrompt(aPrompt) {
+    let { modalType } = aPrompt.args;
+    if (modalType === Ci.nsIPrompt.MODAL_TYPE_TAB) {
+      this._tabPrompts.delete(aPrompt.element);
+    } else {
+      this._contentPrompts.delete(aPrompt.element);
+    }
+
+    let browser = this.browser;
+    aPrompt.element.remove();
+
+    let prompts = this.listPrompts(modalType);
+    if (prompts.length) {
+      let prompt = prompts[prompts.length - 1];
+      prompt.element.hidden = false;
+      // Because we were hidden before, this won't have been possible, so do it now:
+      prompt.Dialog.setDefaultFocus();
+    } else if (modalType === Ci.nsIPrompt.MODAL_TYPE_TAB) {
+      // If we remove the last tab chrome prompt, also remove the browser
+      // attribute.
+      browser.removeAttribute("tabmodalChromePromptShowing");
+      // Notify popup notifications of the UI change so they show notification
+      // panels again.
+      UpdatePopupNotificationsVisibility();
+    }
+    // Check if all prompts are closed
+    if (!this._hasPrompts()) {
+      browser.removeAttribute("tabmodalPromptShowing");
+      browser.focus();
+    }
+  },
+
+  /**
+   * Checks if the prompt box has prompt elements.
+   * @returns {Boolean} - true if there are prompt elements.
+   */
+  _hasPrompts() {
+    return !!this._getPromptElements().length;
+  },
+
+  /**
+   * Get list of current prompt elements.
+   * @param {Number} [aModalType] - Optionally filter by
+   * Ci.nsIPrompt.MODAL_TYPE_.
+   * @returns {NodeList} - A list of tabmodalprompt elements.
+   */
+  _getPromptElements(aModalType = null) {
+    let selector = "tabmodalprompt";
+
+    if (aModalType != null) {
+      if (aModalType === Ci.nsIPrompt.MODAL_TYPE_TAB) {
+        selector += ".tab-prompt";
+      } else {
+        selector += ".content-prompt";
+      }
+    }
+    return this.browser.parentNode.querySelectorAll(selector);
+  },
+
+  /**
+   * Get a list of all TabModalPrompt objects associated with the prompt box.
+   * @param {Number} [aModalType] - Optionally filter by
+   * Ci.nsIPrompt.MODAL_TYPE_.
+   * @returns {TabModalPrompt[]} - An array of TabModalPrompt objects.
+   */
+  listPrompts(aModalType = null) {
+    // Get the nodelist, then return the TabModalPrompt instances as an array
+    let promptMap;
+
+    if (aModalType) {
+      if (aModalType === Ci.nsIPrompt.MODAL_TYPE_TAB) {
+        promptMap = this._tabPrompts;
+      } else {
+        promptMap = this._contentPrompts;
+      }
+    }
+
+    let elements = this._getPromptElements(aModalType);
+
+    if (promptMap) {
+      return [...elements].map(el => promptMap.get(el));
+    }
+    return [...elements].map(
+      el => this._contentPrompts.get(el) || this._tabPrompts.get(el)
+    );
+  },
+
+  onNextPromptShowAllowFocusCheckboxFor(principal) {
+    this._allowTabFocusByPromptPrincipal = principal;
+  },
+
+  get browser() {
+    let browser = this._weakBrowserRef.get();
+    if (!browser) {
+      throw new Error("Stale promptbox! The associated browser is gone.");
+    }
+    return browser;
+  },
+};
+
+// Handle window-modal prompts that we want to display with the same style as
+// tab-modal prompts.
+var gDialogBox = {
+  _dialog: null,
+  _nextOpenJumpsQueue: false,
+  _queued: [],
+
+  // Used to wait for a `close` event from the HTML
+  // dialog. The  event is fired asynchronously, which means
+  // that if we open another dialog immediately after the
+  // previous one, we might be confused into thinking a
+  // `close` event for the old dialog is for the new one.
+  // As they have the same event target, we have no way of
+  // distinguishing them. So we wait for the `close` event
+  // to have happened before allowing another dialog to open.
+  _didCloseHTMLDialog: null,
+  // Whether we managed to open the dialog we tried to open.
+  // Used to avoid waiting for the above callback in case
+  // of an error opening the dialog.
+  _didOpenHTMLDialog: false,
+
+  get dialog() {
+    return this._dialog;
+  },
+
+  get isOpen() {
+    return !!this._dialog;
+  },
+
+  replaceDialogIfOpen() {
+    this._dialog?.close();
+    this._nextOpenJumpsQueue = true;
+  },
+
+  async open(uri, args) {
+    // If we need to queue, some callers indicate they should go first.
+    const queueMethod = this._nextOpenJumpsQueue ? "unshift" : "push";
+    this._nextOpenJumpsQueue = false;
+
+    // If we already have a dialog opened and are trying to open another,
+    // queue the next one to be opened later.
+    if (this.isOpen) {
+      return new Promise((resolve, reject) => {
+        this._queued[queueMethod]({ resolve, reject, uri, args });
+      });
+    }
+
+    // We're not open. If we're in a modal state though, we can't
+    // show the dialog effectively. To avoid hanging by deadlock,
+    // just return immediately for sync prompts:
+    if (window.windowUtils.isInModalState() && !args.getProperty("async")) {
+      throw Components.Exception(
+        "Prompt could not be shown.",
+        Cr.NS_ERROR_NOT_AVAILABLE
+      );
+    }
+
+    // Indicate if we should wait for the dialog to close.
+    this._didOpenHTMLDialog = false;
+    let haveClosedPromise = new Promise(resolve => {
+      this._didCloseHTMLDialog = resolve;
+    });
+
+    // Bring the window to the front in case we're minimized or occluded:
+    window.focus();
+
+    try {
+      await this._open(uri, args);
+    } catch (ex) {
+      Cu.reportError(ex);
+    } finally {
+      let dialog = document.getElementById("window-modal-dialog");
+      if (dialog.open) {
+        dialog.close();
+      }
+      // If the dialog was opened successfully, then we can wait for it
+      // to close before trying to open any others.
+      if (this._didOpenHTMLDialog) {
+        await haveClosedPromise;
+      }
+      dialog.style.visibility = "hidden";
+      dialog.style.height = "0";
+      dialog.style.width = "0";
+      document.documentElement.removeAttribute("window-modal-open");
+      dialog.removeEventListener("dialogopen", this);
+      dialog.removeEventListener("close", this);
+      this._updateMenuAndCommandState(true /* to enable */);
+      this._dialog = null;
+      UpdatePopupNotificationsVisibility();
+    }
+    if (this._queued.length) {
+      setTimeout(() => this._openNextDialog(), 0);
+    }
+    return args;
+  },
+
+  _openNextDialog() {
+    if (!this.isOpen) {
+      let { resolve, reject, uri, args } = this._queued.shift();
+      this.open(uri, args).then(resolve, reject);
+    }
+  },
+
+  handleEvent(event) {
+    switch (event.type) {
+      case "dialogopen":
+        this._dialog.focus(true);
+        break;
+      case "close":
+        this._didCloseHTMLDialog();
+        this._dialog.close();
+        break;
+    }
+  },
+
+  _open(uri, args) {
+    // Get this offset before we touch style below, as touching style seems
+    // to reset the cached layout bounds.
+    let offset = window.windowUtils.getBoundsWithoutFlushing(
+      gBrowser.selectedBrowser
+    ).top;
+    let parentElement = document.getElementById("window-modal-dialog");
+    parentElement.style.setProperty("--chrome-offset", offset + "px");
+    parentElement.style.removeProperty("visibility");
+    parentElement.style.removeProperty("width");
+    parentElement.style.removeProperty("height");
+    document.documentElement.setAttribute("window-modal-open", true);
+    // Call this first so the contents show up and get layout, which is
+    // required for SubDialog to work.
+    parentElement.showModal();
+    this._didOpenHTMLDialog = true;
+
+    // Disable menus and shortcuts.
+    this._updateMenuAndCommandState(false /* to disable */);
+
+    // Now actually set up the dialog contents:
+    let template = document.getElementById("window-modal-dialog-template")
+      .content.firstElementChild;
+    parentElement.addEventListener("dialogopen", this);
+    parentElement.addEventListener("close", this);
+    this._dialog = new SubDialog({
+      template,
+      parentElement,
+      id: "window-modal-dialog-subdialog",
+      options: {
+        consumeOutsideClicks: false,
+      },
+    });
+    let closedPromise = new Promise(resolve => {
+      this._closedCallback = function() {
+        PromptUtils.fireDialogEvent(window, "DOMModalDialogClosed");
+        resolve();
+      };
+    });
+    this._dialog.open(
+      uri,
+      {
+        features: "resizable=no",
+        modalType: Ci.nsIPrompt.MODAL_TYPE_INTERNAL_WINDOW,
+        closedCallback: () => {
+          this._closedCallback();
+        },
+      },
+      args
+    );
+    UpdatePopupNotificationsVisibility();
+    return closedPromise;
+  },
+
+  _nonUpdatableElements: new Set([
+    // Make an exception for debugging tools, for developer ease of use.
+    "key_browserConsole",
+    "key_browserToolbox",
+
+    // Don't touch the editing keys/commands which we might want inside the dialog.
+    "key_undo",
+    "key_redo",
+
+    "key_cut",
+    "key_copy",
+    "key_paste",
+    "key_delete",
+    "key_selectAll",
+  ]),
+
+  _updateMenuAndCommandState(shouldBeEnabled) {
+    let editorCommands = document.getElementById("editMenuCommands");
+    // For the following items, set or clear disabled state:
+    // - toplevel menubar items (will affect inner items on macOS)
+    // - command elements
+    // - key elements not connected to command elements.
+    for (let element of document.querySelectorAll(
+      "menubar > menu, command, key:not([command])"
+    )) {
+      if (
+        editorCommands?.contains(element) ||
+        (element.id && this._nonUpdatableElements.has(element.id))
+      ) {
+        continue;
+      }
+      if (element.nodeName == "key" && element.command) {
+        continue;
+      }
+      if (!shouldBeEnabled) {
+        if (element.getAttribute("disabled") != "true") {
+          element.setAttribute("disabled", true);
+        } else {
+          element.setAttribute("wasdisabled", true);
+        }
+      } else if (element.getAttribute("wasdisabled") != "true") {
+        element.removeAttribute("disabled");
+      } else {
+        element.removeAttribute("wasdisabled");
+      }
+    }
+  },
+};
+
+// browser.js loads in the library window, too, but we can only show prompts
+// in the main browser window:
+if (window.location.href != AppConstants.BROWSER_CHROME_URL) {
+  gDialogBox = null;
+}
+
+var ConfirmationHint = {
+  _timerID: null,
+
+  /**
+   * Shows a transient, non-interactive confirmation hint anchored to an
+   * element, usually used in response to a user action to reaffirm that it was
+   * successful and potentially provide extra context. Examples for such hints:
+   * - "Saved to bookmarks" after bookmarking a page
+   * - "Sent!" after sending a tab to another device
+   * - "Queued (offline)" when attempting to send a tab to another device
+   *   while offline
+   *
+   * @param  anchor (DOM node, required)
+   *         The anchor for the panel.
+   * @param  messageId (string, required)
+   *         For getting the message string from browser.properties:
+   *         confirmationHint.<messageId>.label
+   * @param  options (object, optional)
+   *         An object with the following optional properties:
+   *         - event (DOM event): The event that triggered the feedback.
+   *         - showDescription (boolean): show description text (confirmationHint.<messageId>.description)
+   *
+   */
+  show(anchor, messageId, options = {}) {
+    this._reset();
+
+    this._message.textContent = gBrowserBundle.GetStringFromName(
+      `confirmationHint.${messageId}.label`
+    );
+
+    if (options.showDescription) {
+      this._description.textContent = gBrowserBundle.GetStringFromName(
+        `confirmationHint.${messageId}.description`
+      );
+      this._description.hidden = false;
+      this._panel.classList.add("with-description");
+    } else {
+      this._description.hidden = true;
+      this._panel.classList.remove("with-description");
+    }
+
+    this._panel.setAttribute("data-message-id", messageId);
+
+    // The timeout value used here allows the panel to stay open for
+    // 1.5s second after the text transition (duration=120ms) has finished.
+    // If there is a description, we show for 4s after the text transition.
+    const DURATION = options.showDescription ? 4000 : 1500;
+    this._panel.addEventListener(
+      "popupshown",
+      () => {
+        this._animationBox.setAttribute("animate", "true");
+        this._timerID = setTimeout(() => {
+          this._panel.hidePopup(true);
+        }, DURATION + 120);
+      },
+      { once: true }
+    );
+
+    this._panel.addEventListener(
+      "popuphidden",
+      () => {
+        // reset the timerId in case our timeout wasn't the cause of the popup being hidden
+        this._reset();
+      },
+      { once: true }
+    );
+
+    this._panel.openPopup(anchor, {
+      position: "bottomcenter topleft",
+      triggerEvent: options.event,
+    });
+  },
+
+  _reset() {
+    if (this._timerID) {
+      clearTimeout(this._timerID);
+      this._timerID = null;
+    }
+    if (this.__panel) {
+      this._animationBox.removeAttribute("animate");
+      this._panel.removeAttribute("data-message-id");
+    }
+  },
+
+  get _panel() {
+    this._ensurePanel();
+    return this.__panel;
+  },
+
+  get _animationBox() {
+    this._ensurePanel();
+    delete this._animationBox;
+    return (this._animationBox = document.getElementById(
+      "confirmation-hint-checkmark-animation-container"
+    ));
+  },
+
+  get _message() {
+    this._ensurePanel();
+    delete this._message;
+    return (this._message = document.getElementById(
+      "confirmation-hint-message"
+    ));
+  },
+
+  get _description() {
+    this._ensurePanel();
+    delete this._description;
+    return (this._description = document.getElementById(
+      "confirmation-hint-description"
+    ));
+  },
+
+  _ensurePanel() {
+    if (!this.__panel) {
+      let wrapper = document.getElementById("confirmation-hint-wrapper");
+      wrapper.replaceWith(wrapper.content);
+      this.__panel = document.getElementById("confirmation-hint");
+    }
+  },
+};
diff --git a/browser/components/places/content/places.xhtml b/browser/components/places/content/places.xhtml
index e19a580298..4271915765 100644
--- a/browser/components/places/content/places.xhtml
+++ b/browser/components/places/content/places.xhtml
@@ -166,6 +166,7 @@
 #else
       <menubar id="placesMenu">
         <menu class="menu-iconic" data-l10n-id="places-organize-button"
+              _moz-menubarkeeplocal="true"
 #endif
               id="organizeButton">
           <menupopup id="organizeButtonPopup">
diff --git a/browser/components/places/content/places.xhtml.orig b/browser/components/places/content/places.xhtml.orig
new file mode 100644
index 0000000000..e19a580298
--- /dev/null
+++ b/browser/components/places/content/places.xhtml.orig
@@ -0,0 +1,413 @@
+<?xml version="1.0"?>
+
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+<?xml-stylesheet href="chrome://browser/content/places/places.css"?>
+<?xml-stylesheet href="chrome://browser/content/usercontext/usercontext.css"?>
+
+<?xml-stylesheet href="chrome://global/skin/global.css"?>
+<?xml-stylesheet href="chrome://browser/skin/places/tree-icons.css"?>
+<?xml-stylesheet href="chrome://browser/skin/places/organizer.css"?>
+<?xml-stylesheet href="chrome://browser/skin/places/editBookmark.css"?>
+
+<?xml-stylesheet href="chrome://browser/content/downloads/downloads.css"?>
+<?xml-stylesheet href="chrome://browser/skin/downloads/allDownloadsView.css"?>
+
+<!DOCTYPE window [
+<!ENTITY % editMenuOverlayDTD SYSTEM "chrome://global/locale/editMenuOverlay.dtd">
+%editMenuOverlayDTD;
+]>
+
+<window id="places"
+        data-l10n-id="places-library"
+        data-l10n-attrs="style"
+        windowtype="Places:Organizer"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml"
+        onload="PlacesOrganizer.init();"
+        onunload="PlacesOrganizer.destroy();"
+        screenX="10" screenY="10"
+        toggletoolbar="true"
+        persist="width height screenX screenY sizemode">
+
+  <linkset>
+    <html:link rel="localization" href="toolkit/global/textActions.ftl"/>
+    <html:link rel="localization" href="browser/browserSets.ftl"/>
+    <html:link rel="localization" href="browser/places.ftl"/>
+    <html:link rel="localization" href="browser/downloads.ftl"/>
+    <html:link rel="localization" href="browser/editBookmarkOverlay.ftl"/>
+  </linkset>
+
+  <script src="chrome://browser/content/places/places.js"/>
+  <script src="chrome://global/content/editMenuOverlay.js"/>
+#ifndef XP_MACOSX
+  <!-- On Mac, this is included via macWindow.inc.xhtml -> global-scripts.inc -> browser.js -> defineLazyScriptGetter -->
+  <script src="chrome://browser/content/places/instantEditBookmark.js"/>
+  <!-- On Mac, thes are included via macWindow.inc.xhtml -> global-scripts.inc -->
+  <script src="chrome://global/content/globalOverlay.js"/>
+  <script src="chrome://browser/content/utilityOverlay.js"/>
+#endif
+
+  <stringbundleset id="placesStringSet">
+    <stringbundle id="brandStrings" src="chrome://branding/locale/brand.properties"/>
+  </stringbundleset>
+
+#ifdef XP_MACOSX
+#include ../../../base/content/macWindow.inc.xhtml
+#else
+#include placesCommands.inc.xhtml
+#endif
+
+  <!-- This must be included after macWindow.inc.xhtml to override DownloadsView -->
+  <script src="chrome://browser/content/downloads/allDownloadsView.js"/>
+  <script src="chrome://global/content/contentAreaUtils.js"/>
+  <script src="chrome://browser/content/places/places-tree.js"/>
+
+  <commandset id="organizerCommandSet">
+    <command id="OrganizerCommand_find:all"
+             oncommand="PlacesSearchBox.findAll();"/>
+    <command id="OrganizerCommand_export"
+             oncommand="PlacesOrganizer.exportBookmarks();"/>
+    <command id="OrganizerCommand_import"
+             oncommand="PlacesOrganizer.importFromFile();"/>
+    <command id="OrganizerCommand_browserImport"
+             oncommand="PlacesOrganizer.importFromBrowser();"/>
+    <command id="OrganizerCommand_backup"
+             oncommand="PlacesOrganizer.backupBookmarks();"/>
+    <command id="OrganizerCommand_restoreFromFile"
+             oncommand="PlacesOrganizer.onRestoreBookmarksFromFile();"/>
+    <command id="OrganizerCommand_search:save"
+             oncommand="PlacesOrganizer.saveSearch();"/>
+    <command id="OrganizerCommand_search:moreCriteria"
+             oncommand="PlacesQueryBuilder.addRow();"/>
+    <command id="OrganizerCommand:Back"
+             oncommand="PlacesOrganizer.back();"/>
+    <command id="OrganizerCommand:Forward"
+             oncommand="PlacesOrganizer.forward();"/>
+  </commandset>
+#include ../../downloads/content/downloadsCommands.inc.xhtml
+
+  <keyset id="placesOrganizerKeyset">
+    <!-- Instantiation Keys -->
+    <key id="placesKey_close" data-l10n-id="places-cmd-close" modifiers="accel"
+         oncommand="window.close();"/>
+
+    <!-- Command Keys -->
+    <key id="placesKey_find:all"
+         command="OrganizerCommand_find:all"
+         data-l10n-id="places-cmd-find-key"
+         modifiers="accel"/>
+
+    <!-- Back/Forward Keys Support -->
+#ifndef XP_MACOSX
+    <key id="placesKey_goBackKb"
+         keycode="VK_LEFT"
+         command="OrganizerCommand:Back"
+         modifiers="alt"/>
+    <key id="placesKey_goForwardKb"
+         keycode="VK_RIGHT"
+         command="OrganizerCommand:Forward"
+         modifiers="alt"/>
+#else
+    <key id="placesKey_goBackKb"
+         keycode="VK_LEFT"
+         command="OrganizerCommand:Back"
+         modifiers="accel"/>
+    <key id="placesKey_goForwardKb"
+         keycode="VK_RIGHT"
+         command="OrganizerCommand:Forward"
+         modifiers="accel"/>
+#endif
+#ifdef XP_UNIX
+    <key id="placesKey_goBackKb2"
+         data-l10n-id="nav-back-shortcut-alt"
+         command="OrganizerCommand:Back"
+         modifiers="accel"/>
+    <key id="placesKey_goForwardKb2"
+         data-l10n-id="nav-fwd-shortcut-alt"
+         command="OrganizerCommand:Forward"
+         modifiers="accel"/>
+#endif
+  </keyset>
+
+#include ../../../../toolkit/content/editMenuKeys.inc.xhtml
+#ifdef XP_MACOSX
+  <keyset id="editMenuKeysExtra">
+    <key id="key_delete2" keycode="VK_BACK" command="cmd_delete"/>
+  </keyset>
+#endif
+
+  <popupset id="placesPopupset">
+#include placesContextMenu.inc.xhtml
+    <menupopup id="placesColumnsContext"
+               onpopupshowing="ViewMenu.fillWithColumns(event, null, null, 'checkbox', null);"
+               oncommand="ViewMenu.showHideColumn(event.target); event.stopPropagation();"/>
+#include ../../downloads/content/downloadsContextMenu.inc.xhtml
+  </popupset>
+
+  <toolbox id="placesToolbox">
+    <toolbar class="chromeclass-toolbar" id="placesToolbar" align="center">
+      <toolbarbutton id="back-button"
+                     command="OrganizerCommand:Back"
+                     data-l10n-id="places-back-button"
+                     disabled="true"/>
+
+      <toolbarbutton id="forward-button"
+                     command="OrganizerCommand:Forward"
+                     data-l10n-id="places-forward-button"
+                     disabled="true"/>
+
+#ifdef XP_MACOSX
+        <toolbarbutton type="menu" class="tabbable" wantdropmarker="true"
+              onpopupshowing="document.getElementById('placeContent').focus()"
+              data-l10n-id="places-organize-button-mac"
+#else
+      <menubar id="placesMenu">
+        <menu class="menu-iconic" data-l10n-id="places-organize-button"
+#endif
+              id="organizeButton">
+          <menupopup id="organizeButtonPopup">
+            <menuitem id="newbookmark"
+                      command="placesCmd_new:bookmark"
+                      data-l10n-id="places-add-bookmark"/>
+            <menuitem id="newfolder"
+                      command="placesCmd_new:folder"
+                      data-l10n-id="places-add-folder"/>
+            <menuitem id="newseparator"
+                      command="placesCmd_new:separator"
+                      data-l10n-id="places-add-separator"/>
+
+#ifdef XP_MACOSX
+            <menuseparator id="orgDeleteSeparator"/>
+
+            <menuitem id="orgDelete"
+                      command="cmd_delete"
+                      data-l10n-id="text-action-delete"
+                      key="key_delete"/>
+#else
+            <menuseparator id="orgUndoSeparator"/>
+
+            <menuitem id="orgUndo"
+                      command="cmd_undo"
+                      data-l10n-id="text-action-undo"
+                      key="key_undo"/>
+            <menuitem id="orgRedo"
+                      command="cmd_redo"
+                      data-l10n-id="text-action-redo"
+                      key="key_redo"/>
+
+            <menuseparator id="orgCutSeparator"/>
+
+            <menuitem id="orgCut"
+                      command="cmd_cut"
+                      data-l10n-id="text-action-cut"
+                      key="key_cut"
+                      selection="separator|link|folder|mixed"/>
+            <menuitem id="orgCopy"
+                      command="cmd_copy"
+                      data-l10n-id="text-action-copy"
+                      key="key_copy"
+                      selection="separator|link|folder|mixed"/>
+            <menuitem id="orgPaste"
+                      command="cmd_paste"
+                      data-l10n-id="text-action-paste"
+                      key="key_paste"
+                      selection="mutable"/>
+            <menuitem id="orgDelete"
+                      command="cmd_delete"
+                      data-l10n-id="text-action-delete"
+                      key="key_delete"/>
+
+            <menuseparator id="selectAllSeparator"/>
+
+            <menuitem id="orgSelectAll"
+                      command="cmd_selectAll"
+                      data-l10n-id="text-action-select-all"
+                      key="key_selectAll"/>
+
+            <menuseparator id="orgCloseSeparator"/>
+
+            <menuitem id="orgClose"
+                      key="placesKey_close"
+                      data-l10n-id="places-file-close"
+                      oncommand="window.close();"/>
+#endif
+          </menupopup>
+#ifdef XP_MACOSX
+        </toolbarbutton>
+        <toolbarbutton type="menu" class="tabbable" wantdropmarker="true"
+        data-l10n-id="places-view-button-mac"
+#else
+        </menu>
+        <menu class="menu-iconic" data-l10n-id="places-view-button"
+#endif
+              id="viewMenu">
+          <menupopup id="viewMenuPopup">
+
+            <menu id="viewColumns"
+                  data-l10n-id="places-view-menu-columns">
+              <menupopup onpopupshowing="ViewMenu.fillWithColumns(event, null, null, 'checkbox', null);"
+                         oncommand="ViewMenu.showHideColumn(event.target); event.stopPropagation();"/>
+            </menu>
+
+            <menu id="viewSort" data-l10n-id="places-view-menu-sort">
+              <menupopup onpopupshowing="ViewMenu.populateSortMenu(event);"
+                         oncommand="ViewMenu.setSortColumn(event.target.column, null);">
+                <menuitem id="viewUnsorted" type="radio" name="columns"
+                          data-l10n-id="places-view-sort-unsorted"
+                          oncommand="ViewMenu.setSortColumn(null, null);"/>
+                <menuseparator id="directionSeparator"/>
+                <menuitem id="viewSortAscending" type="radio" name="direction"
+                          data-l10n-id="places-view-sort-ascending"
+                          oncommand="ViewMenu.setSortColumn(null, 'ascending'); event.stopPropagation();"/>
+                <menuitem id="viewSortDescending" type="radio" name="direction"
+                          data-l10n-id="places-view-sort-descending"
+                          oncommand="ViewMenu.setSortColumn(null, 'descending'); event.stopPropagation();"/>
+              </menupopup>
+            </menu>
+          </menupopup>
+#ifdef XP_MACOSX
+        </toolbarbutton>
+        <toolbarbutton type="menu" class="tabbable" wantdropmarker="true"
+        data-l10n-id="places-maintenance-button-mac"
+#else
+        </menu>
+        <menu class="menu-iconic" data-l10n-id="places-maintenance-button"
+#endif
+              id="maintenanceButton">
+          <menupopup id="maintenanceButtonPopup">
+            <menuitem id="backupBookmarks"
+                      command="OrganizerCommand_backup"
+                      data-l10n-id="places-cmd-backup"/>
+            <menu id="fileRestoreMenu" data-l10n-id="places-cmd-restore">
+              <menupopup id="fileRestorePopup" onpopupshowing="PlacesOrganizer.populateRestoreMenu();">
+                <menuitem id="restoreFromFile"
+                          command="OrganizerCommand_restoreFromFile"
+                          data-l10n-id="places-cmd-restore-from-file"/>
+              </menupopup>
+            </menu>
+            <menuseparator/>
+            <menuitem id="fileImport"
+                      command="OrganizerCommand_import"
+                      data-l10n-id="places-import-bookmarks-from-html"/>
+            <menuitem id="fileExport"
+                      command="OrganizerCommand_export"
+                      data-l10n-id="places-export-bookmarks-to-html"/>
+            <menuseparator/>
+            <menuitem id="browserImport"
+                      command="OrganizerCommand_browserImport"
+                      data-l10n-id="places-import-other-browser"/>
+          </menupopup>
+#ifdef XP_MACOSX
+        </toolbarbutton>
+#else
+        </menu>
+      </menubar>
+#endif
+
+      <toolbarbutton id="clearDownloadsButton"
+                          data-l10n-id="downloads-clear-downloads-button"
+                          class="tabbable"
+                          command="downloadsCmd_clearDownloads"/>
+
+      <spacer id="libraryToolbarSpacer" flex="1"/>
+
+      <search-textbox id="searchFilter"
+                      flex="1"
+                      aria-controls="placeContent"
+                      oncommand="PlacesSearchBox.search(this.value);"
+                      collection="bookmarks"/>
+    </toolbar>
+  </toolbox>
+
+  <hbox flex="1" id="placesView">
+    <tree id="placesList"
+          class="plain placesTree"
+          is="places-tree"
+          hidecolumnpicker="true" context="placesContext"
+          onselect="PlacesOrganizer.onPlaceSelected(true);"
+          onclick="PlacesOrganizer.onPlacesListClick(event);"
+          onfocus="PlacesOrganizer.updateDetailsPane(event);"
+          seltype="single"
+          persist="width"
+          width="200"
+          minwidth="100"
+          maxwidth="400">
+      <treecols>
+        <treecol anonid="title" flex="1" primary="true" hideheader="true"/>
+      </treecols>
+      <treechildren flex="1"/>
+    </tree>
+    <splitter collapse="none" persist="state"></splitter>
+    <vbox id="contentView" flex="4">
+      <vbox id="placesViewsBox" flex="1">
+        <tree id="placeContent"
+              class="plain placesTree"
+              context="placesContext"
+              hidecolumnpicker="true"
+              flex="1"
+              is="places-tree"
+              flatList="true"
+              selectfirstnode="true"
+              enableColumnDrag="true"
+              onfocus="PlacesOrganizer.updateDetailsPane(event)"
+              onselect="PlacesOrganizer.updateDetailsPane(event)"
+              onkeypress="ContentTree.onKeyPress(event);">
+          <treecols id="placeContentColumns" context="placesColumnsContext">
+            <!--
+              The below code may suggest that 'ordinal' is still a supported XUL
+              attribute. It is not. This is a crutch so that we can continue
+              persisting the CSS -moz-box-ordinal-group attribute, which is the
+              appropriate replacement for the ordinal attribute but cannot yet
+              be easily persisted. The code that synchronizes the attribute with
+              the CSS lives in toolkit/content/widget/tree.js and is specific to
+              tree elements.
+            -->
+            <treecol data-l10n-id="places-view-sort-col-name" id="placesContentTitle" anonid="title" flex="5" primary="true" ordinal="1"
+                      persist="width hidden ordinal sortActive sortDirection"/>
+            <splitter class="tree-splitter"/>
+            <treecol data-l10n-id="places-view-sort-col-tags" id="placesContentTags" anonid="tags" flex="2"
+                      persist="width hidden ordinal sortActive sortDirection"/>
+            <splitter class="tree-splitter"/>
+            <treecol data-l10n-id="places-view-sort-col-url" id="placesContentUrl" anonid="url" flex="5"
+                      persist="width hidden ordinal sortActive sortDirection"/>
+            <splitter class="tree-splitter"/>
+            <treecol data-l10n-id="places-view-sort-col-most-recent-visit" id="placesContentDate" anonid="date" flex="1" hidden="true"
+                      persist="width hidden ordinal sortActive sortDirection"/>
+            <splitter class="tree-splitter"/>
+            <treecol data-l10n-id="places-view-sort-col-visit-count" id="placesContentVisitCount" anonid="visitCount" flex="1" hidden="true"
+                      persist="width hidden ordinal sortActive sortDirection"/>
+            <splitter class="tree-splitter"/>
+            <treecol data-l10n-id="places-view-sort-col-date-added" id="placesContentDateAdded" anonid="dateAdded" flex="1" hidden="true"
+                      persist="width hidden ordinal sortActive sortDirection"/>
+            <splitter class="tree-splitter"/>
+            <treecol data-l10n-id="places-view-sort-col-last-modified" id="placesContentLastModified" anonid="lastModified" flex="1" hidden="true"
+                      persist="width hidden ordinal sortActive sortDirection"/>
+          </treecols>
+          <treechildren flex="1" onclick="ContentTree.onClick(event);"/>
+        </tree>
+        <richlistbox flex="1"
+                     hidden="true"
+                     seltype="multiple"
+                     id="downloadsListBox"
+                     class="allDownloadsListBox"
+                     context="downloadsContextMenu"/>
+      </vbox>
+      <vbox id="detailsPane" style="height: 11em;">
+        <vbox id="itemsCountBox" align="center" flex="1" hidden="true">
+          <spacer flex="3"/>
+          <label id="itemsCountText"/>
+          <spacer flex="1"/>
+          <description id="selectItemDescription" data-l10n-id="places-details-pane-select-an-item-description">
+          </description>
+          <spacer flex="3"/>
+        </vbox>
+        <vbox id="infoBox" flex="1">
+#include editBookmarkPanel.inc.xhtml
+        </vbox>
+      </vbox>
+    </vbox>
+  </hbox>
+</window>
diff --git a/dom/xul/XULPopupElement.cpp b/dom/xul/XULPopupElement.cpp
index 34c7c87e6c..90f265eb13 100644
--- a/dom/xul/XULPopupElement.cpp
+++ b/dom/xul/XULPopupElement.cpp
@@ -208,6 +208,10 @@ void XULPopupElement::GetState(nsString& aState) {
   // set this here in case there's no frame for the popup
   aState.AssignLiteral("closed");
 
+#ifdef MOZ_WIDGET_GTK
+  nsAutoString nativeState;
+#endif
+
   if (nsXULPopupManager* pm = nsXULPopupManager::GetInstance()) {
     switch (pm->GetPopupState(this)) {
       case ePopupShown:
@@ -230,6 +234,11 @@ void XULPopupElement::GetState(nsString& aState) {
         break;
     }
   }
+#ifdef MOZ_WIDGET_GTK
+  else if (GetAttr(kNameSpaceID_None, nsGkAtoms::_moz_nativemenupopupstate, nativeState)) {
+    aState = nativeState;
+  }
+#endif
 }
 
 nsINode* XULPopupElement::GetTriggerNode() const {
diff --git a/dom/xul/moz.build b/dom/xul/moz.build
index bb7e4b08d9..42d4bd9b65 100644
--- a/dom/xul/moz.build
+++ b/dom/xul/moz.build
@@ -82,4 +82,9 @@ LOCAL_INCLUDES += [
 
 include("/ipc/chromium/chromium-config.mozbuild")
 
+if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
+    LOCAL_INCLUDES += [
+        "/widget/gtk",
+    ]
+
 FINAL_LIBRARY = "xul"
diff --git a/layout/build/moz.build b/layout/build/moz.build
index c7869a01a3..2cbdb021b3 100644
--- a/layout/build/moz.build
+++ b/layout/build/moz.build
@@ -70,6 +70,10 @@ elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "android":
         "/dom/system",
         "/dom/system/android",
     ]
+elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
+    LOCAL_INCLUDES += [
+        "/widget/gtk",
+    ]
 
 XPCOM_MANIFESTS += [
     "components.conf",
diff --git a/modules/libpref/Preferences.cpp b/modules/libpref/Preferences.cpp
index 65d2b6b125..ad651009db 100644
--- a/modules/libpref/Preferences.cpp
+++ b/modules/libpref/Preferences.cpp
@@ -93,6 +93,7 @@
 #ifdef MOZ_BACKGROUNDTASKS
 #  include "mozilla/BackgroundTasks.h"
 #endif
+#include "nsKDEUtils.h"
 
 #ifdef DEBUG
 #  include <map>
@@ -4772,6 +4773,17 @@ nsresult Preferences::InitInitialObjects(bool aIsStartup) {
 #endif
   };
 
+  if(nsKDEUtils::kdeSession()) { // TODO what if some setup actually requires the helper?
+    for(int i = 0;
+        i < MOZ_ARRAY_LENGTH(specialFiles);
+        ++i ) {
+      if( *specialFiles[ i ] == '\0' ) {
+        specialFiles[ i ] = "kde.js";
+        break;
+      }
+    }
+  }
+
   rv = pref_LoadPrefsInDir(defaultPrefDir, specialFiles,
                            ArrayLength(specialFiles));
   if (NS_FAILED(rv)) {
@@ -4846,7 +4858,7 @@ nsresult Preferences::InitInitialObjects(bool aIsStartup) {
       }
 
       // Do we care if a file provided by this process fails to load?
-      pref_LoadPrefsInDir(path, nullptr, 0);
+      pref_LoadPrefsInDir(path, specialFiles, ArrayLength(specialFiles));
     }
   }
 
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
index 9db483dc45..c193b1db78 100644
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -299,6 +299,9 @@ pref("dom.mouseevent.click.hack.use_legacy_non-primary_dispatch", "");
 // Fastback caching - if this pref is negative, then we calculate the number
 // of content viewers to cache based on the amount of available memory.
 pref("browser.sessionhistory.max_total_viewers", -1);
+#ifdef MOZ_WIDGET_GTK
+pref("ui.use_unity_menubar", true);
+#endif
 
 pref("browser.display.force_inline_alttext", false); // true = force ALT text for missing images to be layed out inline
 // 0 = no external leading,
diff --git a/modules/libpref/init/all.js.orig b/modules/libpref/init/all.js.orig
new file mode 100644
index 0000000000..9db483dc45
--- /dev/null
+++ b/modules/libpref/init/all.js.orig
@@ -0,0 +1,4587 @@
+// -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// The prefs in this file are shipped with the GRE and should apply to all
+// embedding situations. Application-specific preferences belong somewhere
+// else, such as browser/app/profile/firefox.js or
+// mobile/android/app/mobile.js.
+//
+// NOTE: Not all prefs should be defined in this (or any other) data file.
+// Static prefs are defined in StaticPrefList.yaml. Those prefs should *not*
+// appear in this file.
+//
+// For the syntax used by this file, consult the comments at the top of
+// modules/libpref/parser/src/lib.rs.
+//
+// Please indent all prefs defined within #ifdef/#ifndef conditions. This
+// improves readability, particular for conditional blocks that exceed a single
+// screen.
+
+pref("security.tls.version.min", 3);
+pref("security.tls.version.max", 4);
+pref("security.tls.version.enable-deprecated", false);
+pref("security.tls.version.fallback-limit", 4);
+pref("security.tls.insecure_fallback_hosts", "");
+// Turn off post-handshake authentication for TLS 1.3 by default,
+// until the incompatibility with HTTP/2 is resolved:
+// https://tools.ietf.org/html/draft-davidben-http2-tls13-00
+pref("security.tls.enable_post_handshake_auth", false);
+pref("security.tls.hello_downgrade_check", true);
+pref("security.tls.enable_delegated_credentials", true);
+
+pref("security.ssl.treat_unsafe_negotiation_as_broken", false);
+pref("security.ssl.require_safe_negotiation",  false);
+pref("security.ssl.enable_ocsp_stapling", true);
+pref("security.ssl.enable_false_start", true);
+pref("security.ssl.enable_alpn", true);
+
+pref("security.ssl3.ecdhe_rsa_aes_128_gcm_sha256", true);
+pref("security.ssl3.ecdhe_ecdsa_aes_128_gcm_sha256", true);
+pref("security.ssl3.ecdhe_ecdsa_chacha20_poly1305_sha256", true);
+pref("security.ssl3.ecdhe_rsa_chacha20_poly1305_sha256", true);
+pref("security.ssl3.ecdhe_ecdsa_aes_256_gcm_sha384", true);
+pref("security.ssl3.ecdhe_rsa_aes_256_gcm_sha384", true);
+pref("security.ssl3.ecdhe_rsa_aes_128_sha", true);
+pref("security.ssl3.ecdhe_ecdsa_aes_128_sha", true);
+pref("security.ssl3.ecdhe_rsa_aes_256_sha", true);
+pref("security.ssl3.ecdhe_ecdsa_aes_256_sha", true);
+pref("security.ssl3.dhe_rsa_aes_128_sha", false);
+pref("security.ssl3.dhe_rsa_aes_256_sha", false);
+pref("security.ssl3.rsa_aes_128_sha", true);
+pref("security.ssl3.rsa_aes_256_sha", true);
+pref("security.ssl3.rsa_aes_128_gcm_sha256", true);
+pref("security.ssl3.rsa_aes_256_gcm_sha384", true);
+pref("security.ssl3.deprecated.rsa_des_ede3_sha", true);
+
+pref("security.content.signature.root_hash",
+     "97:E8:BA:9C:F1:2F:B3:DE:53:CC:42:A4:E6:57:7E:D6:4D:F4:93:C2:47:B4:14:FE:A0:36:81:8D:38:23:56:0E");
+
+pref("security.default_personal_cert",   "Ask Every Time");
+pref("security.remember_cert_checkbox_default_setting", true);
+pref("security.ask_for_password",        0);
+pref("security.password_lifetime",       30);
+
+// On Windows 8.1, if the following preference is 2, we will attempt to detect
+// if the Family Safety TLS interception feature has been enabled. If so, we
+// will behave as if the enterprise roots feature has been enabled (i.e. import
+// and trust third party root certificates from the OS).
+// With any other value of the pref or on any other platform, this does nothing.
+// This preference takes precedence over "security.enterprise_roots.enabled".
+pref("security.family_safety.mode", 2);
+
+pref("security.enterprise_roots.enabled", false);
+
+// If true, attempt to load the osclientcerts PKCS#11 module at startup on a
+// background thread. This module allows Firefox to use client certificates
+// stored in OS certificate storage. Currently only available for Windows and
+// macOS.
+pref("security.osclientcerts.autoload", true);
+
+// The supported values of this pref are:
+// 0: do not fetch OCSP
+// 1: fetch OCSP for DV and EV certificates
+// 2: fetch OCSP only for EV certificates
+pref("security.OCSP.enabled", 1);
+pref("security.OCSP.require", false);
+#ifdef RELEASE_OR_BETA
+  pref("security.OCSP.timeoutMilliseconds.soft", 2000);
+#else
+  pref("security.OCSP.timeoutMilliseconds.soft", 1000);
+#endif
+pref("security.OCSP.timeoutMilliseconds.hard", 10000);
+
+pref("security.pki.cert_short_lifetime_in_days", 10);
+// NB: Changes to this pref affect CERT_CHAIN_SHA1_POLICY_STATUS telemetry.
+// See the comment in CertVerifier.cpp.
+// 3 = only allow SHA-1 for certificates issued by an imported root.
+pref("security.pki.sha1_enforcement_level", 3);
+
+// This preference controls what signature algorithms are accepted for signed
+// apps (i.e. add-ons). The number is interpreted as a bit mask with the
+// following semantic:
+// The lowest order bit determines which PKCS#7 algorithms are accepted.
+// xxx_0_: SHA-1 and/or SHA-256 PKCS#7 allowed
+// xxx_1_: SHA-256 PKCS#7 allowed
+// The next two bits determine whether COSE is required and PKCS#7 is allowed
+// x_00_x: COSE disabled, ignore files, PKCS#7 must verify
+// x_01_x: COSE is verified if present, PKCS#7 must verify
+// x_10_x: COSE is required, PKCS#7 must verify if present
+// x_11_x: COSE is required, PKCS#7 disabled (fail when present)
+pref("security.signed_app_signatures.policy", 2);
+
+// security.pki.netscape_step_up_policy controls how the platform handles the
+// id-Netscape-stepUp OID in extended key usage extensions of CA certificates.
+// 0: id-Netscape-stepUp is always considered equivalent to id-kp-serverAuth
+// 1: it is considered equivalent when the notBefore is before 23 August 2016
+// 2: similarly, but for 23 August 2015
+// 3: it is never considered equivalent
+#ifdef RELEASE_OR_BETA
+  pref("security.pki.netscape_step_up_policy", 1);
+#else
+  pref("security.pki.netscape_step_up_policy", 2);
+#endif
+
+// Configures Certificate Transparency support mode:
+// 0: Fully disabled.
+// 1: Only collect telemetry. CT qualification checks are not performed.
+pref("security.pki.certificate_transparency.mode", 0);
+
+// Only one of ["enable_softtoken", "enable_usbtoken",
+// "webauthn_enable_android_fido2"] should be true at a time, as the
+// softtoken will override the other two. Note android's pref is set in
+// mobile.js / geckoview-prefs.js
+pref("security.webauth.webauthn_enable_softtoken", false);
+
+#ifdef MOZ_WIDGET_ANDROID
+  // the Rust usbtoken support does not function on Android
+  pref("security.webauth.webauthn_enable_usbtoken", false);
+#else
+  pref("security.webauth.webauthn_enable_usbtoken", true);
+#endif
+
+pref("security.xfocsp.errorReporting.enabled", true);
+pref("security.xfocsp.errorReporting.automatic", false);
+
+// 0: Disable CRLite entirely.
+// 1: Consult CRLite but only collect telemetry.
+// 2: Consult CRLite and enforce both "Revoked" and "Not Revoked" results.
+// 3: Consult CRLite and enforce "Not Revoked" results, but defer to OCSP for "Revoked".
+pref("security.pki.crlite_mode", 3);
+
+// Issuer we use to detect MitM proxies. Set to the issuer of the cert of the
+// Firefox update service. The string format is whatever NSS uses to print a DN.
+// This value is set and cleared automatically.
+pref("security.pki.mitm_canary_issuer", "");
+// Pref to disable the MitM proxy checks.
+pref("security.pki.mitm_canary_issuer.enabled", true);
+
+// It is set to true when a non-built-in root certificate is detected on a
+// Firefox update service's connection.
+// This value is set automatically.
+// The difference between security.pki.mitm_canary_issuer and this pref is that
+// here the root is trusted but not a built-in, whereas for
+// security.pki.mitm_canary_issuer.enabled, the root is not trusted.
+pref("security.pki.mitm_detected", false);
+
+// Intermediate CA Preloading settings
+#if !defined(MOZ_WIDGET_ANDROID)
+  pref("security.remote_settings.intermediates.enabled", true);
+#else
+  pref("security.remote_settings.intermediates.enabled", false);
+#endif
+#if defined(EARLY_BETA_OR_EARLIER) && !defined(MOZ_WIDGET_ANDROID)
+  pref("security.intermediate_preloading_healer.enabled", true);
+#else
+  pref("security.intermediate_preloading_healer.enabled", false);
+#endif
+pref("security.intermediate_preloading_healer.timer_interval_ms", 300000);
+pref("security.remote_settings.intermediates.bucket", "security-state");
+pref("security.remote_settings.intermediates.collection", "intermediates");
+pref("security.remote_settings.intermediates.checked", 0);
+pref("security.remote_settings.intermediates.downloads_per_poll", 5000);
+pref("security.remote_settings.intermediates.parallel_downloads", 8);
+pref("security.remote_settings.intermediates.signer", "onecrl.content-signature.mozilla.org");
+
+#if defined(EARLY_BETA_OR_EARLIER) && !defined(MOZ_WIDGET_ANDROID)
+  pref("security.remote_settings.crlite_filters.enabled", true);
+#else
+  pref("security.remote_settings.crlite_filters.enabled", false);
+#endif
+pref("security.remote_settings.crlite_filters.bucket", "security-state");
+pref("security.remote_settings.crlite_filters.collection", "cert-revocations");
+pref("security.remote_settings.crlite_filters.checked", 0);
+pref("security.remote_settings.crlite_filters.signer", "onecrl.content-signature.mozilla.org");
+
+pref("security.osreauthenticator.blank_password", false);
+pref("security.osreauthenticator.password_last_changed_lo", 0);
+pref("security.osreauthenticator.password_last_changed_hi", 0);
+
+pref("security.crash_tracking.js_load_1.prevCrashes", 0);
+pref("security.crash_tracking.js_load_1.maxCrashes", 0);
+
+pref("general.useragent.compatMode.firefox", false);
+
+pref("general.config.obscure_value", 13); // for MCD .cfg files
+
+#ifndef MOZ_BUILD_APP_IS_BROWSER
+pref("general.warnOnAboutConfig", true);
+#endif
+
+// Whether middle button click with a modifier key starts to autoscroll or
+// does nothing.
+pref("general.autoscroll.prevent_to_start.shiftKey", true); // Shift
+pref("general.autoscroll.prevent_to_start.ctrlKey", false); // Control
+pref("general.autoscroll.prevent_to_start.altKey", false);  // Alt
+pref("general.autoscroll.prevent_to_start.metaKey", false); // Command on macOS
+pref("general.autoscroll.prevent_to_start.osKey", false);   // Windows key on Windows or Super key on Linux
+
+// When this pref is set to true, middle click on non-editable content keeps
+// selected range rather than collapsing selection at the clicked position.
+// This behavior is incompatible with Chrome, so enabling this could cause
+// breaking some web apps.
+// Note that this pref is ignored when "general.autoScroll" is set to false
+// or "middlemouse.paste" is set to true.  For the former case, there is no
+// reason do be incompatible with Chrome.  For the latter case, the selection
+// change is important for "paste" event listeners even if it's non-editable
+// content.
+pref("general.autoscroll.prevent_to_collapse_selection_by_middle_mouse_down", false);
+
+// maximum number of dated backups to keep at any time
+pref("browser.bookmarks.max_backups",       5);
+
+pref("browser.cache.disk_cache_ssl",        true);
+// The half life used to re-compute cache entries frecency in hours.
+pref("browser.cache.frecency_half_life_hours", 6);
+
+// offline cache capacity in kilobytes
+pref("browser.cache.offline.capacity",         512000);
+
+// Don't show "Open with" option on download dialog if true.
+pref("browser.download.forbid_open_with", false);
+
+// Whether or not indexedDB experimental features are enabled.
+pref("dom.indexedDB.experimental", false);
+// Enable indexedDB logging.
+pref("dom.indexedDB.logging.enabled", true);
+// Detailed output in log messages.
+pref("dom.indexedDB.logging.details", true);
+// Enable profiler marks for indexedDB events.
+pref("dom.indexedDB.logging.profiler-marks", false);
+
+// Whether or not File Handle is enabled.
+pref("dom.fileHandle.enabled", true);
+
+// The number of workers per domain allowed to run concurrently.
+// We're going for effectively infinite, while preventing abuse.
+pref("dom.workers.maxPerDomain", 512);
+
+// The amount of time (milliseconds) service workers keep running after each event.
+pref("dom.serviceWorkers.idle_timeout", 30000);
+
+// The amount of time (milliseconds) service workers can be kept running using waitUntil promises
+// or executing "long-running" JS after the "idle_timeout" period has expired.
+pref("dom.serviceWorkers.idle_extended_timeout", 30000);
+
+// The amount of time (milliseconds) an update request is delayed when triggered
+// by a service worker that doesn't control any clients.
+pref("dom.serviceWorkers.update_delay", 1000);
+
+// Enable test for 24 hours update, service workers will always treat last update check time is over 24 hours
+pref("dom.serviceWorkers.testUpdateOverOneDay", false);
+
+// Blacklist of domains of web apps which are not aware of strict keypress
+// dispatching behavior.  This is comma separated list.  If you need to match
+// all sub-domains, you can specify it as "*.example.com".  Additionally, you
+// can limit the path.  E.g., "example.com/foo" means "example.com/foo*".  So,
+// if you need to limit under a directory, the path should end with "/" like
+// "example.com/foo/".  Note that this cannot limit port number for now.
+pref("dom.keyboardevent.keypress.hack.dispatch_non_printable_keys", "www.icloud.com");
+// Pref for end-users and policy to add additional values.
+pref("dom.keyboardevent.keypress.hack.dispatch_non_printable_keys.addl", "");
+
+// Blacklist of domains of web apps which handle keyCode and charCode of
+// keypress events with a path only for Firefox (i.e., broken if we set
+// non-zero keyCode or charCode value to the other).  The format is exactly
+// same as "dom.keyboardevent.keypress.hack.dispatch_non_printable_keys". So,
+// check its explanation for the detail.
+pref("dom.keyboardevent.keypress.hack.use_legacy_keycode_and_charcode", "*.collabserv.com,*.gov.online.office365.us,*.officeapps-df.live.com,*.officeapps.live.com,*.online.office.de,*.partner.officewebapps.cn,*.scniris.com");
+// Pref for end-users and policy to add additional values.
+pref("dom.keyboardevent.keypress.hack.use_legacy_keycode_and_charcode.addl", "");
+
+// Blacklist of domains of web apps which listen for non-primary click events
+// on window global or document. The format is exactly same as
+// "dom.keyboardevent.keypress.hack.dispatch_non_printable_keys". So, check its
+// explanation for the detail.
+pref("dom.mouseevent.click.hack.use_legacy_non-primary_dispatch", "");
+
+// Fastback caching - if this pref is negative, then we calculate the number
+// of content viewers to cache based on the amount of available memory.
+pref("browser.sessionhistory.max_total_viewers", -1);
+
+pref("browser.display.force_inline_alttext", false); // true = force ALT text for missing images to be layed out inline
+// 0 = no external leading,
+// 1 = use external leading only when font provides,
+// 2 = add extra leading both internal leading and external leading are zero
+pref("browser.display.normal_lineheight_calc_control", 2);
+// enable showing image placeholders while image is loading or when image is broken
+pref("browser.display.show_image_placeholders", true);
+// if browser.display.show_image_placeholders is true then this controls whether the loading image placeholder and border is shown or not
+pref("browser.display.show_loading_image_placeholder", false);
+// min font device pixel size at which to turn on high quality
+pref("browser.display.auto_quality_min_font_size", 20);
+
+// See http://whatwg.org/specs/web-apps/current-work/#ping
+pref("browser.send_pings", false);
+pref("browser.send_pings.max_per_link", 1);           // limit the number of pings that are sent per link click
+pref("browser.send_pings.require_same_host", false);  // only send pings to the same host if this is true
+
+pref("browser.helperApps.neverAsk.saveToDisk", "");
+pref("browser.helperApps.neverAsk.openFile", "");
+pref("browser.helperApps.deleteTempFileOnExit", false);
+
+// xxxbsmedberg: where should prefs for the toolkit go?
+pref("browser.chrome.toolbar_tips",         true);
+// max image size for which it is placed in the tab icon for tabbrowser.
+// if 0, no images are used for tab icons for image documents.
+pref("browser.chrome.image_icons.max_size", 1024);
+
+pref("browser.triple_click_selects_paragraph", true);
+
+// Enable fillable forms in the PDF viewer.
+pref("pdfjs.annotationMode", 2);
+
+// Enable JavaScript support in the PDF viewer.
+pref("pdfjs.enableScripting", true);
+
+// Enable XFA form support in the PDF viewer.
+pref("pdfjs.enableXfa", true);
+
+// Disable support for MathML
+pref("mathml.disabled",    false);
+
+// Enable scale transform for stretchy MathML operators. See bug 414277.
+pref("mathml.scale_stretchy_operators.enabled", true);
+
+// Used by ChannelMediaResource to run data callbacks from HTTP channel
+// off the main thread.
+pref("media.omt_data_delivery.enabled", true);
+
+// We'll throttle the download if the download rate is throttle-factor times
+// the estimated playback rate, AND we satisfy the cache readahead_limit
+// above. The estimated playback rate is time_duration/length_in_bytes.
+// This means we'll only throttle the download if there's no concern that
+// throttling would cause us to stop and buffer.
+pref("media.throttle-factor", 2);
+// By default, we'll throttle media download once we've reached the the
+// readahead_limit if the download is fast. This pref toggles the "and the
+// download is fast" check off, so that we can always throttle the download
+// once the readaheadd limit is reached even on a slow network.
+pref("media.throttle-regardless-of-download-rate", false);
+
+// Master HTML5 media volume scale.
+pref("media.volume_scale", "1.0");
+
+// Whether we should play videos opened in a "video document", i.e. videos
+// opened as top-level documents, as opposed to inside a media element.
+pref("media.play-stand-alone", true);
+
+pref("media.hardware-video-decoding.enabled", true);
+
+#ifdef MOZ_WMF
+  pref("media.wmf.dxva.enabled", true);
+  pref("media.wmf.play-stand-alone", true);
+#endif
+pref("media.gmp.decoder.aac", 0);
+pref("media.gmp.decoder.h264", 0);
+
+// GMP storage version number. At startup we check the version against
+// media.gmp.storage.version.observed, and if the versions don't match,
+// we clear storage and set media.gmp.storage.version.observed=expected.
+// This provides a mechanism to clear GMP storage when non-compatible
+// changes are made.
+pref("media.gmp.storage.version.expected", 1);
+
+// Filter what triggers user notifications.
+// See DecoderDoctorDocumentWatcher::ReportAnalysis for details.
+#ifdef NIGHTLY_BUILD
+  pref("media.decoder-doctor.notifications-allowed", "MediaWMFNeeded,MediaWidevineNoWMF,MediaCannotInitializePulseAudio,MediaCannotPlayNoDecoders,MediaUnsupportedLibavcodec,MediaPlatformDecoderNotFound,MediaDecodeError");
+#else
+  pref("media.decoder-doctor.notifications-allowed", "MediaWMFNeeded,MediaWidevineNoWMF,MediaCannotInitializePulseAudio,MediaCannotPlayNoDecoders,MediaUnsupportedLibavcodec,MediaPlatformDecoderNotFound");
+#endif
+pref("media.decoder-doctor.decode-errors-allowed", "");
+pref("media.decoder-doctor.decode-warnings-allowed", "");
+// Whether we report partial failures.
+pref("media.decoder-doctor.verbose", false);
+// URL to report decode issues
+pref("media.decoder-doctor.new-issue-endpoint", "https://webcompat.com/issues/new");
+
+pref("media.videocontrols.picture-in-picture.enabled", false);
+pref("media.videocontrols.picture-in-picture.display-text-tracks.enabled", true);
+pref("media.videocontrols.picture-in-picture.video-toggle.enabled", false);
+pref("media.videocontrols.picture-in-picture.video-toggle.always-show", false);
+pref("media.videocontrols.picture-in-picture.video-toggle.min-video-secs", 45);
+pref("media.videocontrols.picture-in-picture.video-toggle.position", "right");
+pref("media.videocontrols.picture-in-picture.video-toggle.has-used", false);
+pref("media.videocontrols.picture-in-picture.display-text-tracks.size", "medium");
+pref("media.videocontrols.keyboard-tab-to-all-controls", true);
+
+#ifdef MOZ_WEBRTC
+  pref("media.navigator.video.enabled", true);
+  pref("media.navigator.video.default_fps",30);
+  pref("media.navigator.video.use_remb", true);
+  pref("media.navigator.video.use_transport_cc", true);
+  pref("media.peerconnection.video.use_rtx", true);
+  pref("media.peerconnection.video.use_rtx.blocklist", "doxy.me,*.doxy.me");
+  pref("media.navigator.video.use_tmmbr", false);
+  pref("media.navigator.audio.use_fec", true);
+  pref("media.navigator.video.red_ulpfec_enabled", false);
+  pref("media.navigator.video.offer_rtcp_rsize", true);
+
+  #ifdef NIGHTLY_BUILD
+    pref("media.peerconnection.sdp.parser", "sipcc");
+    pref("media.peerconnection.sdp.alternate_parse_mode", "parallel");
+    pref("media.peerconnection.sdp.strict_success", false);
+  #else
+    pref("media.peerconnection.sdp.parser", "sipcc");
+    pref("media.peerconnection.sdp.alternate_parse_mode", "never");
+    pref("media.peerconnection.sdp.strict_success", false);
+  #endif
+
+  pref("media.webrtc.debug.trace_mask", 0);
+  pref("media.webrtc.debug.multi_log", false);
+  pref("media.webrtc.debug.log_file", "");
+  pref("media.webrtc.debug.aec_dump_max_size", 4194304); // 4MB
+
+  pref("media.navigator.video.default_width",0);  // adaptive default
+  pref("media.navigator.video.default_height",0); // adaptive default
+  pref("media.peerconnection.video.enabled", true);
+  pref("media.navigator.video.max_fs", 12288); // Enough for 2048x1536
+  pref("media.navigator.video.max_fr", 60);
+  pref("media.navigator.video.h264.level", 31); // 0x42E01f - level 3.1
+  pref("media.navigator.video.h264.max_br", 0);
+  pref("media.navigator.video.h264.max_mbps", 0);
+  pref("media.peerconnection.video.vp9_enabled", true);
+  pref("media.peerconnection.video.vp9_preferred", false);
+  pref("media.getusermedia.channels", 0);
+  #if defined(ANDROID)
+    pref("media.getusermedia.camera.off_while_disabled.enabled", false);
+    pref("media.getusermedia.microphone.off_while_disabled.enabled", false);
+  #else
+    pref("media.getusermedia.camera.off_while_disabled.enabled", true);
+    pref("media.getusermedia.microphone.off_while_disabled.enabled", false);
+  #endif
+  pref("media.getusermedia.camera.off_while_disabled.delay_ms", 3000);
+  pref("media.getusermedia.microphone.off_while_disabled.delay_ms", 3000);
+  // Desktop is typically VGA capture or more; and qm_select will not drop resolution
+  // below 1/2 in each dimension (or so), so QVGA (320x200) is the lowest here usually.
+  pref("media.peerconnection.video.min_bitrate", 0);
+  pref("media.peerconnection.video.start_bitrate", 0);
+  pref("media.peerconnection.video.max_bitrate", 0);
+  pref("media.peerconnection.video.min_bitrate_estimate", 0);
+  pref("media.peerconnection.video.denoising", false);
+  pref("media.navigator.audio.fake_frequency", 1000);
+  pref("media.navigator.permission.disabled", false);
+  pref("media.navigator.streams.fake", false);
+  pref("media.peerconnection.simulcast", true);
+  pref("media.peerconnection.default_iceservers", "[]");
+  pref("media.peerconnection.ice.loopback", false); // Set only for testing in offline environments.
+  pref("media.peerconnection.ice.tcp", true);
+  pref("media.peerconnection.ice.tcp_so_sock_count", 0); // Disable SO gathering
+  pref("media.peerconnection.ice.link_local", false); // Set only for testing IPV6 in networks that don't assign IPV6 addresses
+  pref("media.peerconnection.ice.force_interface", ""); // Limit to only a single interface
+  pref("media.peerconnection.ice.relay_only", false); // Limit candidates to TURN
+  pref("media.peerconnection.use_document_iceservers", true);
+
+  pref("media.peerconnection.identity.timeout", 10000);
+  pref("media.peerconnection.ice.stun_client_maximum_transmits", 7);
+  pref("media.peerconnection.ice.trickle_grace_period", 5000);
+  pref("media.peerconnection.ice.no_host", false);
+  pref("media.peerconnection.ice.default_address_only", false);
+  // See Bug 1581947 for Android hostname obfuscation
+  #if defined(MOZ_WIDGET_ANDROID)
+    pref("media.peerconnection.ice.obfuscate_host_addresses", false);
+  #else
+    pref("media.peerconnection.ice.obfuscate_host_addresses", true);
+  #endif
+  pref("media.peerconnection.ice.obfuscate_host_addresses.blocklist", "");
+  pref("media.peerconnection.ice.proxy_only_if_behind_proxy", false);
+  pref("media.peerconnection.ice.proxy_only", false);
+  pref("media.peerconnection.turn.disable", false);
+
+  // 770 = DTLS 1.0, 771 = DTLS 1.2, 772 = DTLS 1.3
+pref("media.peerconnection.dtls.version.min", 771);
+#ifdef NIGHTLY_BUILD
+  pref("media.peerconnection.dtls.version.max", 772);
+#else
+  pref("media.peerconnection.dtls.version.max", 771);
+#endif
+
+  // These values (aec, agc, and noise) are from:
+  // third_party/libwebrtc/modules/audio_processing/include/audio_processing.h
+  pref("media.getusermedia.aec_enabled", true);
+  pref("media.getusermedia.aec", 1); // kModerateSuppression
+  pref("media.getusermedia.use_aec_mobile", false);
+  pref("media.getusermedia.residual_echo_enabled", false);
+  pref("media.getusermedia.noise_enabled", true);
+  pref("media.getusermedia.noise", 2); // kHigh
+  pref("media.getusermedia.agc_enabled", true);
+  pref("media.getusermedia.agc", 1); // kAdaptiveDigital
+  pref("media.getusermedia.agc2_forced", true);
+  pref("media.getusermedia.hpf_enabled", true);
+  pref("media.getusermedia.transient_enabled", true);
+#endif // MOZ_WEBRTC
+
+#if !defined(ANDROID)
+  pref("media.getusermedia.screensharing.enabled", true);
+#endif
+
+pref("media.getusermedia.audiocapture.enabled", false);
+
+// WebVTT pseudo element and class support.
+pref("media.webvtt.pseudo.enabled", true);
+
+// WebVTT debug logging.
+pref("media.webvtt.debug.logging", false);
+
+// Whether to allow recording of AudioNodes with MediaRecorder
+pref("media.recorder.audio_node.enabled", false);
+
+// Whether MediaRecorder's video encoder should allow dropping frames in order
+// to keep up under load. Useful for tests but beware of memory consumption!
+pref("media.recorder.video.frame_drops", true);
+
+// Whether to autostart a media element with an |autoplay| attribute.
+// ALLOWED=0, BLOCKED=1, defined in dom/media/Autoplay.idl
+pref("media.autoplay.default", 0);
+
+// By default, don't block WebAudio from playing automatically.
+pref("media.autoplay.block-webaudio", false);
+
+// By default, don't block the media from extension background script.
+pref("media.autoplay.allow-extension-background-pages", true);
+
+// The default number of decoded video frames that are enqueued in
+// MediaDecoderReader's mVideoQueue.
+pref("media.video-queue.default-size", 10);
+
+// The maximum number of queued frames to send to the compositor.
+// By default, send all of them.
+pref("media.video-queue.send-to-compositor-size", 9999);
+
+// Log level for cubeb, the audio input/output system. Valid values are
+// "verbose", "normal" and "" (log disabled).
+pref("media.cubeb.logging_level", "");
+
+pref("media.cubeb.output_voice_routing", true);
+
+// GraphRunner (fixed MediaTrackGraph thread) control
+pref("media.audiograph.single_thread.enabled", true);
+
+// APZ preferences. For documentation/details on what these prefs do, check
+// gfx/layers/apz/src/AsyncPanZoomController.cpp.
+pref("apz.overscroll.stop_velocity_threshold", "0.01");
+pref("apz.overscroll.stretch_factor", "0.35");
+
+pref("apz.zoom-to-focused-input.enabled", true);
+
+pref("formhelper.autozoom.force-disable.test-only", false);
+
+#ifdef XP_MACOSX
+  // Whether to run in native HiDPI mode on machines with "Retina"/HiDPI
+  // display.
+  //   <= 0 : hidpi mode disabled, display will just use pixel-based upscaling.
+  //   == 1 : hidpi supported if all screens share the same backingScaleFactor.
+  //   >= 2 : hidpi supported even with mixed backingScaleFactors (somewhat
+  //          broken).
+  pref("gfx.hidpi.enabled", 2);
+#endif
+
+pref("gfx.color_management.display_profile", "");
+
+pref("gfx.downloadable_fonts.enabled", true);
+pref("gfx.downloadable_fonts.fallback_delay", 3000);
+pref("gfx.downloadable_fonts.fallback_delay_short", 100);
+
+// disable downloadable font cache so that behavior is consistently
+// the uncached load behavior across pages (useful for testing reflow problems)
+pref("gfx.downloadable_fonts.disable_cache", false);
+
+// Do we fire a notification about missing fonts, so the front-end can decide
+// whether to try and do something about it (e.g. download additional fonts)?
+pref("gfx.missing_fonts.notify", false);
+
+// whether to always search all font cmaps during system font fallback
+pref("gfx.font_rendering.fallback.always_use_cmaps", false);
+
+// cache shaped word results
+pref("gfx.font_rendering.wordcache.charlimit", 32);
+
+// cache shaped word results
+pref("gfx.font_rendering.wordcache.maxentries", 10000);
+
+pref("gfx.font_rendering.graphite.enabled", true);
+
+#ifdef XP_WIN
+  pref("gfx.font_rendering.directwrite.use_gdi_table_loading", true);
+#endif
+
+#if defined(XP_WIN)
+  // comma separated list of backends to use in order of preference
+  // e.g., pref("gfx.canvas.azure.backends", "direct2d,skia");
+  pref("gfx.canvas.azure.backends", "direct2d1.1,skia");
+#elif defined(XP_MACOSX)
+  pref("gfx.canvas.azure.backends", "skia");
+#else
+  pref("gfx.canvas.azure.backends", "skia");
+#endif
+pref("gfx.content.azure.backends", "skia");
+
+#ifdef XP_WIN
+  pref("gfx.webrender.flip-sequential", false);
+  pref("gfx.webrender.dcomp-win.enabled", true);
+  pref("gfx.webrender.triple-buffering.enabled", true);
+#endif
+
+// WebRender debugging utilities.
+pref("gfx.webrender.debug.texture-cache", false);
+pref("gfx.webrender.debug.texture-cache.clear-evicted", true);
+pref("gfx.webrender.debug.render-targets", false);
+pref("gfx.webrender.debug.gpu-cache", false);
+pref("gfx.webrender.debug.alpha-primitives", false);
+pref("gfx.webrender.debug.profiler", false);
+pref("gfx.webrender.debug.gpu-time-queries", false);
+pref("gfx.webrender.debug.gpu-sample-queries", false);
+pref("gfx.webrender.debug.disable-batching", false);
+pref("gfx.webrender.debug.epochs", false);
+pref("gfx.webrender.debug.echo-driver-messages", false);
+pref("gfx.webrender.debug.show-overdraw", false);
+pref("gfx.webrender.debug.slow-frame-indicator", false);
+pref("gfx.webrender.debug.picture-caching", false);
+pref("gfx.webrender.debug.force-picture-invalidation", false);
+pref("gfx.webrender.debug.primitives", false);
+pref("gfx.webrender.debug.small-screen", false);
+pref("gfx.webrender.debug.obscure-images", false);
+pref("gfx.webrender.debug.glyph-flashing", false);
+pref("gfx.webrender.debug.capture-profiler", false);
+pref("gfx.webrender.debug.profiler-ui", "Default");
+pref("gfx.webrender.debug.window-visibility", false);
+
+pref("gfx.webrender.multithreading", true);
+#ifdef XP_WIN
+pref("gfx.webrender.pbo-uploads", false);
+pref("gfx.webrender.batched-texture-uploads", true);
+pref("gfx.webrender.draw-calls-for-texture-copy", true);
+#else
+pref("gfx.webrender.pbo-uploads", true);
+pref("gfx.webrender.batched-texture-uploads", false);
+pref("gfx.webrender.draw-calls-for-texture-copy", false);
+#endif
+
+
+pref("accessibility.warn_on_browsewithcaret", true);
+
+pref("accessibility.browsewithcaret_shortcut.enabled", true);
+
+#ifndef XP_MACOSX
+  // Tab focus model bit field:
+  // 1 focuses text controls, 2 focuses other form elements, 4 adds links.
+  // Most users will want 1, 3, or 7.
+  // On OS X, we use Full Keyboard Access system preference,
+  // unless accessibility.tabfocus is set by the user.
+  pref("accessibility.tabfocus", 7);
+  pref("accessibility.tabfocus_applies_to_xul", false);
+#else
+  // Only on mac tabfocus is expected to handle UI widgets as well as web
+  // content.
+  pref("accessibility.tabfocus_applies_to_xul", true);
+#endif
+
+// We follow the "Click in the scrollbar to:" system preference on OS X and
+// "gtk-primary-button-warps-slider" property with GTK (since 2.24 / 3.6),
+// unless this preference is explicitly set.
+#if !defined(XP_MACOSX) && !defined(MOZ_WIDGET_GTK)
+  pref("ui.scrollToClick", 0);
+#endif
+
+// These are some selection-related colors which have no per platform
+// implementation.
+#if !defined(XP_MACOSX)
+pref("ui.textSelectDisabledBackground", "#b0b0b0");
+#endif
+
+// This makes the selection stand out when typeaheadfind is on.
+// Used with nsISelectionController::SELECTION_ATTENTION
+pref("ui.textSelectAttentionBackground", "#38d878");
+pref("ui.textSelectAttentionForeground", "#ffffff");
+
+// This makes the matched text stand out when findbar highlighting is on.
+// Used with nsISelectionController::SELECTION_FIND
+pref("ui.textHighlightBackground", "#ef0fff");
+// The foreground color for the matched text in findbar highlighting
+// Used with nsISelectionController::SELECTION_FIND
+pref("ui.textHighlightForeground", "#ffffff");
+// The background color for :autofill-ed inputs.
+//
+// In the past, we used the following `filter` to paint autofill backgrounds:
+//
+//   grayscale(21%) brightness(88%) contrast(161%) invert(10%) sepia(40%) saturate(206%);
+//
+// but there are some pages where using `filter` caused issues because it
+// changes the z-order (see bug 1687682, bug 1727950).
+//
+// The color is chosen so that you get the same final color on a white
+// background as the filter above (#fffcc8), but with some alpha so as to
+// prevent fully illegible text.
+pref("ui.-moz-autofill-background", "rgba(255, 249, 145, .5)");
+
+// We want the ability to forcibly disable platform a11y, because
+// some non-a11y-related components attempt to bring it up.  See bug
+// 538530 for details about Windows; we have a pref here that allows it
+// to be disabled for performance and testing resons.
+// See bug 761589 for the crossplatform aspect.
+//
+// This pref is checked only once, and the browser needs a restart to
+// pick up any changes.
+//
+// Values are -1 always on. 1 always off, 0 is auto as some platform perform
+// further checks.
+pref("accessibility.force_disabled", 0);
+
+#ifdef XP_WIN
+  // Some accessibility tools poke at windows in the plugin process during
+  // setup which can cause hangs.  To hack around this set
+  // accessibility.delay_plugins to true, you can also try increasing
+  // accessibility.delay_plugin_time if your machine is slow and you still
+  // experience hangs. See bug 781791.
+  pref("accessibility.delay_plugins", false);
+  pref("accessibility.delay_plugin_time", 10000);
+
+  // The COM handler used for Windows e10s performance and live regions.
+  pref("accessibility.handler.enabled", true);
+#endif
+
+pref("focusmanager.testmode", false);
+
+pref("accessibility.usetexttospeech", "");
+
+// Type Ahead Find
+pref("accessibility.typeaheadfind", true);
+// Enable FAYT by pressing / or "
+pref("accessibility.typeaheadfind.manual", true);
+pref("accessibility.typeaheadfind.autostart", true);
+// casesensitive: controls the find bar's case-sensitivity
+//     0 - "never"  (case-insensitive)
+//     1 - "always" (case-sensitive)
+// other - "auto"   (case-sensitive for mixed-case input, insensitive otherwise)
+pref("accessibility.typeaheadfind.casesensitive", 0);
+pref("accessibility.typeaheadfind.linksonly", true);
+pref("accessibility.typeaheadfind.startlinksonly", false);
+// timeout: controls the delay in milliseconds after which the quick-find dialog will close
+//          if no further keystrokes are pressed
+//              set to a zero or negative value to keep dialog open until it's manually closed
+pref("accessibility.typeaheadfind.timeout", 4000);
+pref("accessibility.typeaheadfind.soundURL", "beep");
+pref("accessibility.typeaheadfind.enablesound", true);
+#ifdef XP_MACOSX
+  pref("accessibility.typeaheadfind.prefillwithselection", false);
+#else
+  pref("accessibility.typeaheadfind.prefillwithselection", true);
+#endif
+pref("accessibility.typeaheadfind.matchesCountLimit", 1000);
+pref("findbar.highlightAll", false);
+pref("findbar.entireword", false);
+pref("findbar.iteratorTimeout", 100);
+// matchdiacritics: controls the find bar's diacritic matching
+//     0 - "never"  (ignore diacritics)
+//     1 - "always" (match diacritics)
+// other - "auto"   (match diacritics if input has diacritics, ignore otherwise)
+pref("findbar.matchdiacritics", 0);
+pref("findbar.modalHighlight", false);
+
+// use Mac OS X Appearance panel text smoothing setting when rendering text, disabled by default
+pref("gfx.use_text_smoothing_setting", false);
+
+// Number of characters to consider emphasizing for rich autocomplete results
+pref("toolkit.autocomplete.richBoundaryCutoff", 200);
+
+// Variable controlling logging for osfile.
+pref("toolkit.osfile.log", false);
+
+pref("toolkit.scrollbox.smoothScroll", true);
+pref("toolkit.scrollbox.scrollIncrement", 20);
+pref("toolkit.scrollbox.clickToScroll.scrollDelay", 150);
+
+// Controls logging for Sqlite.jsm.
+pref("toolkit.sqlitejsm.loglevel", "Error");
+
+pref("toolkit.tabbox.switchByScrolling", false);
+
+// Telemetry settings.
+// Server to submit telemetry pings to.
+pref("toolkit.telemetry.server", "https://incoming.telemetry.mozilla.org");
+// Telemetry server owner. Please change if you set toolkit.telemetry.server to a different server
+pref("toolkit.telemetry.server_owner", "Mozilla");
+// Determines whether full SQL strings are returned when they might contain sensitive info
+// i.e. dynamically constructed SQL strings or SQL executed by addons against addon DBs
+pref("toolkit.telemetry.debugSlowSql", false);
+// Whether to use the unified telemetry behavior, requires a restart.
+pref("toolkit.telemetry.unified", true);
+// AsyncShutdown delay before crashing in case of shutdown freeze
+#if !defined(MOZ_ASAN) && !defined(MOZ_TSAN)
+  pref("toolkit.asyncshutdown.crash_timeout", 60000); // 1 minute
+#else
+  // ASan and TSan builds can be considerably slower. Extend the grace period
+  // of both asyncshutdown and the terminator.
+  #if defined(MOZ_TSAN)
+    pref("toolkit.asyncshutdown.crash_timeout", 360000); // 6 minutes
+  #else
+    pref("toolkit.asyncshutdown.crash_timeout", 300000); // 5 minutes
+  #endif
+#endif // !defined(MOZ_ASAN) && !defined(MOZ_TSAN)
+// Extra logging for AsyncShutdown barriers and phases
+pref("toolkit.asyncshutdown.log", false);
+
+// Enable JS dump() function.
+// IMPORTANT: These prefs must be here even though they're also defined in
+// StaticPrefList.yaml. They are required because MOZILLA_OFFICIAL is false in
+// local full builds but true in artifact builds. Without these definitions
+// here, dumping is disabled in artifact builds (see Bug 1490412).
+#ifdef MOZILLA_OFFICIAL
+  pref("browser.dom.window.dump.enabled", false, sticky);
+  pref("devtools.console.stdout.chrome", false, sticky);
+#else
+  pref("browser.dom.window.dump.enabled", true, sticky);
+  pref("devtools.console.stdout.chrome", true, sticky);
+#endif
+
+pref("devtools.console.stdout.content", false, sticky);
+
+// Controls whether EventEmitter module throws dump message on each emit
+pref("toolkit.dump.emit", false);
+
+// Preferences for the new performance panel. Note that some preferences are duplicated
+// with a ".remote" postfix. This is because we have one set of preference for local
+// profiling, and a second set for remote profiling.
+
+// This pref configures the base URL for the profiler.firefox.com instance to
+// use. This is useful so that a developer can change it while working on
+// profiler.firefox.com, or in tests. This isn't exposed directly to the user.
+pref("devtools.performance.recording.ui-base-url", "https://profiler.firefox.com");
+// When gathering profiles from child processes, this is the longest time (in
+// seconds) allowed between two responses. 0 = Use internal default.
+pref("devtools.performance.recording.child.timeout_s", 0);
+// The popup is only enabled by default on Nightly, Dev Edition, and debug buildsd since
+// it's a developer focused item. It can still be enabled by going to profiler.firefox.com,
+// but by default it is off on Release and Beta. Note that this only adds it to the
+// the customization palette, not to the navbar.
+#if defined(NIGHTLY_BUILD) || defined(MOZ_DEV_EDITION) || defined(DEBUG)
+  pref("devtools.performance.popup.feature-flag", true);
+#else
+  pref("devtools.performance.popup.feature-flag", false);
+#endif
+// The preset to use for the recording settings. If set to "custom" then the pref
+// values below will be used.
+#if defined(NIGHTLY_BUILD) || !defined(MOZILLA_OFFICIAL)
+  // Use a more advanced preset on Nightly and local builds.
+  pref("devtools.performance.recording.preset", "firefox-platform");
+  pref("devtools.performance.recording.preset.remote", "firefox-platform");
+#else
+  pref("devtools.performance.recording.preset", "web-developer");
+  pref("devtools.performance.recording.preset.remote", "web-developer");
+#endif
+// The profiler's active tab view has a few issues. Disable it in most
+// environments until the issues are ironed out.
+#if defined(NIGHTLY_BUILD)
+  pref("devtools.performance.recording.active-tab-view.enabled", true);
+#else
+  pref("devtools.performance.recording.active-tab-view.enabled", false);
+#endif
+// Profiler buffer size. It is the maximum number of 8-bytes entries in the
+// profiler's buffer. 10000000 is ~80mb.
+pref("devtools.performance.recording.entries", 10000000);
+pref("devtools.performance.recording.entries.remote", 10000000);
+// Profiler interval in microseconds. 1000s is 1ms
+pref("devtools.performance.recording.interval", 1000);
+pref("devtools.performance.recording.interval.remote", 1000);
+// Profiler duration of entries in the profiler's buffer in seconds.
+// `0` means no time limit for the markers, they roll off naturally from the
+// circular buffer.
+pref("devtools.performance.recording.duration", 0);
+pref("devtools.performance.recording.duration.remote", 0);
+// Profiler feature set. See tools/profiler/core/platform.cpp for features and
+// explanations. Remote profiling also includes the java feature by default.
+// If the remote debuggee isn't an Android phone, then this feature will
+// be ignored.
+pref("devtools.performance.recording.features", "[\"js\",\"leaf\",\"stackwalk\",\"cpu\",\"screenshots\"]");
+pref("devtools.performance.recording.features.remote", "[\"js\",\"leaf\",\"stackwalk\",\"cpu\",\"screenshots\",\"java\"]");
+// Threads to be captured by the profiler.
+pref("devtools.performance.recording.threads", "[\"GeckoMain\",\"Compositor\",\"Renderer\"]");
+pref("devtools.performance.recording.threads.remote", "[\"GeckoMain\",\"Compositor\",\"Renderer\"]");
+// A JSON array of strings, where each string is a file path to an objdir on
+// the host machine. This is used in order to look up symbol information from
+// build artifacts of local builds.
+pref("devtools.performance.recording.objdirs", "[]");
+// The popup will display some introductory text the first time it is displayed.
+pref("devtools.performance.popup.intro-displayed", false);
+
+// Compatibility preferences
+// Stringified array of target browsers that users investigate.
+pref("devtools.inspector.compatibility.target-browsers", "");
+
+// Storage preferencex
+// Force instancing legacy storage actors
+pref("devtools.storage.test.forceLegacyActors", false);
+
+// view source
+pref("view_source.editor.path", "");
+// allows to add further arguments to the editor; use the %LINE% placeholder
+// for jumping to a specific line (e.g. "/line:%LINE%" or "--goto %LINE%")
+pref("view_source.editor.args", "");
+
+// whether or not to draw images while dragging
+pref("nglayout.enable_drag_images", true);
+
+// URI fixup prefs
+pref("browser.fixup.alternate.enabled", true);
+pref("browser.fixup.alternate.prefix", "www.");
+pref("browser.fixup.alternate.protocol", "https");
+pref("browser.fixup.alternate.suffix", ".com");
+pref("browser.fixup.fallback-to-https", true);
+
+// NOTE: On most platforms we save print settins to prefs with the name of the
+// printer in the pref name (Android being the notable exception, where prefs
+// are saved "globally" without a printer name in the pref name).  For those
+// platforms, the prefs below simply act as default values for when we
+// encounter a printer for the first time, but only a subset of prefs will be
+// used in this case.  See nsPrintSettingsService::InitPrintSettingsFromPrefs
+// for the restrictions on which prefs can act as defaults.
+
+// Whether we directly use the system print dialog to collect the user's print
+// settings rather than using the tab-modal print preview dialog.
+// Note: `print.always_print_silent` overrides this.
+pref("print.prefer_system_dialog", false);
+
+// Print/Preview Shrink-To-Fit won't shrink below 20% for text-ish documents.
+pref("print.shrink-to-fit.scale-limit-percent", 20);
+
+// Whether we should display simplify page checkbox on print preview UI
+pref("print.use_simplify_page", false);
+
+// Whether or not to force the Page Setup submenu of the File menu to shown
+pref("print.show_page_setup_menu", false);
+
+// Print header customization
+// Use the following codes:
+// &T - Title
+// &U - Document URL
+// &D - Date/Time
+// &P - Page Number
+// &PT - Page Number "of" Page total
+// Set each header to a string containing zero or one of these codes
+// and the code will be replaced in that string by the corresponding data
+pref("print.print_headerleft", "&T");
+pref("print.print_headercenter", "");
+pref("print.print_headerright", "&U");
+pref("print.print_footerleft", "&PT");
+pref("print.print_footercenter", "");
+pref("print.print_footerright", "&D");
+
+// A list of comma separated key:value pairs, so:
+//
+//   key1:value1,key2:value2
+//
+// Which allows testing extra CUPS-related printer settings for monochrome
+// printing.
+pref("print.cups.monochrome.extra_settings", "");
+
+// xxxbsmedberg: more toolkit prefs
+
+// Save the Printings after each print job
+pref("print.save_print_settings", true);
+
+// Enables the "more settings" in Print Preview to match previous
+// configuration.
+pref("print.more-settings.open", false);
+
+// Enables you to specify a user unwriteable margin, if a printer's actual
+// unwriteable margin is greater than this the printer one will be used.
+// This is used by both Printing and Print Preview
+// Units are in 1/100ths of an inch.
+pref("print.print_edge_top", 0);
+pref("print.print_edge_left", 0);
+pref("print.print_edge_right", 0);
+pref("print.print_edge_bottom", 0);
+
+// Should this just be checking for MOZ_WIDGET_GTK?
+#if defined(ANDROID) || defined(XP_UNIX) && !defined(XP_MACOSX)
+  pref("print.print_reversed", false);
+  // This is the default. Probably just remove this.
+  pref("print.print_in_color", true);
+#endif
+
+// Scripts & Windows prefs
+pref("dom.beforeunload_timeout_ms",         1000);
+pref("dom.disable_window_flip",             false);
+pref("dom.disable_window_move_resize",      false);
+
+pref("dom.allow_scripts_to_close_windows",          false);
+
+pref("dom.popup_allowed_events", "change click dblclick auxclick mousedown mouseup pointerdown pointerup notificationclick reset submit touchend contextmenu");
+
+pref("dom.serviceWorkers.disable_open_click_delay", 1000);
+
+pref("dom.storage.enabled", true);
+pref("dom.storage.shadow_writes", true);
+pref("dom.storage.snapshot_prefill", 16384);
+pref("dom.storage.snapshot_gradual_prefill", 4096);
+pref("dom.storage.snapshot_reusing", true);
+pref("dom.storage.client_validation", true);
+
+pref("dom.send_after_paint_to_content", false);
+
+// Enable time picker UI. By default, disabled.
+pref("dom.forms.datetime.timepicker", false);
+
+// Enable search in <select> dropdowns (more than 40 options)
+pref("dom.forms.selectSearch", false);
+// Allow for webpages to provide custom styling for <select>
+// popups. Disabled on GTK due to bug 1338283.
+#ifdef MOZ_WIDGET_GTK
+  pref("dom.forms.select.customstyling", false);
+#else
+  pref("dom.forms.select.customstyling", true);
+#endif
+
+pref("dom.cycle_collector.incremental", true);
+
+// Disable popups from plugins by default
+//   0 = openAllowed
+//   1 = openControlled
+//   2 = openBlocked
+//   3 = openAbused
+pref("privacy.popups.disable_from_plugins", 3);
+
+// If enabled by privacy.resistFingerprinting.testGranularityMask, list of
+// domains exempted from RFP.
+pref("privacy.resistFingerprinting.exemptedDomains", "*.example.invalid");
+
+// Fix cookie blocking breakage by providing ephemeral Paritioned LocalStorage
+// for a list of hosts when detected as trackers.
+// (See nsICookieService::BEHAVIOR_REJECT_TRACKER cookie behavior)
+// See: Bug 1505212, Bug 1659394, Bug 1631811, Bug 1665035.
+pref("privacy.restrict3rdpartystorage.partitionedHosts", "accounts.google.com/o/oauth2/,d35nw2lg0ahg0v.cloudfront.net/,datastudio.google.com/embed/reporting/,d3qlaywcwingl6.cloudfront.net/");
+
+// If a host is contained in this pref list, user-interaction is required
+// before granting the storage access permission.
+pref("privacy.restrict3rdpartystorage.userInteractionRequiredForHosts", "");
+
+// The url decoration tokens used to for stripping document referrers based on.
+// A list separated by spaces.  This pref isn't meant to be changed by users.
+pref("privacy.restrict3rdpartystorage.url_decorations", "");
+
+// Excessive reporting of blocked popups can be a DOS vector,
+// by overloading the main process as popups get blocked and when
+// users try to restore all popups, which is the most visible
+// option in our UI at the time of writing.
+// We will invisibly drop any popups from a page that has already
+// opened more than this number of popups.
+pref("privacy.popups.maxReported", 100);
+
+// Purging first-party tracking cookies.
+pref("privacy.purge_trackers.enabled", true);
+#ifdef NIGHTLY_BUILD
+  pref("privacy.purge_trackers.logging.level", "Warn");
+#else
+  pref("privacy.purge_trackers.logging.level", "Error");
+#endif
+
+// Allowable amount of cookies to purge in a batch.
+pref("privacy.purge_trackers.max_purge_count", 100);
+
+// Whether purging should not clear data from domains
+// that are associated with other domains which have
+// user interaction (even if they don't have user
+// interaction directly).
+pref("privacy.purge_trackers.consider_entity_list", false);
+
+pref("dom.event.contextmenu.enabled",       true);
+
+pref("javascript.enabled",                  true);
+pref("javascript.options.asmjs",                  true);
+pref("javascript.options.wasm",                   true);
+pref("javascript.options.wasm_trustedprincipals", true);
+pref("javascript.options.wasm_verbose",           false);
+pref("javascript.options.wasm_baselinejit",       true);
+
+pref("javascript.options.parallel_parsing", true);
+pref("javascript.options.source_pragmas",    true);
+
+pref("javascript.options.asyncstack", true);
+// Broadly capturing async stack data adds overhead that is only advisable for
+// developers, so we only enable it when the devtools are open, by default.
+pref("javascript.options.asyncstack_capture_debuggee_only", true);
+
+pref("javascript.options.throw_on_asmjs_validation_failure", false);
+// This preference instructs the JS engine to discard the
+// source of any privileged JS after compilation. This saves
+// memory, but makes things like Function.prototype.toSource()
+// fail.
+pref("javascript.options.discardSystemSource", false);
+
+// Many of the the following preferences tune the SpiderMonkey GC, if you
+// change the defaults here please also consider changing them in
+// js/src/jsgc.cpp.  They're documented in js/src/jsapi.h.
+
+// JSGC_MAX_BYTES
+// SpiderMonkey defaults to 2^32-1 bytes, but this is measured in MB so that
+// cannot be represented directly in order to show it in about:config.
+pref("javascript.options.mem.max", -1);
+
+// JSGC_MIN_NURSERY_BYTES / JSGC_MAX_NURSERY_BYTES
+#if defined(ANDROID) || defined(XP_IOS)
+  pref("javascript.options.mem.nursery.min_kb", 256);
+  pref("javascript.options.mem.nursery.max_kb", 4096);
+#else
+  pref("javascript.options.mem.nursery.min_kb", 256);
+  pref("javascript.options.mem.nursery.max_kb", 16384);
+#endif
+
+// JSGC_MODE
+pref("javascript.options.mem.gc_per_zone", true);
+pref("javascript.options.mem.gc_incremental", true);
+
+// JSGC_INCREMENTAL_WEAKMAP_ENABLED
+pref("javascript.options.mem.incremental_weakmap", true);
+
+// JSGC_SLICE_TIME_BUDGET_MS
+// Override the shell's default of unlimited slice time.
+pref("javascript.options.mem.gc_incremental_slice_ms", 5);
+
+// JSGC_COMPACTING_ENABLED
+pref("javascript.options.mem.gc_compacting", true);
+
+// JSGC_HIGH_FREQUENCY_TIME_LIMIT
+pref("javascript.options.mem.gc_high_frequency_time_limit_ms", 1000);
+
+// JSGC_SMALL_HEAP_SIZE_MAX
+pref("javascript.options.mem.gc_small_heap_size_max_mb", 100);
+
+// JSGC_LARGE_HEAP_SIZE_MIN
+pref("javascript.options.mem.gc_large_heap_size_min_mb", 500);
+
+// JSGC_HIGH_FREQUENCY_SMALL_HEAP_GROWTH
+pref("javascript.options.mem.gc_high_frequency_small_heap_growth", 300);
+
+// JSGC_HIGH_FREQUENCY_LARGE_HEAP_GROWTH
+pref("javascript.options.mem.gc_high_frequency_large_heap_growth", 150);
+
+// JSGC_LOW_FREQUENCY_HEAP_GROWTH
+pref("javascript.options.mem.gc_low_frequency_heap_growth", 150);
+
+// JSGC_ALLOCATION_THRESHOLD
+pref("javascript.options.mem.gc_allocation_threshold_mb", 27);
+
+// JSGC_MALLOC_THRESHOLD_BASE
+pref("javascript.options.mem.gc_malloc_threshold_base_mb", 38);
+
+// JSGC_SMALL_HEAP_INCREMENTAL_LIMIT
+pref("javascript.options.mem.gc_small_heap_incremental_limit", 140);
+
+// JSGC_LARGE_HEAP_INCREMENTAL_LIMIT
+pref("javascript.options.mem.gc_large_heap_incremental_limit", 110);
+
+// JSGC_URGENT_THRESHOLD_MB
+pref("javascript.options.mem.gc_urgent_threshold_mb", 16);
+
+// JSGC_MIN_EMPTY_CHUNK_COUNT
+pref("javascript.options.mem.gc_min_empty_chunk_count", 1);
+
+// JSGC_MAX_EMPTY_CHUNK_COUNT
+pref("javascript.options.mem.gc_max_empty_chunk_count", 30);
+
+// JSGC_HELPER_THREAD_RATIO
+pref("javascript.options.mem.gc_helper_thread_ratio", 50);
+
+// JSGC_MAX_HELPER_THREADS
+pref("javascript.options.mem.gc_max_helper_threads", 8);
+
+pref("javascript.options.shared_memory", true);
+
+pref("javascript.options.throw_on_debuggee_would_run", false);
+pref("javascript.options.dump_stack_on_debuggee_would_run", false);
+
+// Dynamic module import.
+pref("javascript.options.dynamicImport", true);
+
+// advanced prefs
+pref("image.animation_mode",                "normal");
+
+// If this pref is true, prefs in the logging.config branch will be cleared on
+// startup. This is done so that setting a log-file and log-modules at runtime
+// doesn't persist across restarts leading to huge logfile and low disk space.
+pref("logging.config.clear_on_startup", true);
+
+// If there is ever a security firedrill that requires
+// us to block certian ports global, this is the pref
+// to use.  Is is a comma delimited list of port numbers
+// for example:
+//   pref("network.security.ports.banned", "1,2,3,4,5");
+// prevents necko connecting to ports 1-5 unless the protocol
+// overrides.
+
+// Transmit UDP busy-work to the LAN when anticipating low latency
+// network reads and on wifi to mitigate 802.11 Power Save Polling delays
+pref("network.tickle-wifi.enabled", false);
+pref("network.tickle-wifi.duration", 400);
+pref("network.tickle-wifi.delay", 16);
+
+// Default action for unlisted external protocol handlers
+pref("network.protocol-handler.external-default", true);      // OK to load
+pref("network.protocol-handler.warn-external-default", true); // warn before load
+
+// Prevent using external protocol handlers for these schemes
+pref("network.protocol-handler.external.hcp", false);
+pref("network.protocol-handler.external.vbscript", false);
+pref("network.protocol-handler.external.javascript", false);
+pref("network.protocol-handler.external.data", false);
+pref("network.protocol-handler.external.ie.http", false);
+pref("network.protocol-handler.external.iehistory", false);
+pref("network.protocol-handler.external.ierss", false);
+pref("network.protocol-handler.external.mk", false);
+pref("network.protocol-handler.external.ms-help", false);
+pref("network.protocol-handler.external.res", false);
+pref("network.protocol-handler.external.shell", false);
+pref("network.protocol-handler.external.vnd.ms.radio", false);
+#ifdef XP_MACOSX
+  pref("network.protocol-handler.external.help", false);
+#endif
+pref("network.protocol-handler.external.disk", false);
+pref("network.protocol-handler.external.disks", false);
+pref("network.protocol-handler.external.afp", false);
+pref("network.protocol-handler.external.moz-icon", false);
+
+// Don't allow  external protocol handlers for common typos
+pref("network.protocol-handler.external.ttp", false);  // http
+pref("network.protocol-handler.external.htp", false);  // http
+pref("network.protocol-handler.external.ttps", false); // https
+pref("network.protocol-handler.external.tps", false);  // https
+pref("network.protocol-handler.external.ps", false);   // https
+pref("network.protocol-handler.external.htps", false); // https
+pref("network.protocol-handler.external.ile", false);  // file
+pref("network.protocol-handler.external.le", false);   // file
+
+// An exposed protocol handler is one that can be used in all contexts.  A
+// non-exposed protocol handler is one that can only be used internally by the
+// application.  For example, a non-exposed protocol would not be loaded by the
+// application in response to a link click or a X-remote openURL command.
+// Instead, it would be deferred to the system's external protocol handler.
+// Only internal/built-in protocol handlers can be marked as exposed.
+
+// This pref controls the default settings.  Per protocol settings can be used
+// to override this value.
+pref("network.protocol-handler.expose-all", true);
+
+// Example: make IMAP an exposed protocol
+// pref("network.protocol-handler.expose.imap", true);
+
+// Whether IOService.connectivity and NS_IsOffline depends on connectivity status
+pref("network.manage-offline-status", true);
+
+// <http>
+pref("network.http.version", "1.1");      // default
+// pref("network.http.version", "1.0");   // uncomment this out in case of problems
+// pref("network.http.version", "0.9");   // it'll work too if you're crazy
+// keep-alive option is effectively obsolete. Nevertheless it'll work with
+// some older 1.0 servers:
+
+pref("network.http.proxy.version", "1.1");    // default
+// pref("network.http.proxy.version", "1.0"); // uncomment this out in case of problems
+                                              // (required if using junkbuster proxy)
+
+// Whether we should respect the BE_CONSERVATIVE (aka nsIHttpChannelInternal.beConservative)
+// flag when connecting to a proxy.  If the configured proxy accepts only TLS 1.3, system
+// requests like updates will not pass through.  Setting this pref to false will fix that
+// problem.
+// Default at true to preserve the behavior we had before for backward compat.
+pref("network.http.proxy.respect-be-conservative", true);
+
+// this preference can be set to override the socket type used for normal
+// HTTP traffic.  an empty value indicates the normal TCP/IP socket type.
+pref("network.http.default-socket-type", "");
+
+// There is a problem with some IIS7 servers that don't close the connection
+// properly after it times out (bug #491541). Default timeout on IIS7 is
+// 120 seconds. We need to reuse or drop the connection within this time.
+// We set the timeout a little shorter to keep a reserve for cases when
+// the packet is lost or delayed on the route.
+pref("network.http.keep-alive.timeout", 115);
+
+// Timeout connections if an initial response is not received after 5 mins.
+pref("network.http.response.timeout", 300);
+
+// Limit the absolute number of http connections.
+// Note: the socket transport service will clamp the number below this if the OS
+// cannot allocate that many FDs
+#ifdef ANDROID
+  pref("network.http.max-connections", 40);
+#else
+  pref("network.http.max-connections", 900);
+#endif
+
+// If NOT connecting via a proxy, then
+// a new connection will only be attempted if the number of active persistent
+// connections to the server is less then max-persistent-connections-per-server.
+pref("network.http.max-persistent-connections-per-server", 6);
+
+// Number of connections that we can open beyond the standard parallelism limit defined
+// by max-persistent-connections-per-server/-proxy to handle urgent-start marked requests
+pref("network.http.max-urgent-start-excessive-connections-per-host", 3);
+
+// If connecting via a proxy, then a
+// new connection will only be attempted if the number of active persistent
+// connections to the proxy is less then max-persistent-connections-per-proxy.
+pref("network.http.max-persistent-connections-per-proxy", 32);
+
+// amount of time (in seconds) to suspend pending requests, before spawning a
+// new connection, once the limit on the number of persistent connections per
+// host has been reached.  however, a new connection will not be created if
+// max-connections or max-connections-per-server has also been reached.
+pref("network.http.request.max-start-delay", 10);
+
+// If a connection is reset, we will retry it max-attempts times.
+pref("network.http.request.max-attempts", 10);
+
+// Maximum number of consecutive redirects before aborting.
+pref("network.http.redirection-limit", 20);
+
+// Enable http compression: comment this out in case of problems with 1.1
+// NOTE: support for "compress" has been disabled per bug 196406.
+// NOTE: separate values with comma+space (", "): see bug 576033
+pref("network.http.accept-encoding", "gzip, deflate");
+pref("network.http.accept-encoding.secure", "gzip, deflate, br");
+
+// Prompt for redirects resulting in unsafe HTTP requests
+pref("network.http.prompt-temp-redirect", false);
+
+// If true generate CORRUPTED_CONTENT errors for entities that
+// contain an invalid Assoc-Req response header
+pref("network.http.assoc-req.enforce", false);
+
+// On networks deploying QoS, it is recommended that these be lockpref()'d,
+// since inappropriate marking can easily overwhelm bandwidth reservations
+// for certain services (i.e. EF for VoIP, AF4x for interactive video,
+// AF3x for broadcast/streaming video, etc)
+
+// default value for HTTP
+// in a DSCP environment this should be 40 (0x28, or AF11), per RFC-4594,
+// Section 4.8 "High-Throughput Data Service Class"
+pref("network.http.qos", 0);
+
+// The number of milliseconds after sending a SYN for an HTTP connection,
+// to wait before trying a different connection. 0 means do not use a second
+// connection.
+pref("network.http.connection-retry-timeout", 250);
+
+// The number of seconds after sending initial SYN for an HTTP connection
+// to give up if the OS does not give up first
+pref("network.http.connection-timeout", 90);
+
+// Close a connection if tls handshake does not finish in given number of
+// seconds.
+pref("network.http.tls-handshake-timeout", 30);
+
+// The number of seconds after which we time out a connection of a retry (fallback)
+// socket when a certain IP family is already preferred.  This shorter connection
+// timeout allows us to find out more quickly that e.g. an IPv6 host is no longer
+// available and let us try an IPv4 address, if provided for the host name.
+// Set to '0' to use the default connection timeout.
+pref("network.http.fallback-connection-timeout", 5);
+
+// The number of seconds to allow active connections to prove that they have
+// traffic before considered stalled, after a network change has been detected
+// and signalled.
+pref("network.http.network-changed.timeout", 5);
+
+// The maximum number of current global half open sockets allowable
+// when starting a new speculative connection.
+pref("network.http.speculative-parallel-limit", 6);
+
+// Whether or not to block requests for non head js/css items (e.g. media)
+// while those elements load.
+pref("network.http.rendering-critical-requests-prioritization", true);
+
+// Disable IPv6 for backup connections to workaround problems about broken
+// IPv6 connectivity.
+pref("network.http.fast-fallback-to-IPv4", true);
+
+// Http3 qpack table size.
+pref("network.http.http3.default-qpack-table-size", 65536); // 64k
+// Maximal number of streams that can be blocked on waiting for qpack
+// instructions.
+pref("network.http.http3.default-max-stream-blocked", 20);
+
+
+// This is only for testing!
+// This adds alt-svc mapping and it has a form of <host-name>;<alt-svc-header>
+// Example: example1.com;h3-29=":443",example2.com;h3-29=":443"
+pref("network.http.http3.alt-svc-mapping-for-testing", "");
+
+// alt-svc allows separation of transport routing from
+// the origin host without using a proxy.
+pref("network.http.altsvc.enabled", true);
+pref("network.http.altsvc.oe", false);
+
+// Turn on 0RTT data for TLS 1.3
+pref("security.tls.enable_0rtt_data", true);
+
+// the origin extension impacts h2 coalescing
+pref("network.http.originextension", true);
+
+pref("network.http.diagnostics", false);
+
+pref("network.http.pacing.requests.enabled", true);
+pref("network.http.pacing.requests.min-parallelism", 6);
+pref("network.http.pacing.requests.hz", 80);
+pref("network.http.pacing.requests.burst", 10);
+
+// TCP Keepalive config for HTTP connections.
+pref("network.http.tcp_keepalive.short_lived_connections", true);
+// Max time from initial request during which conns are considered short-lived.
+pref("network.http.tcp_keepalive.short_lived_time", 60);
+// Idle time of TCP connection until first keepalive probe sent.
+pref("network.http.tcp_keepalive.short_lived_idle_time", 10);
+
+pref("network.http.tcp_keepalive.long_lived_connections", true);
+pref("network.http.tcp_keepalive.long_lived_idle_time", 600);
+
+pref("network.http.enforce-framing.http1", false); // should be named "strict"
+pref("network.http.enforce-framing.soft", true);
+pref("network.http.enforce-framing.strict_chunked_encoding", true);
+
+// Max size, in bytes, for received HTTP response header.
+pref("network.http.max_response_header_size", 393216);
+
+// The ratio of the transaction count for the focused window and the count of
+// all available active connections.
+pref("network.http.focused_window_transaction_ratio", "0.9");
+
+// This is the size of the flow control window (KB) (i.e., the amount of data
+// that the parent can send to the child before getting an ack). 0 for disable
+// the flow control.
+pref("network.http.send_window_size", 1024);
+
+// Whether or not we give more priority to active tab.
+// Note that this requires restart for changes to take effect.
+#ifdef ANDROID
+  // disabled because of bug 1382274
+  pref("network.http.active_tab_priority", false);
+#else
+  pref("network.http.active_tab_priority", true);
+#endif
+
+// By default the Accept header sent for documents loaded over HTTP(S) is derived
+// by DocumentAcceptHeader() in nsHttpHandler.cpp. If set, this pref overrides it.
+// There is also image.http.accept which works in scope of image.
+pref("network.http.accept", "");
+
+// The max time to spend on xpcom events between two polls in ms.
+pref("network.sts.max_time_for_events_between_two_polls", 100);
+
+// The number of seconds we don't let poll() handing indefinitely after network
+// link change has been detected so we can detect breakout of the pollable event.
+// Expected in seconds, 0 to disable.
+pref("network.sts.poll_busy_wait_period", 50);
+
+// The number of seconds we cap poll() timeout to during the network link change
+// detection period.
+// Expected in seconds, 0 to disable.
+pref("network.sts.poll_busy_wait_period_timeout", 7);
+
+// During shutdown we limit PR_Close calls. If time exceeds this pref (in ms)
+// let sockets just leak.
+pref("network.sts.max_time_for_pr_close_during_shutdown", 5000);
+
+// When the polling socket pair we use to wake poll() up on demand doesn't
+// get signalled (is not readable) within this timeout, we try to repair it.
+// This timeout can be disabled by setting this pref to 0.
+// The value is expected in seconds.
+pref("network.sts.pollable_event_timeout", 6);
+
+// 2147483647 == PR_INT32_MAX == ~2 GB
+pref("network.websocket.max-message-size", 2147483647);
+
+// Should we automatically follow http 3xx redirects during handshake
+pref("network.websocket.auto-follow-http-redirects", false);
+
+// the number of seconds to wait for websocket connection to be opened
+pref("network.websocket.timeout.open", 20);
+
+// the number of seconds to wait for a clean close after sending the client
+// close message
+pref("network.websocket.timeout.close", 20);
+
+// the number of seconds of idle read activity to sustain before sending a
+// ping probe. 0 to disable.
+pref("network.websocket.timeout.ping.request", 0);
+
+// the deadline, expressed in seconds, for some read activity to occur after
+// generating a ping. If no activity happens then an error and unclean close
+// event is sent to the javascript websockets application
+pref("network.websocket.timeout.ping.response", 10);
+
+// Defines whether or not to try to negotiate the permessage compression
+// extension with the websocket server.
+pref("network.websocket.extensions.permessage-deflate", true);
+
+// the maximum number of concurrent websocket sessions. By specification there
+// is never more than one handshake oustanding to an individual host at
+// one time.
+pref("network.websocket.max-connections", 200);
+
+// by default scripts loaded from a https:// origin can only open secure
+// (i.e. wss://) websockets.
+pref("network.websocket.allowInsecureFromHTTPS", false);
+
+// by default we delay websocket reconnects to same host/port if previous
+// connection failed, per RFC 6455 section 7.2.3
+pref("network.websocket.delay-failed-reconnects", true);
+
+// </ws>
+
+// Server-Sent Events
+// Equal to the DEFAULT_RECONNECTION_TIME_VALUE value in nsEventSource.cpp
+pref("dom.server-events.default-reconnection-time", 5000); // in milliseconds
+
+// This preference, if true, causes all UTF-8 domain names to be normalized to
+// punycode.  The intention is to allow UTF-8 domain names as input, but never
+// generate them from punycode.
+pref("network.IDN_show_punycode", false);
+
+// If "network.IDN.use_whitelist" is set to true, TLDs with
+// "network.IDN.whitelist.tld" explicitly set to true are treated as
+// IDN-safe. Otherwise, they're treated as unsafe and punycode will be used
+// for displaying them in the UI (e.g. URL bar), unless they conform to one of
+// the profiles specified in
+// https://www.unicode.org/reports/tr39/#Restriction_Level_Detection
+// If "network.IDN.restriction_profile" is "high", the Highly Restrictive
+// profile is used.
+// If "network.IDN.restriction_profile" is "moderate", the Moderately
+// Restrictive profile is used.
+// In all other cases, the ASCII-Only profile is used.
+// Note that these preferences are referred to ONLY when
+// "network.IDN_show_punycode" is false. In other words, all IDNs will be shown
+// in punycode if "network.IDN_show_punycode" is true.
+pref("network.IDN.restriction_profile", "high");
+pref("network.IDN.use_whitelist", false);
+
+// ccTLDs
+pref("network.IDN.whitelist.ac", true);
+pref("network.IDN.whitelist.ar", true);
+pref("network.IDN.whitelist.at", true);
+pref("network.IDN.whitelist.br", true);
+pref("network.IDN.whitelist.ca", true);
+pref("network.IDN.whitelist.ch", true);
+pref("network.IDN.whitelist.cl", true);
+pref("network.IDN.whitelist.cn", true);
+pref("network.IDN.whitelist.de", true);
+pref("network.IDN.whitelist.dk", true);
+pref("network.IDN.whitelist.ee", true);
+pref("network.IDN.whitelist.es", true);
+pref("network.IDN.whitelist.fi", true);
+pref("network.IDN.whitelist.fr", true);
+pref("network.IDN.whitelist.gr", true);
+pref("network.IDN.whitelist.gt", true);
+pref("network.IDN.whitelist.hu", true);
+pref("network.IDN.whitelist.il", true);
+pref("network.IDN.whitelist.io", true);
+pref("network.IDN.whitelist.ir", true);
+pref("network.IDN.whitelist.is", true);
+pref("network.IDN.whitelist.jp", true);
+pref("network.IDN.whitelist.kr", true);
+pref("network.IDN.whitelist.li", true);
+pref("network.IDN.whitelist.lt", true);
+pref("network.IDN.whitelist.lu", true);
+pref("network.IDN.whitelist.lv", true);
+pref("network.IDN.whitelist.no", true);
+pref("network.IDN.whitelist.nu", true);
+pref("network.IDN.whitelist.nz", true);
+pref("network.IDN.whitelist.pl", true);
+pref("network.IDN.whitelist.pm", true);
+pref("network.IDN.whitelist.pr", true);
+pref("network.IDN.whitelist.re", true);
+pref("network.IDN.whitelist.se", true);
+pref("network.IDN.whitelist.sh", true);
+pref("network.IDN.whitelist.si", true);
+pref("network.IDN.whitelist.tf", true);
+pref("network.IDN.whitelist.th", true);
+pref("network.IDN.whitelist.tm", true);
+pref("network.IDN.whitelist.tw", true);
+pref("network.IDN.whitelist.ua", true);
+pref("network.IDN.whitelist.vn", true);
+pref("network.IDN.whitelist.wf", true);
+pref("network.IDN.whitelist.yt", true);
+
+// IDN ccTLDs
+// ae, UAE, .<Emarat>
+pref("network.IDN.whitelist.xn--mgbaam7a8h", true);
+// cn, China, .<China> with variants
+pref("network.IDN.whitelist.xn--fiqz9s", true); // Traditional
+pref("network.IDN.whitelist.xn--fiqs8s", true); // Simplified
+// eg, Egypt, .<Masr>
+pref("network.IDN.whitelist.xn--wgbh1c", true);
+// hk, Hong Kong, .<Hong Kong>
+pref("network.IDN.whitelist.xn--j6w193g", true);
+// ir, Iran, <.Iran> with variants
+pref("network.IDN.whitelist.xn--mgba3a4f16a", true);
+pref("network.IDN.whitelist.xn--mgba3a4fra", true);
+// jo, Jordan, .<Al-Ordon>
+pref("network.IDN.whitelist.xn--mgbayh7gpa", true);
+// lk, Sri Lanka, .<Lanka> and .<Ilangai>
+pref("network.IDN.whitelist.xn--fzc2c9e2c", true);
+pref("network.IDN.whitelist.xn--xkc2al3hye2a", true);
+// qa, Qatar, .<Qatar>
+pref("network.IDN.whitelist.xn--wgbl6a", true);
+// rs, Serbia, .<Srb>
+pref("network.IDN.whitelist.xn--90a3ac", true);
+// ru, Russian Federation, .<RF>
+pref("network.IDN.whitelist.xn--p1ai", true);
+// sa, Saudi Arabia, .<al-Saudiah> with variants
+pref("network.IDN.whitelist.xn--mgberp4a5d4ar", true);
+pref("network.IDN.whitelist.xn--mgberp4a5d4a87g", true);
+pref("network.IDN.whitelist.xn--mgbqly7c0a67fbc", true);
+pref("network.IDN.whitelist.xn--mgbqly7cvafr", true);
+// sy, Syria, .<Souria>
+pref("network.IDN.whitelist.xn--ogbpf8fl", true);
+// th, Thailand, .<Thai>
+pref("network.IDN.whitelist.xn--o3cw4h", true);
+// tw, Taiwan, <.Taiwan> with variants
+pref("network.IDN.whitelist.xn--kpry57d", true);  // Traditional
+pref("network.IDN.whitelist.xn--kprw13d", true);  // Simplified
+
+// gTLDs
+pref("network.IDN.whitelist.asia", true);
+pref("network.IDN.whitelist.biz", true);
+pref("network.IDN.whitelist.cat", true);
+pref("network.IDN.whitelist.info", true);
+pref("network.IDN.whitelist.museum", true);
+pref("network.IDN.whitelist.org", true);
+pref("network.IDN.whitelist.tel", true);
+
+// NOTE: Before these can be removed, one of bug 414812's tests must be updated
+//       or it will likely fail!  Please CC jwalden+bmo on the bug associated
+//       with removing these so he can provide a patch to make the necessary
+//       changes to avoid bustage.
+// ".test" localised TLDs for ICANN's top-level IDN trial
+pref("network.IDN.whitelist.xn--0zwm56d", true);
+pref("network.IDN.whitelist.xn--11b5bs3a9aj6g", true);
+pref("network.IDN.whitelist.xn--80akhbyknj4f", true);
+pref("network.IDN.whitelist.xn--9t4b11yi5a", true);
+pref("network.IDN.whitelist.xn--deba0ad", true);
+pref("network.IDN.whitelist.xn--g6w251d", true);
+pref("network.IDN.whitelist.xn--hgbk6aj7f53bba", true);
+pref("network.IDN.whitelist.xn--hlcj6aya9esc7a", true);
+pref("network.IDN.whitelist.xn--jxalpdlp", true);
+pref("network.IDN.whitelist.xn--kgbechtv", true);
+pref("network.IDN.whitelist.xn--zckzah", true);
+
+// If a domain includes any of the blocklist characters, it may be a spoof
+// attempt and so we always display the domain name as punycode. This would
+// override the settings "network.IDN_show_punycode" and
+// "network.IDN.whitelist.*".
+// For a complete list of the blocked IDN characters see:
+//   netwerk/dns/IDNCharacterBlocklist.inc
+
+// This pref may contain characters that will override the hardcoded blocklist,
+// so their presence in a domain name will not cause it to be displayed as
+// punycode.
+// Note that this only removes the characters from the blocklist, but there may
+// be other rules in place that cause it to be displayed as punycode.
+pref("network.IDN.extra_allowed_chars", "");
+// This pref may contain additional blocklist characters
+pref("network.IDN.extra_blocked_chars", "");
+
+// This preference specifies a list of domains for which DNS lookups will be
+// IPv4 only. Works around broken DNS servers which can't handle IPv6 lookups
+// and/or allows the user to disable IPv6 on a per-domain basis. See bug 68796.
+pref("network.dns.ipv4OnlyDomains", "");
+
+// This preference can be used to turn off IPv6 name lookups. See bug 68796.
+pref("network.dns.disableIPv6", false);
+
+// This is the number of dns cache entries allowed
+pref("network.dnsCacheEntries", 400);
+
+// In the absence of OS TTLs, the DNS cache TTL value
+pref("network.dnsCacheExpiration", 60);
+
+// Get TTL; not supported on all platforms; nop on the unsupported ones.
+pref("network.dns.get-ttl", true);
+
+// For testing purposes! Makes the native resolver resolve IPv4 "localhost"
+// instead of the actual given name.
+pref("network.dns.native-is-localhost", false);
+
+// The grace period allows the DNS cache to use expired entries, while kicking off
+// a revalidation in the background.
+pref("network.dnsCacheExpirationGracePeriod", 60);
+
+// This preference can be used to turn off DNS prefetch.
+pref("network.dns.disablePrefetch", false);
+
+// This preference controls whether .onion hostnames are
+// rejected before being given to DNS. RFC 7686
+pref("network.dns.blockDotOnion", true);
+
+// These domains are treated as localhost equivalent
+pref("network.dns.localDomains", "");
+
+// When non empty all non-localhost DNS queries (including IP addresses)
+// resolve to this value. The value can be a name or an IP address.
+// domains mapped to localhost with localDomains stay localhost.
+pref("network.dns.forceResolve", "");
+
+// Contols whether or not "localhost" should resolve when offline
+pref("network.dns.offline-localhost", true);
+
+// Defines how much longer resolver threads should stay idle before are shut down.
+// A negative value will keep the thread alive forever.
+pref("network.dns.resolver-thread-extra-idle-time-seconds", 60);
+
+// enables the prefetch service (i.e., prefetching of <link rel="next"> and
+// <link rel="prefetch"> URLs).
+pref("network.prefetch-next", true);
+
+// The following prefs pertain to the negotiate-auth extension (see bug 17578),
+// which provides transparent Kerberos or NTLM authentication using the SPNEGO
+// protocol.  Each pref is a comma-separated list of keys, where each key has
+// the format:
+//   [scheme "://"] [host [":" port]]
+// For example, "foo.com" would match "http://www.foo.com/bar", etc.
+
+// This list controls which URIs can use the negotiate-auth protocol.  This
+// list should be limited to the servers you know you'll need to login to.
+pref("network.negotiate-auth.trusted-uris", "");
+// This list controls which URIs can support delegation.
+pref("network.negotiate-auth.delegation-uris", "");
+
+// Do not allow SPNEGO by default when challenged by a local server.
+pref("network.negotiate-auth.allow-non-fqdn", false);
+
+// Allow SPNEGO by default when challenged by a proxy server.
+pref("network.negotiate-auth.allow-proxies", true);
+
+// Path to a specific gssapi library
+pref("network.negotiate-auth.gsslib", "");
+
+// Specify if the gss lib comes standard with the OS
+pref("network.negotiate-auth.using-native-gsslib", true);
+
+#ifdef XP_WIN
+  // Default to using the SSPI intead of GSSAPI on windows
+  pref("network.auth.use-sspi", true);
+#endif
+
+// Controls which NTLM authentication implementation we default to. True forces
+// the use of our generic (internal) NTLM authentication implementation vs. any
+// native implementation provided by the os. This pref is for diagnosing issues
+// with native NTLM. (See bug 520607 for details.) Using generic NTLM authentication
+// can expose the user to reflection attack vulnerabilities. Do not change this
+// unless you know what you're doing!
+// This pref should be removed 6 months after the release of firefox 3.6.
+pref("network.auth.force-generic-ntlm", false);
+
+// The following prefs are used to enable automatic use of the operating
+// system's NTLM implementation to silently authenticate the user with their
+// Window's domain logon.  The trusted-uris pref follows the format of the
+// trusted-uris pref for negotiate authentication.
+pref("network.automatic-ntlm-auth.allow-proxies", true);
+pref("network.automatic-ntlm-auth.allow-non-fqdn", false);
+pref("network.automatic-ntlm-auth.trusted-uris", "");
+
+// The string to return to the server as the 'workstation' that the
+// user is using.  Bug 1046421 notes that the previous default, of the
+// system hostname, could be used for user fingerprinting.
+//
+// However, in some network environments where allowedWorkstations is in use
+// to provide a level of host-based access control, it must be set to a string
+// that is listed in allowedWorkstations for the user's account in their
+// AD Domain.
+pref("network.generic-ntlm-auth.workstation", "WORKSTATION");
+
+// This preference controls whether to allow sending default credentials (SSO) to
+// NTLM/Negotiate servers allowed in the "trusted uri" list when navigating them
+// in a Private Browsing window.
+// If set to false, Private Browsing windows will not use default credentials and ask
+// for credentials from the user explicitly.
+// If set to true, and a server URL conforms other conditions for sending default
+// credentials, those will be sent automatically in Private Browsing windows.
+//
+// This preference has no effect when the browser is set to "Never Remember History",
+// in that case default credentials will always be used.
+pref("network.auth.private-browsing-sso", false);
+
+// Control how throttling of http responses works - number of ms that each
+// suspend and resume period lasts (prefs named appropriately)
+// This feature is occasionally causing visible regressions (download too slow for
+// too long time, jitter in video/audio in background tabs...)
+pref("network.http.throttle.enable", false);
+
+// Make HTTP throttling v2 algorithm Nightly-only due to bug 1462906
+#ifdef NIGHTLY_BUILD
+  pref("network.http.throttle.version", 2);
+#else
+  pref("network.http.throttle.version", 1);
+#endif
+
+// V1 prefs
+pref("network.http.throttle.suspend-for", 900);
+pref("network.http.throttle.resume-for", 100);
+
+// V2 prefs
+pref("network.http.throttle.read-limit-bytes", 8000);
+pref("network.http.throttle.read-interval-ms", 500);
+
+// Common prefs
+// Delay we resume throttled background responses after the last unthrottled
+// response has finished.  Prevents resuming too soon during an active page load
+// at which sub-resource reqeusts quickly come and go.
+pref("network.http.throttle.hold-time-ms", 800);
+// After the last transaction activation or last data chunk response we only
+// throttle for this period of time.  This prevents comet and unresponsive
+// http requests to engage long-standing throttling.
+pref("network.http.throttle.max-time-ms", 500);
+
+// Give higher priority to requests resulting from a user interaction event
+// like click-to-play, image fancy-box zoom, navigation.
+pref("network.http.on_click_priority", true);
+
+// When the page load has not yet reached DOMContentLoaded point, tail requestes are delayed
+// by (non-tailed requests count + 1) * delay-quantum milliseconds.
+pref("network.http.tailing.delay-quantum", 600);
+// The same as above, but applied after the document load reached DOMContentLoaded event.
+pref("network.http.tailing.delay-quantum-after-domcontentloaded", 100);
+// Upper limit for the calculated delay, prevents long standing and comet-like requests
+// tail forever.  This is in milliseconds as well.
+pref("network.http.tailing.delay-max", 6000);
+// Total limit we delay tailed requests since a page load beginning.
+pref("network.http.tailing.total-max", 45000);
+
+pref("network.proxy.http",                  "");
+pref("network.proxy.http_port",             0);
+pref("network.proxy.ssl",                   "");
+pref("network.proxy.ssl_port",              0);
+pref("network.proxy.socks",                 "");
+pref("network.proxy.socks_port",            0);
+pref("network.proxy.socks_version",         5);
+pref("network.proxy.proxy_over_tls",        true);
+pref("network.proxy.no_proxies_on",         "");
+pref("network.proxy.failover_timeout",      1800); // 30 minutes
+pref("network.online",                      true); //online/offline
+
+// The interval in seconds to move the cookies in the child process.
+// Set to 0 to disable moving the cookies.
+pref("network.cookie.move.interval_sec",    0);
+
+// This pref contains the list of hostnames (such as
+// "mozilla.org,example.net"). For these hosts, firefox will treat
+// SameSite=None if nothing else is specified, even if
+// network.cookie.sameSite.laxByDefault if set to true.
+// To know the correct syntax, see nsContentUtils::IsURIInList()
+pref("network.cookie.sameSite.laxByDefault.disabledHosts", "");
+
+pref("network.cookie.maxNumber", 3000);
+pref("network.cookie.maxPerHost", 180);
+// Cookies quota for each host. If cookies exceed the limit maxPerHost,
+// (maxPerHost - quotaPerHost) cookies will be evicted.
+pref("network.cookie.quotaPerHost", 150);
+
+// The PAC file to load.  Ignored unless network.proxy.type is 2.
+pref("network.proxy.autoconfig_url", "");
+// Strip off paths when sending URLs to PAC scripts
+pref("network.proxy.autoconfig_url.include_path", false);
+
+// If we cannot load the PAC file, then try again (doubling from interval_min
+// until we reach interval_max or the PAC file is successfully loaded).
+pref("network.proxy.autoconfig_retry_interval_min", 5);    // 5 seconds
+pref("network.proxy.autoconfig_retry_interval_max", 300);  // 5 minutes
+pref("network.proxy.enable_wpad_over_dhcp", true);
+
+// Use the HSTS preload list by default
+pref("network.stricttransportsecurity.preloadlist", true);
+
+// Use JS mDNS as a fallback
+pref("network.mdns.use_js_fallback", false);
+
+pref("converter.html2txt.structs",          true); // Output structured phrases (strong, em, code, sub, sup, b, i, u)
+pref("converter.html2txt.header_strategy",  1); // 0 = no indention; 1 = indention, increased with header level; 2 = numbering and slight indention
+
+pref("intl.accept_languages",               "chrome://global/locale/intl.properties");
+pref("intl.menuitems.alwaysappendaccesskeys","chrome://global/locale/intl.properties");
+pref("intl.menuitems.insertseparatorbeforeaccesskeys","chrome://global/locale/intl.properties");
+pref("intl.ellipsis",                       "chrome://global-platform/locale/intl.properties");
+// this pref allows user to request that all internationalization formatters
+// like date/time formatting, unit formatting, calendars etc. should use
+// OS locale set instead of the app locale set.
+pref("intl.regional_prefs.use_os_locales",  false);
+// fallback charset list for Unicode conversion (converting from Unicode)
+// currently used for mail send only to handle symbol characters (e.g Euro, trademark, smartquotes)
+// for ISO-8859-1
+pref("intl.fallbackCharsetList.ISO-8859-1", "windows-1252");
+pref("font.language.group",                 "chrome://global/locale/intl.properties");
+pref("font.cjk_pref_fallback_order",        "zh-cn,zh-hk,zh-tw,ja,ko");
+
+pref("intl.uidirection", -1); // -1 to set from locale; 0 for LTR; 1 for RTL
+
+// This pref controls pseudolocales for testing localization.
+// See https://firefox-source-docs.mozilla.org/l10n/fluent/tutorial.html#pseudolocalization.
+pref("intl.l10n.pseudo", "");
+
+// use en-US hyphenation by default for content tagged with plain lang="en"
+pref("intl.hyphenation-alias.en", "en-us");
+// and for other subtags of en-*, if no specific patterns are available
+pref("intl.hyphenation-alias.en-*", "en-us");
+
+pref("intl.hyphenation-alias.af-*", "af");
+pref("intl.hyphenation-alias.bg-*", "bg");
+pref("intl.hyphenation-alias.bn-*", "bn");
+pref("intl.hyphenation-alias.ca-*", "ca");
+pref("intl.hyphenation-alias.cy-*", "cy");
+pref("intl.hyphenation-alias.da-*", "da");
+pref("intl.hyphenation-alias.eo-*", "eo");
+pref("intl.hyphenation-alias.es-*", "es");
+pref("intl.hyphenation-alias.et-*", "et");
+pref("intl.hyphenation-alias.fi-*", "fi");
+pref("intl.hyphenation-alias.fr-*", "fr");
+pref("intl.hyphenation-alias.gl-*", "gl");
+pref("intl.hyphenation-alias.gu-*", "gu");
+pref("intl.hyphenation-alias.hi-*", "hi");
+pref("intl.hyphenation-alias.hr-*", "hr");
+pref("intl.hyphenation-alias.hsb-*", "hsb");
+pref("intl.hyphenation-alias.hu-*", "hu");
+pref("intl.hyphenation-alias.ia-*", "ia");
+pref("intl.hyphenation-alias.is-*", "is");
+pref("intl.hyphenation-alias.it-*", "it");
+pref("intl.hyphenation-alias.kmr-*", "kmr");
+pref("intl.hyphenation-alias.kn-*", "kn");
+pref("intl.hyphenation-alias.la-*", "la");
+pref("intl.hyphenation-alias.lt-*", "lt");
+pref("intl.hyphenation-alias.ml-*", "ml");
+pref("intl.hyphenation-alias.mn-*", "mn");
+pref("intl.hyphenation-alias.nl-*", "nl");
+pref("intl.hyphenation-alias.or-*", "or");
+pref("intl.hyphenation-alias.pa-*", "pa");
+pref("intl.hyphenation-alias.pl-*", "pl");
+pref("intl.hyphenation-alias.pt-*", "pt");
+pref("intl.hyphenation-alias.ru-*", "ru");
+pref("intl.hyphenation-alias.sl-*", "sl");
+pref("intl.hyphenation-alias.sv-*", "sv");
+pref("intl.hyphenation-alias.ta-*", "ta");
+pref("intl.hyphenation-alias.te-*", "te");
+pref("intl.hyphenation-alias.tr-*", "tr");
+pref("intl.hyphenation-alias.uk-*", "uk");
+
+// Assamese and Marathi use the same patterns as Bengali and Hindi respectively
+pref("intl.hyphenation-alias.as", "bn");
+pref("intl.hyphenation-alias.as-*", "bn");
+pref("intl.hyphenation-alias.mr", "hi");
+pref("intl.hyphenation-alias.mr-*", "hi");
+
+// use reformed (1996) German patterns by default unless specifically tagged as de-1901
+// (these prefs may soon be obsoleted by better BCP47-based tag matching, but for now...)
+pref("intl.hyphenation-alias.de", "de-1996");
+pref("intl.hyphenation-alias.de-*", "de-1996");
+pref("intl.hyphenation-alias.de-AT-1901", "de-1901");
+pref("intl.hyphenation-alias.de-DE-1901", "de-1901");
+pref("intl.hyphenation-alias.de-CH-*", "de-CH");
+
+// patterns from TeX are tagged as "sh" (Serbo-Croatian) macrolanguage;
+// alias "sr" (Serbian) and "bs" (Bosnian) to those patterns
+// (Croatian has its own separate patterns).
+pref("intl.hyphenation-alias.sr", "sh");
+pref("intl.hyphenation-alias.bs", "sh");
+pref("intl.hyphenation-alias.sh-*", "sh");
+pref("intl.hyphenation-alias.sr-*", "sh");
+pref("intl.hyphenation-alias.bs-*", "sh");
+
+// Norwegian has two forms, Bokml and Nynorsk, with "no" as a macrolanguage encompassing both.
+// For "no", we'll alias to "nb" (Bokml) as that is the more widely used written form.
+pref("intl.hyphenation-alias.no", "nb");
+pref("intl.hyphenation-alias.no-*", "nb");
+pref("intl.hyphenation-alias.nb-*", "nb");
+pref("intl.hyphenation-alias.nn-*", "nn");
+
+// In German, we allow hyphenation of capitalized words; otherwise not.
+pref("intl.hyphenate-capitalized.de-1996", true);
+pref("intl.hyphenate-capitalized.de-1901", true);
+pref("intl.hyphenate-capitalized.de-CH", true);
+
+// All prefs of default font should be "auto".
+pref("font.name.serif.ar", "");
+pref("font.name.sans-serif.ar", "");
+pref("font.name.monospace.ar", "");
+pref("font.name.cursive.ar", "");
+
+pref("font.name.serif.el", "");
+pref("font.name.sans-serif.el", "");
+pref("font.name.monospace.el", "");
+pref("font.name.cursive.el", "");
+
+pref("font.name.serif.he", "");
+pref("font.name.sans-serif.he", "");
+pref("font.name.monospace.he", "");
+pref("font.name.cursive.he", "");
+
+pref("font.name.serif.ja", "");
+pref("font.name.sans-serif.ja", "");
+pref("font.name.monospace.ja", "");
+pref("font.name.cursive.ja", "");
+
+pref("font.name.serif.ko", "");
+pref("font.name.sans-serif.ko", "");
+pref("font.name.monospace.ko", "");
+pref("font.name.cursive.ko", "");
+
+pref("font.name.serif.th", "");
+pref("font.name.sans-serif.th", "");
+pref("font.name.monospace.th", "");
+pref("font.name.cursive.th", "");
+
+pref("font.name.serif.x-cyrillic", "");
+pref("font.name.sans-serif.x-cyrillic", "");
+pref("font.name.monospace.x-cyrillic", "");
+pref("font.name.cursive.x-cyrillic", "");
+
+pref("font.name.serif.x-unicode", "");
+pref("font.name.sans-serif.x-unicode", "");
+pref("font.name.monospace.x-unicode", "");
+pref("font.name.cursive.x-unicode", "");
+
+pref("font.name.serif.x-western", "");
+pref("font.name.sans-serif.x-western", "");
+pref("font.name.monospace.x-western", "");
+pref("font.name.cursive.x-western", "");
+
+pref("font.name.serif.zh-CN", "");
+pref("font.name.sans-serif.zh-CN", "");
+pref("font.name.monospace.zh-CN", "");
+pref("font.name.cursive.zh-CN", "");
+
+pref("font.name.serif.zh-TW", "");
+pref("font.name.sans-serif.zh-TW", "");
+pref("font.name.monospace.zh-TW", "");
+pref("font.name.cursive.zh-TW", "");
+
+pref("font.name.serif.zh-HK", "");
+pref("font.name.sans-serif.zh-HK", "");
+pref("font.name.monospace.zh-HK", "");
+pref("font.name.cursive.zh-HK", "");
+
+pref("font.name.serif.x-devanagari", "");
+pref("font.name.sans-serif.x-devanagari", "");
+pref("font.name.monospace.x-devanagari", "");
+pref("font.name.cursive.x-devanagari", "");
+
+pref("font.name.serif.x-tamil", "");
+pref("font.name.sans-serif.x-tamil", "");
+pref("font.name.monospace.x-tamil", "");
+pref("font.name.cursive.x-tamil", "");
+
+pref("font.name.serif.x-armn", "");
+pref("font.name.sans-serif.x-armn", "");
+pref("font.name.monospace.x-armn", "");
+pref("font.name.cursive.x-armn", "");
+
+pref("font.name.serif.x-beng", "");
+pref("font.name.sans-serif.x-beng", "");
+pref("font.name.monospace.x-beng", "");
+pref("font.name.cursive.x-beng", "");
+
+pref("font.name.serif.x-cans", "");
+pref("font.name.sans-serif.x-cans", "");
+pref("font.name.monospace.x-cans", "");
+pref("font.name.cursive.x-cans", "");
+
+pref("font.name.serif.x-ethi", "");
+pref("font.name.sans-serif.x-ethi", "");
+pref("font.name.monospace.x-ethi", "");
+pref("font.name.cursive.x-ethi", "");
+
+pref("font.name.serif.x-geor", "");
+pref("font.name.sans-serif.x-geor", "");
+pref("font.name.monospace.x-geor", "");
+pref("font.name.cursive.x-geor", "");
+
+pref("font.name.serif.x-gujr", "");
+pref("font.name.sans-serif.x-gujr", "");
+pref("font.name.monospace.x-gujr", "");
+pref("font.name.cursive.x-gujr", "");
+
+pref("font.name.serif.x-guru", "");
+pref("font.name.sans-serif.x-guru", "");
+pref("font.name.monospace.x-guru", "");
+pref("font.name.cursive.x-guru", "");
+
+pref("font.name.serif.x-khmr", "");
+pref("font.name.sans-serif.x-khmr", "");
+pref("font.name.monospace.x-khmr", "");
+pref("font.name.cursive.x-khmr", "");
+
+pref("font.name.serif.x-mlym", "");
+pref("font.name.sans-serif.x-mlym", "");
+pref("font.name.monospace.x-mlym", "");
+pref("font.name.cursive.x-mlym", "");
+
+pref("font.name.serif.x-orya", "");
+pref("font.name.sans-serif.x-orya", "");
+pref("font.name.monospace.x-orya", "");
+pref("font.name.cursive.x-orya", "");
+
+pref("font.name.serif.x-telu", "");
+pref("font.name.sans-serif.x-telu", "");
+pref("font.name.monospace.x-telu", "");
+pref("font.name.cursive.x-telu", "");
+
+pref("font.name.serif.x-knda", "");
+pref("font.name.sans-serif.x-knda", "");
+pref("font.name.monospace.x-knda", "");
+pref("font.name.cursive.x-knda", "");
+
+pref("font.name.serif.x-sinh", "");
+pref("font.name.sans-serif.x-sinh", "");
+pref("font.name.monospace.x-sinh", "");
+pref("font.name.cursive.x-sinh", "");
+
+pref("font.name.serif.x-tibt", "");
+pref("font.name.sans-serif.x-tibt", "");
+pref("font.name.monospace.x-tibt", "");
+pref("font.name.cursive.x-tibt", "");
+
+pref("font.name.serif.x-math", "");
+pref("font.name.sans-serif.x-math", "");
+pref("font.name.monospace.x-math", "");
+pref("font.name.cursive.x-math", "");
+
+pref("font.name-list.serif.x-math", "Latin Modern Math, STIX Two Math, XITS Math, Cambria Math, Libertinus Math, DejaVu Math TeX Gyre, TeX Gyre Bonum Math, TeX Gyre Pagella Math, TeX Gyre Schola, TeX Gyre Termes Math, STIX Math, Asana Math, STIXGeneral, DejaVu Serif, DejaVu Sans, serif");
+pref("font.name-list.sans-serif.x-math", "sans-serif");
+pref("font.name-list.monospace.x-math", "monospace");
+
+// Some CJK fonts have bad underline offset, their CJK character glyphs are overlapped (or adjoined)  to its underline.
+// These fonts are ignored the underline offset, instead of it, the underline is lowered to bottom of its em descent.
+pref("font.blacklist.underline_offset", "FangSong,Gulim,GulimChe,MingLiU,MingLiU-ExtB,MingLiU_HKSCS,MingLiU-HKSCS-ExtB,MS Gothic,MS Mincho,MS PGothic,MS PMincho,MS UI Gothic,PMingLiU,PMingLiU-ExtB,SimHei,SimSun,SimSun-ExtB,Hei,Kai,Apple LiGothic,Apple LiSung,Osaka");
+
+pref("security.directory",              "");
+
+// security-sensitive dialogs should delay button enabling. In milliseconds.
+pref("security.dialog_enable_delay", 1000);
+pref("security.notification_enable_delay", 500);
+
+#ifdef EARLY_BETA_OR_EARLIER
+  // Disallow web documents loaded with the SystemPrincipal
+  pref("security.disallow_non_local_systemprincipal_in_tests", false);
+#endif
+
+// OCSP must-staple
+pref("security.ssl.enable_ocsp_must_staple", true);
+
+// Insecure Form Field Warning
+pref("security.insecure_field_warning.contextual.enabled", false);
+pref("security.insecure_field_warning.ignore_local_ip_address", true);
+
+// Remote settings preferences
+pref("services.settings.poll_interval", 86400); // 24H
+pref("services.settings.server", "https://firefox.settings.services.mozilla.com/v1");
+pref("services.settings.default_bucket", "main");
+
+// The percentage of clients who will report uptake telemetry as
+// events instead of just a histogram. This only applies on Release;
+// other channels always report events.
+pref("services.common.uptake.sampleRate", 1);   // 1%
+
+// Security state OneCRL.
+pref("services.settings.security.onecrl.bucket", "security-state");
+pref("services.settings.security.onecrl.collection", "onecrl");
+pref("services.settings.security.onecrl.signer", "onecrl.content-signature.mozilla.org");
+pref("services.settings.security.onecrl.checked", 0);
+
+pref("extensions.abuseReport.enabled", true);
+// Allow AMO to handoff reports to the Firefox integrated dialog.
+pref("extensions.abuseReport.amWebAPI.enabled", true);
+pref("extensions.abuseReport.url", "https://services.addons.mozilla.org/api/v4/abuse/report/addon/");
+pref("extensions.abuseReport.amoDetailsURL", "https://services.addons.mozilla.org/api/v4/addons/addon/");
+
+// Blocklist preferences
+pref("extensions.blocklist.enabled", true);
+pref("extensions.blocklist.detailsURL", "https://blocked.cdn.mozilla.net/");
+pref("extensions.blocklist.itemURL", "https://blocked.cdn.mozilla.net/%blockID%.html");
+pref("extensions.blocklist.addonItemURL", "https://addons.mozilla.org/%LOCALE%/%APP%/blocked-addon/%addonID%/%addonVersion%/");
+// Controls what level the blocklist switches from warning about items to forcibly
+// blocking them.
+pref("extensions.blocklist.level", 2);
+// Whether event pages should be enabled for "manifest_version: 2" extensions.
+pref("extensions.eventPages.enabled", false);
+// Whether "manifest_version: 3" extensions should be allowed to install successfully.
+pref("extensions.manifestV3.enabled", false);
+
+// Blocklist via settings server (Kinto)
+pref("services.blocklist.bucket", "blocklists");
+pref("services.blocklist.addons.collection", "addons");
+pref("services.blocklist.addons.checked", 0);
+pref("services.blocklist.addons.signer", "remote-settings.content-signature.mozilla.org");
+pref("services.blocklist.addons-mlbf.checked", 0);
+pref("services.blocklist.plugins.collection", "plugins");
+pref("services.blocklist.plugins.checked", 0);
+pref("services.blocklist.plugins.signer", "remote-settings.content-signature.mozilla.org");
+pref("services.blocklist.gfx.collection", "gfx");
+pref("services.blocklist.gfx.checked", 0);
+pref("services.blocklist.gfx.signer", "remote-settings.content-signature.mozilla.org");
+
+// Modifier key prefs: default to Windows settings,
+// menu access key = alt, accelerator key = control.
+// Use 17 for Ctrl, 18 for Alt, 224 for Meta, 91 for Win, 0 for none. Mac settings in macprefs.js
+pref("ui.key.accelKey", 17);
+pref("ui.key.menuAccessKey", 18);
+
+// Middle-mouse handling
+pref("middlemouse.paste", false);
+pref("middlemouse.contentLoadURL", false);
+pref("middlemouse.scrollbarPosition", false);
+
+// Clipboard only supports text/plain
+pref("clipboard.plainTextOnly", false);
+
+#if defined(XP_WIN) || defined(XP_MACOSX) || defined(MOZ_WIDGET_GTK)
+  // Setting false you can disable 4th button and/or 5th button of your mouse.
+  // 4th button is typically mapped to "Back" and 5th button is typically mapped
+  // to "Forward" button.
+  pref("mousebutton.4th.enabled", true);
+  pref("mousebutton.5th.enabled", true);
+#endif
+
+// mousewheel.*.action can specify the action when you use mosue wheel.
+// When no modifier keys are pressed or two or more modifires are pressed,
+// .default is used.
+// 0: Nothing happens
+// 1: Scrolling contents
+// 2: Go back or go forward, in your history
+// 3: Zoom in or out (reflowing zoom).
+// 4: Treat vertical wheel as horizontal scroll
+//      This treats vertical wheel operation (i.e., deltaY) as horizontal
+//      scroll.  deltaX and deltaZ are always ignored.  So, only
+//      "delta_multiplier_y" pref affects the scroll speed.
+// 5: Zoom in or out (pinch zoom).
+pref("mousewheel.default.action", 1);
+pref("mousewheel.with_alt.action", 2);
+pref("mousewheel.with_control.action", 3);
+pref("mousewheel.with_meta.action", 1);  // command key on Mac
+pref("mousewheel.with_shift.action", 4);
+pref("mousewheel.with_win.action", 1);
+
+// mousewheel.*.action.override_x will override the action
+// when the mouse wheel is rotated along the x direction.
+// -1: Don't override the action.
+// 0 to 3: Override the action with the specified value.
+// Note that 4 isn't available because it doesn't make sense to apply the
+// default action only for y direction to this pref.
+pref("mousewheel.default.action.override_x", -1);
+pref("mousewheel.with_alt.action.override_x", -1);
+pref("mousewheel.with_control.action.override_x", -1);
+pref("mousewheel.with_meta.action.override_x", -1);  // command key on Mac
+pref("mousewheel.with_shift.action.override_x", -1);
+pref("mousewheel.with_win.action.override_x", -1);
+
+// mousewheel.*.delta_multiplier_* can specify the value muliplied by the delta
+// value.  The values will be used after divided by 100.  I.e., 100 means 1.0,
+// -100 means -1.0.  If the values were negative, the direction would be
+// reverted.  The absolue value must be 100 or larger.
+pref("mousewheel.default.delta_multiplier_x", 100);
+pref("mousewheel.default.delta_multiplier_y", 100);
+pref("mousewheel.default.delta_multiplier_z", 100);
+pref("mousewheel.with_alt.delta_multiplier_x", 100);
+pref("mousewheel.with_alt.delta_multiplier_y", 100);
+pref("mousewheel.with_alt.delta_multiplier_z", 100);
+pref("mousewheel.with_control.delta_multiplier_x", 100);
+pref("mousewheel.with_control.delta_multiplier_y", 100);
+pref("mousewheel.with_control.delta_multiplier_z", 100);
+pref("mousewheel.with_meta.delta_multiplier_x", 100);  // command key on Mac
+pref("mousewheel.with_meta.delta_multiplier_y", 100);  // command key on Mac
+pref("mousewheel.with_meta.delta_multiplier_z", 100);  // command key on Mac
+pref("mousewheel.with_shift.delta_multiplier_x", 100);
+pref("mousewheel.with_shift.delta_multiplier_y", 100);
+pref("mousewheel.with_shift.delta_multiplier_z", 100);
+pref("mousewheel.with_win.delta_multiplier_x", 100);
+pref("mousewheel.with_win.delta_multiplier_y", 100);
+pref("mousewheel.with_win.delta_multiplier_z", 100);
+
+// We can show it anytime from menus
+pref("profile.manage_only_at_launch", false);
+
+// ------------------
+//  Text Direction
+// ------------------
+// 1 = directionLTRBidi *
+// 2 = directionRTLBidi
+pref("bidi.direction", 1);
+// ------------------
+//  Text Type
+// ------------------
+// 1 = charsettexttypeBidi *
+// 2 = logicaltexttypeBidi
+// 3 = visualtexttypeBidi
+pref("bidi.texttype", 1);
+// ------------------
+//  Numeral Style
+// ------------------
+// 0 = nominalnumeralBidi *
+// 1 = regularcontextnumeralBidi
+// 2 = hindicontextnumeralBidi
+// 3 = arabicnumeralBidi
+// 4 = hindinumeralBidi
+// 5 = persiancontextnumeralBidi
+// 6 = persiannumeralBidi
+pref("bidi.numeral", 0);
+
+// Setting this pref to |true| forces Bidi UI menu items and keyboard shortcuts
+// to be exposed, and enables the directional caret hook. By default, only
+// expose it for bidi-associated system locales.
+pref("bidi.browser.ui", false);
+
+// pref for which side vertical scrollbars should be on
+// 0 = end-side in UI direction
+// 1 = end-side in document/content direction
+// 2 = right
+// 3 = left
+pref("layout.scrollbar.side", 0);
+
+// pref to control whether layout warnings that are hit quite often are enabled
+pref("layout.spammy_warnings.enabled", false);
+
+// if true, allow plug-ins to override internal imglib decoder mime types in full-page mode
+pref("plugin.override_internal_types", false);
+
+// enable single finger gesture input (win7+ tablets)
+pref("gestures.enable_single_finger_input", true);
+
+pref("dom.use_watchdog", true);
+
+// Stop all scripts in a compartment when the "stop script" dialog is used.
+pref("dom.global_stop_script", true);
+
+// Support the input event queue on the main thread of content process
+pref("input_event_queue.supported", true);
+
+// The maximum and minimum time (milliseconds) we reserve for handling input
+// events in each frame.
+pref("input_event_queue.duration.max", 8);
+pref("input_event_queue.duration.min", 1);
+
+// The default amount of time (milliseconds) required for handling a input
+// event.
+pref("input_event_queue.default_duration_per_event", 1);
+
+// The number of processed input events we use to predict the amount of time
+// required to process the following input events.
+pref("input_event_queue.count_for_prediction", 9);
+
+// This only supports one hidden ctp plugin, edit nsPluginArray.cpp if adding a second
+pref("plugins.navigator.hidden_ctp_plugin", "");
+
+// The default value for nsIPluginTag.enabledState (STATE_ENABLED = 2)
+pref("plugin.default.state", 2);
+
+// This pref can take 3 possible string values:
+// "always"     - always use favor fallback mode
+// "follow-ctp" - activate if ctp is active for the given
+//                plugin object (could be due to a plugin-wide
+//                setting or a site-specific setting)
+// "never"      - never use favor fallback mode
+pref("plugins.favorfallback.mode", "never");
+
+// A comma-separated list of rules to follow when deciding
+// whether an object has been provided with good fallback content.
+// The valid values can be found at nsObjectLoadingContent::HasGoodFallback.
+pref("plugins.favorfallback.rules", "");
+
+
+// Set IPC timeouts for plugins and tabs, except in leak-checking and
+// dynamic analysis builds.  (NS_FREE_PERMANENT_DATA is C++ only, so
+// approximate its definition here.)
+#if !defined(DEBUG) && !defined(MOZ_ASAN) && !defined(MOZ_VALGRIND) && !defined(MOZ_TSAN)
+  // How long a plugin is allowed to process a synchronous IPC message
+  // before we consider it "hung".
+  pref("dom.ipc.plugins.timeoutSecs", 45);
+  // How long a plugin process will wait for a response from the parent
+  // to a synchronous request before terminating itself. After this
+  // point the child assumes the parent is hung. Currently disabled.
+  pref("dom.ipc.plugins.parentTimeoutSecs", 0);
+  // How long a plugin in e10s is allowed to process a synchronous IPC
+  // message before we notify the chrome process of a hang.
+  pref("dom.ipc.plugins.contentTimeoutSecs", 10);
+  // How long a plugin launch is allowed to take before
+  // we consider it failed.
+  pref("dom.ipc.plugins.processLaunchTimeoutSecs", 45);
+  #ifdef XP_WIN
+    // How long a plugin is allowed to process a synchronous IPC message
+    // before we display the plugin hang UI
+    pref("dom.ipc.plugins.hangUITimeoutSecs", 11);
+    // Minimum time that the plugin hang UI will be displayed
+    pref("dom.ipc.plugins.hangUIMinDisplaySecs", 10);
+  #endif
+#else
+  // No timeout in leak-checking builds
+  pref("dom.ipc.plugins.timeoutSecs", 0);
+  pref("dom.ipc.plugins.contentTimeoutSecs", 0);
+  pref("dom.ipc.plugins.processLaunchTimeoutSecs", 0);
+  pref("dom.ipc.plugins.parentTimeoutSecs", 0);
+  #ifdef XP_WIN
+    pref("dom.ipc.plugins.hangUITimeoutSecs", 0);
+    pref("dom.ipc.plugins.hangUIMinDisplaySecs", 0);
+  #endif
+#endif
+
+pref("dom.ipc.plugins.reportCrashURL", true);
+
+// Force the accelerated direct path for a subset of Flash wmode values
+pref("dom.ipc.plugins.forcedirect.enabled", true);
+
+// Enable multi by default.
+#if !defined(MOZ_ASAN) && !defined(MOZ_TSAN)
+  pref("dom.ipc.processCount", 8);
+#else
+  pref("dom.ipc.processCount", 4);
+#endif
+
+// Default to allow only one file:// URL content process.
+pref("dom.ipc.processCount.file", 1);
+
+// WebExtensions only support a single extension process.
+pref("dom.ipc.processCount.extension", 1);
+
+// The privileged about process only supports a single content process.
+pref("dom.ipc.processCount.privilegedabout", 1);
+
+// Limit the privileged mozilla process to a single instance only
+// to avoid multiple of these content processes
+pref("dom.ipc.processCount.privilegedmozilla", 1);
+
+// Maximum number of isolated content processes per-origin.
+#ifdef ANDROID
+pref("dom.ipc.processCount.webIsolated", 1);
+#else
+pref("dom.ipc.processCount.webIsolated", 4);
+#endif
+
+// Keep a single privileged about process alive for performance reasons.
+// e.g. we do not want to throw content processes out every time we navigate
+// away from about:newtab.
+pref("dom.ipc.keepProcessesAlive.privilegedabout", 1);
+
+// Disable support for SVG
+pref("svg.disabled", false);
+
+// Disable e10s for Gecko by default. This is overridden in firefox.js.
+pref("browser.tabs.remote.autostart", false);
+
+// This pref will cause assertions when a remoteType triggers a process switch
+// to a new remoteType it should not be able to trigger.
+pref("browser.tabs.remote.enforceRemoteTypeRestrictions", false);
+
+// Pref to control whether we use a separate privileged content process
+// for about: pages. This pref name did not age well: we will have multiple
+// types of privileged content processes, each with different privileges.
+pref("browser.tabs.remote.separatePrivilegedContentProcess", false);
+
+// The domains we will isolate into the Mozilla Content Process. Comma-separated
+// full domains: any subdomains of the domains listed will also be allowed.
+pref("browser.tabs.remote.separatedMozillaDomains", "addons.mozilla.org,accounts.firefox.com");
+
+// Default font types and sizes by locale
+pref("font.default.ar", "sans-serif");
+pref("font.minimum-size.ar", 0);
+pref("font.size.variable.ar", 16);
+pref("font.size.monospace.ar", 13);
+
+pref("font.default.el", "serif");
+pref("font.minimum-size.el", 0);
+pref("font.size.variable.el", 16);
+pref("font.size.monospace.el", 13);
+
+pref("font.default.he", "sans-serif");
+pref("font.minimum-size.he", 0);
+pref("font.size.variable.he", 16);
+pref("font.size.monospace.he", 13);
+
+pref("font.default.ja", "sans-serif");
+pref("font.minimum-size.ja", 0);
+pref("font.size.variable.ja", 16);
+pref("font.size.monospace.ja", 16);
+
+pref("font.default.ko", "sans-serif");
+pref("font.minimum-size.ko", 0);
+pref("font.size.variable.ko", 16);
+pref("font.size.monospace.ko", 16);
+
+pref("font.default.th", "sans-serif");
+pref("font.minimum-size.th", 0);
+pref("font.size.variable.th", 16);
+pref("font.size.monospace.th", 13);
+
+pref("font.default.x-cyrillic", "serif");
+pref("font.minimum-size.x-cyrillic", 0);
+pref("font.size.variable.x-cyrillic", 16);
+pref("font.size.monospace.x-cyrillic", 13);
+
+pref("font.default.x-devanagari", "serif");
+pref("font.minimum-size.x-devanagari", 0);
+pref("font.size.variable.x-devanagari", 16);
+pref("font.size.monospace.x-devanagari", 13);
+
+pref("font.default.x-tamil", "serif");
+pref("font.minimum-size.x-tamil", 0);
+pref("font.size.variable.x-tamil", 16);
+pref("font.size.monospace.x-tamil", 13);
+
+pref("font.default.x-armn", "serif");
+pref("font.minimum-size.x-armn", 0);
+pref("font.size.variable.x-armn", 16);
+pref("font.size.monospace.x-armn", 13);
+
+pref("font.default.x-beng", "serif");
+pref("font.minimum-size.x-beng", 0);
+pref("font.size.variable.x-beng", 16);
+pref("font.size.monospace.x-beng", 13);
+
+pref("font.default.x-cans", "serif");
+pref("font.minimum-size.x-cans", 0);
+pref("font.size.variable.x-cans", 16);
+pref("font.size.monospace.x-cans", 13);
+
+pref("font.default.x-ethi", "serif");
+pref("font.minimum-size.x-ethi", 0);
+pref("font.size.variable.x-ethi", 16);
+pref("font.size.monospace.x-ethi", 13);
+
+pref("font.default.x-geor", "serif");
+pref("font.minimum-size.x-geor", 0);
+pref("font.size.variable.x-geor", 16);
+pref("font.size.monospace.x-geor", 13);
+
+pref("font.default.x-gujr", "serif");
+pref("font.minimum-size.x-gujr", 0);
+pref("font.size.variable.x-gujr", 16);
+pref("font.size.monospace.x-gujr", 13);
+
+pref("font.default.x-guru", "serif");
+pref("font.minimum-size.x-guru", 0);
+pref("font.size.variable.x-guru", 16);
+pref("font.size.monospace.x-guru", 13);
+
+pref("font.default.x-khmr", "serif");
+pref("font.minimum-size.x-khmr", 0);
+pref("font.size.variable.x-khmr", 16);
+pref("font.size.monospace.x-khmr", 13);
+
+pref("font.default.x-mlym", "serif");
+pref("font.minimum-size.x-mlym", 0);
+pref("font.size.variable.x-mlym", 16);
+pref("font.size.monospace.x-mlym", 13);
+
+pref("font.default.x-orya", "serif");
+pref("font.minimum-size.x-orya", 0);
+pref("font.size.variable.x-orya", 16);
+pref("font.size.monospace.x-orya", 13);
+
+pref("font.default.x-telu", "serif");
+pref("font.minimum-size.x-telu", 0);
+pref("font.size.variable.x-telu", 16);
+pref("font.size.monospace.x-telu", 13);
+
+pref("font.default.x-knda", "serif");
+pref("font.minimum-size.x-knda", 0);
+pref("font.size.variable.x-knda", 16);
+pref("font.size.monospace.x-knda", 13);
+
+pref("font.default.x-sinh", "serif");
+pref("font.minimum-size.x-sinh", 0);
+pref("font.size.variable.x-sinh", 16);
+pref("font.size.monospace.x-sinh", 13);
+
+pref("font.default.x-tibt", "serif");
+pref("font.minimum-size.x-tibt", 0);
+pref("font.size.variable.x-tibt", 16);
+pref("font.size.monospace.x-tibt", 13);
+
+pref("font.default.x-unicode", "serif");
+pref("font.minimum-size.x-unicode", 0);
+pref("font.size.variable.x-unicode", 16);
+pref("font.size.monospace.x-unicode", 13);
+
+pref("font.default.x-western", "serif");
+pref("font.minimum-size.x-western", 0);
+pref("font.size.variable.x-western", 16);
+pref("font.size.monospace.x-western", 13);
+
+pref("font.default.zh-CN", "sans-serif");
+pref("font.minimum-size.zh-CN", 0);
+pref("font.size.variable.zh-CN", 16);
+pref("font.size.monospace.zh-CN", 16);
+
+pref("font.default.zh-HK", "sans-serif");
+pref("font.minimum-size.zh-HK", 0);
+pref("font.size.variable.zh-HK", 16);
+pref("font.size.monospace.zh-HK", 16);
+
+pref("font.default.zh-TW", "sans-serif");
+pref("font.minimum-size.zh-TW", 0);
+pref("font.size.variable.zh-TW", 16);
+pref("font.size.monospace.zh-TW", 16);
+
+// mathml.css sets font-size to "inherit" and font-family to "serif" so only
+// font.name.*.x-math and font.minimum-size.x-math are really relevant.
+pref("font.default.x-math", "serif");
+pref("font.minimum-size.x-math", 0);
+pref("font.size.variable.x-math", 16);
+pref("font.size.monospace.x-math", 13);
+
+#ifdef XP_WIN
+
+  pref("font.name-list.emoji", "Segoe UI Emoji, Twemoji Mozilla");
+
+  pref("font.name-list.serif.ar", "Times New Roman");
+  pref("font.name-list.sans-serif.ar", "Segoe UI, Tahoma, Arial");
+  pref("font.name-list.monospace.ar", "Consolas");
+  pref("font.name-list.cursive.ar", "Comic Sans MS");
+
+  pref("font.name-list.serif.el", "Times New Roman");
+  pref("font.name-list.sans-serif.el", "Arial");
+  pref("font.name-list.monospace.el", "Consolas");
+  pref("font.name-list.cursive.el", "Comic Sans MS");
+
+  pref("font.name-list.serif.he", "Narkisim, David");
+  pref("font.name-list.sans-serif.he", "Arial");
+  pref("font.name-list.monospace.he", "Fixed Miriam Transparent, Miriam Fixed, Rod, Consolas, Courier New");
+  pref("font.name-list.cursive.he", "Guttman Yad, Ktav, Arial");
+
+  pref("font.name-list.serif.ja", "Yu Mincho, MS PMincho, MS Mincho, Meiryo, Yu Gothic, MS PGothic, MS Gothic");
+  pref("font.name-list.sans-serif.ja", "Meiryo, Yu Gothic, MS PGothic, MS Gothic, Yu Mincho, MS PMincho, MS Mincho");
+  pref("font.name-list.monospace.ja", "MS Gothic, MS Mincho, Meiryo, Yu Gothic, Yu Mincho, MS PGothic, MS PMincho");
+
+  pref("font.name-list.serif.ko", "Batang, Gulim");
+  pref("font.name-list.sans-serif.ko", "Malgun Gothic, Gulim");
+  pref("font.name-list.monospace.ko", "GulimChe");
+  pref("font.name-list.cursive.ko", "Gungsuh");
+
+  pref("font.name-list.serif.th", "Tahoma");
+  pref("font.name-list.sans-serif.th", "Tahoma");
+  pref("font.name-list.monospace.th", "Tahoma");
+  pref("font.name-list.cursive.th", "Tahoma");
+
+  pref("font.name-list.serif.x-cyrillic", "Times New Roman");
+  pref("font.name-list.sans-serif.x-cyrillic", "Arial");
+  pref("font.name-list.monospace.x-cyrillic", "Consolas");
+  pref("font.name-list.cursive.x-cyrillic", "Comic Sans MS");
+
+  pref("font.name-list.serif.x-unicode", "Times New Roman");
+  pref("font.name-list.sans-serif.x-unicode", "Arial");
+  pref("font.name-list.monospace.x-unicode", "Consolas");
+  pref("font.name-list.cursive.x-unicode", "Comic Sans MS");
+
+  pref("font.name-list.serif.x-western", "Times New Roman");
+  pref("font.name-list.sans-serif.x-western", "Arial");
+  pref("font.name-list.monospace.x-western", "Consolas");
+  pref("font.name-list.cursive.x-western", "Comic Sans MS");
+
+  pref("font.name-list.serif.zh-CN", "SimSun, MS Song, SimSun-ExtB");
+  pref("font.name-list.sans-serif.zh-CN", "Microsoft YaHei, SimHei");
+  pref("font.name-list.monospace.zh-CN", "SimSun, MS Song, SimSun-ExtB");
+  pref("font.name-list.cursive.zh-CN", "KaiTi, KaiTi_GB2312");
+
+  // Per Taiwanese users' demand. They don't want to use TC fonts for
+  // rendering Latin letters. (bug 88579)
+  pref("font.name-list.serif.zh-TW", "Times New Roman, PMingLiu, MingLiU, MingLiU-ExtB");
+  #ifdef EARLY_BETA_OR_EARLIER
+    pref("font.name-list.sans-serif.zh-TW", "Arial, Microsoft JhengHei, PMingLiU, MingLiU, MingLiU-ExtB");
+  #else
+    pref("font.name-list.sans-serif.zh-TW", "Arial, PMingLiU, MingLiU, MingLiU-ExtB, Microsoft JhengHei");
+  #endif
+  pref("font.name-list.monospace.zh-TW", "MingLiU, MingLiU-ExtB");
+  pref("font.name-list.cursive.zh-TW", "DFKai-SB");
+
+  // hkscsm3u.ttf (HKSCS-2001) :  http://www.microsoft.com/hk/hkscs
+  // Hong Kong users have the same demand about glyphs for Latin letters (bug 88579)
+  pref("font.name-list.serif.zh-HK", "Times New Roman, MingLiu_HKSCS, Ming(for ISO10646), MingLiU, MingLiU_HKSCS-ExtB, Microsoft JhengHei");
+  pref("font.name-list.sans-serif.zh-HK", "Arial, MingLiU_HKSCS, Ming(for ISO10646), MingLiU, MingLiU_HKSCS-ExtB, Microsoft JhengHei");
+  pref("font.name-list.monospace.zh-HK", "MingLiU_HKSCS, Ming(for ISO10646), MingLiU, MingLiU_HKSCS-ExtB, Microsoft JhengHei");
+  pref("font.name-list.cursive.zh-HK", "DFKai-SB");
+
+  pref("font.name-list.serif.x-devanagari", "Kokila, Raghindi");
+  pref("font.name-list.sans-serif.x-devanagari", "Nirmala UI, Mangal");
+  pref("font.name-list.monospace.x-devanagari", "Mangal, Nirmala UI");
+
+  pref("font.name-list.serif.x-tamil", "Latha");
+  pref("font.name-list.monospace.x-tamil", "Latha");
+
+  // http://www.alanwood.net/unicode/fonts.html
+
+  pref("font.name-list.serif.x-armn", "Sylfaen");
+  pref("font.name-list.sans-serif.x-armn", "Arial AMU");
+  pref("font.name-list.monospace.x-armn", "Arial AMU");
+
+  pref("font.name-list.serif.x-beng", "Vrinda, Akaash, Likhan, Ekushey Punarbhaba");
+  pref("font.name-list.sans-serif.x-beng", "Vrinda, Akaash, Likhan, Ekushey Punarbhaba");
+  pref("font.name-list.monospace.x-beng", "Mitra Mono, Likhan, Mukti Narrow");
+
+  pref("font.name-list.serif.x-cans", "Aboriginal Serif, BJCree Uni");
+  pref("font.name-list.sans-serif.x-cans", "Aboriginal Sans");
+  pref("font.name-list.monospace.x-cans", "Aboriginal Sans, OskiDakelh, Pigiarniq, Uqammaq");
+
+  pref("font.name-list.serif.x-ethi", "Visual Geez Unicode, Visual Geez Unicode Agazian");
+  pref("font.name-list.sans-serif.x-ethi", "GF Zemen Unicode");
+  pref("font.name-list.monospace.x-ethi", "Ethiopia Jiret");
+  pref("font.name-list.cursive.x-ethi", "Visual Geez Unicode Title");
+
+  pref("font.name-list.serif.x-geor", "Sylfaen, BPG Paata Khutsuri U, TITUS Cyberbit Basic");
+  pref("font.name-list.sans-serif.x-geor", "BPG Classic 99U");
+  pref("font.name-list.monospace.x-geor", "BPG Classic 99U");
+
+  pref("font.name-list.serif.x-gujr", "Shruti");
+  pref("font.name-list.sans-serif.x-gujr", "Shruti");
+  pref("font.name-list.monospace.x-gujr", "Shruti");
+
+  pref("font.name-list.serif.x-guru", "Raavi, Saab");
+  pref("font.name-list.sans-serif.x-guru", "");
+  pref("font.name-list.monospace.x-guru", "Raavi, Saab");
+
+  pref("font.name-list.serif.x-khmr", "PhnomPenh OT,.Mondulkiri U GR 1.5, Khmer OS");
+  pref("font.name-list.sans-serif.x-khmr", "Khmer OS");
+  pref("font.name-list.monospace.x-khmr", "Khmer OS, Khmer OS System");
+
+  pref("font.name-list.serif.x-mlym", "Rachana_w01, AnjaliOldLipi, Kartika, ThoolikaUnicode");
+  pref("font.name-list.sans-serif.x-mlym", "Rachana_w01, AnjaliOldLipi, Kartika, ThoolikaUnicode");
+  pref("font.name-list.monospace.x-mlym", "Rachana_w01, AnjaliOldLipi, Kartika, ThoolikaUnicode");
+
+  pref("font.name-list.serif.x-orya", "ori1Uni, Kalinga");
+  pref("font.name-list.sans-serif.x-orya", "ori1Uni, Kalinga");
+  pref("font.name-list.monospace.x-orya", "ori1Uni, Kalinga");
+
+  pref("font.name-list.serif.x-telu", "Gautami, Akshar Unicode");
+  pref("font.name-list.sans-serif.x-telu", "Gautami, Akshar Unicode");
+  pref("font.name-list.monospace.x-telu", "Gautami, Akshar Unicode");
+
+  pref("font.name-list.serif.x-knda", "Tunga, AksharUnicode");
+  pref("font.name-list.sans-serif.x-knda", "Tunga, AksharUnicode");
+  pref("font.name-list.monospace.x-knda", "Tunga, AksharUnicode");
+
+  pref("font.name-list.serif.x-sinh", "Iskoola Pota, AksharUnicode");
+  pref("font.name-list.sans-serif.x-sinh", "Iskoola Pota, AksharUnicode");
+  pref("font.name-list.monospace.x-sinh", "Iskoola Pota, AksharUnicode");
+
+  pref("font.name-list.serif.x-tibt", "Tibetan Machine Uni, Jomolhari, Microsoft Himalaya");
+  pref("font.name-list.sans-serif.x-tibt", "Tibetan Machine Uni, Jomolhari, Microsoft Himalaya");
+  pref("font.name-list.monospace.x-tibt", "Tibetan Machine Uni, Jomolhari, Microsoft Himalaya");
+
+  pref("font.minimum-size.th", 10);
+
+  pref("font.default.x-devanagari", "sans-serif");
+
+  pref("font.name-list.serif.x-math", "Latin Modern Math, STIX Two Math, XITS Math, Cambria Math, Libertinus Math, DejaVu Math TeX Gyre, TeX Gyre Bonum Math, TeX Gyre Pagella Math, TeX Gyre Schola, TeX Gyre Termes Math, STIX Math, Asana Math, STIXGeneral, DejaVu Serif, DejaVu Sans, Times New Roman");
+  pref("font.name-list.sans-serif.x-math", "Arial");
+  pref("font.name-list.monospace.x-math", "Consolas");
+  pref("font.name-list.cursive.x-math", "Comic Sans MS");
+
+  // ClearType tuning parameters for directwrite/d2d.
+  //
+  // Allows overriding of underlying registry values in:
+  //   HKCU/Software/Microsoft/Avalon.Graphics/<display> (contrast and level)
+  //   HKLM/Software/Microsoft/Avalon.Graphics/<display> (gamma, pixel structure)
+  // and selection of the ClearType/antialiasing mode.
+  //
+  // A value of -1 implies use the default value, otherwise value ranges
+  // follow registry settings:
+  //   gamma [1000, 2200]  default: based on screen, typically 2200 (== 2.2)
+  //   enhanced contrast [0, 1000] default: 50
+  //   cleartype level [0, 100] default: 100
+  //   pixel structure [0, 2] default: 0 (flat/RGB/BGR)
+  //   rendering mode [0, 5] default: 0
+  //     0 = use default for font & size;
+  //     1 = aliased;
+  //     2 = GDI Classic;
+  //     3 = GDI Natural Widths;
+  //     4 = Natural;
+  //     5 = Natural Symmetric
+  //
+  // See:
+  //   http://msdn.microsoft.com/en-us/library/aa970267.aspx
+  //   http://msdn.microsoft.com/en-us/library/dd368190%28v=VS.85%29.aspx
+  // Note: DirectWrite uses the "Enhanced Contrast Level" value rather than the
+  // "Text Contrast Level" value
+
+  pref("gfx.font_rendering.cleartype_params.gamma", -1);
+  pref("gfx.font_rendering.cleartype_params.enhanced_contrast", -1);
+  pref("gfx.font_rendering.cleartype_params.cleartype_level", -1);
+  pref("gfx.font_rendering.cleartype_params.pixel_structure", -1);
+  pref("gfx.font_rendering.cleartype_params.rendering_mode", -1);
+
+  // A comma-separated list of font family names. Fonts in these families will
+  // be forced to use "GDI Classic" ClearType mode, provided the value
+  // of gfx.font_rendering.cleartype_params.rendering_mode is -1
+  // (i.e. a specific rendering_mode has not been explicitly set).
+  // Currently we apply this setting to the sans-serif Microsoft "core Web fonts".
+  pref("gfx.font_rendering.cleartype_params.force_gdi_classic_for_families",
+       "Arial,Consolas,Courier New,Microsoft Sans Serif,Segoe UI,Tahoma,Trebuchet MS,Verdana");
+  // The maximum size at which we will force GDI classic mode using
+  // force_gdi_classic_for_families.
+  pref("gfx.font_rendering.cleartype_params.force_gdi_classic_max_size", 15);
+
+  // Locate plugins by the directories specified in the Windows registry for PLIDs
+  // Which is currently HKLM\Software\MozillaPlugins\xxxPLIDxxx\Path
+  pref("plugin.scan.plid.all", true);
+
+  // Switch the keyboard layout per window
+  pref("intl.keyboard.per_window_layout", false);
+
+  // Whether Gecko sets input scope of the URL bar to IS_DEFAULT when black
+  // listed IMEs are active.  If you use tablet mode mainly and you want to
+  // use touch keyboard for URL when you set focus to the URL bar, you can
+  // set this to false.  Then, you'll see, e.g., ".com" key on the keyboard.
+  // However, if you set this to false, such IMEs set its open state to "closed"
+  // when you set focus to the URL bar.  I.e., input mode is automatically
+  // changed to English input mode.
+  // Black listed IMEs:
+  //   - Microsoft IME for Japanese
+  //   - Google Japanese Input
+  //   - Microsoft Bopomofo
+  //   - Microsoft ChangJie
+  //   - Microsoft Phonetic
+  //   - Microsoft Quick
+  //   - Microsoft New ChangJie
+  //   - Microsoft New Phonetic
+  //   - Microsoft New Quick
+  //   - Microsoft Pinyin
+  //   - Microsoft Pinyin New Experience Input Style
+  //   - Microsoft Wubi
+  //   - Microsoft IME for Korean (except on Win7)
+  //   - Microsoft Old Hangul
+  pref("intl.ime.hack.set_input_scope_of_url_bar_to_default", true);
+
+  // Enable/Disable TSF support.
+  pref("intl.tsf.enable", true);
+
+  // Support IMEs implemented with IMM in TSF mode.
+  pref("intl.tsf.support_imm", true);
+
+  // This is referred only when both "intl.tsf.enable" and
+  // "intl.tsf.support_imm" are true.  When this is true, default IMC is
+  // associated with focused window only when active keyboard layout is a
+  // legacy IMM-IME.
+  pref("intl.tsf.associate_imc_only_when_imm_ime_is_active", false);
+
+  // Enables/Disables hack for specific TIP.
+
+  // On Windows 10 Build 17643 (an Insider Preview build of RS5), Microsoft
+  // have fixed the caller of ITextACPStore::GetTextExt() to return
+  // TS_E_NOLAYOUT to TIP as-is, rather than converting to E_FAIL.
+  // Therefore, if TIP supports asynchronous layout computation perfectly, we
+  // can return TS_E_NOLAYOUT and TIP waits next OnLayoutChange()
+  // notification.  However, some TIPs still have some bugs of asynchronous
+  // layout support.  We keep hacking the result of GetTextExt() like running
+  // on Windows 10, however, there could be unknown TIP bugs if we stop
+  // hacking the result.  So, user can stop checking build ID to make Gecko
+  // hack the result forcibly.
+  #ifdef EARLY_BETA_OR_EARLIER
+    pref("intl.tsf.hack.allow_to_stop_hacking_on_build_17643_or_later", true);
+  #else
+    pref("intl.tsf.hack.allow_to_stop_hacking_on_build_17643_or_later", false);
+  #endif
+
+  // Whether creates native caret for ATOK or not.
+  pref("intl.tsf.hack.atok.create_native_caret", true);
+  // Whether use available composition string rect for result of
+  // ITextStoreACP::GetTextExt() even if the specified range is same as the
+  // range of composition string but some character rects of them are not
+  // available.  Note that this is ignored if active ATOK is or older than
+  // 2016 and create_native_caret is true.
+  pref("intl.tsf.hack.atok.do_not_return_no_layout_error_of_composition_string", true);
+  // Whether disable "search" input scope when the ATOK is active on windows.
+  // When "search" is set to the input scope, ATOK may stop their suggestions.
+  // To avoid it, turn this pref on, or changing the settings in ATOK.
+  // Note that if you enable this pref and you use the touch keyboard for touch
+  // screens, you cannot access some specific features for a "search" input
+  // field.
+  pref("intl.tsf.hack.atok.search_input_scope_disabled", false);
+  // Whether use available composition string rect for result of
+  // ITextStoreACP::GetTextExt() even if the specified range is same as or is
+  // in the range of composition string but some character rects of them are
+  // not available.
+  pref("intl.tsf.hack.japanist10.do_not_return_no_layout_error_of_composition_string", true);
+  // Whether use composition start position for the result of
+  // ITfContextView::GetTextExt() if the specified range is larger than
+  // composition start offset.
+  // For Free ChangJie 2010
+  pref("intl.tsf.hack.free_chang_jie.do_not_return_no_layout_error", true);
+  // For Microsoft Pinyin and Microsoft Wubi
+  pref("intl.tsf.hack.ms_simplified_chinese.do_not_return_no_layout_error", true);
+  // For Microsoft ChangJie and Microsoft Quick
+  pref("intl.tsf.hack.ms_traditional_chinese.do_not_return_no_layout_error", true);
+  // Whether use previous character rect for the result of
+  // ITfContextView::GetTextExt() if the specified range is the first
+  // character of selected clause of composition string.
+  pref("intl.tsf.hack.ms_japanese_ime.do_not_return_no_layout_error_at_first_char", true);
+  // Whether use previous character rect for the result of
+  // ITfContextView::GetTextExt() if the specified range is the caret of
+  // composition string.
+  pref("intl.tsf.hack.ms_japanese_ime.do_not_return_no_layout_error_at_caret", true);
+  // Whether hack ITextStoreACP::QueryInsert() or not.  The method should
+  // return new selection after specified length text is inserted at
+  // specified range. However, Microsoft's some Chinese TIPs expect that the
+  // result is same as specified range.  If following prefs are true,
+  // ITextStoreACP::QueryInsert() returns specified range only when one of
+  // the TIPs is active. For Microsoft Pinyin and Microsoft Wubi.
+  pref("intl.tsf.hack.ms_simplified_chinese.query_insert_result", true);
+  // For Microsoft ChangJie and Microsoft Quick
+  pref("intl.tsf.hack.ms_traditional_chinese.query_insert_result", true);
+
+  // If composition_font is set, Gecko sets the font to IME.  IME may use
+  // the fonts on their window like candidate window.  If they are empty,
+  // Gecko uses the system default font which is set to the IM context.
+  // The font name must not start with '@'.  When the writing mode is vertical,
+  // Gecko inserts '@' to the start of the font name automatically.
+  // FYI: Changing these prefs requires to restart.
+  pref("intl.imm.composition_font", "");
+
+  // Japanist 2003's candidate window is broken if the font is "@System" which
+  // is default composition font for vertical writing mode.
+  // You can specify font to use on candidate window of Japanist 2003.
+  // This value must not start with '@'.
+  // FYI: Changing this pref requires to restart.
+  pref("intl.imm.composition_font.japanist_2003", "MS PGothic");
+
+  // Even if IME claims that they support vertical writing mode but it may not
+  // support vertical writing mode for its candidate window.  This pref allows
+  // to ignore the claim.
+  // FYI: Changing this pref requires to restart.
+  pref("intl.imm.vertical_writing.always_assume_not_supported", false);
+
+  // We cannot retrieve active IME name with IMM32 API if a TIP of TSF is
+  // active. This pref can specify active IME name when Japanese TIP is active.
+  // For example:
+  //   Google Japanese Input: "Google  IMM32 "
+  //   ATOK 2011: "ATOK 2011" (similarly, e.g., ATOK 2013 is "ATOK 2013")
+  pref("intl.imm.japanese.assume_active_tip_name_as", "");
+
+  // See bug 448927, on topmost panel, some IMEs are not usable on Windows.
+  pref("ui.panel.default_level_parent", false);
+
+  // Enable system settings cache for mouse wheel message handling.
+  // Note that even if this pref is set to true, Gecko may not cache the system
+  // settings if Gecko detects that the cache won't be refreshed properly when
+  // the settings are changed.
+  pref("mousewheel.system_settings_cache.enabled", true);
+
+  // This is a pref to test system settings cache for mouse wheel message
+  // handling.  If this is set to true, Gecko forcibly use the cache.
+  pref("mousewheel.system_settings_cache.force_enabled", false);
+
+  // High resolution scrolling with supported mouse drivers on Vista or later.
+  pref("mousewheel.enable_pixel_scrolling", true);
+
+  // If your mouse drive sends WM_*SCROLL messages when you turn your mouse
+  // wheel, set this to true.  Then, gecko processes them as mouse wheel
+  // messages.
+  pref("mousewheel.emulate_at_wm_scroll", false);
+
+  // Some odd touchpad utils give focus to window under cursor when user tries
+  // to scroll.  If this is true, Gecko tries to emulate such odd behavior.
+  // Don't make this true unless you want to debug.  Enabling this pref causes
+  // making damage to the performance.
+  pref("mousewheel.debug.make_window_under_cursor_foreground", false);
+
+  // Enables or disabled the TrackPoint hack, -1 is autodetect, 0 is off,
+  // and 1 is on.  Set this to 1 if TrackPoint scrolling is not working.
+  pref("ui.trackpoint_hack.enabled", -1);
+
+  // Setting this to a non-empty string overrides the Win32 "window class" used
+  // for "normal" windows. Setting this to MozillaUIWindowClass might make
+  // some trackpad drivers behave better.
+  pref("ui.window_class_override", "");
+
+  // Enables or disables the Elantech gesture hacks.  -1 is autodetect, 0 is
+  // off, and 1 is on.  Set this to 1 if three-finger swipe gestures do not
+  // cause page back/forward actions, or if pinch-to-zoom does not work.
+  pref("ui.elantech_gesture_hacks.enabled", -1);
+
+  // Show the Windows on-screen keyboard (osk.exe) when a text field is focused.
+  pref("ui.osk.enabled", true);
+  // Only show the on-screen keyboard if there are no physical keyboards
+  // attached to the device.
+  pref("ui.osk.detect_physical_keyboard", true);
+  // Path to TabTip.exe on local machine. Cached for performance reasons.
+  pref("ui.osk.on_screen_keyboard_path", "");
+  // Only try to show the on-screen keyboard on Windows 10 and later. Setting
+  // this pref to false will allow the OSK to show on Windows 8 and 8.1.
+  pref("ui.osk.require_win10", false);
+  // This pref stores the "reason" that the on-screen keyboard was either
+  // shown or not shown when focus is moved to an editable text field. It is
+  // used to help debug why the keyboard is either not appearing when expected
+  // or appearing when it is not expected.
+  pref("ui.osk.debug.keyboardDisplayReason", "");
+
+#endif // XP_WIN
+
+#ifdef XP_MACOSX
+  // Mac specific preference defaults
+  pref("browser.drag_out_of_frame_style", 1);
+  pref("ui.key.saveLink.shift", false); // true = shift, false = meta
+
+  // default fonts (in UTF8 and using canonical names)
+  // to determine canonical font names, use a debug build and
+  // enable NSPR logging for module fontInfoLog:5
+  // canonical names immediately follow '(fontinit) family:' in the log
+
+  // For some scripts there is no commonly-installed monospace font, so we just use
+  // the same as serif/sans-serif, but we prefix the list with Menlo so that at least
+  // Latin text will be monospaced if it occurs when that lang code is in effect.
+
+  pref("font.name-list.emoji", "Apple Color Emoji");
+
+  pref("font.name-list.serif.ar", "Al Bayan");
+  pref("font.name-list.sans-serif.ar", "Geeza Pro");
+  pref("font.name-list.monospace.ar", "Menlo, Geeza Pro");
+  pref("font.name-list.cursive.ar", "DecoType Naskh");
+  pref("font.name-list.fantasy.ar", "KufiStandardGK");
+
+  pref("font.name-list.serif.el", "Times, Times New Roman");
+  pref("font.name-list.sans-serif.el", "Helvetica, Lucida Grande");
+  pref("font.name-list.monospace.el", "Menlo");
+  pref("font.name-list.cursive.el", "Lucida Grande, Times");
+  pref("font.name-list.fantasy.el", "Lucida Grande, Times");
+
+  pref("font.name-list.serif.he", "Times New Roman");
+  pref("font.name-list.sans-serif.he", "Arial");
+  pref("font.name-list.monospace.he", "Menlo, Courier New");
+  pref("font.name-list.cursive.he", "Times New Roman");
+  pref("font.name-list.fantasy.he", "Times New Roman");
+
+  pref("font.name-list.serif.ja", "Hiragino Mincho ProN, Hiragino Mincho Pro");
+  pref("font.name-list.sans-serif.ja", "Hiragino Kaku Gothic ProN, Hiragino Kaku Gothic Pro, Hiragino Sans");
+  pref("font.name-list.monospace.ja", "Osaka-Mono, Hiragino Kaku Gothic ProN, Hiragino Sans");
+
+  pref("font.name-list.serif.ko", "AppleMyungjo");
+  pref("font.name-list.sans-serif.ko", "Apple SD Gothic Neo, AppleGothic");
+  pref("font.name-list.monospace.ko", "Menlo, Apple SD Gothic Neo, AppleGothic");
+
+  pref("font.name-list.serif.th", "Thonburi");
+  pref("font.name-list.sans-serif.th", "Thonburi");
+  pref("font.name-list.monospace.th", "Menlo, Ayuthaya");
+
+  pref("font.name-list.serif.x-armn", "Mshtakan");
+  pref("font.name-list.sans-serif.x-armn", "Mshtakan");
+  pref("font.name-list.monospace.x-armn", "Menlo, Mshtakan");
+
+  // SolaimanLipi, Rupali http://ekushey.org/?page/mac_download
+  pref("font.name-list.serif.x-beng", "Bangla MN");
+  pref("font.name-list.sans-serif.x-beng", "Bangla Sangam MN");
+  pref("font.name-list.monospace.x-beng", "Menlo, Bangla Sangam MN");
+
+  pref("font.name-list.serif.x-cans", "Euphemia UCAS");
+  pref("font.name-list.sans-serif.x-cans", "Euphemia UCAS");
+  pref("font.name-list.monospace.x-cans", "Menlo, Euphemia UCAS");
+
+  pref("font.name-list.serif.x-cyrillic", "Times, Times New Roman");
+  pref("font.name-list.sans-serif.x-cyrillic", "Helvetica, Arial");
+  pref("font.name-list.monospace.x-cyrillic", "Menlo");
+  pref("font.name-list.cursive.x-cyrillic", "Geneva");
+  pref("font.name-list.fantasy.x-cyrillic", "Charcoal CY");
+
+  pref("font.name-list.serif.x-devanagari", "Devanagari MT");
+  pref("font.name-list.sans-serif.x-devanagari", "Devanagari Sangam MN, Devanagari MT");
+  pref("font.name-list.monospace.x-devanagari", "Menlo, Devanagari Sangam MN, Devanagari MT");
+
+  // Abyssinica SIL http://scripts.sil.org/AbyssinicaSIL_Download
+  pref("font.name-list.serif.x-ethi", "Kefa, Abyssinica SIL");
+  pref("font.name-list.sans-serif.x-ethi", "Kefa, Abyssinica SIL");
+  pref("font.name-list.monospace.x-ethi", "Menlo, Kefa, Abyssinica SIL");
+
+  // no suitable fonts for georgian ship with mac os x
+  // however some can be freely downloaded
+  // TITUS Cyberbit Basic http://titus.fkidg1.uni-frankfurt.de/unicode/tituut.asp
+  // Zuzumbo http://homepage.mac.com/rsiradze/FileSharing91.html
+  pref("font.name-list.serif.x-geor", "TITUS Cyberbit Basic");
+  pref("font.name-list.sans-serif.x-geor", "Zuzumbo");
+  pref("font.name-list.monospace.x-geor", "Menlo, Zuzumbo");
+
+  pref("font.name-list.serif.x-gujr", "Gujarati MT");
+  pref("font.name-list.sans-serif.x-gujr", "Gujarati Sangam MN, Gujarati MT");
+  pref("font.name-list.monospace.x-gujr", "Menlo, Gujarati Sangam MN, Gujarati MT");
+
+  pref("font.name-list.serif.x-guru", "Gurmukhi MT");
+  pref("font.name-list.sans-serif.x-guru", "Gurmukhi MT");
+  pref("font.name-list.monospace.x-guru", "Menlo, Gurmukhi MT");
+
+  pref("font.name-list.serif.x-khmr", "Khmer MN");
+  pref("font.name-list.sans-serif.x-khmr", "Khmer Sangam MN");
+  pref("font.name-list.monospace.x-khmr", "Menlo, Khmer Sangam MN");
+
+  pref("font.name-list.serif.x-mlym", "Malayalam MN");
+  pref("font.name-list.sans-serif.x-mlym", "Malayalam Sangam MN");
+  pref("font.name-list.monospace.x-mlym", "Menlo, Malayalam Sangam MN");
+
+  pref("font.name-list.serif.x-orya", "Oriya MN");
+  pref("font.name-list.sans-serif.x-orya", "Oriya Sangam MN");
+  pref("font.name-list.monospace.x-orya", "Menlo, Oriya Sangam MN");
+
+  // Pothana http://web.nickshanks.com/typography/telugu/
+  pref("font.name-list.serif.x-telu", "Telugu MN, Pothana");
+  pref("font.name-list.sans-serif.x-telu", "Telugu Sangam MN, Pothana");
+  pref("font.name-list.monospace.x-telu", "Menlo, Telugu Sangam MN, Pothana");
+
+  // Kedage http://web.nickshanks.com/typography/kannada/
+  pref("font.name-list.serif.x-knda", "Kannada MN, Kedage");
+  pref("font.name-list.sans-serif.x-knda", "Kannada Sangam MN, Kedage");
+  pref("font.name-list.monospace.x-knda", "Menlo, Kannada Sangam MN, Kedage");
+
+  pref("font.name-list.serif.x-sinh", "Sinhala MN");
+  pref("font.name-list.sans-serif.x-sinh", "Sinhala Sangam MN");
+  pref("font.name-list.monospace.x-sinh", "Menlo, Sinhala Sangam MN");
+
+  pref("font.name-list.serif.x-tamil", "InaiMathi");
+  pref("font.name-list.sans-serif.x-tamil", "InaiMathi");
+  pref("font.name-list.monospace.x-tamil", "Menlo, InaiMathi");
+
+  // Kailasa ships with mac os x >= 10.5
+  pref("font.name-list.serif.x-tibt", "Kailasa");
+  pref("font.name-list.sans-serif.x-tibt", "Kailasa");
+  pref("font.name-list.monospace.x-tibt", "Menlo, Kailasa");
+
+  pref("font.name-list.serif.x-unicode", "Times");
+  pref("font.name-list.sans-serif.x-unicode", "Helvetica");
+  pref("font.name-list.monospace.x-unicode", "Menlo");
+  pref("font.name-list.cursive.x-unicode", "Apple Chancery");
+  pref("font.name-list.fantasy.x-unicode", "Papyrus");
+
+  pref("font.name-list.serif.x-western", "Times, Times New Roman");
+  pref("font.name-list.sans-serif.x-western", "Helvetica, Arial");
+  pref("font.name-list.monospace.x-western", "Menlo");
+  pref("font.name-list.cursive.x-western", "Apple Chancery");
+  pref("font.name-list.fantasy.x-western", "Papyrus");
+
+  pref("font.name-list.serif.zh-CN", "Times New Roman, Songti SC, STSong, Heiti SC");
+  pref("font.name-list.sans-serif.zh-CN", "Arial, PingFang SC, STHeiti, Heiti SC");
+  pref("font.name-list.monospace.zh-CN", "Menlo, PingFang SC, STHeiti, Heiti SC");
+  pref("font.name-list.cursive.zh-CN", "Kaiti SC");
+
+  pref("font.name-list.serif.zh-TW", "Times New Roman, Songti TC, LiSong Pro, Heiti TC");
+  pref("font.name-list.sans-serif.zh-TW", "Arial, PingFang TC, Heiti TC, LiHei Pro");
+  pref("font.name-list.monospace.zh-TW", "Menlo, PingFang TC, Heiti TC, LiHei Pro");
+  pref("font.name-list.cursive.zh-TW", "Kaiti TC");
+
+  pref("font.name-list.serif.zh-HK", "Times New Roman, Songti TC, LiSong Pro, Heiti TC");
+  pref("font.name-list.sans-serif.zh-HK", "Arial, PingFang TC, Heiti TC, LiHei Pro");
+  pref("font.name-list.monospace.zh-HK", "Menlo, PingFang TC, Heiti TC, LiHei Pro");
+  pref("font.name-list.cursive.zh-HK", "Kaiti TC");
+
+  // XP_MACOSX changes to default font sizes
+  pref("font.minimum-size.th", 10);
+
+  // Apple's Symbol is Unicode so use it
+  pref("font.name-list.serif.x-math", "Latin Modern Math, STIX Two Math, XITS Math, Cambria Math, Libertinus Math, DejaVu Math TeX Gyre, TeX Gyre Bonum Math, TeX Gyre Pagella Math, TeX Gyre Schola, TeX Gyre Termes Math, STIX Math, Asana Math, STIXGeneral, DejaVu Serif, DejaVu Sans, Symbol, Times");
+  pref("font.name-list.sans-serif.x-math", "Helvetica");
+  pref("font.name-list.monospace.x-math", "Menlo");
+  pref("font.name-list.cursive.x-math", "Apple Chancery");
+  pref("font.name-list.fantasy.x-math", "Papyrus");
+
+  // Individual font faces to be treated as independent families,
+  // listed as <Postscript name of face:Owning family name>
+  pref("font.single-face-list", "Osaka-Mono:Osaka");
+
+  // optimization hint for fonts with localized names to be read in at startup, otherwise read in at lookup miss
+  // names are canonical family names (typically English names)
+  pref("font.preload-names-list", "Hiragino Kaku Gothic ProN,Hiragino Mincho ProN,STSong");
+
+  // Override font-weight values for some problematic families Apple ships
+  // (see bug 931426).
+  // The name here is the font's PostScript name, which can be checked in
+  // the Font Book utility or other tools.
+  pref("font.weight-override.AppleSDGothicNeo-Thin", 100); // Ensure Thin < UltraLight < Light
+  pref("font.weight-override.AppleSDGothicNeo-UltraLight", 200);
+  pref("font.weight-override.AppleSDGothicNeo-Light", 300);
+  pref("font.weight-override.AppleSDGothicNeo-Heavy", 900); // Ensure Heavy > ExtraBold (800)
+
+  pref("font.weight-override.Avenir-Book", 300); // Ensure Book < Roman (400)
+  pref("font.weight-override.Avenir-BookOblique", 300);
+  pref("font.weight-override.Avenir-MediumOblique", 500); // Harmonize MediumOblique with Medium
+  pref("font.weight-override.Avenir-Black", 900); // Ensure Black > Heavy (800)
+  pref("font.weight-override.Avenir-BlackOblique", 900);
+
+  pref("font.weight-override.AvenirNext-MediumItalic", 500); // Harmonize MediumItalic with Medium
+  pref("font.weight-override.AvenirNextCondensed-MediumItalic", 500);
+
+  pref("font.weight-override.HelveticaNeue-Light", 300); // Ensure Light > Thin (200)
+  pref("font.weight-override.HelveticaNeue-LightItalic", 300);
+  pref("font.weight-override.HelveticaNeue-MediumItalic", 500); // Harmonize MediumItalic with Medium
+
+  // Override the Windows settings: no menu key, meta accelerator key. ctrl for general access key in HTML/XUL
+  // Use 17 for Ctrl, 18 for Option, 224 for Cmd, 0 for none
+  pref("ui.key.menuAccessKey", 0);
+  pref("ui.key.accelKey", 224);
+
+  // See bug 404131, topmost <panel> element wins to Dashboard on MacOSX.
+  pref("ui.panel.default_level_parent", false);
+
+  // Macbook touchpad two finger pixel scrolling
+  pref("mousewheel.enable_pixel_scrolling", true);
+
+#endif // XP_MACOSX
+
+#ifdef ANDROID
+  // Handled differently under Mac/Windows
+  pref("network.protocol-handler.warn-external.file", false);
+  pref("browser.drag_out_of_frame_style", 1);
+
+  // Middle-mouse handling
+  pref("middlemouse.paste", true);
+  pref("middlemouse.openNewWindow", true);
+  pref("middlemouse.scrollbarPosition", true);
+
+  // Tab focus model bit field:
+  // 1 focuses text controls, 2 focuses other form elements, 4 adds links.
+  // Leave this at the default, 7, to match mozilla1.0-era user expectations.
+  // pref("accessibility.tabfocus", 1);
+
+  pref("helpers.global_mime_types_file", "/etc/mime.types");
+  pref("helpers.global_mailcap_file", "/etc/mailcap");
+  pref("helpers.private_mime_types_file", "~/.mime.types");
+  pref("helpers.private_mailcap_file", "~/.mailcap");
+
+  // Setting default_level_parent to true makes the default level for popup
+  // windows "top" instead of "parent".  On GTK2 platform, this is implemented
+  // with override-redirect windows which is the normal way to implement
+  // temporary popup windows.  Setting this to false would make the default
+  // level "parent" which is implemented with managed windows.
+  // A problem with using managed windows is that metacity sometimes deactivates
+  // the parent window when the managed popup is shown.
+  pref("ui.panel.default_level_parent", true);
+
+  // Forward downloads with known OMA MIME types to Android's download manager
+  // instead of downloading them in the browser.
+  pref("browser.download.forward_oma_android_download_manager", false);
+
+#endif // ANDROID
+
+#if !defined(ANDROID) && !defined(XP_MACOSX) && defined(XP_UNIX)
+  // Handled differently under Mac/Windows
+  pref("network.protocol-handler.warn-external.file", false);
+  pref("browser.drag_out_of_frame_style", 1);
+
+  // Middle-mouse handling
+  pref("middlemouse.paste", true);
+  pref("middlemouse.openNewWindow", true);
+  pref("middlemouse.scrollbarPosition", true);
+
+  // Tab focus model bit field:
+  // 1 focuses text controls, 2 focuses other form elements, 4 adds links.
+  // Leave this at the default, 7, to match mozilla1.0-era user expectations.
+  // pref("accessibility.tabfocus", 1);
+
+  pref("helpers.global_mime_types_file", "/etc/mime.types");
+  pref("helpers.global_mailcap_file", "/etc/mailcap");
+  pref("helpers.private_mime_types_file", "~/.mime.types");
+  pref("helpers.private_mailcap_file", "~/.mailcap");
+
+  // font names
+
+  // fontconfig doesn't support emoji yet
+  // https://lists.freedesktop.org/archives/fontconfig/2016-October/005842.html
+  pref("font.name-list.emoji", "Twemoji Mozilla");
+
+  pref("font.name-list.serif.ar", "serif");
+  pref("font.name-list.sans-serif.ar", "sans-serif");
+  pref("font.name-list.monospace.ar", "monospace");
+  pref("font.name-list.cursive.ar", "cursive");
+  pref("font.size.monospace.ar", 12);
+
+  pref("font.name-list.serif.el", "serif");
+  pref("font.name-list.sans-serif.el", "sans-serif");
+  pref("font.name-list.monospace.el", "monospace");
+  pref("font.name-list.cursive.el", "cursive");
+  pref("font.size.monospace.el", 12);
+
+  pref("font.name-list.serif.he", "serif");
+  pref("font.name-list.sans-serif.he", "sans-serif");
+  pref("font.name-list.monospace.he", "monospace");
+  pref("font.name-list.cursive.he", "cursive");
+  pref("font.size.monospace.he", 12);
+
+  pref("font.name-list.serif.ja", "serif");
+  pref("font.name-list.sans-serif.ja", "sans-serif");
+  pref("font.name-list.monospace.ja", "monospace");
+  pref("font.name-list.cursive.ja", "cursive");
+
+  pref("font.name-list.serif.ko", "serif");
+  pref("font.name-list.sans-serif.ko", "sans-serif");
+  pref("font.name-list.monospace.ko", "monospace");
+  pref("font.name-list.cursive.ko", "cursive");
+
+  pref("font.name-list.serif.th", "serif");
+  pref("font.name-list.sans-serif.th", "sans-serif");
+  pref("font.name-list.monospace.th", "monospace");
+  pref("font.name-list.cursive.th", "cursive");
+  pref("font.minimum-size.th", 13);
+
+  pref("font.name-list.serif.x-armn", "serif");
+  pref("font.name-list.sans-serif.x-armn", "sans-serif");
+  pref("font.name-list.monospace.x-armn", "monospace");
+  pref("font.name-list.cursive.x-armn", "cursive");
+
+  pref("font.name-list.serif.x-beng", "serif");
+  pref("font.name-list.sans-serif.x-beng", "sans-serif");
+  pref("font.name-list.monospace.x-beng", "monospace");
+  pref("font.name-list.cursive.x-beng", "cursive");
+
+  pref("font.name-list.serif.x-cans", "serif");
+  pref("font.name-list.sans-serif.x-cans", "sans-serif");
+  pref("font.name-list.monospace.x-cans", "monospace");
+  pref("font.name-list.cursive.x-cans", "cursive");
+
+  pref("font.name-list.serif.x-cyrillic", "serif");
+  pref("font.name-list.sans-serif.x-cyrillic", "sans-serif");
+  pref("font.name-list.monospace.x-cyrillic", "monospace");
+  pref("font.name-list.cursive.x-cyrillic", "cursive");
+  pref("font.size.monospace.x-cyrillic", 12);
+
+  pref("font.name-list.serif.x-devanagari", "serif");
+  pref("font.name-list.sans-serif.x-devanagari", "sans-serif");
+  pref("font.name-list.monospace.x-devanagari", "monospace");
+  pref("font.name-list.cursive.x-devanagari", "cursive");
+
+  pref("font.name-list.serif.x-ethi", "serif");
+  pref("font.name-list.sans-serif.x-ethi", "sans-serif");
+  pref("font.name-list.monospace.x-ethi", "monospace");
+  pref("font.name-list.cursive.x-ethi", "cursive");
+
+  pref("font.name-list.serif.x-geor", "serif");
+  pref("font.name-list.sans-serif.x-geor", "sans-serif");
+  pref("font.name-list.monospace.x-geor", "monospace");
+  pref("font.name-list.cursive.x-geor", "cursive");
+
+  pref("font.name-list.serif.x-gujr", "serif");
+  pref("font.name-list.sans-serif.x-gujr", "sans-serif");
+  pref("font.name-list.monospace.x-gujr", "monospace");
+  pref("font.name-list.cursive.x-gujr", "cursive");
+
+  pref("font.name-list.serif.x-guru", "serif");
+  pref("font.name-list.sans-serif.x-guru", "sans-serif");
+  pref("font.name-list.monospace.x-guru", "monospace");
+  pref("font.name-list.cursive.x-guru", "cursive");
+
+  pref("font.name-list.serif.x-khmr", "serif");
+  pref("font.name-list.sans-serif.x-khmr", "sans-serif");
+  pref("font.name-list.monospace.x-khmr", "monospace");
+  pref("font.name-list.cursive.x-khmr", "cursive");
+
+  pref("font.name-list.serif.x-knda", "serif");
+  pref("font.name-list.sans-serif.x-knda", "sans-serif");
+  pref("font.name-list.monospace.x-knda", "monospace");
+  pref("font.name-list.cursive.x-knda", "cursive");
+
+  pref("font.name-list.serif.x-mlym", "serif");
+  pref("font.name-list.sans-serif.x-mlym", "sans-serif");
+  pref("font.name-list.monospace.x-mlym", "monospace");
+  pref("font.name-list.cursive.x-mlym", "cursive");
+
+  pref("font.name-list.serif.x-orya", "serif");
+  pref("font.name-list.sans-serif.x-orya", "sans-serif");
+  pref("font.name-list.monospace.x-orya", "monospace");
+  pref("font.name-list.cursive.x-orya", "cursive");
+
+  pref("font.name-list.serif.x-sinh", "serif");
+  pref("font.name-list.sans-serif.x-sinh", "sans-serif");
+  pref("font.name-list.monospace.x-sinh", "monospace");
+  pref("font.name-list.cursive.x-sinh", "cursive");
+
+  pref("font.name-list.serif.x-tamil", "serif");
+  pref("font.name-list.sans-serif.x-tamil", "sans-serif");
+  pref("font.name-list.monospace.x-tamil", "monospace");
+  pref("font.name-list.cursive.x-tamil", "cursive");
+
+  pref("font.name-list.serif.x-telu", "serif");
+  pref("font.name-list.sans-serif.x-telu", "sans-serif");
+  pref("font.name-list.monospace.x-telu", "monospace");
+  pref("font.name-list.cursive.x-telu", "cursive");
+
+  pref("font.name-list.serif.x-tibt", "serif");
+  pref("font.name-list.sans-serif.x-tibt", "sans-serif");
+  pref("font.name-list.monospace.x-tibt", "monospace");
+  pref("font.name-list.cursive.x-tibt", "cursive");
+
+  pref("font.name-list.serif.x-unicode", "serif");
+  pref("font.name-list.sans-serif.x-unicode", "sans-serif");
+  pref("font.name-list.monospace.x-unicode", "monospace");
+  pref("font.name-list.cursive.x-unicode", "cursive");
+  pref("font.size.monospace.x-unicode", 12);
+
+  pref("font.name-list.serif.x-western", "serif");
+  pref("font.name-list.sans-serif.x-western", "sans-serif");
+  pref("font.name-list.monospace.x-western", "monospace");
+  pref("font.name-list.cursive.x-western", "cursive");
+  pref("font.size.monospace.x-western", 12);
+
+  pref("font.name-list.serif.zh-CN", "serif");
+  pref("font.name-list.sans-serif.zh-CN", "sans-serif");
+  pref("font.name-list.monospace.zh-CN", "monospace");
+  pref("font.name-list.cursive.zh-CN", "cursive");
+
+  pref("font.name-list.serif.zh-HK", "serif");
+  pref("font.name-list.sans-serif.zh-HK", "sans-serif");
+  pref("font.name-list.monospace.zh-HK", "monospace");
+  pref("font.name-list.cursive.zh-HK", "cursive");
+
+  pref("font.name-list.serif.zh-TW", "serif");
+  pref("font.name-list.sans-serif.zh-TW", "sans-serif");
+  pref("font.name-list.monospace.zh-TW", "monospace");
+  pref("font.name-list.cursive.zh-TW", "cursive");
+
+  // On GTK2 platform, we should use topmost window level for the default window
+  // level of <panel> element of XUL. GTK2 has only two window types. One is
+  // normal top level window, other is popup window. The popup window is always
+  // topmost window level, therefore, we are using normal top level window for
+  // non-topmost panel, but it is pretty hacky. On some Window Managers, we have
+  // 2 problems:
+  // 1. The non-topmost panel steals focus from its parent window at showing.
+  // 2. The parent of non-topmost panel is not activated when the panel is hidden.
+  // So, we have no reasons we should use non-toplevel window for popup.
+  pref("ui.panel.default_level_parent", true);
+
+  pref("intl.ime.use_simple_context_on_password_field", false);
+
+  // uim may use key snooper to listen to key events.  Unfortunately, we cannot
+  // know whether it uses or not since it's a build option.  So, we need to make
+  // distribution switchable whether we think uim uses key snooper or not with
+  // this pref.  Debian 9.x still uses uim as their default IM and it uses key
+  // snooper.  So, let's use true for its default value.
+  pref("intl.ime.hack.uim.using_key_snooper", true);
+
+  #ifdef MOZ_WIDGET_GTK
+    // maximum number of fonts to substitute for a generic
+    pref("gfx.font_rendering.fontconfig.max_generic_substitutions", 3);
+  #endif
+
+#endif // !ANDROID && !XP_MACOSX && XP_UNIX
+
+#if defined(ANDROID)
+
+  pref("font.size.monospace.ar", 12);
+
+  pref("font.default.el", "sans-serif");
+  pref("font.size.monospace.el", 12);
+
+  pref("font.size.monospace.he", 12);
+
+  pref("font.default.x-cyrillic", "sans-serif");
+  pref("font.size.monospace.x-cyrillic", 12);
+
+  pref("font.default.x-unicode", "sans-serif");
+  pref("font.size.monospace.x-unicode", 12);
+
+  pref("font.default.x-western", "sans-serif");
+  pref("font.size.monospace.x-western", 12);
+
+#endif // ANDROID
+
+#if defined(ANDROID)
+  // We use the bundled Charis SIL Compact as serif font for Firefox for Android
+
+  pref("font.name-list.emoji", "Noto Color Emoji");
+
+  pref("font.name-list.serif.ar", "Noto Naskh Arabic, Noto Serif, Droid Serif");
+  pref("font.name-list.sans-serif.ar", "Noto Naskh Arabic, Roboto, Google Sans, Droid Sans");
+  pref("font.name-list.monospace.ar", "Noto Naskh Arabic");
+
+  pref("font.name-list.serif.el", "Droid Serif, Noto Serif"); // not Charis SIL Compact, only has a few Greek chars
+  pref("font.name-list.sans-serif.el", "Roboto, Google Sans, Droid Sans");
+  pref("font.name-list.monospace.el", "Droid Sans Mono");
+
+  pref("font.name-list.serif.he", "Droid Serif, Noto Serif, Noto Serif Hebrew");
+  pref("font.name-list.sans-serif.he", "Roboto, Google Sans, Noto Sans Hebrew, Droid Sans Hebrew, Droid Sans, Arial");
+  pref("font.name-list.monospace.he", "Droid Sans Mono");
+
+  pref("font.name-list.serif.ja", "Charis SIL Compact, Noto Serif CJK JP, Noto Serif, Droid Serif");
+  pref("font.name-list.sans-serif.ja", "Roboto, Google Sans, Droid Sans, MotoyaLMaru, MotoyaLCedar, Noto Sans JP, Noto Sans CJK JP, SEC CJK JP, Droid Sans Japanese");
+  pref("font.name-list.monospace.ja", "MotoyaLMaru, MotoyaLCedar, Noto Sans Mono CJK JP, SEC Mono CJK JP, Droid Sans Mono");
+
+  pref("font.name-list.serif.ko", "Charis SIL Compact, Noto Serif CJK KR, Noto Serif, Droid Serif, HYSerif");
+  pref("font.name-list.sans-serif.ko", "Roboto, Google Sans, SmartGothic, NanumGothic, Noto Sans KR, Noto Sans CJK KR, SamsungKorean_v2.0, SEC CJK KR, DroidSansFallback, Droid Sans Fallback");
+  pref("font.name-list.monospace.ko", "Droid Sans Mono, Noto Sans Mono CJK KR, SEC Mono CJK KR");
+
+  pref("font.name-list.serif.th", "Charis SIL Compact, Noto Serif, Noto Serif Thai, Droid Serif");
+  pref("font.name-list.sans-serif.th", "Roboto, Google Sans, Noto Sans Thai, Droid Sans Thai, Droid Sans");
+  pref("font.name-list.monospace.th", "Droid Sans Mono");
+
+  pref("font.name-list.serif.x-armn", "Noto Serif Armenian");
+  pref("font.name-list.sans-serif.x-armn", "Noto Sans Armenian");
+
+  pref("font.name-list.serif.x-beng", "Noto Serif Bengali");
+  pref("font.name-list.sans-serif.x-beng", "Noto Sans Bengali");
+
+  pref("font.name-list.serif.x-cyrillic", "Charis SIL Compact, Noto Serif, Droid Serif");
+  pref("font.name-list.sans-serif.x-cyrillic", "Roboto, Google Sans, Droid Sans");
+  pref("font.name-list.monospace.x-cyrillic", "Droid Sans Mono");
+
+  pref("font.name-list.serif.x-devanagari", "Noto Serif Devanagari");
+  pref("font.name-list.sans-serif.x-devanagari", "Noto Sans Devanagari");
+
+  pref("font.name-list.serif.x-ethi", "Noto Serif Ethiopic");
+  pref("font.name-list.sans-serif.x-ethi", "Noto Sans Ethiopic");
+
+  pref("font.name-list.serif.x-geor", "Noto Serif Georgian");
+  pref("font.name-list.sans-serif.x-geor", "Noto Sans Georgian");
+
+  pref("font.name-list.serif.x-gujr", "Noto Serif Gujarati");
+  pref("font.name-list.sans-serif.x-gujr", "Noto Sans Gujarati");
+
+  pref("font.name-list.serif.x-guru", "Noto Serif Gurmukhi");
+  pref("font.name-list.sans-serif.x-guru", "Noto Sans Gurmukhi");
+
+  pref("font.name-list.serif.x-khmr", "Noto Serif Khmer");
+  pref("font.name-list.sans-serif.x-khmr", "Noto Sans Khmer");
+
+  pref("font.name-list.serif.x-knda", "Noto Serif Kannada");
+  pref("font.name-list.sans-serif.x-knda", "Noto Sans Kannada");
+
+  pref("font.name-list.serif.x-mlym", "Noto Serif Malayalam");
+  pref("font.name-list.sans-serif.x-mlym", "Noto Sans Malayalam");
+
+  pref("font.name-list.sans-serif.x-orya", "Noto Sans Oriya");
+
+  pref("font.name-list.serif.x-sinh", "Noto Serif Sinhala");
+  pref("font.name-list.sans-serif.x-sinh", "Noto Sans Sinhala");
+
+  pref("font.name-list.serif.x-tamil", "Noto Serif Tamil");
+  pref("font.name-list.sans-serif.x-tamil", "Noto Sans Tamil");
+
+  pref("font.name-list.serif.x-telu", "Noto Serif Telugu");
+  pref("font.name-list.sans-serif.x-telu", "Noto Sans Telugu");
+
+  pref("font.name-list.serif.x-tibt", "Noto Serif Tibetan");
+  pref("font.name-list.sans-serif.x-tibt", "Noto Sans Tibetan");
+
+  pref("font.name-list.serif.x-unicode", "Charis SIL Compact, Noto Serif, Droid Serif");
+  pref("font.name-list.sans-serif.x-unicode", "Roboto, Google Sans, Droid Sans");
+  pref("font.name-list.monospace.x-unicode", "Droid Sans Mono");
+
+  pref("font.name-list.serif.x-western", "Charis SIL Compact, Noto Serif, Droid Serif");
+  pref("font.name-list.sans-serif.x-western", "Roboto, Google Sans, Droid Sans");
+  pref("font.name-list.monospace.x-western", "Droid Sans Mono");
+
+  pref("font.name-list.serif.zh-CN", "Charis SIL Compact, Noto Serif CJK SC, Noto Serif, Droid Serif, Droid Sans Fallback");
+  pref("font.name-list.sans-serif.zh-CN", "Roboto, Google Sans, Droid Sans, Noto Sans SC, Noto Sans CJK SC, SEC CJK SC, Droid Sans Fallback");
+  pref("font.name-list.monospace.zh-CN", "Droid Sans Mono, Noto Sans Mono CJK SC, SEC Mono CJK SC, Droid Sans Fallback");
+
+  pref("font.name-list.serif.zh-HK", "Charis SIL Compact, Noto Serif CJK TC, Noto Serif, Droid Serif, Droid Sans Fallback");
+  pref("font.name-list.sans-serif.zh-HK", "Roboto, Google Sans, Droid Sans, Noto Sans TC, Noto Sans SC, Noto Sans CJK TC, SEC CJK TC, Droid Sans Fallback");
+  pref("font.name-list.monospace.zh-HK", "Droid Sans Mono, Noto Sans Mono CJK TC, SEC Mono CJK TC, Droid Sans Fallback");
+
+  pref("font.name-list.serif.zh-TW", "Charis SIL Compact, Noto Serif CJK TC, Noto Serif, Droid Serif, Droid Sans Fallback");
+  pref("font.name-list.sans-serif.zh-TW", "Roboto, Google Sans, Droid Sans, Noto Sans TC, Noto Sans SC, Noto Sans CJK TC, SEC CJK TC, Droid Sans Fallback");
+  pref("font.name-list.monospace.zh-TW", "Droid Sans Mono, Noto Sans Mono CJK TC, SEC Mono CJK TC, Droid Sans Fallback");
+
+  pref("font.name-list.serif.x-math", "Latin Modern Math, STIX Two Math, XITS Math, Cambria Math, Libertinus Math, DejaVu Math TeX Gyre, TeX Gyre Bonum Math, TeX Gyre Pagella Math, TeX Gyre Schola, TeX Gyre Termes Math, STIX Math, Asana Math, STIXGeneral, DejaVu Serif, DejaVu Sans, Charis SIL Compact");
+  pref("font.name-list.sans-serif.x-math", "Roboto, Google Sans");
+  pref("font.name-list.monospace.x-math", "Droid Sans Mono");
+
+#endif
+
+#if OS_ARCH==AIX
+
+  // Override default Japanese fonts
+  pref("font.name-list.serif.ja", "dt-interface system-jisx0208.1983-0");
+  pref("font.name-list.sans-serif.ja", "dt-interface system-jisx0208.1983-0");
+  pref("font.name-list.monospace.ja", "dt-interface user-jisx0208.1983-0");
+
+  // Override default Cyrillic fonts
+  pref("font.name-list.serif.x-cyrillic", "dt-interface system-iso8859-5");
+  pref("font.name-list.sans-serif.x-cyrillic", "dt-interface system-iso8859-5");
+  pref("font.name-list.monospace.x-cyrillic", "dt-interface user-iso8859-5");
+
+  // Override default Unicode fonts
+  pref("font.name-list.serif.x-unicode", "dt-interface system-ucs2.cjk_japan-0");
+  pref("font.name-list.sans-serif.x-unicode", "dt-interface system-ucs2.cjk_japan-0");
+  pref("font.name-list.monospace.x-unicode", "dt-interface user-ucs2.cjk_japan-0");
+
+#endif // AIX
+
+// Login Manager prefs
+pref("signon.rememberSignons",              true);
+pref("signon.rememberSignons.visibilityToggle", true);
+pref("signon.autofillForms",                true);
+pref("signon.autofillForms.autocompleteOff", true);
+pref("signon.autofillForms.http",           false);
+pref("signon.autologin.proxy",              false);
+pref("signon.capture.inputChanges.enabled", true);
+pref("signon.formlessCapture.enabled",      true);
+pref("signon.formRemovalCapture.enabled",   true);
+pref("signon.generation.available",               true);
+pref("signon.improvedPasswordRules.enabled", true);
+pref("signon.backup.enabled",               true);
+pref("signon.generation.confidenceThreshold",     "0.75");
+pref("signon.generation.enabled",                 true);
+pref("signon.passwordEditCapture.enabled",        false);
+pref("signon.privateBrowsingCapture.enabled",     true);
+pref("signon.storeWhenAutocompleteOff",     true);
+pref("signon.userInputRequiredToCapture.enabled", true);
+pref("signon.usernameOnlyForm.lookupThreshold",  5);
+pref("signon.debug",                        false);
+pref("signon.recipes.path", "resource://app/defaults/settings/main/password-recipes.json");
+pref("signon.recipes.remoteRecipes.enabled", true);
+pref("signon.relatedRealms.enabled", false);
+
+pref("signon.schemeUpgrades",                     true);
+pref("signon.includeOtherSubdomainsInLookup",     true);
+// This temporarily prevents the primary password to reprompt for autocomplete.
+pref("signon.masterPasswordReprompt.timeout_ms", 900000); // 15 Minutes
+pref("signon.showAutoCompleteFooter",             false);
+pref("signon.showAutoCompleteOrigins",            true);
+
+// Satchel (Form Manager) prefs
+pref("browser.formfill.debug",            false);
+pref("browser.formfill.enable",           true);
+pref("browser.formfill.expire_days",      180);
+pref("browser.formfill.agedWeight",       2);
+pref("browser.formfill.bucketSize",       1);
+pref("browser.formfill.maxTimeGroupings", 25);
+pref("browser.formfill.timeGroupingSize", 604800);
+pref("browser.formfill.boundaryWeight",   25);
+pref("browser.formfill.prefixWeight",     5);
+
+// Zoom prefs
+pref("browser.zoom.full", false);
+pref("toolkit.zoomManager.zoomValues", ".3,.5,.67,.8,.9,1,1.1,1.2,1.33,1.5,1.7,2,2.4,3,4,5");
+
+//
+// Image-related prefs
+//
+
+// By default the Accept header sent for images loaded over HTTP(S) is derived
+// by ImageAcceptHeader() in nsHttpHandler.cpp. If set, this pref overrides it.
+// There is also network.http.accept which works in scope of document.
+pref("image.http.accept", "");
+
+//
+// Image memory management prefs
+//
+
+pref("webgl.renderer-string-override", "");
+pref("webgl.vendor-string-override", "");
+
+// sendbuffer of 0 means use OS default, sendbuffer unset means use
+// gecko default which varies depending on windows version and is OS
+// default on non windows
+// pref("network.tcp.sendbuffer", 0);
+
+// TCP Keepalive
+pref("network.tcp.keepalive.enabled", true);
+// Default idle time before first TCP keepalive probe; same time for interval
+// between successful probes. Can be overridden in socket transport API.
+// Win, Linux and Mac.
+pref("network.tcp.keepalive.idle_time", 600); // seconds; 10 mins
+// Default timeout for retransmission of unack'd keepalive probes.
+// Win and Linux only; not configurable on Mac.
+#if defined(XP_UNIX) && !defined(XP_MACOSX) || defined(XP_WIN)
+  pref("network.tcp.keepalive.retry_interval", 1); // seconds
+#endif
+// Default maximum probe retransmissions.
+// Linux only; not configurable on Win and Mac; fixed at 10 and 8 respectively.
+#if defined(XP_UNIX) && !defined(XP_MACOSX)
+  pref("network.tcp.keepalive.probe_count", 4);
+#endif
+
+// This pref controls if we send the "public-suffix-list-updated" notification
+// from PublicSuffixList.onUpdate() - Doing so would cause the PSL graph to
+// be updated while Firefox is running which may cause principals to have an
+// inconsistent state. See bug 1582647 comment 30
+pref("network.psl.onUpdate_notify", false);
+
+#ifdef MOZ_WIDGET_GTK
+  pref("widget.content.gtk-theme-override", "");
+  pref("widget.disable-workspace-management", false);
+  pref("widget.titlebar-x11-use-shape-mask", false);
+#endif
+
+// All the Geolocation preferences are here.
+//
+#ifndef EARLY_BETA_OR_EARLIER
+  pref("geo.provider.network.url", "https://www.googleapis.com/geolocation/v1/geolocate?key=%GOOGLE_LOCATION_SERVICE_API_KEY%");
+#else
+  // Use MLS on Nightly and early Beta.
+  pref("geo.provider.network.url", "https://location.services.mozilla.com/v1/geolocate?key=%MOZILLA_API_KEY%");
+#endif
+
+// Timeout to wait before sending the location request.
+pref("geo.provider.network.timeToWaitBeforeSending", 5000);
+// Timeout for outbound network geolocation provider.
+pref("geo.provider.network.timeout", 60000);
+
+#ifdef XP_MACOSX
+  pref("geo.provider.use_corelocation", true);
+#endif
+
+// Set to false if things are really broken.
+#ifdef XP_WIN
+  pref("geo.provider.ms-windows-location", true);
+#endif
+
+#if defined(MOZ_WIDGET_GTK) && defined(MOZ_GPSD)
+  pref("geo.provider.use_gpsd", true);
+#endif
+
+// Region
+pref("browser.region.log", false);
+pref("browser.region.network.url", "https://location.services.mozilla.com/v1/country?key=%MOZILLA_API_KEY%");
+// Include wifi data in region request.
+pref("browser.region.network.scan", false);
+// Timeout for whole region request.
+pref("browser.region.timeout", 5000);
+pref("browser.region.update.enabled", true);
+
+// Enable/Disable the device storage API for content
+pref("device.storage.enabled", false);
+
+pref("browser.meta_refresh_when_inactive.disabled", false);
+
+// XPInstall prefs
+pref("xpinstall.whitelist.required", true);
+// Only Firefox requires add-on signatures
+pref("xpinstall.signatures.required", false);
+pref("extensions.langpacks.signatures.required", false);
+pref("extensions.webExtensionsMinPlatformVersion", "42.0a1");
+pref("extensions.experiments.enabled", true);
+
+// Other webextensions prefs
+pref("extensions.webextensions.keepStorageOnUninstall", false);
+pref("extensions.webextensions.keepUuidOnUninstall", false);
+// Redirect basedomain used by identity api
+pref("extensions.webextensions.identity.redirectDomain", "extensions.allizom.org");
+pref("extensions.webextensions.restrictedDomains", "accounts-static.cdn.mozilla.net,accounts.firefox.com,addons.cdn.mozilla.net,addons.mozilla.org,api.accounts.firefox.com,content.cdn.mozilla.net,discovery.addons.mozilla.org,install.mozilla.org,oauth.accounts.firefox.com,profile.accounts.firefox.com,support.mozilla.org,sync.services.mozilla.com");
+
+// Whether or not the moz-extension resource loads are remoted. For debugging
+// purposes only. Setting this to false will break moz-extension URI loading
+// unless other process sandboxing and extension remoting prefs are changed.
+pref("extensions.webextensions.protocol.remote", true);
+
+// Enable userScripts API by default.
+pref("extensions.webextensions.userScripts.enabled", true);
+
+// Whether or not the installed extensions should be migrated to the storage.local IndexedDB backend.
+pref("extensions.webextensions.ExtensionStorageIDB.enabled", true);
+
+// if enabled, store execution times for API calls
+pref("extensions.webextensions.enablePerformanceCounters", true);
+
+// Maximum age in milliseconds of performance counters in children
+// When reached, the counters are sent to the main process and
+// reset, so we reduce memory footprint.
+pref("extensions.webextensions.performanceCountersMaxAge", 5000);
+
+// Whether to allow the inline options browser in HTML about:addons page.
+pref("extensions.htmlaboutaddons.inline-options.enabled", true);
+// Show recommendations on the extension and theme list views.
+pref("extensions.htmlaboutaddons.recommendations.enabled", true);
+
+// The URL for the privacy policy related to recommended add-ons.
+pref("extensions.recommendations.privacyPolicyUrl", "");
+// The URL for a recommended theme, shown on the theme page in about:addons.
+pref("extensions.recommendations.themeRecommendationUrl", "");
+
+// Report Site Issue button
+// Note that on enabling the button in other release channels, make sure to
+// disable it in problematic tests, see disableNonReleaseActions() inside
+// browser/modules/test/browser/head.js
+pref("extensions.webcompat-reporter.newIssueEndpoint", "https://webcompat.com/issues/new");
+#if MOZ_UPDATE_CHANNEL != release && MOZ_UPDATE_CHANNEL != esr
+  pref("extensions.webcompat-reporter.enabled", true);
+#else
+  pref("extensions.webcompat-reporter.enabled", false);
+#endif
+
+// Add-on content security policies.
+pref("extensions.webextensions.base-content-security-policy", "script-src 'self' https://* http://localhost:* http://127.0.0.1:* moz-extension: blob: filesystem: 'unsafe-eval' 'unsafe-inline'; object-src 'self' moz-extension: blob: filesystem:;");
+pref("extensions.webextensions.base-content-security-policy.v3", "script-src 'self' http://localhost:* http://127.0.0.1:*; object-src 'self';");
+pref("extensions.webextensions.default-content-security-policy", "script-src 'self'; object-src 'self';");
+
+
+pref("network.buffer.cache.count", 24);
+pref("network.buffer.cache.size",  32768);
+
+// Web Notification
+pref("dom.webnotifications.requireinteraction.count", 3);
+
+// Show favicons in web notifications.
+pref("alerts.showFavicons", false);
+
+// DOM full-screen API.
+#ifdef XP_MACOSX
+  // Whether to use macOS native full screen for Fullscreen API
+  pref("full-screen-api.macos-native-full-screen", false);
+#endif
+// whether to prevent the top level widget from going fullscreen
+pref("full-screen-api.ignore-widgets", false);
+// transition duration of fade-to-black and fade-from-black, unit: ms
+#ifndef MOZ_WIDGET_GTK
+  pref("full-screen-api.transition-duration.enter", "200 200");
+  pref("full-screen-api.transition-duration.leave", "200 200");
+#else
+  pref("full-screen-api.transition-duration.enter", "0 0");
+  pref("full-screen-api.transition-duration.leave", "0 0");
+#endif
+// timeout for black screen in fullscreen transition, unit: ms
+pref("full-screen-api.transition.timeout", 1000);
+// time for the warning box stays on the screen before sliding out, unit: ms
+pref("full-screen-api.warning.timeout", 3000);
+// delay for the warning box to show when pointer stays on the top, unit: ms
+pref("full-screen-api.warning.delay", 500);
+
+// DOM pointerlock API
+// time for the warning box stays on the screen before sliding out, unit: ms
+pref("pointer-lock-api.warning.timeout", 3000);
+
+// Push
+
+pref("dom.push.loglevel", "Error");
+
+pref("dom.push.serverURL", "wss://push.services.mozilla.com/");
+pref("dom.push.userAgentID", "");
+
+// The maximum number of push messages that a service worker can receive
+// without user interaction.
+pref("dom.push.maxQuotaPerSubscription", 16);
+
+// The maximum number of recent message IDs to store for each push
+// subscription, to avoid duplicates for unacknowledged messages.
+pref("dom.push.maxRecentMessageIDsPerSubscription", 10);
+
+// The delay between receiving a push message and updating the quota for a
+// subscription.
+pref("dom.push.quotaUpdateDelay", 3000); // 3 seconds
+
+// Is the network connection allowed to be up?
+// This preference should be used in UX to enable/disable push.
+pref("dom.push.connection.enabled", true);
+
+// Exponential back-off start is 5 seconds like in HTTP/1.1.
+// Maximum back-off is pingInterval.
+pref("dom.push.retryBaseInterval", 5000);
+
+// Interval at which to ping PushServer to check connection status. In
+// milliseconds. If no reply is received within requestTimeout, the connection
+// is considered closed.
+pref("dom.push.pingInterval", 1800000); // 30 minutes
+
+// How long before we timeout
+pref("dom.push.requestTimeout", 10000);
+
+// WebPush prefs:
+pref("dom.push.http2.reset_retry_count_after_ms", 60000);
+pref("dom.push.http2.maxRetries", 2);
+pref("dom.push.http2.retryInterval", 5000);
+
+// How long must we wait before declaring that a window is a "ghost" (i.e., a
+// likely leak)?  This should be longer than it usually takes for an eligible
+// window to be collected via the GC/CC.
+pref("memory.ghost_window_timeout_seconds", 60);
+
+// Don't dump memory reports on OOM, by default.
+pref("memory.dump_reports_on_oom", false);
+
+// Number of stack frames to capture in createObjectURL for about:memory.
+pref("memory.blob_report.stack_frames", 0);
+
+// Activates the activity monitor
+pref("io.activity.enabled", false);
+
+// path to OSVR DLLs
+pref("gfx.vr.osvr.utilLibPath", "");
+pref("gfx.vr.osvr.commonLibPath", "");
+pref("gfx.vr.osvr.clientLibPath", "");
+pref("gfx.vr.osvr.clientKitLibPath", "");
+
+// nsMemoryInfoDumper can watch a fifo in the temp directory and take various
+// actions when the fifo is written to.  Disable this in general.
+pref("memory_info_dumper.watch_fifo.enabled", false);
+
+// If minInterval is 0, the check will only happen
+// when the service has a strong suspicion we are in a captive portal
+pref("network.captive-portal-service.minInterval", 60000); // 60 seconds
+pref("network.captive-portal-service.maxInterval", 1500000); // 25 minutes
+// Every 10 checks, the delay is increased by a factor of 5
+pref("network.captive-portal-service.backoffFactor", "5.0");
+pref("network.captive-portal-service.enabled", false);
+
+pref("network.connectivity-service.enabled", true);
+pref("network.connectivity-service.DNSv4.domain", "example.org");
+pref("network.connectivity-service.DNSv6.domain", "example.org");
+pref("network.connectivity-service.IPv4.url", "http://detectportal.firefox.com/success.txt?ipv4");
+pref("network.connectivity-service.IPv6.url", "http://detectportal.firefox.com/success.txt?ipv6");
+
+// DNS Trusted Recursive Resolver
+// 0 - default off, 1 - reserved/off, 2 - TRR first, 3 - TRR only, 4 - reserved/off, 5 off by choice
+pref("network.trr.mode", 0);
+pref("network.trr.uri", "");
+// credentials to pass to DOH end-point
+pref("network.trr.credentials", "");
+pref("network.trr.custom_uri", "");
+// Before TRR is widely used the NS record for this host is fetched
+// from the DOH end point to ensure proper configuration
+pref("network.trr.confirmationNS", "example.com");
+// Comma separated list of domains that we should not use TRR for
+pref("network.trr.excluded-domains", "");
+pref("network.trr.builtin-excluded-domains", "localhost,local");
+
+pref("captivedetect.canonicalURL", "http://detectportal.firefox.com/canonical.html");
+pref("captivedetect.canonicalContent", "<meta http-equiv=\"refresh\" content=\"0;url=https://support.mozilla.org/kb/captive-portal\"/>");
+pref("captivedetect.maxWaitingTime", 5000);
+pref("captivedetect.pollingTime", 3000);
+pref("captivedetect.maxRetryCount", 5);
+
+// The tables used for Safebrowsing phishing and malware checks
+pref("urlclassifier.malwareTable", "goog-malware-proto,goog-unwanted-proto,moztest-harmful-simple,moztest-malware-simple,moztest-unwanted-simple");
+#ifdef MOZILLA_OFFICIAL
+  // In official builds, we are allowed to use Google's private phishing
+  // list (see bug 1288840).
+  pref("urlclassifier.phishTable", "goog-phish-proto,moztest-phish-simple");
+#else
+  pref("urlclassifier.phishTable", "googpub-phish-proto,moztest-phish-simple");
+#endif
+
+// Tables for application reputation
+pref("urlclassifier.downloadAllowTable", "goog-downloadwhite-proto");
+pref("urlclassifier.downloadBlockTable", "goog-badbinurl-proto");
+
+// Tables for login reputation
+pref("urlclassifier.passwordAllowTable", "goog-passwordwhite-proto");
+
+// Tables for anti-tracking features
+pref("urlclassifier.trackingAnnotationTable", "moztest-track-simple,ads-track-digest256,social-track-digest256,analytics-track-digest256,content-track-digest256");
+pref("urlclassifier.trackingAnnotationWhitelistTable", "moztest-trackwhite-simple,mozstd-trackwhite-digest256,google-trackwhite-digest256");
+pref("urlclassifier.trackingTable", "moztest-track-simple,ads-track-digest256,social-track-digest256,analytics-track-digest256");
+pref("urlclassifier.trackingWhitelistTable", "moztest-trackwhite-simple,mozstd-trackwhite-digest256,google-trackwhite-digest256");
+
+pref("urlclassifier.features.fingerprinting.blacklistTables", "base-fingerprinting-track-digest256");
+pref("urlclassifier.features.fingerprinting.whitelistTables", "mozstd-trackwhite-digest256,google-trackwhite-digest256");
+pref("urlclassifier.features.fingerprinting.annotate.blacklistTables", "base-fingerprinting-track-digest256");
+pref("urlclassifier.features.fingerprinting.annotate.whitelistTables", "mozstd-trackwhite-digest256,google-trackwhite-digest256");
+pref("urlclassifier.features.cryptomining.blacklistTables", "base-cryptomining-track-digest256");
+pref("urlclassifier.features.cryptomining.whitelistTables", "mozstd-trackwhite-digest256");
+pref("urlclassifier.features.cryptomining.annotate.blacklistTables", "base-cryptomining-track-digest256");
+pref("urlclassifier.features.cryptomining.annotate.whitelistTables", "mozstd-trackwhite-digest256");
+pref("urlclassifier.features.socialtracking.blacklistTables", "social-tracking-protection-facebook-digest256,social-tracking-protection-linkedin-digest256,social-tracking-protection-twitter-digest256");
+pref("urlclassifier.features.socialtracking.whitelistTables", "mozstd-trackwhite-digest256,google-trackwhite-digest256");
+pref("urlclassifier.features.socialtracking.annotate.blacklistTables", "social-tracking-protection-facebook-digest256,social-tracking-protection-linkedin-digest256,social-tracking-protection-twitter-digest256");
+pref("urlclassifier.features.socialtracking.annotate.whitelistTables", "mozstd-trackwhite-digest256,google-trackwhite-digest256");
+
+// These tables will never trigger a gethash call.
+pref("urlclassifier.disallow_completions", "goog-downloadwhite-digest256,base-track-digest256,mozstd-trackwhite-digest256,content-track-digest256,mozplugin-block-digest256,mozplugin2-block-digest256,block-flash-digest256,except-flash-digest256,allow-flashallow-digest256,except-flashallow-digest256,block-flashsubdoc-digest256,except-flashsubdoc-digest256,goog-passwordwhite-proto,ads-track-digest256,social-track-digest256,analytics-track-digest256,base-fingerprinting-track-digest256,content-fingerprinting-track-digest256,base-cryptomining-track-digest256,content-cryptomining-track-digest256,fanboyannoyance-ads-digest256,fanboysocial-ads-digest256,easylist-ads-digest256,easyprivacy-ads-digest256,adguard-ads-digest256,social-tracking-protection-digest256,social-tracking-protection-facebook-digest256,social-tracking-protection-linkedin-digest256,social-tracking-protection-twitter-digest256");
+
+// Workaround for Google Recaptcha
+pref("urlclassifier.trackingAnnotationSkipURLs", "google.com/recaptcha/,*.google.com/recaptcha/");
+pref("privacy.rejectForeign.allowList", "");
+
+// Number of random entries to send with a gethash request
+pref("urlclassifier.gethashnoise", 4);
+
+// Gethash timeout for Safe Browsing
+pref("urlclassifier.gethash.timeout_ms", 5000);
+
+// Name of the about: page to display Safe Browsing warnings (bug 399233)
+pref("urlclassifier.alternate_error_page", "blocked");
+
+// Enable safe-browsing debugging
+pref("browser.safebrowsing.debug", false);
+
+// Allow users to ignore Safe Browsing warnings.
+pref("browser.safebrowsing.allowOverride", true);
+
+// These names are approved by the Google Safe Browsing team.
+// Any changes must be coordinated with them.
+#ifdef MOZILLA_OFFICIAL
+  pref("browser.safebrowsing.id", "navclient-auto-ffox");
+#else
+  pref("browser.safebrowsing.id", "Firefox");
+#endif
+
+// Download protection
+pref("browser.safebrowsing.downloads.enabled", true);
+pref("browser.safebrowsing.downloads.remote.enabled", true);
+pref("browser.safebrowsing.downloads.remote.timeout_ms", 15000);
+pref("browser.safebrowsing.downloads.remote.url", "https://sb-ssl.google.com/safebrowsing/clientreport/download?key=%GOOGLE_SAFEBROWSING_API_KEY%");
+pref("browser.safebrowsing.downloads.remote.block_dangerous",            true);
+pref("browser.safebrowsing.downloads.remote.block_dangerous_host",       true);
+pref("browser.safebrowsing.downloads.remote.block_potentially_unwanted", true);
+pref("browser.safebrowsing.downloads.remote.block_uncommon",             true);
+
+// Android SafeBrowsing's configuration is in ContentBlocking.java, keep in sync.
+#ifndef MOZ_WIDGET_ANDROID
+
+// Google Safe Browsing provider (legacy)
+pref("browser.safebrowsing.provider.google.pver", "2.2");
+pref("browser.safebrowsing.provider.google.lists", "goog-badbinurl-shavar,goog-downloadwhite-digest256,goog-phish-shavar,googpub-phish-shavar,goog-malware-shavar,goog-unwanted-shavar");
+pref("browser.safebrowsing.provider.google.updateURL", "https://safebrowsing.google.com/safebrowsing/downloads?client=SAFEBROWSING_ID&appver=%MAJOR_VERSION%&pver=2.2&key=%GOOGLE_SAFEBROWSING_API_KEY%");
+pref("browser.safebrowsing.provider.google.gethashURL", "https://safebrowsing.google.com/safebrowsing/gethash?client=SAFEBROWSING_ID&appver=%MAJOR_VERSION%&pver=2.2");
+pref("browser.safebrowsing.provider.google.reportURL", "https://safebrowsing.google.com/safebrowsing/diagnostic?site=");
+pref("browser.safebrowsing.provider.google.reportPhishMistakeURL", "https://%LOCALE%.phish-error.mozilla.com/?url=");
+pref("browser.safebrowsing.provider.google.reportMalwareMistakeURL", "https://%LOCALE%.malware-error.mozilla.com/?url=");
+pref("browser.safebrowsing.provider.google.advisoryURL", "https://developers.google.com/safe-browsing/v4/advisory");
+pref("browser.safebrowsing.provider.google.advisoryName", "Google Safe Browsing");
+
+// Google Safe Browsing provider
+pref("browser.safebrowsing.provider.google4.pver", "4");
+pref("browser.safebrowsing.provider.google4.lists", "goog-badbinurl-proto,goog-downloadwhite-proto,goog-phish-proto,googpub-phish-proto,goog-malware-proto,goog-unwanted-proto,goog-harmful-proto,goog-passwordwhite-proto");
+pref("browser.safebrowsing.provider.google4.updateURL", "https://safebrowsing.googleapis.com/v4/threatListUpdates:fetch?$ct=application/x-protobuf&key=%GOOGLE_SAFEBROWSING_API_KEY%&$httpMethod=POST");
+pref("browser.safebrowsing.provider.google4.gethashURL", "https://safebrowsing.googleapis.com/v4/fullHashes:find?$ct=application/x-protobuf&key=%GOOGLE_SAFEBROWSING_API_KEY%&$httpMethod=POST");
+pref("browser.safebrowsing.provider.google4.reportURL", "https://safebrowsing.google.com/safebrowsing/diagnostic?site=");
+pref("browser.safebrowsing.provider.google4.reportPhishMistakeURL", "https://%LOCALE%.phish-error.mozilla.com/?url=");
+pref("browser.safebrowsing.provider.google4.reportMalwareMistakeURL", "https://%LOCALE%.malware-error.mozilla.com/?url=");
+pref("browser.safebrowsing.provider.google4.advisoryURL", "https://developers.google.com/safe-browsing/v4/advisory");
+pref("browser.safebrowsing.provider.google4.advisoryName", "Google Safe Browsing");
+pref("browser.safebrowsing.provider.google4.dataSharingURL", "https://safebrowsing.googleapis.com/v4/threatHits?$ct=application/x-protobuf&key=%GOOGLE_SAFEBROWSING_API_KEY%&$httpMethod=POST");
+pref("browser.safebrowsing.provider.google4.dataSharing.enabled", false);
+
+#endif // ifndef MOZ_WIDGET_ANDROID
+
+pref("browser.safebrowsing.reportPhishURL", "https://%LOCALE%.phish-report.mozilla.com/?url=");
+
+// Mozilla Safe Browsing provider (for tracking protection and plugin blocking)
+pref("browser.safebrowsing.provider.mozilla.pver", "2.2");
+pref("browser.safebrowsing.provider.mozilla.lists", "base-track-digest256,mozstd-trackwhite-digest256,google-trackwhite-digest256,content-track-digest256,mozplugin-block-digest256,mozplugin2-block-digest256,block-flash-digest256,except-flash-digest256,allow-flashallow-digest256,except-flashallow-digest256,block-flashsubdoc-digest256,except-flashsubdoc-digest256,ads-track-digest256,social-track-digest256,analytics-track-digest256,base-fingerprinting-track-digest256,content-fingerprinting-track-digest256,base-cryptomining-track-digest256,content-cryptomining-track-digest256,fanboyannoyance-ads-digest256,fanboysocial-ads-digest256,easylist-ads-digest256,easyprivacy-ads-digest256,adguard-ads-digest256,social-tracking-protection-digest256,social-tracking-protection-facebook-digest256,social-tracking-protection-linkedin-digest256,social-tracking-protection-twitter-digest256");
+pref("browser.safebrowsing.provider.mozilla.updateURL", "https://shavar.services.mozilla.com/downloads?client=SAFEBROWSING_ID&appver=%MAJOR_VERSION%&pver=2.2");
+pref("browser.safebrowsing.provider.mozilla.gethashURL", "https://shavar.services.mozilla.com/gethash?client=SAFEBROWSING_ID&appver=%MAJOR_VERSION%&pver=2.2");
+// Set to a date in the past to force immediate download in new profiles.
+pref("browser.safebrowsing.provider.mozilla.nextupdatetime", "1");
+// Block lists for tracking protection. The name values will be used as the keys
+// to lookup the localized name in preferences.properties.
+pref("browser.safebrowsing.provider.mozilla.lists.base", "moz-std");
+pref("browser.safebrowsing.provider.mozilla.lists.content", "moz-full");
+
+// The table and global pref for blocking plugin content
+pref("urlclassifier.blockedTable", "moztest-block-simple,mozplugin-block-digest256");
+
+// Flash blocking tables
+pref("urlclassifier.flashAllowTable", "allow-flashallow-digest256");
+pref("urlclassifier.flashAllowExceptTable", "except-flashallow-digest256");
+pref("urlclassifier.flashTable", "block-flash-digest256");
+pref("urlclassifier.flashExceptTable", "except-flash-digest256");
+pref("urlclassifier.flashSubDocTable", "block-flashsubdoc-digest256");
+pref("urlclassifier.flashSubDocExceptTable", "except-flashsubdoc-digest256");
+
+// Turn off Spatial navigation by default.
+pref("snav.enabled", false);
+
+// Wakelock is disabled by default.
+pref("dom.wakelock.enabled", false);
+
+#ifdef XP_MACOSX
+  #if !defined(RELEASE_OR_BETA) || defined(DEBUG)
+    // In non-release builds we crash by default on insecure text input (when a
+    // password editor has focus but secure event input isn't enabled).  The
+    // following pref, when turned on, disables this behavior.  See bug 1188425.
+    pref("intl.allow-insecure-text-input", false);
+  #endif
+#endif // XP_MACOSX
+
+// Search service settings
+pref("browser.search.log", false);
+pref("browser.search.update", true);
+pref("browser.search.suggest.enabled", true);
+pref("browser.search.suggest.enabled.private", false);
+pref("browser.search.separatePrivateDefault", false);
+pref("browser.search.separatePrivateDefault.ui.enabled", false);
+pref("browser.search.removeEngineInfobar.enabled", true);
+
+// GMPInstallManager prefs
+
+// User-settable override to media.gmp-manager.url for testing purposes.
+//pref("media.gmp-manager.url.override", "");
+
+// Update service URL for GMP install/updates:
+pref("media.gmp-manager.url", "https://aus5.mozilla.org/update/3/GMP/%VERSION%/%BUILD_ID%/%BUILD_TARGET%/%LOCALE%/%CHANNEL%/%OS_VERSION%/%DISTRIBUTION%/%DISTRIBUTION_VERSION%/update.xml");
+
+// When |media.gmp-manager.checkContentSignature| is true, then the reply
+// containing the update xml file is expected to provide a content signature
+// header. Information from this header will be used to validate the response.
+// If this header is not present, is malformed, or cannot be determined as
+// valid then the update will fail.
+// We should eventually remove this pref and any cert pinning code and make
+// the content signature path the sole path. We retain this for now in case
+// we need to debug content sig vs cert pin.
+pref("media.gmp-manager.checkContentSignature", true);
+
+// When |media.gmp-manager.cert.requireBuiltIn| is true or not specified the
+// final certificate and all certificates the connection is redirected to before
+// the final certificate for the url specified in the |media.gmp-manager.url|
+// preference must be built-in. The check related to this pref is not done if
+// |media.gmp-manager.checkContentSignature| is set to true (the content
+// signature check provides protection that supersedes the built in
+// requirement).
+pref("media.gmp-manager.cert.requireBuiltIn", true);
+
+// The |media.gmp-manager.certs.| preference branch contains branches that are
+// sequentially numbered starting at 1 that contain attribute name / value
+// pairs for the certificate used by the server that hosts the update xml file
+// as specified in the |media.gmp-manager.url| preference. When these preferences are
+// present the following conditions apply for a successful update check:
+// 1. the uri scheme must be https
+// 2. the preference name must exist as an attribute name on the certificate and
+//    the value for the name must be the same as the value for the attribute name
+//    on the certificate.
+// If these conditions aren't met it will be treated the same as when there is
+// no update available. This validation will not be performed when the
+// |media.gmp-manager.url.override| user preference has been set for testing updates or
+// when the |media.gmp-manager.cert.checkAttributes| preference is set to false.
+// This check will also not be done if the |media.gmp-manager.checkContentSignature|
+// pref is set to true. Also, the |media.gmp-manager.url.override| preference should
+// ONLY be used for testing.
+// IMPORTANT! app.update.certs.* prefs should also be updated if these
+// are updated.
+pref("media.gmp-manager.cert.checkAttributes", true);
+pref("media.gmp-manager.certs.1.issuerName", "CN=DigiCert SHA2 Secure Server CA,O=DigiCert Inc,C=US");
+pref("media.gmp-manager.certs.1.commonName", "aus5.mozilla.org");
+pref("media.gmp-manager.certs.2.issuerName", "CN=thawte SSL CA - G2,O=\"thawte, Inc.\",C=US");
+pref("media.gmp-manager.certs.2.commonName", "aus5.mozilla.org");
+
+// Whether or not to perform reader mode article parsing on page load.
+// If this pref is disabled, we will never show a reader mode icon in the toolbar.
+pref("reader.parse-on-load.enabled", true);
+
+// After what size document we don't bother running Readability on it
+// because it'd slow things down too much
+pref("reader.parse-node-limit", 3000);
+
+// Whether we include full URLs in browser console errors. This is disabled
+// by default because some platforms will persist these, leading to privacy issues.
+pref("reader.errors.includeURLs", false);
+
+// The default relative font size in reader mode (1-9)
+pref("reader.font_size", 5);
+
+// The default relative content width in reader mode (1-9)
+pref("reader.content_width", 3);
+
+// The default relative line height in reader mode (1-9)
+pref("reader.line_height", 4);
+
+// The default color scheme in reader mode (light, dark, sepia, auto)
+// auto = color automatically adjusts according to ambient light level
+// (auto only works on platforms where the 'devicelight' event is enabled)
+pref("reader.color_scheme", "auto");
+
+// Color scheme values available in reader mode UI.
+pref("reader.color_scheme.values", "[\"light\",\"dark\",\"sepia\",\"auto\"]");
+
+// The font type in reader (sans-serif, serif)
+pref("reader.font_type", "sans-serif");
+
+// Whether or not the user has interacted with the reader mode toolbar.
+// This is used to show a first-launch tip in reader mode.
+pref("reader.has_used_toolbar", false);
+
+// Whether to use a vertical or horizontal toolbar.
+pref("reader.toolbar.vertical", true);
+
+// Whether or not we display additional UI (such as the full screen, reset to default, and browser theme buttons).
+pref("reader.improvements_H12022.enabled", false);
+
+#if !defined(ANDROID)
+  pref("narrate.enabled", true);
+#else
+  pref("narrate.enabled", false);
+#endif
+
+pref("narrate.test", false);
+pref("narrate.rate", 0);
+pref("narrate.voice", " { \"default\": \"automatic\" }");
+// Only make voices that match content language available.
+pref("narrate.filter-voices", true);
+
+pref("memory.report_concurrency", 10);
+
+pref("toolkit.pageThumbs.screenSizeDivisor", 7);
+pref("toolkit.pageThumbs.minWidth", 0);
+pref("toolkit.pageThumbs.minHeight", 0);
+
+pref("webextensions.tests", false);
+
+// 16MB default non-parseable upload limit for requestBody.raw.bytes
+pref("webextensions.webRequest.requestBodyMaxRawBytes", 16777216);
+
+pref("webextensions.storage.sync.enabled", true);
+// Should we use the old kinto-based implementation of storage.sync? To be removed in bug 1637465.
+pref("webextensions.storage.sync.kinto", false);
+// Server used by the old kinto-based implementation of storage.sync.
+pref("webextensions.storage.sync.serverURL", "https://webextensions.settings.services.mozilla.com/v1");
+
+// Allow customization of the fallback directory for file uploads
+pref("dom.input.fallbackUploadDir", "");
+
+// Turn rewriting of youtube embeds on/off
+pref("plugins.rewrite_youtube_embeds", true);
+
+// Default media volume
+pref("media.default_volume", "1.0");
+
+pref("dom.storageManager.prompt.testing", false);
+pref("dom.storageManager.prompt.testing.allow", false);
+
+
+pref("browser.storageManager.pressureNotification.minIntervalMS", 1200000);
+pref("browser.storageManager.pressureNotification.usageThresholdGB", 5);
+
+pref("browser.sanitizer.loglevel", "Warn");
+
+// When a user cancels this number of authentication dialogs coming from
+// a single web page in a row, all following authentication dialogs will
+// be blocked (automatically canceled) for that page. The counter resets
+// when the page is reloaded.
+// To disable all auth prompting, set the limit to 0.
+// To disable blocking of auth prompts, set the limit to -1.
+pref("prompts.authentication_dialog_abuse_limit", 2);
+
+// The prompt type to use for http auth prompts
+// content: 1, tab: 2, window: 3
+pref("prompts.modalType.httpAuth", 2);
+
+// Payment Request API preferences
+pref("dom.payments.loglevel", "Warn");
+pref("dom.payments.defaults.saveCreditCard", false);
+pref("dom.payments.defaults.saveAddress", true);
+pref("dom.payments.request.supportedRegions", "US,CA");
+
+#ifdef MOZ_ASAN_REPORTER
+  pref("asanreporter.apiurl", "https://anf1.fuzzing.mozilla.org/crashproxy/submit/");
+  pref("asanreporter.clientid", "unknown");
+  pref("toolkit.telemetry.overrideUpdateChannel", "nightly-asan");
+#endif
+
+// Control whether clients.openWindow() opens windows in the same process
+// that called the API vs following our normal multi-process selection
+// algorithm.  Restricting openWindow to same process improves service worker
+// web compat in the short term.  Once the SW multi-e10s refactor is complete
+// this can be removed.
+pref("dom.clients.openwindow_favors_same_process", true);
+
+#ifdef RELEASE_OR_BETA
+  pref("toolkit.aboutPerformance.showInternals", false);
+#else
+  pref("toolkit.aboutPerformance.showInternals", true);
+#endif
+
+// If `true`, about:processes shows in-process subframes.
+pref("toolkit.aboutProcesses.showAllSubframes", false);
+// If `true`, about:processes shows thread information.
+#ifdef NIGHTLY_BUILD
+  pref("toolkit.aboutProcesses.showThreads", true);
+#else
+  pref("toolkit.aboutProcesses.showThreads", false);
+#endif
+// If `true`, about:processes will offer to profile processes.
+#ifdef NIGHTLY_BUILD
+  pref("toolkit.aboutProcesses.showProfilerIcons", true);
+#else
+  pref("toolkit.aboutProcesses.showProfilerIcons", false);
+#endif
+// Time in seconds between when the profiler is started and when the
+// profile is captured.
+pref("toolkit.aboutProcesses.profileDuration", 5);
+
+// When a crash happens, whether to include heap regions of the crash context
+// in the minidump. Enabled by default on nightly and aurora.
+#ifdef RELEASE_OR_BETA
+  pref("toolkit.crashreporter.include_context_heap", false);
+#else
+  pref("toolkit.crashreporter.include_context_heap", true);
+#endif
+
+// Support for legacy customizations that rely on checking the
+// user profile directory for these stylesheets:
+//  * userContent.css
+//  * userChrome.css
+pref("toolkit.legacyUserProfileCustomizations.stylesheets", false);
+
+#ifdef MOZ_DATA_REPORTING
+  pref("datareporting.policy.dataSubmissionEnabled", true);
+  pref("datareporting.policy.dataSubmissionPolicyNotifiedTime", "0");
+  pref("datareporting.policy.dataSubmissionPolicyAcceptedVersion", 0);
+  pref("datareporting.policy.dataSubmissionPolicyBypassNotification", false);
+  pref("datareporting.policy.currentPolicyVersion", 2);
+  pref("datareporting.policy.minimumPolicyVersion", 1);
+  pref("datareporting.policy.minimumPolicyVersion.channel-beta", 2);
+  pref("datareporting.policy.firstRunURL", "https://www.mozilla.org/privacy/firefox/");
+#endif
+
+#ifdef MOZ_SERVICES_HEALTHREPORT
+  #if !defined(ANDROID)
+    pref("datareporting.healthreport.infoURL", "https://www.mozilla.org/legal/privacy/firefox.html#health-report");
+
+    // Health Report is enabled by default on all channels.
+    pref("datareporting.healthreport.uploadEnabled", true);
+  #endif
+#endif
+
+pref("services.common.log.logger.rest.request", "Debug");
+pref("services.common.log.logger.rest.response", "Debug");
+pref("services.common.log.logger.tokenserverclient", "Debug");
+
+#ifdef MOZ_SERVICES_SYNC
+  pref("services.sync.lastversion", "firstrun");
+  pref("services.sync.sendVersionInfo", true);
+
+  pref("services.sync.scheduler.idleInterval", 3600);  // 1 hour
+  pref("services.sync.scheduler.activeInterval", 600);   // 10 minutes
+  pref("services.sync.scheduler.immediateInterval", 90);    // 1.5 minutes
+  pref("services.sync.scheduler.idleTime", 300);   // 5 minutes
+
+  pref("services.sync.scheduler.fxa.singleDeviceInterval", 3600); // 1 hour
+
+  // Note that new engines are typically added with a default of disabled, so
+  // when an existing sync user gets the Firefox upgrade that supports the engine
+  // it starts as disabled until the user has explicitly opted in.
+  // The sync "create account" process typically *will* offer these engines, so
+  // they may be flipped to enabled at that time.
+  pref("services.sync.engine.addons", true);
+  pref("services.sync.engine.addresses", false);
+  pref("services.sync.engine.bookmarks", true);
+  pref("services.sync.engine.creditcards", false);
+  pref("services.sync.engine.history", true);
+  pref("services.sync.engine.passwords", true);
+  pref("services.sync.engine.prefs", true);
+  pref("services.sync.engine.tabs", true);
+  pref("services.sync.engine.tabs.filteredSchemes", "about|resource|chrome|file|blob|moz-extension");
+
+  // The addresses and CC engines might not actually be available at all.
+  pref("services.sync.engine.addresses.available", false);
+  pref("services.sync.engine.creditcards.available", false);
+
+  // If true, add-on sync ignores changes to the user-enabled flag. This
+  // allows people to have the same set of add-ons installed across all
+  // profiles while maintaining different enabled states.
+  pref("services.sync.addons.ignoreUserEnabledChanges", false);
+
+  // Comma-delimited list of hostnames to trust for add-on install.
+  pref("services.sync.addons.trustedSourceHostnames", "addons.mozilla.org");
+
+  pref("services.sync.log.appender.console", "Fatal");
+  pref("services.sync.log.appender.dump", "Error");
+  pref("services.sync.log.appender.file.level", "Trace");
+  pref("services.sync.log.appender.file.logOnError", true);
+  #if defined(NIGHTLY_BUILD)
+    pref("services.sync.log.appender.file.logOnSuccess", true);
+  #else
+    pref("services.sync.log.appender.file.logOnSuccess", false);
+  #endif
+  pref("services.sync.log.appender.file.maxErrorAge", 864000); // 10 days
+
+  // The default log level for all "Sync.*" logs. Adjusting this pref will
+  // adjust the level for *all* Sync logs (except engines, and that's only
+  // because we supply a default for the engines below.)
+  pref("services.sync.log.logger", "Debug");
+
+  // Prefs for Sync engines can be controlled globally or per-engine.
+  // We only define the global level here, but manually creating prefs
+  // like "services.sync.log.logger.engine.bookmarks" will control just
+  // that engine.
+  pref("services.sync.log.logger.engine", "Debug");
+  pref("services.sync.log.cryptoDebug", false);
+
+  pref("services.sync.telemetry.submissionInterval", 43200); // 12 hours in seconds
+  pref("services.sync.telemetry.maxPayloadCount", 500);
+
+  #ifdef EARLY_BETA_OR_EARLIER
+    // Enable the (fairly costly) client/server validation through early Beta, but
+    // not release candidates or Release.
+    pref("services.sync.engine.bookmarks.validation.enabled", true);
+    pref("services.sync.engine.passwords.validation.enabled", true);
+  #endif
+
+  // We consider validation this frequently. After considering validation, even
+  // if we don't end up validating, we won't try again unless this much time has passed.
+  pref("services.sync.engine.bookmarks.validation.interval", 86400); // 24 hours in seconds
+  pref("services.sync.engine.passwords.validation.interval", 86400); // 24 hours in seconds
+
+  // We only run validation `services.sync.validation.percentageChance` percent of
+  // the time, even if it's been the right amount of time since the last validation,
+  // and you meet the maxRecord checks.
+  pref("services.sync.engine.bookmarks.validation.percentageChance", 10);
+  pref("services.sync.engine.passwords.validation.percentageChance", 10);
+
+  // We won't validate an engine if it has more than this many records on the server.
+  pref("services.sync.engine.bookmarks.validation.maxRecords", 1000);
+  pref("services.sync.engine.passwords.validation.maxRecords", 1000);
+
+  // The maximum number of immediate resyncs to trigger for changes made during
+  // a sync.
+  pref("services.sync.maxResyncs", 1);
+
+  // The URL of the Firefox Accounts auth server backend
+  pref("identity.fxaccounts.auth.uri", "https://api.accounts.firefox.com/v1");
+
+  // Percentage chance we skip an extension storage sync (kinto life support).
+  pref("services.sync.extension-storage.skipPercentageChance", 50);
+#endif // MOZ_SERVICES_SYNC
+
+#if defined(ENABLE_WEBDRIVER)
+  // WebDriver is a remote control interface that enables introspection and
+  // control of user agents. It provides a platform- and language-neutral wire
+  // protocol as a way for out-of-process programs to remotely instruct the
+  // behavior of web browsers.
+  //
+  // Gecko's implementation is backed by Marionette (WebDriver HTTP) and the
+  // Remote Agent (WebDriver BiDi).
+
+  // Delay server startup until a modal dialogue has been clicked to allow time
+  // for user to set breakpoints in the Browser Toolbox.
+  pref("marionette.debugging.clicktostart", false);
+
+  // Port to start Marionette server on.
+  pref("marionette.port", 2828);
+
+  // Defines the protocols that will be active for the Remote Agent.
+  // 1: WebDriver BiDi
+  // 2: CDP (Chrome DevTools Protocol)
+  // 3: WebDriver BiDi + CDP
+  pref("remote.active-protocols", 3);
+
+  // Defines the verbosity of the internal logger.
+  //
+  // Available levels are, in descending order of severity, "Trace", "Debug",
+  // "Config", "Info", "Warn", "Error", and "Fatal". The value is treated
+  // case-sensitively.
+  pref("remote.log.level", "Info");
+
+  // Certain log messages that are known to be long are truncated. This
+  // preference causes them to not be truncated.
+  pref("remote.log.truncate", true);
+
+  // Sets recommended automation preferences when Remote Agent or Marionette is
+  // started.
+  pref("remote.prefs.recommended", true);
+#endif
+
+// Enable the JSON View tool (an inspector for application/json documents).
+pref("devtools.jsonview.enabled", true);
+
+// Default theme ("auto", "dark" or "light").
+pref("devtools.theme", "auto", sticky);
+
+// Completely disable DevTools entry points, as well as all DevTools command
+// line arguments.
+pref("devtools.policy.disabled", false);
+
+// Enable deprecation warnings.
+pref("devtools.errorconsole.deprecation_warnings", true);
+
+#ifdef NIGHTLY_BUILD
+  // Don't show the Browser Toolbox prompt on local builds / nightly.
+  pref("devtools.debugger.prompt-connection", false, sticky);
+#else
+  pref("devtools.debugger.prompt-connection", true, sticky);
+#endif
+
+#ifdef MOZILLA_OFFICIAL
+  // Disable debugging chrome.
+  pref("devtools.chrome.enabled", false, sticky);
+  // Disable remote debugging connections.
+  pref("devtools.debugger.remote-enabled", false, sticky);
+#else
+  // In local builds, enable the browser toolbox by default.
+  pref("devtools.chrome.enabled", true, sticky);
+  pref("devtools.debugger.remote-enabled", true, sticky);
+#endif
+
+// Disable service worker debugging on all channels (see Bug 1651605).
+pref("devtools.debugger.features.windowless-service-workers", false);
+
+// Disable remote debugging protocol logging.
+pref("devtools.debugger.log", false);
+pref("devtools.debugger.log.verbose", false);
+
+pref("devtools.debugger.remote-port", 6000);
+pref("devtools.debugger.remote-websocket", false);
+// Force debugger server binding on the loopback interface.
+pref("devtools.debugger.force-local", true);
+
+// Limit for intercepted request and response bodies (1 MB).
+// Possible values:
+// 0 => the response body has no limit
+// n => represents max number of bytes stored
+pref("devtools.netmonitor.responseBodyLimit", 1048576);
+pref("devtools.netmonitor.requestBodyLimit", 1048576);
+
+// Limit for WebSocket/EventSource messages (100 KB).
+pref("devtools.netmonitor.msg.messageDataLimit", 100000);
+
+// DevTools default color unit.
+pref("devtools.defaultColorUnit", "authored");
+
+// Used for devtools debugging.
+pref("devtools.dump.emit", false);
+
+// Disable device discovery logging.
+pref("devtools.discovery.log", false);
+// Whether to scan for DevTools devices via WiFi.
+pref("devtools.remote.wifi.scan", true);
+// Client must complete TLS handshake within this window (ms).
+pref("devtools.remote.tls-handshake-timeout", 10000);
+
+// The extension ID for devtools-adb-extension.
+pref("devtools.remote.adb.extensionID", "adb@mozilla.org");
+// The URL for for devtools-adb-extension (overridden in tests to a local
+// path).
+pref("devtools.remote.adb.extensionURL", "https://ftp.mozilla.org/pub/mozilla.org/labs/devtools/adb-extension/#OS#/adb-extension-latest-#OS#.xpi");
+
+// URL of the remote JSON catalog used for device simulation.
+pref("devtools.devices.url", "https://code.cdn.mozilla.net/devices/devices.json");
+
+// Enable Inactive CSS detection; used both by the client and the server.
+pref("devtools.inspector.inactive.css.enabled", true);
+
+// The F12 experiment aims at disabling f12 on selected profiles.
+pref("devtools.experiment.f12.shortcut_disabled", false);
+
+#if defined(NIGHTLY_BUILD) || defined(MOZ_DEV_EDITION)
+// Define in StaticPrefList.yaml and override here since StaticPrefList.yaml
+// doesn't provide a way to lock the pref
+pref("dom.postMessage.sharedArrayBuffer.bypassCOOP_COEP.insecure.enabled", false);
+#else
+pref("dom.postMessage.sharedArrayBuffer.bypassCOOP_COEP.insecure.enabled", false, locked);
+#endif
+
+// Whether to start the private browsing mode at application startup
+pref("browser.privatebrowsing.autostart", false);
+
+// Whether sites require the open-protocol-handler permission to open a
+//preferred external application for a protocol. If a site doesn't have
+// permission we will show a prompt.
+pref("security.external_protocol_requires_permission", true);
+
+// Preferences for the form autofill toolkit component.
+// The truthy values of "extensions.formautofill.addresses.available"
+// and "extensions.formautofill.creditCards.available" are "on" and "detect",
+// any other value means autofill isn't available.
+// "detect" means it's enabled if conditions defined in the extension are met.
+// Note: "extensions.formautofill.available" and "extensions.formautofill.creditCards.available"
+// are not being used in form autofill, but need to exist for migration purposes.
+pref("extensions.formautofill.available", "detect");
+pref("extensions.formautofill.addresses.supported", "detect");
+pref("extensions.formautofill.addresses.enabled", true);
+pref("extensions.formautofill.addresses.capture.enabled", false);
+// Supported countries need to follow ISO 3166-1 to align with "browser.search.region"
+pref("extensions.formautofill.addresses.supportedCountries", "US,CA");
+// Note: this ".available" pref is only used for migration purposes and will be removed/replaced later.
+pref("extensions.formautofill.creditCards.available", true);
+pref("extensions.formautofill.creditCards.supported", "detect");
+pref("extensions.formautofill.creditCards.enabled", true);
+// Supported countries need to follow ISO 3166-1 to align with "browser.search.region"
+pref("extensions.formautofill.creditCards.supportedCountries", "US,CA,GB,FR,DE");
+// Temporary preference to control displaying the UI elements for
+// credit card autofill used for the duration of the A/B test.
+pref("extensions.formautofill.creditCards.hideui", false);
+// Algorithm used by formautofill while determine whether a field is a credit card field
+// 0:Heurstics based on regular expression string matching
+// 1:Fathom in js implementation, 2:Fathom in c++ implementation
+pref("extensions.formautofill.creditCards.heuristics.mode", 0);
+pref("extensions.formautofill.creditCards.heuristics.confidenceThreshold", "0.5");
+// Pref for shield/heartbeat to recognize users who have used Credit Card
+// Autofill. The valid values can be:
+// 0: none
+// 1: submitted a manually-filled credit card form (but didn't see the doorhanger
+//    because of a duplicate profile in the storage)
+// 2: saw the doorhanger
+// 3: submitted an autofill'ed credit card form
+pref("extensions.formautofill.creditCards.used", 0);
+pref("extensions.formautofill.firstTimeUse", true);
+pref("extensions.formautofill.heuristics.enabled", true);
+pref("extensions.formautofill.section.enabled", true);
+pref("extensions.formautofill.loglevel", "Warn");
+
+pref("toolkit.osKeyStore.loglevel", "Warn");
+
+pref("extensions.formautofill.supportRTL", false);
diff --git a/modules/libpref/moz.build b/modules/libpref/moz.build
index 1f021d409c..171d034cc0 100644
--- a/modules/libpref/moz.build
+++ b/modules/libpref/moz.build
@@ -125,6 +125,10 @@ UNIFIED_SOURCES += [
     "SharedPrefMap.cpp",
 ]
 
+LOCAL_INCLUDES += [
+    '/toolkit/xre'
+]
+
 gen_all_tuple = tuple(gen_h + gen_cpp + gen_rs)
 
 GeneratedFile(
diff --git a/python/mozbuild/mozpack/chrome/flags.py b/python/mozbuild/mozpack/chrome/flags.py
index 7d6d7e0c7f..724c527b4c 100644
--- a/python/mozbuild/mozpack/chrome/flags.py
+++ b/python/mozbuild/mozpack/chrome/flags.py
@@ -234,6 +234,7 @@ class Flags(OrderedDict):
         "tablet": Flag,
         "process": StringFlag,
         "backgroundtask": StringFlag,
+        "desktop": StringFlag,
     }
     RE = re.compile(r"([!<>=]+)")
 
diff --git a/python/mozbuild/mozpack/chrome/manifest.py b/python/mozbuild/mozpack/chrome/manifest.py
index a733685f95..f64b17fb7b 100644
--- a/python/mozbuild/mozpack/chrome/manifest.py
+++ b/python/mozbuild/mozpack/chrome/manifest.py
@@ -44,6 +44,7 @@ class ManifestEntry(object):
         "process",
         "contentaccessible",
         "backgroundtask",
+        "desktop",
     ]
 
     def __init__(self, base, *flags):
diff --git a/toolkit/components/downloads/moz.build b/toolkit/components/downloads/moz.build
index d4172e2d73..8bd0577bc5 100644
--- a/toolkit/components/downloads/moz.build
+++ b/toolkit/components/downloads/moz.build
@@ -51,5 +51,9 @@ if CONFIG["MOZ_PLACES"]:
 
 FINAL_LIBRARY = "xul"
 
+LOCAL_INCLUDES += [
+    '/toolkit/xre'
+]
+
 with Files("**"):
     BUG_COMPONENT = ("Toolkit", "Downloads API")
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
index 5ef47b97ba..82f1f7bfac 100644
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -228,6 +228,13 @@ toolbox {
   }
 }
 
+@media (-moz-platform: linux) {
+*|*:root[shellshowingmenubar="true"]
+toolbar[type="menubar"]:not([customizing="true"]) {
+  display: none !important;
+}
+}
+
 toolbarspring {
   -moz-box-flex: 1000;
 }
diff --git a/toolkit/content/xul.css.orig b/toolkit/content/xul.css.orig
new file mode 100644
index 0000000000..5ef47b97ba
--- /dev/null
+++ b/toolkit/content/xul.css.orig
@@ -0,0 +1,631 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * A minimal set of rules for the XUL elements that may be implicitly created
+ * as part of HTML/SVG documents (e.g. scrollbars) can be found over in
+ * minimal-xul.css.  Rules for everything else related to XUL can be found in
+ * this file.  Make sure you choose the correct style sheet when adding new
+ * rules.  (This split of the XUL rules is to minimize memory use and improve
+ * performance in HTML/SVG documents.)
+ *
+ * This file should also not contain any app specific styling.  Defaults for
+ * widgets of a particular application should be in that application's style
+ * sheet.  For example, style definitions for browser can be found in
+ * browser.css.
+ */
+
+@import url("chrome://global/skin/tooltip.css");
+
+@namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"); /* set default namespace to XUL */
+@namespace html url("http://www.w3.org/1999/xhtml"); /* namespace for HTML elements */
+
+/* TODO: investigate unifying these two root selectors
+ * https://bugzilla.mozilla.org/show_bug.cgi?id=1592344
+ */
+*|*:root {
+  --animation-easing-function: cubic-bezier(.07, .95, 0, 1);
+}
+
+:root {
+  text-rendering: optimizeLegibility;
+  -moz-control-character-visibility: visible;
+}
+
+:root:-moz-locale-dir(rtl) {
+  direction: rtl;
+}
+
+/* XUL doesn't show outlines by default */
+:focus-visible {
+  outline: initial;
+}
+
+/*
+ * Native anonymous popups and tooltips in html are document-level, which means
+ * that they don't inherit from the root, so this is needed.
+ */
+popupgroup:-moz-native-anonymous:-moz-locale-dir(rtl),
+tooltip:-moz-native-anonymous:-moz-locale-dir(rtl) {
+  direction: rtl;
+}
+
+/* ::::::::::
+   :: Rules for 'hiding' portions of the chrome for special
+   :: kinds of windows (not JUST browser windows) with toolbars
+   ::::: */
+
+*|*:root[chromehidden~="menubar"] .chromeclass-menubar,
+*|*:root[chromehidden~="directories"] .chromeclass-directories,
+*|*:root[chromehidden~="status"] .chromeclass-status,
+*|*:root[chromehidden~="extrachrome"] .chromeclass-extrachrome,
+*|*:root[chromehidden~="location"] .chromeclass-location,
+*|*:root[chromehidden~="location"][chromehidden~="toolbar"] .chromeclass-toolbar,
+*|*:root[chromehidden~="toolbar"] .chromeclass-toolbar-additional {
+  display: none;
+}
+
+/* ::::::::::
+   :: Rules for forcing direction for entry and display of URIs
+   :: or URI elements
+   ::::: */
+
+.uri-element {
+  direction: ltr !important;
+}
+
+/****** elements that have no visual representation ******/
+
+script, data, commandset, command,
+broadcasterset, broadcaster, observes,
+keyset, key, toolbarpalette, template,
+treeitem, treeseparator, treerow, treecell {
+  display: none;
+}
+
+/********** focus rules **********/
+
+button,
+checkbox,
+menulist,
+radiogroup,
+tree,
+browser,
+editor,
+iframe {
+  -moz-user-focus: normal;
+}
+
+/******** window & page ******/
+
+window {
+  overflow: clip;
+  -moz-box-orient: vertical;
+}
+
+/******** box *******/
+
+vbox {
+  -moz-box-orient: vertical;
+}
+
+/********** label **********/
+
+label {
+  display: inline-block;
+}
+
+description {
+  display: flow-root;
+}
+
+label.text-link, label[onclick] {
+  -moz-user-focus: normal;
+}
+
+label html|span.accesskey {
+  text-decoration: underline;
+  text-decoration-skip-ink: none;
+}
+
+/********** toolbarbutton **********/
+
+toolbar[mode="icons"] .toolbarbutton-text,
+toolbar[mode="text"] .toolbarbutton-icon,
+html|label.toolbarbutton-badge:empty {
+  display: none;
+}
+
+/********** button **********/
+
+button {
+  -moz-default-appearance: button;
+  appearance: auto;
+}
+
+/******** browser, editor, iframe ********/
+
+browser,
+editor,
+iframe {
+  display: inline;
+}
+
+@supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
+  browser,
+  editor,
+  iframe {
+    display: block;
+  }
+}
+
+/* Allow the browser to shrink below its intrinsic size, to match legacy
+ * behavior */
+browser {
+  align-self: stretch;
+  justify-self: stretch;
+  min-height: 0;
+  min-width: 0;
+}
+
+/*********** popup notification ************/
+popupnotification {
+  -moz-box-orient: vertical;
+}
+
+.popup-notification-menubutton:not([label]) {
+  display: none;
+}
+
+/********** radio **********/
+
+radiogroup {
+  -moz-box-orient: vertical;
+}
+
+/******** groupbox *********/
+
+groupbox {
+  -moz-box-orient: vertical;
+}
+
+/******** draggable elements *********/
+
+toolbar:not([nowindowdrag="true"], [customizing="true"]) {
+  -moz-window-dragging: drag;
+}
+
+/* The list below is non-comprehensive and will probably need some tweaking. */
+toolbaritem,
+toolbarbutton,
+toolbarseparator,
+button,
+search-textbox,
+html|input,
+tab,
+radio,
+splitter,
+menu,
+menulist {
+  -moz-window-dragging: no-drag;
+}
+
+titlebar {
+  pointer-events: auto !important;
+}
+
+/******* toolbar *******/
+
+toolbox {
+  -moz-box-orient: vertical;
+}
+
+@media (-moz-platform: macos) {
+  toolbar[type="menubar"] {
+    min-height: 0 !important;
+    border: 0 !important;
+  }
+}
+
+toolbarspring {
+  -moz-box-flex: 1000;
+}
+
+/********* menu ***********/
+
+menubar > menu:empty {
+  visibility: collapse;
+}
+
+.menu-text {
+  -moz-box-flex: 1;
+}
+
+/********* menupopup, panel, & tooltip ***********/
+
+menupopup,
+panel {
+  -moz-box-orient: vertical;
+}
+
+menupopup,
+panel,
+tooltip {
+  display: -moz-popup;
+  z-index: 2147483647;
+  text-shadow: none;
+}
+
+tooltip {
+  -moz-box-orient: vertical;
+  white-space: pre-wrap;
+}
+
+tooltip:not([position]) {
+  margin-top: 21px;
+}
+
+@supports -moz-bool-pref("xul.panel-animations.enabled") {
+@media (prefers-reduced-motion: no-preference) {
+@media (-moz-platform: macos) {
+  /* On Mac, use the properties "-moz-window-transform" and "-moz-window-opacity"
+     instead of "transform" and "opacity" for these animations.
+     The -moz-window* properties apply to the whole window including the window's
+     shadow, and they don't affect the window's "shape", so the system doesn't
+     have to recompute the shadow shape during the animation. This makes them a
+     lot faster. In fact, Gecko no longer triggers shadow shape recomputations
+     for repaints.
+     These properties are not implemented on other platforms. */
+  panel[type="arrow"]:not([animate="false"]) {
+    transition-property: -moz-window-transform, -moz-window-opacity;
+    transition-duration: 0.18s, 0.18s;
+    transition-timing-function:
+      var(--animation-easing-function), ease-out;
+  }
+
+  /* Only do the fade-in animation on pre-Big Sur to avoid missing shadows on
+   * Big Sur, see bug 1672091. */
+  @media (-moz-mac-big-sur-theme: 0) {
+    panel[type="arrow"]:not([animate="false"]) {
+      -moz-window-opacity: 0;
+      -moz-window-transform: translateY(-70px);
+    }
+
+    panel[type="arrow"][side="bottom"]:not([animate="false"]) {
+      -moz-window-transform: translateY(70px);
+    }
+  }
+
+  /* [animate] is here only so that this rule has greater specificity than the
+   * rule right above */
+  panel[type="arrow"][animate][animate="open"] {
+    -moz-window-opacity: 1.0;
+    transition-duration: 0.18s, 0.18s;
+    -moz-window-transform: none;
+    transition-timing-function:
+      var(--animation-easing-function), ease-in-out;
+  }
+
+  panel[type="arrow"][animate][animate="cancel"] {
+    -moz-window-opacity: 0;
+    -moz-window-transform: none;
+  }
+} /* end of macOS rules */
+
+@media not (-moz-platform: macos) {
+  panel[type="arrow"]:not([animate="false"]) {
+    opacity: 0;
+    transform: translateY(-70px);
+    transition-property: transform, opacity;
+    transition-duration: 0.18s, 0.18s;
+    transition-timing-function:
+      var(--animation-easing-function), ease-out;
+  }
+
+  panel[type="arrow"][side="bottom"]:not([animate="false"]) {
+    transform: translateY(70px);
+  }
+
+  /* [animate] is here only so that this rule has greater specificity than the
+   * rule right above */
+  panel[type="arrow"][animate][animate="open"] {
+    opacity: 1.0;
+    transition-duration: 0.18s, 0.18s;
+    transform: none;
+    transition-timing-function:
+      var(--animation-easing-function), ease-in-out;
+  }
+
+  panel[type="arrow"][animate][animate="cancel"] {
+    transform: none;
+  }
+} /* end of non-macOS rules */
+}
+}
+
+panel[type="arrow"][animating] {
+  pointer-events: none;
+}
+
+/******** tree ******/
+
+treecolpicker {
+  -moz-box-ordinal-group: 2147483646;
+}
+
+treechildren {
+  display: -moz-box;
+  user-select: none;
+  -moz-box-flex: 1;
+}
+
+tree {
+  -moz-box-orient: vertical;
+  width: 10px;
+  height: 10px;
+}
+
+tree[hidecolumnpicker="true"] treecolpicker {
+  display: none;
+}
+
+treecol {
+  min-width: 16px;
+}
+
+treecol[hidden="true"] {
+  visibility: collapse;
+  display: -moz-box;
+}
+
+/* ::::: lines connecting cells ::::: */
+tree:not([treelines="true"]) treechildren::-moz-tree-line {
+  visibility: hidden;
+}
+
+treechildren::-moz-tree-cell(ltr) {
+  direction: ltr !important;
+}
+
+/********** deck & stack *********/
+
+deck {
+  display: -moz-deck;
+}
+
+stack {
+  display: grid;
+  position: relative;
+}
+
+/* We shouldn't style native anonymous children like scrollbars or what not */
+stack > *|*:not(:-moz-native-anonymous) {
+  grid-area: 1 / 1;
+  z-index: 0;
+
+  /*
+    The default `min-height: auto` value makes grid items refuse to be smaller
+    than their content. This doesn't match the traditional behavior of XUL stack,
+    which often shoehorns tall content into a smaller stack and allows the content
+    to decide how to handle overflow (e.g. by scaling down if it's an image, or
+    by adding scrollbars if it's scrollable).
+  */
+  min-height: 0;
+}
+
+/********** tabbox *********/
+
+tabbox {
+  -moz-box-orient: vertical;
+}
+
+tabs {
+  -moz-box-orient: horizontal;
+}
+
+tab {
+  -moz-box-align: center;
+  -moz-box-pack: center;
+}
+
+tab[selected="true"]:not([ignorefocus="true"]) {
+  -moz-user-focus: normal;
+}
+
+tabpanels {
+  display: -moz-deck;
+}
+
+/********** tooltip *********/
+
+tooltip[titletip="true"] {
+  /* The width of the tooltip isn't limited on cropped <tree> cells. */
+  max-width: none;
+}
+
+/********** basic rule for anonymous content that needs to pass box properties through
+ ********** to an insertion point parent that holds the real kids **************/
+
+.box-inherit {
+  -moz-box-orient: inherit;
+  -moz-box-pack: inherit;
+  -moz-box-align: inherit;
+  -moz-box-direction: inherit;
+}
+
+/********** textbox **********/
+
+search-textbox {
+  user-select: text;
+  text-shadow: none;
+}
+
+/* Prefix with (xul|*):root to workaround HTML tests loading xul.css */
+:root html|textarea:not([resizable="true"]) {
+  resize: none;
+}
+
+@supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
+  html|*.textbox-input {
+    /* Be block-level, so that -moz-box-flex can take effect, when we are an item
+       in a -moz-box being emulated by modified modern flex. */
+    display: block;
+  }
+}
+
+/********** autocomplete textbox **********/
+
+.autocomplete-richlistbox {
+  -moz-user-focus: ignore;
+  overflow-x: hidden !important;
+}
+
+.autocomplete-richlistitem {
+  -moz-box-orient: vertical;
+  -moz-box-align: center;
+  overflow: clip;
+}
+
+/* The following rule is here to fix bug 96899 (and now 117952).
+   Somehow trees create a situation
+   in which a popupset flows itself as if its popup child is directly within it
+   instead of the placeholder child that should actually be inside the popupset.
+   This is a stopgap measure, and it does not address the real bug.  */
+.autocomplete-result-popupset {
+  max-width: 0px;
+  width: 0 !important;
+  min-width: 0%;
+  min-height: 0%;
+}
+
+/********** menulist **********/
+
+menulist[popuponly] {
+  appearance: none !important;
+  margin: 0 !important;
+  height: 0 !important;
+  min-height: 0 !important;
+  border: 0 !important;
+}
+
+/********** splitter **********/
+
+.tree-splitter {
+  width: 0px;
+  max-width: 0px;
+  min-width: 0% ! important;
+  min-height: 0% ! important;
+  -moz-box-ordinal-group: 2147483646;
+}
+
+/******** scrollbar ********/
+
+slider {
+  /* This is a hint to layerization that the scrollbar thumb can never leave
+     the scrollbar track. */
+  overflow: hidden;
+}
+
+/******** scrollbox ********/
+
+scrollbox {
+  /* This makes it scrollable! */
+  overflow: hidden;
+}
+
+scrollbox[smoothscroll=true] {
+  scroll-behavior: smooth;
+}
+
+/********** stringbundle **********/
+
+stringbundle,
+stringbundleset {
+  display: none;
+}
+
+/********** dialog **********/
+
+dialog {
+  -moz-box-flex: 1;
+  -moz-box-orient: vertical;
+}
+
+/********** wizard **********/
+
+wizard {
+  -moz-box-flex: 1;
+  -moz-box-orient: vertical;
+  width: 40em;
+  height: 30em;
+}
+
+wizard > wizardpage {
+  grid-area: 1 / 1;
+  min-height: 0;
+}
+
+wizard > wizardpage:not(.selected) {
+  visibility: hidden;
+}
+
+wizardpage {
+  -moz-box-orient: vertical;
+  overflow: auto;
+}
+
+/********** Rich Listbox ********/
+
+richlistbox {
+  -moz-user-focus: normal;
+  -moz-box-orient: vertical;
+}
+
+/*********** findbar ************/
+findbar {
+  overflow-x: hidden;
+}
+
+/* Some elements that in HTML blocks should be inline-level by default */
+button, image {
+  display: -moz-inline-box;
+}
+
+.menu-iconic-highlightable-text:not([highlightable="true"]),
+.menu-iconic-text[highlightable="true"] {
+  display: none;
+}
+
+[orient="vertical"] { -moz-box-orient: vertical !important; }
+[orient="horizontal"] { -moz-box-orient: horizontal !important; }
+
+[align="start"] { -moz-box-align: start !important; }
+[align="center"] { -moz-box-align: center !important; }
+[align="end"] { -moz-box-align: end !important; }
+[align="baseline"] { -moz-box-align: baseline !important; }
+[align="stretch"] { -moz-box-align: stretch !important; }
+
+[pack="start"] { -moz-box-pack: start !important; }
+[pack="center"] { -moz-box-pack: center !important; }
+[pack="end"] { -moz-box-pack: end !important; }
+
+@supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
+  /* This isn't a real solution for [flex] and [ordinal], but it covers enough
+     cases to render the browser chrome for us to test emulated flex mode without
+     mass-changing existing markup and CSS.
+     If we get attr() in Bug 435426 this could  work for all cases. */
+  [flex="1"] { -moz-box-flex: 1; }
+  [flex="2"] { -moz-box-flex: 2; }
+  [flex="3"] { -moz-box-flex: 3; }
+  [flex="4"] { -moz-box-flex: 4; }
+  [flex="5"] { -moz-box-flex: 5; }
+  [flex="6"] { -moz-box-flex: 6; }
+  [flex="7"] { -moz-box-flex: 7; }
+  [flex="8"] { -moz-box-flex: 8; }
+  [flex="9"] { -moz-box-flex: 9; }
+  [flex="100"] { -moz-box-flex: 100; }
+  [flex="400"] { -moz-box-flex: 400; }
+  [flex="1000"] { -moz-box-flex: 1000; }
+  [flex="10000"] { -moz-box-flex: 10000; }
+}
diff --git a/toolkit/mozapps/downloads/HelperAppDlg.jsm b/toolkit/mozapps/downloads/HelperAppDlg.jsm
index e3572722f7..812133d09d 100644
--- a/toolkit/mozapps/downloads/HelperAppDlg.jsm
+++ b/toolkit/mozapps/downloads/HelperAppDlg.jsm
@@ -1257,26 +1257,56 @@ nsUnknownContentTypeDialog.prototype = {
         this.chosenApp = params.handlerApp;
       }
     } else if ("@mozilla.org/applicationchooser;1" in Cc) {
-      var nsIApplicationChooser = Ci.nsIApplicationChooser;
-      var appChooser = Cc["@mozilla.org/applicationchooser;1"].createInstance(
-        nsIApplicationChooser
-      );
-      appChooser.init(
-        this.mDialog,
-        this.dialogElement("strings").getString("chooseAppFilePickerTitle")
-      );
-      var contentTypeDialogObj = this;
-      let appChooserCallback = function appChooserCallback_done(aResult) {
-        if (aResult) {
-          contentTypeDialogObj.chosenApp = aResult.QueryInterface(
-            Ci.nsILocalHandlerApp
-          );
-        }
-        contentTypeDialogObj.finishChooseApp();
-      };
-      appChooser.open(this.mLauncher.MIMEInfo.MIMEType, appChooserCallback);
-      // The finishChooseApp is called from appChooserCallback
-      return;
+      // handle the KDE case which is implemented in the filepicker
+      // therefore falling back to Gtk2 like behaviour if KDE is running
+      // FIXME this should be better handled in the nsIApplicationChooser
+      // interface
+      var env = Components.classes["@mozilla.org/process/environment;1"]
+                          .getService(Components.interfaces.nsIEnvironment);
+      if (env.get('KDE_FULL_SESSION') == "true")
+      {
+        var nsIFilePicker = Ci.nsIFilePicker;
+        var fp = Cc["@mozilla.org/filepicker;1"]
+                    .createInstance(nsIFilePicker);
+        fp.init(this.mDialog,
+                this.dialogElement("strings").getString("chooseAppFilePickerTitle"),
+                nsIFilePicker.modeOpen);
+
+        fp.appendFilters(nsIFilePicker.filterApps);
+
+        fp.open(aResult => {
+          if (aResult == nsIFilePicker.returnOK && fp.file) {
+            // Remember the file they chose to run.
+            var localHandlerApp =
+              Cc["@mozilla.org/uriloader/local-handler-app;1"].
+                         createInstance(Ci.nsILocalHandlerApp);
+            localHandlerApp.executable = fp.file;
+            this.chosenApp = localHandlerApp;
+          }
+          this.finishChooseApp();
+        });
+      } else {
+        var nsIApplicationChooser = Ci.nsIApplicationChooser;
+        var appChooser = Cc["@mozilla.org/applicationchooser;1"].createInstance(
+          nsIApplicationChooser
+        );
+        appChooser.init(
+          this.mDialog,
+          this.dialogElement("strings").getString("chooseAppFilePickerTitle")
+        );
+        var contentTypeDialogObj = this;
+        let appChooserCallback = function appChooserCallback_done(aResult) {
+          if (aResult) {
+            contentTypeDialogObj.chosenApp = aResult.QueryInterface(
+              Ci.nsILocalHandlerApp
+            );
+          }
+          contentTypeDialogObj.finishChooseApp();
+        };
+        appChooser.open(this.mLauncher.MIMEInfo.MIMEType, appChooserCallback);
+        // The finishChooseApp is called from appChooserCallback
+        return;
+      }
     } else {
       var nsIFilePicker = Ci.nsIFilePicker;
       var fp = Cc["@mozilla.org/filepicker;1"].createInstance(nsIFilePicker);
diff --git a/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
index f8d0880545..091ccf3d9e 100644
--- a/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
+++ b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
@@ -18,6 +18,7 @@
 #include "nsInterfaceHashtable.h"
 #include "mozilla/Attributes.h"
 #include "nsIURI.h"
+#include "nsKDEUtils.h"
 
 using namespace mozilla;
 
@@ -41,6 +42,8 @@ class nsUnixSystemProxySettings final : public nsISystemProxySettings {
                                  nsACString& aResult);
   nsresult SetProxyResultFromGSettings(const char* aKeyBase, const char* aType,
                                        nsACString& aResult);
+  nsresult GetProxyFromKDE(const nsACString& aScheme, const nsACString& aHost,
+                           PRInt32 aPort, nsACString& aResult);
 };
 
 NS_IMPL_ISUPPORTS(nsUnixSystemProxySettings, nsISystemProxySettings)
@@ -382,6 +385,9 @@ nsresult nsUnixSystemProxySettings::GetProxyForURI(const nsACString& aSpec,
                                                    const nsACString& aHost,
                                                    const int32_t aPort,
                                                    nsACString& aResult) {
+  if (nsKDEUtils::kdeSupport())
+    return GetProxyFromKDE(aScheme, aHost, aPort, aResult);
+
   if (mProxySettings) {
     nsresult rv = GetProxyFromGSettings(aScheme, aHost, aPort, aResult);
     if (NS_SUCCEEDED(rv)) return rv;
@@ -390,6 +396,32 @@ nsresult nsUnixSystemProxySettings::GetProxyForURI(const nsACString& aSpec,
   return GetProxyFromEnvironment(aScheme, aHost, aPort, aResult);
 }
 
+nsresult
+nsUnixSystemProxySettings::GetProxyFromKDE(const nsACString& aScheme,
+                                           const nsACString& aHost,
+                                           PRInt32 aPort,
+                                           nsACString& aResult)
+{
+  nsAutoCString url;
+  url = aScheme;
+  url += "://";
+  url += aHost;
+  if( aPort >= 0 )
+  {
+    url += ":";
+    url += nsPrintfCString("%d", aPort);
+  }
+  nsTArray<nsCString> command;
+  command.AppendElement( "GETPROXY"_ns );
+  command.AppendElement( url );
+  nsTArray<nsCString> result;
+  if( !nsKDEUtils::command( command, &result ) || result.Length() != 1 )
+    return NS_ERROR_FAILURE;
+  aResult = result[0];
+  return NS_OK;
+}
+
+
 NS_IMPL_COMPONENT_FACTORY(nsUnixSystemProxySettings) {
   auto result = MakeRefPtr<nsUnixSystemProxySettings>();
   result->Init();
diff --git a/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp.orig b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp.orig
new file mode 100644
index 0000000000..f8d0880545
--- /dev/null
+++ b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp.orig
@@ -0,0 +1,397 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISystemProxySettings.h"
+#include "mozilla/Components.h"
+#include "nsIURI.h"
+#include "nsReadableUtils.h"
+#include "nsArrayUtils.h"
+#include "prnetdb.h"
+#include "prenv.h"
+#include "nsPrintfCString.h"
+#include "nsNetCID.h"
+#include "nsNetUtil.h"
+#include "nsISupportsPrimitives.h"
+#include "nsIGSettingsService.h"
+#include "nsInterfaceHashtable.h"
+#include "mozilla/Attributes.h"
+#include "nsIURI.h"
+
+using namespace mozilla;
+
+class nsUnixSystemProxySettings final : public nsISystemProxySettings {
+ public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSISYSTEMPROXYSETTINGS
+
+  nsUnixSystemProxySettings() : mSchemeProxySettings(4) {}
+  void Init();
+
+ private:
+  ~nsUnixSystemProxySettings() = default;
+
+  nsCOMPtr<nsIGSettingsService> mGSettings;
+  nsCOMPtr<nsIGSettingsCollection> mProxySettings;
+  nsInterfaceHashtable<nsCStringHashKey, nsIGSettingsCollection>
+      mSchemeProxySettings;
+  nsresult GetProxyFromGSettings(const nsACString& aScheme,
+                                 const nsACString& aHost, int32_t aPort,
+                                 nsACString& aResult);
+  nsresult SetProxyResultFromGSettings(const char* aKeyBase, const char* aType,
+                                       nsACString& aResult);
+};
+
+NS_IMPL_ISUPPORTS(nsUnixSystemProxySettings, nsISystemProxySettings)
+
+NS_IMETHODIMP
+nsUnixSystemProxySettings::GetMainThreadOnly(bool* aMainThreadOnly) {
+  // dbus prevents us from being threadsafe, but this routine should not block
+  // anyhow
+  *aMainThreadOnly = true;
+  return NS_OK;
+}
+
+void nsUnixSystemProxySettings::Init() {
+  mGSettings = do_GetService(NS_GSETTINGSSERVICE_CONTRACTID);
+  if (mGSettings) {
+    mGSettings->GetCollectionForSchema("org.gnome.system.proxy"_ns,
+                                       getter_AddRefs(mProxySettings));
+  }
+}
+
+nsresult nsUnixSystemProxySettings::GetPACURI(nsACString& aResult) {
+  if (mProxySettings) {
+    nsCString proxyMode;
+    // Check if mode is auto
+    nsresult rv = mProxySettings->GetString("mode"_ns, proxyMode);
+    if (rv == NS_OK && proxyMode.EqualsLiteral("auto")) {
+      return mProxySettings->GetString("autoconfig-url"_ns, aResult);
+    }
+  }
+
+  // Return an empty string when auto mode is not set.
+  aResult.Truncate();
+  return NS_OK;
+}
+
+static bool IsInNoProxyList(const nsACString& aHost, int32_t aPort,
+                            const char* noProxyVal) {
+  NS_ASSERTION(aPort >= 0, "Negative port?");
+
+  nsAutoCString noProxy(noProxyVal);
+  if (noProxy.EqualsLiteral("*")) return true;
+
+  noProxy.StripWhitespace();
+
+  nsReadingIterator<char> pos;
+  nsReadingIterator<char> end;
+  noProxy.BeginReading(pos);
+  noProxy.EndReading(end);
+  while (pos != end) {
+    nsReadingIterator<char> last = pos;
+    nsReadingIterator<char> nextPos;
+    if (FindCharInReadable(',', last, end)) {
+      nextPos = last;
+      ++nextPos;
+    } else {
+      last = end;
+      nextPos = end;
+    }
+
+    nsReadingIterator<char> colon = pos;
+    int32_t port = -1;
+    if (FindCharInReadable(':', colon, last)) {
+      ++colon;
+      nsDependentCSubstring portStr(colon, last);
+      nsAutoCString portStr2(
+          portStr);  // We need this for ToInteger. String API's suck.
+      nsresult err;
+      port = portStr2.ToInteger(&err);
+      if (NS_FAILED(err)) {
+        port = -2;  // don't match any port, so we ignore this pattern
+      }
+      --colon;
+    } else {
+      colon = last;
+    }
+
+    if (port == -1 || port == aPort) {
+      nsDependentCSubstring hostStr(pos, colon);
+      // By using StringEndsWith instead of an equality comparator, we can
+      // include sub-domains
+      if (StringEndsWith(aHost, hostStr, nsCaseInsensitiveCStringComparator))
+        return true;
+    }
+
+    pos = nextPos;
+  }
+
+  return false;
+}
+
+static void SetProxyResult(const char* aType, const nsACString& aHost,
+                           int32_t aPort, nsACString& aResult) {
+  aResult.AssignASCII(aType);
+  aResult.Append(' ');
+  aResult.Append(aHost);
+  if (aPort > 0) {
+    aResult.Append(':');
+    aResult.AppendInt(aPort);
+  }
+}
+
+static void SetProxyResultDirect(nsACString& aResult) {
+  aResult.AssignLiteral("DIRECT");
+}
+
+static nsresult GetProxyFromEnvironment(const nsACString& aScheme,
+                                        const nsACString& aHost, int32_t aPort,
+                                        nsACString& aResult) {
+  nsAutoCString envVar;
+  envVar.Append(aScheme);
+  envVar.AppendLiteral("_proxy");
+  const char* proxyVal = PR_GetEnv(envVar.get());
+  if (!proxyVal) {
+    proxyVal = PR_GetEnv("all_proxy");
+    if (!proxyVal) {
+      // Return failure so that the caller can detect the failure and
+      // fall back to other proxy detection (e.g., WPAD)
+      return NS_ERROR_FAILURE;
+    }
+  }
+
+  const char* noProxyVal = PR_GetEnv("no_proxy");
+  if (noProxyVal && IsInNoProxyList(aHost, aPort, noProxyVal)) {
+    SetProxyResultDirect(aResult);
+    return NS_OK;
+  }
+
+  // Use our URI parser to crack the proxy URI
+  nsCOMPtr<nsIURI> proxyURI;
+  nsresult rv = NS_NewURI(getter_AddRefs(proxyURI), proxyVal);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Is there a way to specify "socks://" or something in these environment
+  // variables? I can't find any documentation.
+  if (!proxyURI->SchemeIs("http")) {
+    return NS_ERROR_UNKNOWN_PROTOCOL;
+  }
+
+  nsAutoCString proxyHost;
+  rv = proxyURI->GetHost(proxyHost);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  int32_t proxyPort;
+  rv = proxyURI->GetPort(&proxyPort);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  SetProxyResult("PROXY", proxyHost, proxyPort, aResult);
+  return NS_OK;
+}
+
+nsresult nsUnixSystemProxySettings::SetProxyResultFromGSettings(
+    const char* aKeyBase, const char* aType, nsACString& aResult) {
+  nsDependentCString key(aKeyBase);
+
+  nsCOMPtr<nsIGSettingsCollection> proxy_settings =
+      mSchemeProxySettings.Get(key);
+  nsresult rv;
+  if (!proxy_settings) {
+    rv =
+        mGSettings->GetCollectionForSchema(key, getter_AddRefs(proxy_settings));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    mSchemeProxySettings.InsertOrUpdate(key, proxy_settings);
+  }
+
+  nsAutoCString host;
+  rv = proxy_settings->GetString("host"_ns, host);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (host.IsEmpty()) return NS_ERROR_FAILURE;
+
+  int32_t port;
+  rv = proxy_settings->GetInt("port"_ns, &port);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  /* When port is 0, proxy is not considered as enabled even if host is set. */
+  if (port == 0) return NS_ERROR_FAILURE;
+
+  SetProxyResult(aType, host, port, aResult);
+  return NS_OK;
+}
+
+/* copied from nsProtocolProxyService.cpp --- we should share this! */
+static void proxy_MaskIPv6Addr(PRIPv6Addr& addr, uint16_t mask_len) {
+  if (mask_len == 128) return;
+
+  if (mask_len > 96) {
+    addr.pr_s6_addr32[3] =
+        PR_htonl(PR_ntohl(addr.pr_s6_addr32[3]) & (~0L << (128 - mask_len)));
+  } else if (mask_len > 64) {
+    addr.pr_s6_addr32[3] = 0;
+    addr.pr_s6_addr32[2] =
+        PR_htonl(PR_ntohl(addr.pr_s6_addr32[2]) & (~0L << (96 - mask_len)));
+  } else if (mask_len > 32) {
+    addr.pr_s6_addr32[3] = 0;
+    addr.pr_s6_addr32[2] = 0;
+    addr.pr_s6_addr32[1] =
+        PR_htonl(PR_ntohl(addr.pr_s6_addr32[1]) & (~0L << (64 - mask_len)));
+  } else {
+    addr.pr_s6_addr32[3] = 0;
+    addr.pr_s6_addr32[2] = 0;
+    addr.pr_s6_addr32[1] = 0;
+    addr.pr_s6_addr32[0] =
+        PR_htonl(PR_ntohl(addr.pr_s6_addr32[0]) & (~0L << (32 - mask_len)));
+  }
+}
+
+static bool ConvertToIPV6Addr(const nsACString& aName, PRIPv6Addr* aAddr,
+                              int32_t* aMask) {
+  PRNetAddr addr;
+  // try to convert hostname to IP
+  if (PR_StringToNetAddr(PromiseFlatCString(aName).get(), &addr) != PR_SUCCESS)
+    return false;
+
+  // convert parsed address to IPv6
+  if (addr.raw.family == PR_AF_INET) {
+    // convert to IPv4-mapped address
+    PR_ConvertIPv4AddrToIPv6(addr.inet.ip, aAddr);
+    if (aMask) {
+      if (*aMask <= 32)
+        *aMask += 96;
+      else
+        return false;
+    }
+  } else if (addr.raw.family == PR_AF_INET6) {
+    // copy the address
+    memcpy(aAddr, &addr.ipv6.ip, sizeof(PRIPv6Addr));
+  } else {
+    return false;
+  }
+
+  return true;
+}
+
+static bool HostIgnoredByProxy(const nsACString& aIgnore,
+                               const nsACString& aHost) {
+  if (aIgnore.Equals(aHost, nsCaseInsensitiveCStringComparator)) return true;
+
+  if (aIgnore.First() == '*' &&
+      StringEndsWith(aHost, nsDependentCSubstring(aIgnore, 1),
+                     nsCaseInsensitiveCStringComparator))
+    return true;
+
+  int32_t mask = 128;
+  nsReadingIterator<char> start;
+  nsReadingIterator<char> slash;
+  nsReadingIterator<char> end;
+  aIgnore.BeginReading(start);
+  aIgnore.BeginReading(slash);
+  aIgnore.EndReading(end);
+  if (FindCharInReadable('/', slash, end)) {
+    ++slash;
+    nsDependentCSubstring maskStr(slash, end);
+    nsAutoCString maskStr2(maskStr);
+    nsresult err;
+    mask = maskStr2.ToInteger(&err);
+    if (NS_FAILED(err)) {
+      mask = 128;
+    }
+    --slash;
+  } else {
+    slash = end;
+  }
+
+  nsDependentCSubstring ignoreStripped(start, slash);
+  PRIPv6Addr ignoreAddr, hostAddr;
+  if (!ConvertToIPV6Addr(ignoreStripped, &ignoreAddr, &mask) ||
+      !ConvertToIPV6Addr(aHost, &hostAddr, nullptr))
+    return false;
+
+  proxy_MaskIPv6Addr(ignoreAddr, mask);
+  proxy_MaskIPv6Addr(hostAddr, mask);
+
+  return memcmp(&ignoreAddr, &hostAddr, sizeof(PRIPv6Addr)) == 0;
+}
+
+nsresult nsUnixSystemProxySettings::GetProxyFromGSettings(
+    const nsACString& aScheme, const nsACString& aHost, int32_t aPort,
+    nsACString& aResult) {
+  nsCString proxyMode;
+  nsresult rv = mProxySettings->GetString("mode"_ns, proxyMode);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // return NS_ERROR_FAILURE when no proxy is set
+  if (!proxyMode.EqualsLiteral("manual")) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsIArray> ignoreList;
+  if (NS_SUCCEEDED(mProxySettings->GetStringList("ignore-hosts"_ns,
+                                                 getter_AddRefs(ignoreList))) &&
+      ignoreList) {
+    uint32_t len = 0;
+    ignoreList->GetLength(&len);
+    for (uint32_t i = 0; i < len; ++i) {
+      nsCOMPtr<nsISupportsCString> str = do_QueryElementAt(ignoreList, i);
+      if (str) {
+        nsCString s;
+        if (NS_SUCCEEDED(str->GetData(s)) && !s.IsEmpty()) {
+          if (HostIgnoredByProxy(s, aHost)) {
+            SetProxyResultDirect(aResult);
+            return NS_OK;
+          }
+        }
+      }
+    }
+  }
+
+  if (aScheme.LowerCaseEqualsLiteral("http")) {
+    rv = SetProxyResultFromGSettings("org.gnome.system.proxy.http", "PROXY",
+                                     aResult);
+  } else if (aScheme.LowerCaseEqualsLiteral("https")) {
+    rv = SetProxyResultFromGSettings("org.gnome.system.proxy.https", "PROXY",
+                                     aResult);
+    /* Try to use HTTP proxy when HTTPS proxy is not explicitly defined */
+    if (rv != NS_OK)
+      rv = SetProxyResultFromGSettings("org.gnome.system.proxy.http", "PROXY",
+                                       aResult);
+  } else if (aScheme.LowerCaseEqualsLiteral("ftp")) {
+    rv = SetProxyResultFromGSettings("org.gnome.system.proxy.ftp", "PROXY",
+                                     aResult);
+  } else {
+    rv = NS_ERROR_FAILURE;
+  }
+  if (rv != NS_OK) {
+    /* If proxy for scheme is not specified, use SOCKS proxy for all schemes */
+    rv = SetProxyResultFromGSettings("org.gnome.system.proxy.socks", "SOCKS",
+                                     aResult);
+  }
+
+  if (NS_FAILED(rv)) {
+    SetProxyResultDirect(aResult);
+  }
+
+  return NS_OK;
+}
+
+nsresult nsUnixSystemProxySettings::GetProxyForURI(const nsACString& aSpec,
+                                                   const nsACString& aScheme,
+                                                   const nsACString& aHost,
+                                                   const int32_t aPort,
+                                                   nsACString& aResult) {
+  if (mProxySettings) {
+    nsresult rv = GetProxyFromGSettings(aScheme, aHost, aPort, aResult);
+    if (NS_SUCCEEDED(rv)) return rv;
+  }
+
+  return GetProxyFromEnvironment(aScheme, aHost, aPort, aResult);
+}
+
+NS_IMPL_COMPONENT_FACTORY(nsUnixSystemProxySettings) {
+  auto result = MakeRefPtr<nsUnixSystemProxySettings>();
+  result->Init();
+  return result.forget().downcast<nsISupports>();
+}
diff --git a/toolkit/xre/moz.build b/toolkit/xre/moz.build
index 84af551f18..751627fd97 100644
--- a/toolkit/xre/moz.build
+++ b/toolkit/xre/moz.build
@@ -97,7 +97,9 @@ elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "uikit":
         "UIKitDirProvider.mm",
     ]
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
+    EXPORTS += ['nsKDEUtils.h']
     UNIFIED_SOURCES += [
+        "nsKDEUtils.cpp",
         "nsNativeAppSupportUnix.cpp",
     ]
     CXXFLAGS += CONFIG["MOZ_X11_SM_CFLAGS"]
diff --git a/toolkit/xre/nsKDEUtils.cpp b/toolkit/xre/nsKDEUtils.cpp
new file mode 100644
index 0000000000..7a6edf0770
--- /dev/null
+++ b/toolkit/xre/nsKDEUtils.cpp
@@ -0,0 +1,321 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsKDEUtils.h"
+#include "nsIWidget.h"
+#include "nsISupportsPrimitives.h"
+#include "nsIMutableArray.h"
+#include "nsComponentManagerUtils.h"
+#include "nsArrayUtils.h"
+
+#include <gtk/gtk.h>
+
+#include <limits.h>
+#include <stdio.h>
+#include <sys/wait.h>
+#include <sys/resource.h>
+#include <unistd.h>
+#include <X11/Xlib.h>
+// copied from X11/X.h as a hack since for an unknown
+// reason it's not picked up from X11/X.h
+#ifndef None
+#define None                 0L /* universal null resource or null atom */
+#endif
+
+//#define DEBUG_KDE
+#ifdef DEBUG_KDE
+#define KMOZILLAHELPER "kmozillahelper"
+#else
+// not need for lib64, it's a binary
+#define KMOZILLAHELPER "/usr/lib/mozilla/kmozillahelper"
+#endif
+
+#define KMOZILLAHELPER_VERSION 6
+#define MAKE_STR2( n ) #n
+#define MAKE_STR( n ) MAKE_STR2( n )
+
+static bool getKdeSession()
+{
+    if (PR_GetEnv("KDE_FULL_SESSION"))
+    {
+      return true;
+    }
+    return false;
+}
+
+static bool getKdeSupport()
+    {
+    nsTArray<nsCString> command;
+    command.AppendElement( "CHECK"_ns );
+    command.AppendElement( "KMOZILLAHELPER_VERSION"_ns );
+    bool kde = nsKDEUtils::command( command );
+#ifdef DEBUG_KDE
+    fprintf( stderr, "KDE RUNNING %d\n", kde );
+#endif
+    return kde;
+    }
+
+nsKDEUtils::nsKDEUtils()
+    : commandFile( NULL )
+    , replyFile( NULL )
+    {
+    }
+
+nsKDEUtils::~nsKDEUtils()
+    {
+//    closeHelper(); not actually useful, exiting will close the fd too
+    }
+
+nsKDEUtils* nsKDEUtils::self()
+    {
+    static nsKDEUtils s;
+    return &s;
+    }
+
+static bool helperRunning = false;
+static bool helperFailed = false;
+
+bool nsKDEUtils::kdeSession()
+    {
+    static bool session = getKdeSession();
+    return session;
+    }
+
+bool nsKDEUtils::kdeSupport()
+    {
+    static bool support = kdeSession() && getKdeSupport();
+    return support && helperRunning;
+    }
+
+struct nsKDECommandData
+    {
+    FILE* file;
+    nsTArray<nsCString>* output;
+    GMainLoop* loop;
+    bool success;
+    };
+
+static gboolean kdeReadFunc( GIOChannel*, GIOCondition, gpointer data )
+    {
+    nsKDECommandData* p = static_cast< nsKDECommandData* >( data );
+    char buf[ 8192 ]; // TODO big enough
+    bool command_done = false;
+    bool command_failed = false;
+    while( !command_done && !command_failed && fgets( buf, 8192, p->file ) != NULL )
+        { // TODO what if the kernel splits a line into two chunks?
+//#ifdef DEBUG_KDE
+//        fprintf( stderr, "READ: %s %d\n", buf, feof( p->file ));
+//#endif
+        if( char* eol = strchr( buf, '\n' ))
+            *eol = '\0';
+        command_done = ( strcmp( buf, "\\1" ) == 0 );
+        command_failed = ( strcmp( buf, "\\0" ) == 0 );
+        nsAutoCString line( buf );
+        line.ReplaceSubstring( "\\n", "\n" );
+        line.ReplaceSubstring( "\\" "\\", "\\" ); //  \\ -> \ , i.e. unescape
+        if( p->output && !( command_done || command_failed ))
+            p->output->AppendElement( nsCString( buf )); // TODO utf8?
+        }
+    bool quit = false;
+    if( feof( p->file ) || command_failed )
+        {
+        quit = true;
+        p->success = false;
+        }
+    if( command_done )
+        { // reading one reply finished
+        quit = true;
+        p->success = true;
+        }
+    if( quit )
+        {
+        if( p->loop )
+            g_main_loop_quit( p->loop );
+        return FALSE;
+        }
+    return TRUE;
+    }
+
+bool nsKDEUtils::command( const nsTArray<nsCString>& command, nsTArray<nsCString>* output )
+    {
+    return self()->internalCommand( command, NULL, false, output );
+    }
+
+bool nsKDEUtils::command( nsIArray* command, nsIArray** output)
+    {
+    nsTArray<nsCString> in;
+    PRUint32 length;
+    command->GetLength( &length );
+    for ( PRUint32 i = 0; i < length; i++ )
+        {
+        nsCOMPtr<nsISupportsCString> str = do_QueryElementAt( command, i );
+        if( str )
+            {
+            nsAutoCString s;
+            str->GetData( s );
+            in.AppendElement( s );
+            }
+        }
+
+    nsTArray<nsCString> out;
+    bool ret = self()->internalCommand( in, NULL, false, &out );
+
+    if ( !output ) return ret;
+
+    nsCOMPtr<nsIMutableArray> result = do_CreateInstance( NS_ARRAY_CONTRACTID );
+    if ( !result ) return false;
+
+    for ( PRUint32 i = 0; i < out.Length(); i++ )
+        {
+        nsCOMPtr<nsISupportsCString> rstr = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+        if ( !rstr ) return false;
+
+        rstr->SetData( out[i] );
+        result->AppendElement( rstr );
+        }
+
+    NS_ADDREF( *output = result);
+    return ret;
+    }
+
+
+bool nsKDEUtils::commandBlockUi( const nsTArray<nsCString>& command, GtkWindow* parent, nsTArray<nsCString>* output )
+    {
+    return self()->internalCommand( command, parent, true, output );
+    }
+
+bool nsKDEUtils::internalCommand( const nsTArray<nsCString>& command, GtkWindow* parent, bool blockUi,
+    nsTArray<nsCString>* output )
+    {
+    if( !startHelper())
+        return false;
+    feedCommand( command );
+    // do not store the data in 'this' but in extra structure, just in case there
+    // is reentrancy (can there be? the event loop is re-entered)
+    nsKDECommandData data;
+    data.file = replyFile;
+    data.output = output;
+    data.success = false;
+    if( blockUi )
+        {
+        data.loop = g_main_loop_new( NULL, FALSE );
+        GtkWidget* window = gtk_window_new( GTK_WINDOW_TOPLEVEL );
+        if( parent && gtk_window_get_group(parent) )
+            gtk_window_group_add_window( gtk_window_get_group(parent), GTK_WINDOW( window ));
+        gtk_widget_realize( window );
+        gtk_widget_set_sensitive( window, TRUE );
+        gtk_grab_add( window );
+        GIOChannel* channel = g_io_channel_unix_new( fileno( data.file ));
+        g_io_add_watch( channel, static_cast< GIOCondition >( G_IO_IN | G_IO_ERR | G_IO_HUP ), kdeReadFunc, &data );
+        g_io_channel_unref( channel );
+        g_main_loop_run( data.loop );
+        g_main_loop_unref( data.loop );
+        gtk_grab_remove( window );
+        gtk_widget_destroy( window );
+        }
+    else
+        {
+        data.loop = NULL;
+        while( kdeReadFunc( NULL, static_cast< GIOCondition >( 0 ), &data ))
+            ;
+        }
+    return data.success;
+    }
+
+bool nsKDEUtils::startHelper()
+    {
+    if( helperRunning )
+        return true;
+    if( helperFailed )
+        return false;
+    helperFailed = true;
+    int fdcommand[ 2 ];
+    int fdreply[ 2 ];
+    if( pipe( fdcommand ) < 0 )
+        return false;
+    if( pipe( fdreply ) < 0 )
+        {
+        close( fdcommand[ 0 ] );
+        close( fdcommand[ 1 ] );
+        return false;
+        }
+    char* args[ 2 ] = { const_cast< char* >( KMOZILLAHELPER ), NULL };
+    switch( fork())
+        {
+        case -1:
+            {
+            close( fdcommand[ 0 ] );
+            close( fdcommand[ 1 ] );
+            close( fdreply[ 0 ] );
+            close( fdreply[ 1 ] );
+            return false;
+            }
+        case 0: // child
+            {
+            if( dup2( fdcommand[ 0 ], STDIN_FILENO ) < 0 )
+                _exit( 1 );
+            if( dup2( fdreply[ 1 ], STDOUT_FILENO ) < 0 )
+                _exit( 1 );
+            int maxfd = 1024; // close all other fds
+            struct rlimit rl;
+            if( getrlimit( RLIMIT_NOFILE, &rl ) == 0 )
+                maxfd = rl.rlim_max;
+            for( int i = 3;
+                 i < maxfd;
+                 ++i )
+                close( i );
+#ifdef DEBUG_KDE
+            execvp( KMOZILLAHELPER, args );
+#else
+            execv( KMOZILLAHELPER, args );
+#endif
+            _exit( 1 ); // failed
+            }
+        default: // parent
+            {
+            commandFile = fdopen( fdcommand[ 1 ], "w" );
+            replyFile = fdopen( fdreply[ 0 ], "r" );
+            close( fdcommand[ 0 ] );
+            close( fdreply[ 1 ] );
+            if( commandFile == NULL || replyFile == NULL )
+                {
+                closeHelper();
+                return false;
+                }
+            // ok, helper ready, getKdeRunning() will check if it works
+            }
+        }
+    helperFailed = false;
+    helperRunning = true;
+    return true;
+    }
+
+void nsKDEUtils::closeHelper()
+    {
+    if( commandFile != NULL )
+        fclose( commandFile ); // this will also make the helper quit
+    if( replyFile != NULL )
+        fclose( replyFile );
+    helperRunning = false;
+    }
+
+void nsKDEUtils::feedCommand( const nsTArray<nsCString>& command )
+    {
+    for( int i = 0;
+         i < command.Length();
+         ++i )
+        {
+        nsCString line = command[ i ];
+        line.ReplaceSubstring( "\\", "\\" "\\" ); // \ -> \\ , i.e. escape
+        line.ReplaceSubstring( "\n", "\\n" );
+#ifdef DEBUG_KDE
+        fprintf( stderr, "COMM: %s\n", line.get());
+#endif
+        fputs( line.get(), commandFile );
+        fputs( "\n", commandFile );
+        }
+    fputs( "\\E\n", commandFile ); // done as \E, so it cannot happen in normal data
+    fflush( commandFile );
+    }
diff --git a/toolkit/xre/nsKDEUtils.h b/toolkit/xre/nsKDEUtils.h
new file mode 100644
index 0000000000..c9c1284e29
--- /dev/null
+++ b/toolkit/xre/nsKDEUtils.h
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsKDEUtils_h__
+#define nsKDEUtils_h__
+
+#include "nsString.h"
+#include "nsTArray.h"
+#include <stdio.h>
+
+typedef struct _GtkWindow GtkWindow;
+
+class nsIArray;
+
+class NS_EXPORT nsKDEUtils
+    {
+    public:
+        /* Returns true if running inside a KDE session (regardless of whether there is KDE
+           support available for Firefox). This should be used e.g. when determining
+           dialog button order but not for code that requires the KDE support. */
+        static bool kdeSession();
+        /* Returns true if running inside a KDE session and KDE support is available
+           for Firefox. This should be used everywhere where the external helper is needed. */
+        static bool kdeSupport();
+        /* Executes the given helper command, returns true if helper returned success. */
+        static bool command( const nsTArray<nsCString>& command, nsTArray<nsCString>* output = NULL );
+        static bool command( nsIArray* command, nsIArray** output = NULL );
+        /* Like command(), but additionally blocks the parent widget like if there was
+           a modal dialog shown and enters the event loop (i.e. there are still paint updates,
+           this is for commands that take long). */
+        static bool commandBlockUi( const nsTArray<nsCString>& command, GtkWindow* parent, nsTArray<nsCString>* output = NULL );
+
+    private:
+        nsKDEUtils();
+        ~nsKDEUtils();
+        static nsKDEUtils* self();
+        bool startHelper();
+        void closeHelper();
+        void feedCommand( const nsTArray<nsCString>& command );
+        bool internalCommand( const nsTArray<nsCString>& command, GtkWindow* parent, bool isParent,
+            nsTArray<nsCString>* output );
+        FILE* commandFile;
+        FILE* replyFile;
+    };
+
+#endif // nsKDEUtils
diff --git a/uriloader/exthandler/HandlerServiceParent.cpp b/uriloader/exthandler/HandlerServiceParent.cpp
index 0796c7428b..4f21c058f8 100644
--- a/uriloader/exthandler/HandlerServiceParent.cpp
+++ b/uriloader/exthandler/HandlerServiceParent.cpp
@@ -12,7 +12,7 @@
 #include "ContentHandlerService.h"
 #include "nsStringEnumerator.h"
 #ifdef MOZ_WIDGET_GTK
-#  include "unix/nsGNOMERegistry.h"
+#  include "unix/nsCommonRegistry.h"
 #endif
 
 using mozilla::dom::ContentHandlerService;
@@ -304,7 +304,7 @@ mozilla::ipc::IPCResult HandlerServiceParent::RecvExistsForProtocolOS(
   }
 #ifdef MOZ_WIDGET_GTK
   // Check the GNOME registry for a protocol handler
-  *aHandlerExists = nsGNOMERegistry::HandlerExists(aProtocolScheme.get());
+  *aHandlerExists = nsCommonRegistry::HandlerExists(aProtocolScheme.get());
 #else
   *aHandlerExists = false;
 #endif
@@ -333,7 +333,7 @@ mozilla::ipc::IPCResult HandlerServiceParent::RecvExistsForProtocol(
   }
   rv = protoSvc->ExternalProtocolHandlerExists(aProtocolScheme.get(),
                                                aHandlerExists);
-
+##
   if (NS_WARN_IF(NS_FAILED(rv))) {
     *aHandlerExists = false;
   }
diff --git a/uriloader/exthandler/moz.build b/uriloader/exthandler/moz.build
index 92647a9b34..fc5068cd20 100644
--- a/uriloader/exthandler/moz.build
+++ b/uriloader/exthandler/moz.build
@@ -83,7 +83,9 @@ else:
 
 if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
     UNIFIED_SOURCES += [
+        "unix/nsCommonRegistry.cpp",
         "unix/nsGNOMERegistry.cpp",
+        "unix/nsKDERegistry.cpp",
         "unix/nsMIMEInfoUnix.cpp",
     ]
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "android":
@@ -135,6 +137,7 @@ LOCAL_INCLUDES += [
     "/dom/ipc",
     "/netwerk/base",
     "/netwerk/protocol/http",
+    "/toolkit/xre",
 ]
 
 if CONFIG["MOZ_ENABLE_DBUS"]:
diff --git a/uriloader/exthandler/unix/nsCommonRegistry.cpp b/uriloader/exthandler/unix/nsCommonRegistry.cpp
new file mode 100644
index 0000000000..630ab6147d
--- /dev/null
+++ b/uriloader/exthandler/unix/nsCommonRegistry.cpp
@@ -0,0 +1,53 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsCommonRegistry.h"
+
+#include "nsGNOMERegistry.h"
+#include "nsKDERegistry.h"
+#include "nsString.h"
+#include "nsKDEUtils.h"
+
+/* static */ bool
+nsCommonRegistry::HandlerExists(const char *aProtocolScheme)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::HandlerExists( aProtocolScheme );
+    return nsGNOMERegistry::HandlerExists( aProtocolScheme );
+}
+
+/* static */ nsresult
+nsCommonRegistry::LoadURL(nsIURI *aURL)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::LoadURL( aURL );
+    return nsGNOMERegistry::LoadURL( aURL );
+}
+
+/* static */ void
+nsCommonRegistry::GetAppDescForScheme(const nsACString& aScheme,
+                                     nsAString& aDesc)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetAppDescForScheme( aScheme, aDesc );
+    return nsGNOMERegistry::GetAppDescForScheme( aScheme, aDesc );
+}
+
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsCommonRegistry::GetFromExtension(const nsACString& aFileExt)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetFromExtension( aFileExt );
+    return nsGNOMERegistry::GetFromExtension( aFileExt );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsCommonRegistry::GetFromType(const nsACString& aMIMEType)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetFromType( aMIMEType );
+    return nsGNOMERegistry::GetFromType( aMIMEType );
+}
diff --git a/uriloader/exthandler/unix/nsCommonRegistry.h b/uriloader/exthandler/unix/nsCommonRegistry.h
new file mode 100644
index 0000000000..85b3d9cee2
--- /dev/null
+++ b/uriloader/exthandler/unix/nsCommonRegistry.h
@@ -0,0 +1,28 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsCommonRegistry_h__
+#define nsCommonRegistry_h__
+
+#include "nsIURI.h"
+#include "nsCOMPtr.h"
+
+class nsMIMEInfoBase;
+
+class nsCommonRegistry
+{
+ public:
+  static bool HandlerExists(const char *aProtocolScheme);
+
+  static nsresult LoadURL(nsIURI *aURL);
+
+  static void GetAppDescForScheme(const nsACString& aScheme,
+                                  nsAString& aDesc);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromExtension(const nsACString& aFileExt);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromType(const nsACString& aMIMEType);
+};
+
+#endif
diff --git a/uriloader/exthandler/unix/nsKDERegistry.cpp b/uriloader/exthandler/unix/nsKDERegistry.cpp
new file mode 100644
index 0000000000..f78e64c7e9
--- /dev/null
+++ b/uriloader/exthandler/unix/nsKDERegistry.cpp
@@ -0,0 +1,89 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/StaticPrefs_browser.h"
+#include "nsKDERegistry.h"
+#include "prlink.h"
+#include "prmem.h"
+#include "nsString.h"
+#include "nsMIMEInfoUnix.h"
+#include "nsKDEUtils.h"
+
+/* static */ bool
+nsKDERegistry::HandlerExists(const char *aProtocolScheme)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( "HANDLEREXISTS"_ns );
+    command.AppendElement( nsAutoCString( aProtocolScheme ));
+    return nsKDEUtils::command( command );
+}
+
+/* static */ nsresult
+nsKDERegistry::LoadURL(nsIURI *aURL)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( "OPEN"_ns );
+    nsCString url;
+    aURL->GetSpec( url );
+    command.AppendElement( url );
+    bool rv = nsKDEUtils::command( command );
+    if (!rv)
+      return NS_ERROR_FAILURE;
+
+    return NS_OK;
+}
+
+/* static */ void
+nsKDERegistry::GetAppDescForScheme(const nsACString& aScheme,
+                                     nsAString& aDesc)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( "GETAPPDESCFORSCHEME"_ns );
+    command.AppendElement( aScheme );
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::command( command, &output ) && output.Length() == 1 )
+        CopyUTF8toUTF16( output[ 0 ], aDesc );
+}
+
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromExtension(const nsACString& aFileExt)
+{
+    NS_ASSERTION(aFileExt[0] != '.', "aFileExt shouldn't start with a dot");
+    nsTArray<nsCString> command;
+    command.AppendElement( "GETFROMEXTENSION"_ns );
+    command.AppendElement( aFileExt );
+    return GetFromHelper( command );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromType(const nsACString& aMIMEType)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( "GETFROMTYPE"_ns );
+    command.AppendElement( aMIMEType );
+    return GetFromHelper( command );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromHelper(const nsTArray<nsCString>& command)
+{
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::command( command, &output ) && output.Length() == 3 )
+        {
+        nsCString mimetype = output[ 0 ];
+        RefPtr<nsMIMEInfoUnix> mimeInfo = new nsMIMEInfoUnix( mimetype );
+        NS_ENSURE_TRUE(mimeInfo, nullptr);
+        nsCString description = output[ 1 ];
+        mimeInfo->SetDescription(NS_ConvertUTF8toUTF16(description));
+        nsCString handlerAppName = output[ 2 ];
+        mozilla::StaticPrefs::browser_download_improvements_to_download_panel()
+            ? mimeInfo->SetPreferredAction(nsIMIMEInfo::saveToDisk)
+            : mimeInfo->SetPreferredAction(nsIMIMEInfo::useSystemDefault);
+        mimeInfo->SetDefaultDescription(NS_ConvertUTF8toUTF16(handlerAppName));
+        return mimeInfo.forget();
+        }
+    return nullptr;
+}
diff --git a/uriloader/exthandler/unix/nsKDERegistry.h b/uriloader/exthandler/unix/nsKDERegistry.h
new file mode 100644
index 0000000000..5b07eebc6d
--- /dev/null
+++ b/uriloader/exthandler/unix/nsKDERegistry.h
@@ -0,0 +1,34 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsKDERegistry_h__
+#define nsKDERegistry_h__
+
+#include "nsIURI.h"
+#include "nsCOMPtr.h"
+#include "nsTArray.h"
+
+class nsMIMEInfoBase;
+//class nsAutoCString;
+//class nsCString;
+
+class nsKDERegistry
+{
+ public:
+  static bool HandlerExists(const char *aProtocolScheme);
+
+  static nsresult LoadURL(nsIURI *aURL);
+
+  static void GetAppDescForScheme(const nsACString& aScheme,
+                                  nsAString& aDesc);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromExtension(const nsACString& aFileExt);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromType(const nsACString& aMIMEType);
+ private:
+  static already_AddRefed<nsMIMEInfoBase> GetFromHelper(const nsTArray<nsCString>& command);
+
+};
+
+#endif //nsKDERegistry_h__
diff --git a/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp b/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
index 7cbefcce3e..84083348c8 100644
--- a/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
+++ b/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
@@ -5,16 +5,19 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsMIMEInfoUnix.h"
-#include "nsGNOMERegistry.h"
+#include "nsCommonRegistry.h"
 #include "nsIGIOService.h"
 #include "nsNetCID.h"
 #include "nsIIOService.h"
 #ifdef MOZ_ENABLE_DBUS
 #  include "nsDBusHandlerApp.h"
 #endif
+#if defined(XP_UNIX) && !defined(XP_MACOSX)
+#include "nsKDEUtils.h"
+#endif
 
 nsresult nsMIMEInfoUnix::LoadUriInternal(nsIURI* aURI) {
-  return nsGNOMERegistry::LoadURL(aURI);
+  return nsCommonRegistry::LoadURL(aURI);
 }
 
 NS_IMETHODIMP
@@ -27,15 +30,15 @@ nsMIMEInfoUnix::GetHasDefaultHandler(bool* _retval) {
   *_retval = false;
 
   if (mClass == eProtocolInfo) {
-    *_retval = nsGNOMERegistry::HandlerExists(mSchemeOrType.get());
+    *_retval = nsCommonRegistry::HandlerExists(mSchemeOrType.get());
   } else {
     RefPtr<nsMIMEInfoBase> mimeInfo =
-        nsGNOMERegistry::GetFromType(mSchemeOrType);
+        nsCommonRegistry::GetFromType(mSchemeOrType);
     if (!mimeInfo) {
       nsAutoCString ext;
       nsresult rv = GetPrimaryExtension(ext);
       if (NS_SUCCEEDED(rv)) {
-        mimeInfo = nsGNOMERegistry::GetFromExtension(ext);
+        mimeInfo = nsCommonRegistry::GetFromExtension(ext);
       }
     }
     if (mimeInfo) *_retval = true;
@@ -55,6 +58,23 @@ nsresult nsMIMEInfoUnix::LaunchDefaultWithFile(nsIFile* aFile) {
   nsAutoCString nativePath;
   aFile->GetNativePath(nativePath);
 
+  if( nsKDEUtils::kdeSupport()) {
+    bool supports;
+    if( NS_SUCCEEDED( GetHasDefaultHandler( &supports )) && supports ) {
+      nsTArray<nsCString> command;
+      command.AppendElement( "OPEN"_ns );
+      command.AppendElement( nativePath );
+      command.AppendElement( "MIMETYPE"_ns );
+      command.AppendElement( mSchemeOrType );
+      if( nsKDEUtils::command( command ))
+        return NS_OK;
+    }
+    if (!mDefaultApplication)
+      return NS_ERROR_FILE_NOT_FOUND;
+
+    return LaunchWithIProcess(mDefaultApplication, nativePath);
+  }
+
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
   if (!giovfs) {
     return NS_ERROR_FAILURE;
diff --git a/uriloader/exthandler/unix/nsOSHelperAppService.cpp b/uriloader/exthandler/unix/nsOSHelperAppService.cpp
index b9e7aed3cb..367ad9ee24 100644
--- a/uriloader/exthandler/unix/nsOSHelperAppService.cpp
+++ b/uriloader/exthandler/unix/nsOSHelperAppService.cpp
@@ -10,7 +10,7 @@
 #include "nsOSHelperAppService.h"
 #include "nsMIMEInfoUnix.h"
 #ifdef MOZ_WIDGET_GTK
-#  include "nsGNOMERegistry.h"
+#  include "nsCommonRegistry.h"
 #  ifdef MOZ_BUILD_APP_IS_BROWSER
 #    include "nsIToolkitShellService.h"
 #    include "nsIGNOMEShellService.h"
@@ -1030,7 +1030,7 @@ nsresult nsOSHelperAppService::OSProtocolHandlerExists(
   if (!XRE_IsContentProcess()) {
 #ifdef MOZ_WIDGET_GTK
     // Check the GNOME registry for a protocol handler
-    *aHandlerExists = nsGNOMERegistry::HandlerExists(aProtocolScheme);
+    *aHandlerExists = nsCommonRegistry::HandlerExists(aProtocolScheme);
 #else
     *aHandlerExists = false;
 #endif
@@ -1050,7 +1050,7 @@ nsresult nsOSHelperAppService::OSProtocolHandlerExists(
 NS_IMETHODIMP nsOSHelperAppService::GetApplicationDescription(
     const nsACString& aScheme, nsAString& _retval) {
 #ifdef MOZ_WIDGET_GTK
-  nsGNOMERegistry::GetAppDescForScheme(aScheme, _retval);
+  nsCommonRegistry::GetAppDescForScheme(aScheme, _retval);
   return _retval.IsEmpty() ? NS_ERROR_NOT_AVAILABLE : NS_OK;
 #else
   return NS_ERROR_NOT_AVAILABLE;
@@ -1153,7 +1153,7 @@ already_AddRefed<nsMIMEInfoBase> nsOSHelperAppService::GetFromExtension(
 #ifdef MOZ_WIDGET_GTK
     LOG(("Looking in GNOME registry\n"));
     RefPtr<nsMIMEInfoBase> gnomeInfo =
-        nsGNOMERegistry::GetFromExtension(aFileExt);
+        nsCommonRegistry::GetFromExtension(aFileExt);
     if (gnomeInfo) {
       LOG(("Got MIMEInfo from GNOME registry\n"));
       return gnomeInfo.forget();
@@ -1266,7 +1266,7 @@ already_AddRefed<nsMIMEInfoBase> nsOSHelperAppService::GetFromType(
 
 #ifdef MOZ_WIDGET_GTK
   if (handler.IsEmpty()) {
-    RefPtr<nsMIMEInfoBase> gnomeInfo = nsGNOMERegistry::GetFromType(aMIMEType);
+    RefPtr<nsMIMEInfoBase> gnomeInfo = nsCommonRegistry::GetFromType(aMIMEType);
     if (gnomeInfo) {
       LOG(
           ("Got MIMEInfo from GNOME registry without extensions; setting them "
diff --git a/widget/gtk/NativeMenuSupport.cpp b/widget/gtk/NativeMenuSupport.cpp
index 4360867fff..c3a69f31b1 100644
--- a/widget/gtk/NativeMenuSupport.cpp
+++ b/widget/gtk/NativeMenuSupport.cpp
@@ -7,6 +7,8 @@
 
 #include "MainThreadUtils.h"
 #include "NativeMenuGtk.h"
+#include "nsINativeMenuService.h"
+#include "nsServiceManagerUtils.h"
 
 namespace mozilla::widget {
 
@@ -14,7 +16,14 @@ void NativeMenuSupport::CreateNativeMenuBar(nsIWidget* aParent,
                                             dom::Element* aMenuBarElement) {
   MOZ_RELEASE_ASSERT(NS_IsMainThread(),
                      "Attempting to create native menu bar on wrong thread!");
-  // TODO
+
+  nsCOMPtr<nsINativeMenuService> nms =
+      do_GetService("@mozilla.org/widget/nativemenuservice;1");
+  if (!nms) {
+    return;
+  }
+
+  nms->CreateNativeMenuBar(aParent, aMenuBarElement);
 }
 
 already_AddRefed<NativeMenu> NativeMenuSupport::CreateNativeContextMenu(
diff --git a/widget/gtk/NativeMenuSupport.h b/widget/gtk/NativeMenuSupport.h
new file mode 100644
index 0000000000..0843d45185
--- /dev/null
+++ b/widget/gtk/NativeMenuSupport.h
@@ -0,0 +1,31 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_widget_NativeMenuSupport_h
+#define mozilla_widget_NativeMenuSupport_h
+
+class nsIWidget;
+
+namespace mozilla {
+
+namespace dom {
+class Element;
+}
+
+namespace widget {
+
+class NativeMenuSupport final {
+public:
+    // Given a top-level window widget and a menu bar DOM node, sets up native
+    // menus. Once created, native menus are controlled via the DOM, including
+    // destruction.
+    static void CreateNativeMenuBar(nsIWidget* aParent,
+                                    dom::Element* aMenuBarElement);
+};
+
+}  // namespace widget
+}  // namespace mozilla
+
+#endif  // mozilla_widget_NativeMenuSupport_h
diff --git a/widget/gtk/components.conf b/widget/gtk/components.conf
index d98c43c9f9..af6eacf5d6 100644
--- a/widget/gtk/components.conf
+++ b/widget/gtk/components.conf
@@ -117,6 +117,14 @@ Classes = [
         'headers': ['/widget/gtk/nsUserIdleServiceGTK.h'],
         'constructor': 'nsUserIdleServiceGTK::GetInstance',
     },
+    {
+        'cid': '{0b3fe5aa-bc72-4303-85ae-76365df1251d}',
+        'contract_ids': ['@mozilla.org/widget/nativemenuservice;1'],
+        'singleton': True,
+        'type': 'nsNativeMenuService',
+        'constructor': 'nsNativeMenuService::GetInstanceForServiceManager',
+        'headers': ['/widget/gtk/nsNativeMenuService.h'],
+    },
 ]
 
 if defined('NS_PRINTING'):
diff --git a/widget/gtk/components.conf.orig b/widget/gtk/components.conf.orig
new file mode 100644
index 0000000000..d98c43c9f9
--- /dev/null
+++ b/widget/gtk/components.conf.orig
@@ -0,0 +1,158 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+Headers = [
+    '/widget/gtk/nsWidgetFactory.h',
+]
+
+InitFunc = 'nsWidgetGtk2ModuleCtor'
+UnloadFunc = 'nsWidgetGtk2ModuleDtor'
+
+Classes = [
+    {
+        'cid': '{2d96b3df-c051-11d1-a827-0040959a28c9}',
+        'contract_ids': ['@mozilla.org/widget/appshell/gtk;1'],
+        'legacy_constructor': 'nsAppShellConstructor',
+        'headers': ['/widget/gtk/nsWidgetFactory.h'],
+        'processes': ProcessSelector.ALLOW_IN_GPU_RDD_VR_SOCKET_AND_UTILITY_PROCESS,
+    },
+    {
+        'cid': '{c401eb80-f9ea-11d3-bb6f-e732b73ebe7c}',
+        'contract_ids': ['@mozilla.org/gfx/screenmanager;1'],
+        'singleton': True,
+        'type': 'mozilla::widget::ScreenManager',
+        'headers': ['mozilla/StaticPtr.h', 'mozilla/widget/ScreenManager.h'],
+        'constructor': 'mozilla::widget::ScreenManager::GetAddRefedSingleton',
+        'processes': ProcessSelector.ALLOW_IN_GPU_AND_MAIN_PROCESS,
+    },
+    {
+        'cid': '{a9339876-0027-430f-b953-84c9c11c2da3}',
+        'contract_ids': ['@mozilla.org/widget/taskbarprogress/gtk;1'],
+        'type': 'TaskbarProgress',
+        'headers': ['/widget/gtk/TaskbarProgress.h'],
+    },
+    {
+        'cid': '{0f872c8c-3ee6-46bd-92a2-69652c6b474e}',
+        'contract_ids': ['@mozilla.org/colorpicker;1'],
+        'type': 'nsColorPicker',
+        'headers': ['/widget/gtk/nsColorPicker.h'],
+        'processes': ProcessSelector.MAIN_PROCESS_ONLY,
+    },
+    {
+        'cid': '{bd57cee8-1dd1-11b2-9fe7-95cf4709aea3}',
+        'contract_ids': ['@mozilla.org/filepicker;1'],
+        'type': 'nsFilePicker',
+        'headers': ['/widget/gtk/nsFilePicker.h'],
+        'processes': ProcessSelector.MAIN_PROCESS_ONLY,
+    },
+    {
+        'cid': '{948a0023-e3a7-11d2-96cf-0060b0fb9956}',
+        'contract_ids': ['@mozilla.org/widget/htmlformatconverter;1'],
+        'type': 'nsHTMLFormatConverter',
+        'headers': ['/widget/nsHTMLFormatConverter.h'],
+    },
+    {
+        'cid': '{b148eed2-236d-11d3-b35c-00a0cc3c1cde}',
+        'contract_ids': ['@mozilla.org/sound;1'],
+        'singleton': True,
+        'type': 'nsISound',
+        'constructor': 'nsSound::GetInstance',
+        'headers': ['/widget/gtk/nsSound.h'],
+        'processes': ProcessSelector.MAIN_PROCESS_ONLY,
+    },
+    {
+        'cid': '{8b5314bc-db01-11d2-96ce-0060b0fb9956}',
+        'contract_ids': ['@mozilla.org/widget/transferable;1'],
+        'type': 'nsTransferable',
+        'headers': ['/widget/nsTransferable.h'],
+    },
+    {
+        'cid': '{e221df9b-3d66-4045-9a66-5720949f8d10}',
+        'contract_ids': ['@mozilla.org/applicationchooser;1'],
+        'type': 'nsApplicationChooser',
+        'headers': ['/widget/gtk/nsApplicationChooser.h'],
+        'processes': ProcessSelector.MAIN_PROCESS_ONLY,
+    },
+    {
+        'js_name': 'clipboard',
+        'cid': '{8b5314ba-db01-11d2-96ce-0060b0fb9956}',
+        'contract_ids': ['@mozilla.org/widget/clipboard;1'],
+        'interfaces': ['nsIClipboard'],
+        'type': 'nsIClipboard',
+        'processes': ProcessSelector.MAIN_PROCESS_ONLY,
+        'overridable': True,
+    },
+    {
+        'cid': '{77221d5a-1dd2-11b2-8c69-c710f15d2ed5}',
+        'contract_ids': ['@mozilla.org/widget/clipboardhelper;1'],
+        'type': 'nsClipboardHelper',
+        'headers': ['/widget/nsClipboardHelper.h'],
+    },
+    {
+        'cid': '{8b5314bb-db01-11d2-96ce-0060b0fb9956}',
+        'contract_ids': ['@mozilla.org/widget/dragservice;1'],
+        'singleton': True,
+        'type': 'nsDragService',
+        'headers': ['/widget/gtk/nsDragService.h'],
+        'constructor': 'nsDragService::GetInstance',
+        'processes': ProcessSelector.MAIN_PROCESS_ONLY,
+    },
+    {
+        'name': 'GfxInfo',
+        'cid': '{d755a760-9f27-11df-0800-200c9a664242}',
+        'contract_ids': ['@mozilla.org/gfx/info;1'],
+        'type': 'mozilla::widget::GfxInfo',
+        'headers': ['/widget/gtk/GfxInfo.h'],
+        'init_method': 'Init',
+        'processes': ProcessSelector.ALLOW_IN_GPU_PROCESS,
+    },
+    {
+        'cid': '{6987230e-0098-4e78-bc5f-1493ee7519fa}',
+        'contract_ids': ['@mozilla.org/widget/useridleservice;1'],
+        'singleton': True,
+        'type': 'nsUserIdleService',
+        'headers': ['/widget/gtk/nsUserIdleServiceGTK.h'],
+        'constructor': 'nsUserIdleServiceGTK::GetInstance',
+    },
+]
+
+if defined('NS_PRINTING'):
+    Classes += [
+        {
+            'cid': '{d3f69889-e13a-4321-980c-a39332e21f34}',
+            'contract_ids': ['@mozilla.org/gfx/devicecontextspec;1'],
+            'type': 'nsDeviceContextSpecGTK',
+            'headers': ['/widget/gtk/nsDeviceContextSpecG.h'],
+        },
+        {
+            'cid': '{06beec76-a183-4d9f-85dd-085f26da565a}',
+            'contract_ids': ['@mozilla.org/widget/printdialog-service;1'],
+            'type': 'nsPrintDialogServiceGTK',
+            'headers': ['/widget/gtk/nsPrintDialogGTK.h'],
+            'init_method': 'Init',
+        },
+        {
+            'cid': '{2f977d53-5485-11d4-87e2-0010a4e75ef2}',
+            'contract_ids': ['@mozilla.org/gfx/printsession;1'],
+            'type': 'nsPrintSession',
+            'headers': ['/widget/nsPrintSession.h'],
+            'init_method': 'Init',
+        },
+        {
+            'cid': '{841387c8-72e6-484b-9296-bf6eea80d58a}',
+            'contract_ids': ['@mozilla.org/gfx/printsettings-service;1'],
+            'type': 'nsPrintSettingsServiceGTK',
+            'headers': ['/widget/gtk/nsPrintSettingsServiceGTK.h'],
+            'init_method': 'Init',
+        },
+        {
+            'cid': '{a6cf9129-15b3-11d2-932e-00805f8add32}',
+            'contract_ids': ['@mozilla.org/gfx/printerlist;1'],
+            'type': 'nsPrinterListCUPS',
+            'headers': ['/widget/nsPrinterListCUPS.h'],
+            'processes': ProcessSelector.MAIN_PROCESS_ONLY,
+        },
+    ]
diff --git a/widget/gtk/moz.build b/widget/gtk/moz.build
index 5218c7df06..f94b4e017e 100644
--- a/widget/gtk/moz.build
+++ b/widget/gtk/moz.build
@@ -77,6 +77,15 @@ UNIFIED_SOURCES += [
 
 SOURCES += [
     "MediaKeysEventSourceFactory.cpp",
+    "nsDbusmenu.cpp",
+    "nsMenu.cpp", # conflicts with X11 headers
+    "nsMenuBar.cpp",
+    "nsMenuContainer.cpp",
+    "nsMenuItem.cpp",
+    "nsMenuObject.cpp",
+    "nsMenuSeparator.cpp",
+    "nsNativeMenuDocListener.cpp",
+    "nsNativeMenuService.cpp",
     "nsNativeThemeGTK.cpp",  # conflicts with X11 headers
     "nsWindow.cpp",  # conflicts with X11 headers
     "WaylandVsyncSource.cpp",  # conflicts with X11 headers
@@ -156,9 +165,11 @@ LOCAL_INCLUDES += [
     "/layout/base",
     "/layout/forms",
     "/layout/generic",
+    "/layout/style",
     "/layout/xul",
     "/other-licenses/atk-1.0",
     "/third_party/cups/include",
+    "/toolkit/xre",
     "/widget",
     "/widget/headless",
 ]
diff --git a/widget/gtk/moz.build.orig b/widget/gtk/moz.build.orig
new file mode 100644
index 0000000000..bf64f7ebdc
--- /dev/null
+++ b/widget/gtk/moz.build.orig
@@ -0,0 +1,202 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+with Files("**"):
+    BUG_COMPONENT = ("Core", "Widget: Gtk")
+
+with Files("*CompositorWidget*"):
+    BUG_COMPONENT = ("Core", "Graphics")
+
+with Files("*WindowSurface*"):
+    BUG_COMPONENT = ("Core", "Graphics")
+
+with Files("*IMContextWrapper*"):
+    BUG_COMPONENT = ("Core", "DOM: UI Events & Focus Handling")
+
+with Files("*nsGtkKeyUtils*"):
+    BUG_COMPONENT = ("Core", "DOM: UI Events & Focus Handling")
+
+if CONFIG["COMPILE_ENVIRONMENT"]:
+    DIRS += ["mozgtk"]
+
+if CONFIG["MOZ_WAYLAND"]:
+    DIRS += ["wayland", "mozwayland"]
+
+EXPORTS += [
+    "MozContainer.h",
+    "nsGTKToolkit.h",
+    "nsImageToPixbuf.h",
+]
+
+EXPORTS.mozilla += [
+    "GRefPtr.h",
+    "GUniquePtr.h",
+    "WidgetUtilsGtk.h",
+]
+
+EXPORTS.mozilla.widget += [
+    "WindowSurface.h",
+    "WindowSurfaceProvider.h",
+]
+
+UNIFIED_SOURCES += [
+    "AsyncGtkClipboardRequest.cpp",
+    "GfxInfo.cpp",
+    "gtk3drawing.cpp",
+    "GtkCompositorWidget.cpp",
+    "IMContextWrapper.cpp",
+    "MozContainer.cpp",
+    "MPRISServiceHandler.cpp",
+    "NativeKeyBindings.cpp",
+    "NativeMenuGtk.cpp",
+    "NativeMenuSupport.cpp",
+    "nsApplicationChooser.cpp",
+    "nsAppShell.cpp",
+    "nsBidiKeyboard.cpp",
+    "nsClipboard.cpp",
+    "nsColorPicker.cpp",
+    "nsDragService.cpp",
+    "nsFilePicker.cpp",
+    "nsGtkKeyUtils.cpp",
+    "nsImageToPixbuf.cpp",
+    "nsLookAndFeel.cpp",
+    "nsSound.cpp",
+    "nsToolkit.cpp",
+    "nsWidgetFactory.cpp",
+    "ScreenHelperGTK.cpp",
+    "TaskbarProgress.cpp",
+    "WakeLockListener.cpp",
+    "WidgetStyleCache.cpp",
+    "WidgetTraceEvent.cpp",
+    "WidgetUtilsGtk.cpp",
+    "WindowSurfaceProvider.cpp",
+]
+
+SOURCES += [
+    "MediaKeysEventSourceFactory.cpp",
+    "nsDbusmenu.cpp",
+    "nsMenu.cpp", # conflicts with X11 headers
+    "nsMenuBar.cpp",
+    "nsMenuContainer.cpp",
+    "nsMenuItem.cpp",
+    "nsMenuObject.cpp",
+    "nsMenuSeparator.cpp",
+    "nsNativeMenuDocListener.cpp",
+    "nsNativeMenuService.cpp",
+    "nsNativeThemeGTK.cpp",  # conflicts with X11 headers
+    "nsWindow.cpp",  # conflicts with X11 headers
+    "WaylandVsyncSource.cpp",  # conflicts with X11 headers
+]
+
+if CONFIG["ACCESSIBILITY"]:
+    UNIFIED_SOURCES += [
+        "maiRedundantObjectFactory.c",
+    ]
+
+if CONFIG["MOZ_WAYLAND"]:
+    UNIFIED_SOURCES += [
+        "DMABufLibWrapper.cpp",
+        "DMABufSurface.cpp",
+        "MozContainerWayland.cpp",
+        "nsClipboardWayland.cpp",
+        "nsWaylandDisplay.cpp",
+        "VAAPIUtils.cpp",
+        "WaylandBuffer.cpp",
+        "WindowSurfaceWaylandMultiBuffer.cpp",
+    ]
+    EXPORTS.mozilla.widget += [
+        "DMABufLibWrapper.h",
+        "DMABufSurface.h",
+        "MozContainerWayland.h",
+        "nsWaylandDisplay.h",
+        "VAAPIUtils.h",
+        "WaylandBuffer.h",
+    ]
+    LOCAL_INCLUDES += [
+        "/media/mozva",
+    ]
+    USE_LIBS += [
+        "mozva",
+    ]
+
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
+    UNIFIED_SOURCES += [
+        "CompositorWidgetChild.cpp",
+        "CompositorWidgetParent.cpp",
+        "InProcessGtkCompositorWidget.cpp",
+        "nsUserIdleServiceGTK.cpp",
+    ]
+    EXPORTS.mozilla.widget += [
+        "CompositorWidgetChild.h",
+        "CompositorWidgetParent.h",
+        "GtkCompositorWidget.h",
+        "InProcessGtkCompositorWidget.h",
+    ]
+
+if CONFIG["MOZ_X11"]:
+    UNIFIED_SOURCES += [
+        "nsClipboardX11.cpp",
+        "nsShmImage.cpp",
+        "WindowSurfaceX11.cpp",
+        "WindowSurfaceX11Image.cpp",
+        "WindowSurfaceX11SHM.cpp",
+    ]
+
+if CONFIG["NS_PRINTING"]:
+    UNIFIED_SOURCES += [
+        "nsDeviceContextSpecG.cpp",
+        "nsPrintDialogGTK.cpp",
+        "nsPrintSettingsGTK.cpp",
+        "nsPrintSettingsServiceGTK.cpp",
+    ]
+
+XPCOM_MANIFESTS += [
+    "components.conf",
+]
+
+include("/ipc/chromium/chromium-config.mozbuild")
+
+FINAL_LIBRARY = "xul"
+
+LOCAL_INCLUDES += [
+    "/layout/base",
+    "/layout/forms",
+    "/layout/generic",
+    "/layout/style",
+    "/layout/xul",
+    "/other-licenses/atk-1.0",
+    "/third_party/cups/include",
+    "/widget",
+    "/widget/headless",
+]
+
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
+    LOCAL_INCLUDES += [
+        "/widget/x11",
+    ]
+
+DEFINES["CAIRO_GFX"] = True
+
+DEFINES["MOZ_APP_NAME"] = '"%s"' % CONFIG["MOZ_APP_NAME"]
+
+CFLAGS += CONFIG["MOZ_GTK3_CFLAGS"]
+CXXFLAGS += CONFIG["MOZ_GTK3_CFLAGS"]
+
+if CONFIG["MOZ_WAYLAND"]:
+    CFLAGS += CONFIG["MOZ_WAYLAND_CFLAGS"]
+    CXXFLAGS += CONFIG["MOZ_WAYLAND_CFLAGS"]
+
+if CONFIG["MOZ_ENABLE_DBUS"]:
+    EXPORTS.mozilla.widget += [
+        "AsyncDBus.h",
+    ]
+    UNIFIED_SOURCES += [
+        "AsyncDBus.cpp",
+    ]
+    CXXFLAGS += CONFIG["MOZ_DBUS_GLIB_CFLAGS"]
+CXXFLAGS += ["-Werror=switch"]
+
+REQUIRES_UNIFIED_BUILD = True
diff --git a/widget/gtk/nsDbusmenu.cpp b/widget/gtk/nsDbusmenu.cpp
new file mode 100644
index 0000000000..f3a1c4400b
--- /dev/null
+++ b/widget/gtk/nsDbusmenu.cpp
@@ -0,0 +1,61 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsDbusmenu.h"
+#include "prlink.h"
+#include "mozilla/ArrayUtils.h"
+
+#define FUNC(name, type, params) \
+nsDbusmenuFunctions::_##name##_fn nsDbusmenuFunctions::s_##name;
+DBUSMENU_GLIB_FUNCTIONS
+DBUSMENU_GTK_FUNCTIONS
+#undef FUNC
+
+static PRLibrary *gDbusmenuGlib = nullptr;
+static PRLibrary *gDbusmenuGtk = nullptr;
+
+typedef void (*nsDbusmenuFunc)();
+struct nsDbusmenuDynamicFunction {
+    const char *functionName;
+    nsDbusmenuFunc *function;
+};
+
+/* static */ nsresult
+nsDbusmenuFunctions::Init()
+{
+#define FUNC(name, type, params) \
+    { #name, (nsDbusmenuFunc *)&nsDbusmenuFunctions::s_##name },
+    static const nsDbusmenuDynamicFunction kDbusmenuGlibSymbols[] = {
+        DBUSMENU_GLIB_FUNCTIONS
+    };
+    static const nsDbusmenuDynamicFunction kDbusmenuGtkSymbols[] = {
+        DBUSMENU_GTK_FUNCTIONS
+    };
+
+#define LOAD_LIBRARY(symbol, name) \
+    if (!g##symbol) { \
+        g##symbol = PR_LoadLibrary(name); \
+        if (!g##symbol) { \
+            return NS_ERROR_FAILURE; \
+        } \
+    } \
+    for (uint32_t i = 0; i < mozilla::ArrayLength(k##symbol##Symbols); ++i) { \
+        *k##symbol##Symbols[i].function = \
+            PR_FindFunctionSymbol(g##symbol, k##symbol##Symbols[i].functionName); \
+        if (!*k##symbol##Symbols[i].function) { \
+            return NS_ERROR_FAILURE; \
+        } \
+    }
+
+    LOAD_LIBRARY(DbusmenuGlib, "libdbusmenu-glib.so.4")
+#ifdef MOZ_WIDGET_GTK
+    LOAD_LIBRARY(DbusmenuGtk, "libdbusmenu-gtk3.so.4")
+#endif
+#undef LOAD_LIBRARY
+
+    return NS_OK;
+}
diff --git a/widget/gtk/nsDbusmenu.h b/widget/gtk/nsDbusmenu.h
new file mode 100644
index 0000000000..8d46a0d27b
--- /dev/null
+++ b/widget/gtk/nsDbusmenu.h
@@ -0,0 +1,101 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsDbusmenu_h__
+#define __nsDbusmenu_h__
+
+#include "nsError.h"
+
+#include <glib.h>
+#include <gdk/gdk.h>
+
+#define DBUSMENU_GLIB_FUNCTIONS \
+    FUNC(dbusmenu_menuitem_child_add_position, gboolean, (DbusmenuMenuitem *mi, DbusmenuMenuitem *child, guint position)) \
+    FUNC(dbusmenu_menuitem_child_append, gboolean, (DbusmenuMenuitem *mi, DbusmenuMenuitem *child)) \
+    FUNC(dbusmenu_menuitem_child_delete, gboolean, (DbusmenuMenuitem *mi, DbusmenuMenuitem *child)) \
+    FUNC(dbusmenu_menuitem_get_children, GList*, (DbusmenuMenuitem *mi)) \
+    FUNC(dbusmenu_menuitem_new, DbusmenuMenuitem*, (void)) \
+    FUNC(dbusmenu_menuitem_property_get, const gchar*, (DbusmenuMenuitem *mi, const gchar *property)) \
+    FUNC(dbusmenu_menuitem_property_get_bool, gboolean, (DbusmenuMenuitem *mi, const gchar *property)) \
+    FUNC(dbusmenu_menuitem_property_remove, void, (DbusmenuMenuitem *mi, const gchar *property)) \
+    FUNC(dbusmenu_menuitem_property_set, gboolean, (DbusmenuMenuitem *mi, const gchar *property, const gchar *value)) \
+    FUNC(dbusmenu_menuitem_property_set_bool, gboolean, (DbusmenuMenuitem *mi, const gchar *property, const gboolean value)) \
+    FUNC(dbusmenu_menuitem_property_set_int, gboolean, (DbusmenuMenuitem *mi, const gchar *property, const gint value)) \
+    FUNC(dbusmenu_menuitem_show_to_user, void, (DbusmenuMenuitem *mi, guint timestamp)) \
+    FUNC(dbusmenu_menuitem_take_children, GList*, (DbusmenuMenuitem *mi)) \
+    FUNC(dbusmenu_server_new, DbusmenuServer*, (const gchar *object)) \
+    FUNC(dbusmenu_server_set_root, void, (DbusmenuServer *server, DbusmenuMenuitem *root)) \
+    FUNC(dbusmenu_server_set_status, void, (DbusmenuServer *server, DbusmenuStatus status))
+
+#define DBUSMENU_GTK_FUNCTIONS \
+    FUNC(dbusmenu_menuitem_property_set_image, gboolean, (DbusmenuMenuitem *menuitem, const gchar *property, const GdkPixbuf *data)) \
+    FUNC(dbusmenu_menuitem_property_set_shortcut, gboolean, (DbusmenuMenuitem *menuitem, guint key, GdkModifierType modifier))
+
+typedef struct _DbusmenuMenuitem DbusmenuMenuitem;
+typedef struct _DbusmenuServer DbusmenuServer;
+
+enum DbusmenuStatus {
+    DBUSMENU_STATUS_NORMAL,
+    DBUSMENU_STATUS_NOTICE
+};
+
+#define DBUSMENU_MENUITEM_CHILD_DISPLAY_SUBMENU "submenu"
+#define DBUSMENU_MENUITEM_PROP_CHILD_DISPLAY "children-display"
+#define DBUSMENU_MENUITEM_PROP_ENABLED "enabled"
+#define DBUSMENU_MENUITEM_PROP_ICON_DATA "icon-data"
+#define DBUSMENU_MENUITEM_PROP_LABEL "label"
+#define DBUSMENU_MENUITEM_PROP_SHORTCUT "shortcut"
+#define DBUSMENU_MENUITEM_PROP_TYPE "type"
+#define DBUSMENU_MENUITEM_PROP_TOGGLE_STATE "toggle-state"
+#define DBUSMENU_MENUITEM_PROP_TOGGLE_TYPE "toggle-type"
+#define DBUSMENU_MENUITEM_PROP_VISIBLE "visible"
+#define DBUSMENU_MENUITEM_SIGNAL_ABOUT_TO_SHOW "about-to-show"
+#define DBUSMENU_MENUITEM_SIGNAL_EVENT "event"
+#define DBUSMENU_MENUITEM_SIGNAL_ITEM_ACTIVATED "item-activated"
+#define DBUSMENU_MENUITEM_TOGGLE_CHECK "checkmark"
+#define DBUSMENU_MENUITEM_TOGGLE_RADIO "radio"
+#define DBUSMENU_MENUITEM_TOGGLE_STATE_CHECKED 1
+#define DBUSMENU_MENUITEM_TOGGLE_STATE_UNCHECKED 0
+#define DBUSMENU_SERVER_PROP_DBUS_OBJECT "dbus-object"
+
+class nsDbusmenuFunctions
+{
+public:
+    nsDbusmenuFunctions() = delete;
+
+    static nsresult Init();
+
+#define FUNC(name, type, params) \
+    typedef type (*_##name##_fn) params; \
+    static _##name##_fn s_##name;
+    DBUSMENU_GLIB_FUNCTIONS
+    DBUSMENU_GTK_FUNCTIONS
+#undef FUNC
+
+};
+
+#define dbusmenu_menuitem_child_add_position nsDbusmenuFunctions::s_dbusmenu_menuitem_child_add_position
+#define dbusmenu_menuitem_child_append nsDbusmenuFunctions::s_dbusmenu_menuitem_child_append
+#define dbusmenu_menuitem_child_delete nsDbusmenuFunctions::s_dbusmenu_menuitem_child_delete
+#define dbusmenu_menuitem_get_children nsDbusmenuFunctions::s_dbusmenu_menuitem_get_children
+#define dbusmenu_menuitem_new nsDbusmenuFunctions::s_dbusmenu_menuitem_new
+#define dbusmenu_menuitem_property_get nsDbusmenuFunctions::s_dbusmenu_menuitem_property_get
+#define dbusmenu_menuitem_property_get_bool nsDbusmenuFunctions::s_dbusmenu_menuitem_property_get_bool
+#define dbusmenu_menuitem_property_remove nsDbusmenuFunctions::s_dbusmenu_menuitem_property_remove
+#define dbusmenu_menuitem_property_set nsDbusmenuFunctions::s_dbusmenu_menuitem_property_set
+#define dbusmenu_menuitem_property_set_bool nsDbusmenuFunctions::s_dbusmenu_menuitem_property_set_bool
+#define dbusmenu_menuitem_property_set_int nsDbusmenuFunctions::s_dbusmenu_menuitem_property_set_int
+#define dbusmenu_menuitem_show_to_user nsDbusmenuFunctions::s_dbusmenu_menuitem_show_to_user
+#define dbusmenu_menuitem_take_children nsDbusmenuFunctions::s_dbusmenu_menuitem_take_children
+#define dbusmenu_server_new nsDbusmenuFunctions::s_dbusmenu_server_new
+#define dbusmenu_server_set_root nsDbusmenuFunctions::s_dbusmenu_server_set_root
+#define dbusmenu_server_set_status nsDbusmenuFunctions::s_dbusmenu_server_set_status
+
+#define dbusmenu_menuitem_property_set_image nsDbusmenuFunctions::s_dbusmenu_menuitem_property_set_image
+#define dbusmenu_menuitem_property_set_shortcut nsDbusmenuFunctions::s_dbusmenu_menuitem_property_set_shortcut
+
+#endif /* __nsDbusmenu_h__ */
diff --git a/widget/gtk/nsFilePicker.cpp b/widget/gtk/nsFilePicker.cpp
index c73130496a..9e7b9aed56 100644
--- a/widget/gtk/nsFilePicker.cpp
+++ b/widget/gtk/nsFilePicker.cpp
@@ -5,6 +5,7 @@
 
 #include <dlfcn.h>
 #include <gtk/gtk.h>
+#include <gdk/gdkx.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -27,6 +28,8 @@
 #include "WidgetUtilsGtk.h"
 
 #include "nsFilePicker.h"
+#include "nsKDEUtils.h"
+#include "nsURLHelper.h"
 
 #undef LOG
 #ifdef MOZ_LOGGING
@@ -241,7 +244,9 @@ NS_IMETHODIMP
 nsFilePicker::AppendFilter(const nsAString& aTitle, const nsAString& aFilter) {
   if (aFilter.EqualsLiteral("..apps")) {
     // No platform specific thing we can do here, really....
-    return NS_OK;
+    // Unless it's KDE.
+    if( mMode != modeOpen || !nsKDEUtils::kdeSupport())
+      return NS_OK;
   }
 
   nsAutoCString filter, name;
@@ -351,6 +356,29 @@ nsFilePicker::Open(nsIFilePickerShownCallback* aCallback) {
   // Can't show two dialogs concurrently with the same filepicker
   if (mRunning) return NS_ERROR_NOT_AVAILABLE;
 
+  // KDE file picker is not handled via callback
+  if( nsKDEUtils::kdeSupport()) {
+    mCallback = aCallback;
+    mRunning = true;
+    NS_ADDREF_THIS();
+    g_idle_add([](gpointer data) -> gboolean {
+      nsFilePicker* queuedPicker = (nsFilePicker*) data;
+      int16_t result;
+      queuedPicker->kdeFileDialog(&result);
+      if (queuedPicker->mCallback) {
+        queuedPicker->mCallback->Done(result);
+        queuedPicker->mCallback = nullptr;
+      } else {
+        queuedPicker->mResult = result;
+      }
+      queuedPicker->mRunning = false;
+      NS_RELEASE(queuedPicker);
+      return G_SOURCE_REMOVE;
+    }, this);
+
+    return NS_OK;
+  }
+
   NS_ConvertUTF16toUTF8 title(mTitle);
 
   GtkWindow* parent_widget =
@@ -580,6 +608,234 @@ void nsFilePicker::Done(void* file_chooser, gint response) {
   NS_RELEASE_THIS();
 }
 
+nsCString nsFilePicker::kdeMakeFilter( int index )
+    {
+    nsCString buf = mFilters[ index ];
+    for( PRUint32 i = 0;
+         i < buf.Length();
+         ++i )
+        if( buf[ i ] == ';' ) // KDE separates just using spaces
+            buf.SetCharAt( ' ', i );
+    if (!mFilterNames[index].IsEmpty())
+        {
+        buf += "|";
+        buf += mFilterNames[index].get();
+        }
+    return buf;
+    }
+
+static PRInt32 windowToXid( nsIWidget* widget )
+    {
+    GtkWindow *parent_widget = GTK_WINDOW(widget->GetNativeData(NS_NATIVE_SHELLWIDGET));
+    GdkWindow* gdk_window = gtk_widget_get_window( gtk_widget_get_toplevel( GTK_WIDGET( parent_widget )));
+    return GDK_WINDOW_XID( gdk_window );
+    }
+
+NS_IMETHODIMP nsFilePicker::kdeFileDialog(PRInt16 *aReturn)
+    {
+    NS_ENSURE_ARG_POINTER(aReturn);
+
+    if( mMode == modeOpen && mFilters.Length() == 1 && mFilters[ 0 ].EqualsLiteral( "..apps" ))
+        return kdeAppsDialog( aReturn );
+
+    nsCString title;
+    title.Adopt(ToNewUTF8String(mTitle));
+
+    const char* arg = NULL;
+    if( mAllowURLs )
+        {
+        switch( mMode )
+            {
+            case nsIFilePicker::modeOpen:
+            case nsIFilePicker::modeOpenMultiple:
+                arg = "GETOPENURL";
+                break;
+            case nsIFilePicker::modeSave:
+                arg = "GETSAVEURL";
+                break;
+            case nsIFilePicker::modeGetFolder:
+                arg = "GETDIRECTORYURL";
+                break;
+            }
+        }
+    else
+        {
+        switch( mMode )
+            {
+            case nsIFilePicker::modeOpen:
+            case nsIFilePicker::modeOpenMultiple:
+                arg = "GETOPENFILENAME";
+                break;
+            case nsIFilePicker::modeSave:
+                arg = "GETSAVEFILENAME";
+                break;
+            case nsIFilePicker::modeGetFolder:
+                arg = "GETDIRECTORYFILENAME";
+                break;
+            }
+        }
+
+  nsAutoCString directory;
+  if (mDisplayDirectory) {
+    mDisplayDirectory->GetNativePath(directory);
+  } else if (mPrevDisplayDirectory) {
+    mPrevDisplayDirectory->GetNativePath(directory);
+  }
+
+    nsAutoCString startdir;
+  if (!directory.IsEmpty()) {
+    startdir = directory;
+  }
+  if (mMode == nsIFilePicker::modeSave) {
+    if( !startdir.IsEmpty())
+      {
+      startdir += "/";
+      startdir += ToNewUTF8String(mDefault);
+      }
+    else
+      startdir = ToNewUTF8String(mDefault);
+  }
+
+    nsAutoCString filters;
+    PRInt32 count = mFilters.Length();
+    if( count == 0 ) //just in case
+        filters = "*";
+    else
+        {
+        filters = kdeMakeFilter( 0 );
+        for (PRInt32 i = 1; i < count; ++i)
+            {
+            filters += "\n";
+            filters += kdeMakeFilter( i );
+            }
+        }
+
+    nsTArray<nsCString> command;
+    command.AppendElement( nsAutoCString( arg ));
+    command.AppendElement( startdir );
+    if( mMode != nsIFilePicker::modeGetFolder )
+        {
+        command.AppendElement( filters );
+        nsAutoCString selected;
+        selected.AppendInt( mSelectedType );
+        command.AppendElement( selected );
+        }
+    command.AppendElement( title );
+    if( mMode == nsIFilePicker::modeOpenMultiple )
+        command.AppendElement( "MULTIPLE"_ns );
+    if( PRInt32 xid = windowToXid( mParentWidget ))
+        {
+        command.AppendElement( "PARENT"_ns );
+        nsAutoCString parent;
+        parent.AppendInt( xid );
+        command.AppendElement( parent );
+        }
+
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::commandBlockUi( command, GTK_WINDOW(mParentWidget->GetNativeData(NS_NATIVE_SHELLWIDGET)), &output ))
+        {
+        *aReturn = nsIFilePicker::returnOK;
+        mFiles.Clear();
+        if( mMode != nsIFilePicker::modeGetFolder )
+            {
+            mSelectedType = atoi( output[ 0 ].get());
+            output.RemoveElementAt( 0 );
+            }
+        if (mMode == nsIFilePicker::modeOpenMultiple)
+            {
+            mFileURL.Truncate();
+            PRUint32 count = output.Length();
+            for( PRUint32 i = 0;
+                 i < count;
+                 ++i )
+                {
+                nsCOMPtr<nsIFile> localfile;
+                nsresult rv = NS_NewNativeLocalFile( output[ i ],
+                                      PR_FALSE,
+                                      getter_AddRefs(localfile));
+                if (NS_SUCCEEDED(rv))
+                    mFiles.AppendObject(localfile);
+                }
+            }
+        else
+            {
+            if( output.Length() == 0 )
+                mFileURL = nsCString();
+            else if( mAllowURLs )
+                mFileURL = output[ 0 ];
+            else // GetFile() actually requires it to be url even for local files :-/
+                {
+                nsCOMPtr<nsIFile> localfile;
+                nsresult rv = NS_NewNativeLocalFile( output[ 0 ],
+                                   PR_FALSE,
+                                   getter_AddRefs(localfile));
+                if (NS_SUCCEEDED(rv))
+                  rv = net_GetURLSpecFromActualFile(localfile, mFileURL);
+                }
+            }
+  // Remember last used directory.
+  nsCOMPtr<nsIFile> file;
+  GetFile(getter_AddRefs(file));
+  if (file) {
+    nsCOMPtr<nsIFile> dir;
+    file->GetParent(getter_AddRefs(dir));
+    nsCOMPtr<nsIFile> localDir(do_QueryInterface(dir));
+    if (localDir) {
+      localDir.swap(mPrevDisplayDirectory);
+    }
+  }
+        if (mMode == nsIFilePicker::modeSave)
+            {
+            nsCOMPtr<nsIFile> file;
+            GetFile(getter_AddRefs(file));
+            if (file)
+                {
+                bool exists = false;
+                file->Exists(&exists);
+                if (exists) // TODO do overwrite check in the helper app
+                    *aReturn = nsIFilePicker::returnReplace;
+                }
+            }
+        }
+    else
+        {
+        *aReturn = nsIFilePicker::returnCancel;
+        }
+    return NS_OK;
+    }
+
+
+NS_IMETHODIMP nsFilePicker::kdeAppsDialog(PRInt16 *aReturn)
+    {
+    NS_ENSURE_ARG_POINTER(aReturn);
+
+    nsCString title;
+    title.Adopt(ToNewUTF8String(mTitle));
+
+    nsTArray<nsCString> command;
+    command.AppendElement( "APPSDIALOG"_ns );
+    command.AppendElement( title );
+    if( PRInt32 xid = windowToXid( mParentWidget ))
+        {
+        command.AppendElement( "PARENT"_ns );
+        nsAutoCString parent;
+        parent.AppendInt( xid );
+        command.AppendElement( parent );
+        }
+
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::commandBlockUi( command, GTK_WINDOW(mParentWidget->GetNativeData(NS_NATIVE_SHELLWIDGET)), &output ))
+        {
+        *aReturn = nsIFilePicker::returnOK;
+        mFileURL = output.Length() > 0 ? output[ 0 ] : nsCString();
+        }
+    else
+        {
+        *aReturn = nsIFilePicker::returnCancel;
+        }
+    return NS_OK;
+    }
+
 // All below functions available as of GTK 3.20+
 void* nsFilePicker::GtkFileChooserNew(const gchar* title, GtkWindow* parent,
                                       GtkFileChooserAction action,
diff --git a/widget/gtk/nsFilePicker.h b/widget/gtk/nsFilePicker.h
index 9b3110aa00..be9d559c7b 100644
--- a/widget/gtk/nsFilePicker.h
+++ b/widget/gtk/nsFilePicker.h
@@ -72,6 +72,12 @@ class nsFilePicker : public nsBaseFilePicker {
  private:
   static nsIFile* mPrevDisplayDirectory;
 
+  bool kdeRunning();
+  bool getKdeRunning();
+  NS_IMETHODIMP kdeFileDialog(PRInt16 *aReturn);
+  NS_IMETHODIMP kdeAppsDialog(PRInt16 *aReturn);
+  nsCString kdeMakeFilter( int index );
+
   void* GtkFileChooserNew(const gchar* title, GtkWindow* parent,
                           GtkFileChooserAction action,
                           const gchar* accept_label);
diff --git a/widget/gtk/nsMenu.cpp b/widget/gtk/nsMenu.cpp
new file mode 100644
index 0000000000..27142f9798
--- /dev/null
+++ b/widget/gtk/nsMenu.cpp
@@ -0,0 +1,795 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#define _IMPL_NS_LAYOUT
+
+#include "mozilla/dom/Document.h"
+#include "mozilla/dom/Element.h"
+#include "mozilla/Assertions.h"
+#include "mozilla/ComputedStyleInlines.h"
+#include "mozilla/EventDispatcher.h"
+#include "mozilla/MouseEvents.h"
+#include "mozilla/PresShell.h"
+#include "mozilla/PresShellInlines.h"
+#include "nsComponentManagerUtils.h"
+#include "nsContentUtils.h"
+#include "nsCSSValue.h"
+#include "nsGkAtoms.h"
+#include "nsGtkUtils.h"
+#include "nsAtom.h"
+#include "nsIContent.h"
+#include "nsIRunnable.h"
+#include "nsITimer.h"
+#include "nsString.h"
+#include "nsStyleStruct.h"
+#include "nsThreadUtils.h"
+
+#include "nsNativeMenuDocListener.h"
+
+#include <glib-object.h>
+
+#include "nsMenu.h"
+
+using namespace mozilla;
+
+class nsMenuContentInsertedEvent : public Runnable
+{
+public:
+    nsMenuContentInsertedEvent(nsMenu *aMenu,
+                               nsIContent *aContainer,
+                               nsIContent *aChild,
+                               nsIContent *aPrevSibling) :
+        Runnable("nsMenuContentInsertedEvent"),
+        mWeakMenu(aMenu),
+        mContainer(aContainer),
+        mChild(aChild),
+        mPrevSibling(aPrevSibling) { }
+
+    NS_IMETHODIMP Run()
+    {
+        if (!mWeakMenu) {
+            return NS_OK;
+        }
+
+        static_cast<nsMenu *>(mWeakMenu.get())->HandleContentInserted(mContainer,
+                                                                      mChild,
+                                                                      mPrevSibling);
+        return NS_OK;
+    }
+
+private:
+    nsWeakMenuObject mWeakMenu;
+
+    nsCOMPtr<nsIContent> mContainer;
+    nsCOMPtr<nsIContent> mChild;
+    nsCOMPtr<nsIContent> mPrevSibling;
+};
+
+class nsMenuContentRemovedEvent : public Runnable
+{
+public:
+    nsMenuContentRemovedEvent(nsMenu *aMenu,
+                              nsIContent *aContainer,
+                              nsIContent *aChild) :
+        Runnable("nsMenuContentRemovedEvent"),
+        mWeakMenu(aMenu),
+        mContainer(aContainer),
+        mChild(aChild) { }
+
+    NS_IMETHODIMP Run()
+    {
+        if (!mWeakMenu) {
+            return NS_OK;
+        }
+
+        static_cast<nsMenu *>(mWeakMenu.get())->HandleContentRemoved(mContainer,
+                                                                     mChild);
+        return NS_OK;
+    }
+
+private:
+    nsWeakMenuObject mWeakMenu;
+
+    nsCOMPtr<nsIContent> mContainer;
+    nsCOMPtr<nsIContent> mChild;
+};
+
+static void
+DispatchMouseEvent(nsIContent *aTarget, mozilla::EventMessage aMsg)
+{
+    if (!aTarget) {
+        return;
+    }
+
+    WidgetMouseEvent event(true, aMsg, nullptr, WidgetMouseEvent::eReal);
+    EventDispatcher::Dispatch(aTarget, nullptr, &event);
+}
+
+void
+nsMenu::SetPopupState(EPopupState aState)
+{
+    mPopupState = aState;
+
+    if (!mPopupContent) {
+        return;
+    }
+
+    nsAutoString state;
+    switch (aState) {
+        case ePopupState_Showing:
+            state.Assign(u"showing"_ns);
+            break;
+        case ePopupState_Open:
+            state.Assign(u"open"_ns);
+            break;
+        case ePopupState_Hiding:
+            state.Assign(u"hiding"_ns);
+            break;
+        default:
+            break;
+    }
+
+    if (state.IsEmpty()) {
+        mPopupContent->AsElement()->UnsetAttr(
+            kNameSpaceID_None, nsGkAtoms::_moz_nativemenupopupstate,
+            false);
+    } else {
+        mPopupContent->AsElement()->SetAttr(
+            kNameSpaceID_None, nsGkAtoms::_moz_nativemenupopupstate,
+            state, false);
+    }
+}
+
+/* static */ void
+nsMenu::DoOpenCallback(nsITimer *aTimer, void *aClosure)
+{
+    nsMenu* self = static_cast<nsMenu *>(aClosure);
+
+    dbusmenu_menuitem_show_to_user(self->GetNativeData(), 0);
+
+    self->mOpenDelayTimer = nullptr;
+}
+
+/* static */ void
+nsMenu::menu_event_cb(DbusmenuMenuitem *menu,
+                      const gchar *name,
+                      GVariant *value,
+                      guint timestamp,
+                      gpointer user_data)
+{
+    nsMenu *self = static_cast<nsMenu *>(user_data);
+
+    nsAutoCString event(name);
+
+    if (event.Equals("closed"_ns)) {
+        self->OnClose();
+        return;
+    }
+
+    if (event.Equals("opened"_ns)) {
+        self->OnOpen();
+        return;
+    }
+}
+
+void
+nsMenu::MaybeAddPlaceholderItem()
+{
+    MOZ_ASSERT(!IsInBatchedUpdate(),
+               "Shouldn't be modifying the native menu structure now");
+
+    GList *children = dbusmenu_menuitem_get_children(GetNativeData());
+    if (!children) {
+        MOZ_ASSERT(!mPlaceholderItem);
+
+        mPlaceholderItem = dbusmenu_menuitem_new();
+        if (!mPlaceholderItem) {
+            return;
+        }
+
+        dbusmenu_menuitem_property_set_bool(mPlaceholderItem,
+                                            DBUSMENU_MENUITEM_PROP_VISIBLE,
+                                            false);
+
+        MOZ_ALWAYS_TRUE(
+            dbusmenu_menuitem_child_append(GetNativeData(), mPlaceholderItem));
+    }
+}
+
+void
+nsMenu::EnsureNoPlaceholderItem()
+{
+    MOZ_ASSERT(!IsInBatchedUpdate(),
+               "Shouldn't be modifying the native menu structure now");
+
+    if (!mPlaceholderItem) {
+        return;
+    }
+
+    MOZ_ALWAYS_TRUE(
+        dbusmenu_menuitem_child_delete(GetNativeData(), mPlaceholderItem));
+    MOZ_ASSERT(!dbusmenu_menuitem_get_children(GetNativeData()));
+
+    g_object_unref(mPlaceholderItem);
+    mPlaceholderItem = nullptr;
+}
+
+void
+nsMenu::OnOpen()
+{
+    if (mNeedsRebuild) {
+        Build();
+    }
+
+    nsWeakMenuObject self(this);
+    nsCOMPtr<nsIContent> origPopupContent(mPopupContent);
+    {
+        nsNativeMenuDocListener::BlockUpdatesScope updatesBlocker;
+
+        SetPopupState(ePopupState_Showing);
+        DispatchMouseEvent(mPopupContent, eXULPopupShowing);
+
+        ContentNode()->AsElement()->SetAttr(kNameSpaceID_None, nsGkAtoms::open,
+                                            u"true"_ns, true);
+    }
+
+    if (!self) {
+        // We were deleted!
+        return;
+    }
+
+    // I guess that the popup could have changed
+    if (origPopupContent != mPopupContent) {
+        return;
+    }
+
+    nsNativeMenuDocListener::BlockUpdatesScope updatesBlocker;
+
+    size_t count = ChildCount();
+    for (size_t i = 0; i < count; ++i) {
+        ChildAt(i)->ContainerIsOpening();
+    }
+
+    SetPopupState(ePopupState_Open);
+    DispatchMouseEvent(mPopupContent, eXULPopupShown);
+}
+
+void
+nsMenu::Build()
+{
+    mNeedsRebuild = false;
+
+    while (ChildCount() > 0) {
+        RemoveChildAt(0);
+    }
+
+    InitializePopup();
+
+    if (!mPopupContent) {
+        return;
+    }
+
+    uint32_t count = mPopupContent->GetChildCount();
+    for (uint32_t i = 0; i < count; ++i) {
+        nsIContent *childContent = mPopupContent->GetChildAt_Deprecated(i);
+
+        UniquePtr<nsMenuObject> child = CreateChild(childContent);
+
+        if (!child) {
+            continue;
+        }
+
+        AppendChild(std::move(child));
+    }
+}
+
+void
+nsMenu::InitializePopup()
+{
+    nsCOMPtr<nsIContent> oldPopupContent;
+    oldPopupContent.swap(mPopupContent);
+
+    for (uint32_t i = 0; i < ContentNode()->GetChildCount(); ++i) {
+        nsIContent *child = ContentNode()->GetChildAt_Deprecated(i);
+
+        if (child->NodeInfo()->NameAtom() == nsGkAtoms::menupopup) {
+            mPopupContent = child;
+            break;
+        }
+    }
+
+    if (oldPopupContent == mPopupContent) {
+        return;
+    }
+
+    // The popup has changed
+
+    if (oldPopupContent) {
+        DocListener()->UnregisterForContentChanges(oldPopupContent);
+    }
+
+    SetPopupState(ePopupState_Closed);
+
+    if (!mPopupContent) {
+        return;
+    }
+
+    DocListener()->RegisterForContentChanges(mPopupContent, this);
+}
+
+void
+nsMenu::RemoveChildAt(size_t aIndex)
+{
+    MOZ_ASSERT(IsInBatchedUpdate() || !mPlaceholderItem,
+               "Shouldn't have a placeholder menuitem");
+
+    nsMenuContainer::RemoveChildAt(aIndex, !IsInBatchedUpdate());
+    StructureMutated();
+
+    if (!IsInBatchedUpdate()) {
+        MaybeAddPlaceholderItem();
+    }
+}
+
+void
+nsMenu::RemoveChild(nsIContent *aChild)
+{
+    size_t index = IndexOf(aChild);
+    if (index == NoIndex) {
+        return;
+    }
+
+    RemoveChildAt(index);
+}
+
+void
+nsMenu::InsertChildAfter(UniquePtr<nsMenuObject> aChild,
+                         nsIContent *aPrevSibling)
+{
+    if (!IsInBatchedUpdate()) {
+        EnsureNoPlaceholderItem();
+    }
+
+    nsMenuContainer::InsertChildAfter(std::move(aChild), aPrevSibling,
+                                      !IsInBatchedUpdate());
+    StructureMutated();
+}
+
+void
+nsMenu::AppendChild(UniquePtr<nsMenuObject> aChild)
+{
+    if (!IsInBatchedUpdate()) {
+        EnsureNoPlaceholderItem();
+    }
+
+    nsMenuContainer::AppendChild(std::move(aChild), !IsInBatchedUpdate());
+    StructureMutated();
+}
+
+bool
+nsMenu::IsInBatchedUpdate() const
+{
+    return mBatchedUpdateState != eBatchedUpdateState_Inactive;
+}
+
+void
+nsMenu::StructureMutated()
+{
+    if (!IsInBatchedUpdate()) {
+        return;
+    }
+
+    mBatchedUpdateState = eBatchedUpdateState_DidMutate;
+}
+
+bool
+nsMenu::CanOpen() const
+{
+    bool isVisible = dbusmenu_menuitem_property_get_bool(GetNativeData(),
+                                                         DBUSMENU_MENUITEM_PROP_VISIBLE);
+    bool isDisabled = ContentNode()->AsElement()->AttrValueIs(kNameSpaceID_None,
+                                                              nsGkAtoms::disabled,
+                                                              nsGkAtoms::_true,
+                                                              eCaseMatters);
+
+    return (isVisible && !isDisabled);
+}
+
+void
+nsMenu::HandleContentInserted(nsIContent *aContainer,
+                              nsIContent *aChild,
+                              nsIContent *aPrevSibling)
+{
+    if (aContainer == mPopupContent) {
+        UniquePtr<nsMenuObject> child = CreateChild(aChild);
+
+        if (child) {
+            InsertChildAfter(std::move(child), aPrevSibling);
+        }
+    } else {
+        Build();
+    }
+}
+
+void
+nsMenu::HandleContentRemoved(nsIContent *aContainer, nsIContent *aChild)
+{
+    if (aContainer == mPopupContent) {
+        RemoveChild(aChild);
+    } else {
+        Build();
+    }
+}
+
+void
+nsMenu::InitializeNativeData()
+{
+    // Dbusmenu provides an "about-to-show" signal, and also "opened" and
+    // "closed" events. However, Unity is the only thing that sends
+    // both "about-to-show" and "opened" events. Unity 2D and the HUD only
+    // send "opened" events, so we ignore "about-to-show" (I don't think
+    // there's any real difference between them anyway).
+    // To complicate things, there are certain conditions where we don't
+    // get a "closed" event, so we need to be able to handle this :/
+    g_signal_connect(G_OBJECT(GetNativeData()), "event",
+                     G_CALLBACK(menu_event_cb), this);
+
+    mNeedsRebuild = true;
+    mNeedsUpdate = true;
+
+    MaybeAddPlaceholderItem();
+}
+
+void
+nsMenu::Update(ComputedStyle *aComputedStyle)
+{
+    if (mNeedsUpdate) {
+        mNeedsUpdate = false;
+
+        UpdateLabel();
+        UpdateSensitivity();
+    }
+
+    UpdateVisibility(aComputedStyle);
+    UpdateIcon(aComputedStyle);
+}
+
+nsMenuObject::PropertyFlags
+nsMenu::SupportedProperties() const
+{
+    return static_cast<nsMenuObject::PropertyFlags>(
+        nsMenuObject::ePropLabel |
+        nsMenuObject::ePropEnabled |
+        nsMenuObject::ePropVisible |
+        nsMenuObject::ePropIconData |
+        nsMenuObject::ePropChildDisplay
+    );
+}
+
+void
+nsMenu::OnAttributeChanged(nsIContent *aContent, nsAtom *aAttribute)
+{
+    MOZ_ASSERT(aContent == ContentNode() || aContent == mPopupContent,
+               "Received an event that wasn't meant for us!");
+
+    if (mNeedsUpdate) {
+        return;
+    }
+
+    if (aContent != ContentNode()) {
+        return;
+    }
+
+    if (!Parent()->IsBeingDisplayed()) {
+        mNeedsUpdate = true;
+        return;
+    }
+
+    if (aAttribute == nsGkAtoms::disabled) {
+        UpdateSensitivity();
+    } else if (aAttribute == nsGkAtoms::label ||
+               aAttribute == nsGkAtoms::accesskey ||
+               aAttribute == nsGkAtoms::crop) {
+        UpdateLabel();
+    } else if (aAttribute == nsGkAtoms::hidden ||
+        aAttribute == nsGkAtoms::collapsed) {
+        RefPtr<ComputedStyle> style = GetComputedStyle();
+        UpdateVisibility(style);
+    } else if (aAttribute == nsGkAtoms::image) {
+        RefPtr<ComputedStyle> style = GetComputedStyle();
+        UpdateIcon(style);
+    }
+}
+
+void
+nsMenu::OnContentInserted(nsIContent *aContainer, nsIContent *aChild,
+                          nsIContent *aPrevSibling)
+{
+    MOZ_ASSERT(aContainer == ContentNode() || aContainer == mPopupContent,
+               "Received an event that wasn't meant for us!");
+
+    if (mNeedsRebuild) {
+        return;
+    }
+
+    if (mPopupState == ePopupState_Closed) {
+        mNeedsRebuild = true;
+        return;
+    }
+
+    nsContentUtils::AddScriptRunner(
+        new nsMenuContentInsertedEvent(this, aContainer, aChild,
+                                       aPrevSibling));
+}
+
+void
+nsMenu::OnContentRemoved(nsIContent *aContainer, nsIContent *aChild)
+{
+    MOZ_ASSERT(aContainer == ContentNode() || aContainer == mPopupContent,
+               "Received an event that wasn't meant for us!");
+
+    if (mNeedsRebuild) {
+        return;
+    }
+
+    if (mPopupState == ePopupState_Closed) {
+        mNeedsRebuild = true;
+        return;
+    }
+
+    nsContentUtils::AddScriptRunner(
+        new nsMenuContentRemovedEvent(this, aContainer, aChild));
+}
+
+/*
+ * Some menus (eg, the History menu in Firefox) refresh themselves on
+ * opening by removing all children and then re-adding new ones. As this
+ * happens whilst the menu is opening in Unity, it causes some flickering
+ * as the menu popup is resized multiple times. To avoid this, we try to
+ * reuse native menu items when the menu structure changes during a
+ * batched update. If we can handle menu structure changes from Gecko
+ * just by updating properties of native menu items (rather than destroying
+ * and creating new ones), then we eliminate any flickering that occurs as
+ * the menu is opened. To do this, we don't modify any native menu items
+ * until the end of the update batch.
+ */
+
+void
+nsMenu::OnBeginUpdates(nsIContent *aContent)
+{
+    MOZ_ASSERT(aContent == ContentNode() || aContent == mPopupContent,
+               "Received an event that wasn't meant for us!");
+    MOZ_ASSERT(!IsInBatchedUpdate(), "Already in an update batch!");
+
+    if (aContent != mPopupContent) {
+        return;
+    }
+
+    mBatchedUpdateState = eBatchedUpdateState_Active;
+}
+
+void
+nsMenu::OnEndUpdates()
+{
+    if (!IsInBatchedUpdate()) {
+        return;
+    }
+
+    bool didMutate = mBatchedUpdateState == eBatchedUpdateState_DidMutate;
+    mBatchedUpdateState = eBatchedUpdateState_Inactive;
+
+    /* Optimize for the case where we only had attribute changes */
+    if (!didMutate) {
+        return;
+    }
+
+    EnsureNoPlaceholderItem();
+
+    GList *nextNativeChild = dbusmenu_menuitem_get_children(GetNativeData());
+    DbusmenuMenuitem *nextOwnedNativeChild = nullptr;
+
+    size_t count = ChildCount();
+
+    // Find the first native menu item that is `owned` by a corresponding
+    // Gecko menuitem
+    for (size_t i = 0; i < count; ++i) {
+        if (ChildAt(i)->GetNativeData()) {
+            nextOwnedNativeChild = ChildAt(i)->GetNativeData();
+            break;
+        }
+    }
+
+    // Now iterate over all Gecko menuitems
+    for (size_t i = 0; i < count; ++i) {
+        nsMenuObject *child = ChildAt(i);
+
+        if (child->GetNativeData()) {
+            // This child already has a corresponding native menuitem.
+            // Remove all preceding orphaned native items. At this point, we
+            // modify the native menu structure.
+            while (nextNativeChild &&
+                   nextNativeChild->data != nextOwnedNativeChild) {
+
+                DbusmenuMenuitem *data =
+                    static_cast<DbusmenuMenuitem *>(nextNativeChild->data);
+                nextNativeChild = nextNativeChild->next;
+
+                MOZ_ALWAYS_TRUE(dbusmenu_menuitem_child_delete(GetNativeData(),
+                                                               data));
+            }
+
+            if (nextNativeChild) {
+                nextNativeChild = nextNativeChild->next;
+            }
+
+            // Now find the next native menu item that is `owned`
+            nextOwnedNativeChild = nullptr;
+            for (size_t j = i + 1; j < count; ++j) {
+                if (ChildAt(j)->GetNativeData()) {
+                    nextOwnedNativeChild = ChildAt(j)->GetNativeData();
+                    break;
+                }
+            }
+        } else {
+            // This child is new, and doesn't have a native menu item. Find one!
+            if (nextNativeChild &&
+                nextNativeChild->data != nextOwnedNativeChild) {
+
+                DbusmenuMenuitem *data =
+                    static_cast<DbusmenuMenuitem *>(nextNativeChild->data);
+
+                if (NS_SUCCEEDED(child->AdoptNativeData(data))) {
+                    nextNativeChild = nextNativeChild->next;
+                }
+            }
+
+            // There wasn't a suitable one available, so create a new one.
+            // At this point, we modify the native menu structure.
+            if (!child->GetNativeData()) {
+                child->CreateNativeData();
+                MOZ_ALWAYS_TRUE(
+                    dbusmenu_menuitem_child_add_position(GetNativeData(),
+                                                         child->GetNativeData(),
+                                                         i));
+            }
+        }
+    }
+
+    while (nextNativeChild) {
+        DbusmenuMenuitem *data =
+            static_cast<DbusmenuMenuitem *>(nextNativeChild->data);
+        nextNativeChild = nextNativeChild->next;
+
+        MOZ_ALWAYS_TRUE(dbusmenu_menuitem_child_delete(GetNativeData(), data));
+    }
+
+    MaybeAddPlaceholderItem();
+}
+
+nsMenu::nsMenu(nsMenuContainer *aParent, nsIContent *aContent) :
+    nsMenuContainer(aParent, aContent),
+    mNeedsRebuild(false),
+    mNeedsUpdate(false),
+    mPlaceholderItem(nullptr),
+    mPopupState(ePopupState_Closed),
+    mBatchedUpdateState(eBatchedUpdateState_Inactive)
+{
+    MOZ_COUNT_CTOR(nsMenu);
+}
+
+nsMenu::~nsMenu()
+{
+    if (IsInBatchedUpdate()) {
+        OnEndUpdates();
+    }
+
+    // Although nsTArray will take care of this in its destructor,
+    // we have to manually ensure children are removed from our native menu
+    // item, just in case our parent recycles us
+    while (ChildCount() > 0) {
+        RemoveChildAt(0);
+    }
+
+    EnsureNoPlaceholderItem();
+
+    if (DocListener() && mPopupContent) {
+        DocListener()->UnregisterForContentChanges(mPopupContent);
+    }
+
+    if (GetNativeData()) {
+        g_signal_handlers_disconnect_by_func(GetNativeData(),
+                                             FuncToGpointer(menu_event_cb),
+                                             this);
+    }
+
+    MOZ_COUNT_DTOR(nsMenu);
+}
+
+nsMenuObject::EType
+nsMenu::Type() const
+{
+    return eType_Menu;
+}
+
+bool
+nsMenu::IsBeingDisplayed() const
+{
+    return mPopupState == ePopupState_Open;
+}
+
+bool
+nsMenu::NeedsRebuild() const
+{
+    return mNeedsRebuild;
+}
+
+void
+nsMenu::OpenMenu()
+{
+    if (!CanOpen()) {
+        return;
+    }
+
+    if (mOpenDelayTimer) {
+        return;
+    }
+
+    // Here, we synchronously fire popupshowing and popupshown events and then
+    // open the menu after a short delay. This allows the menu to refresh before
+    // it's shown, and avoids an issue where keyboard focus is not on the first
+    // item of the history menu in Firefox when opening it with the keyboard,
+    // because extra items to appear at the top of the menu
+
+    OnOpen();
+
+    mOpenDelayTimer = NS_NewTimer();
+    if (!mOpenDelayTimer) {
+        return;
+    }
+
+    if (NS_FAILED(mOpenDelayTimer->InitWithNamedFuncCallback(DoOpenCallback,
+                                                             this,
+                                                             100,
+                                                             nsITimer::TYPE_ONE_SHOT,
+                                                             "nsMenu::DoOpenCallback"))) {
+        mOpenDelayTimer = nullptr;
+    }
+}
+
+void
+nsMenu::OnClose()
+{
+    if (mPopupState == ePopupState_Closed) {
+        return;
+    }
+
+    MOZ_ASSERT(nsContentUtils::IsSafeToRunScript());
+
+    // We do this to avoid mutating our view of the menu until
+    // after we have finished
+    nsNativeMenuDocListener::BlockUpdatesScope updatesBlocker;
+
+    SetPopupState(ePopupState_Hiding);
+    DispatchMouseEvent(mPopupContent, eXULPopupHiding);
+
+    // Sigh, make sure all of our descendants are closed, as we don't
+    // always get closed events for submenus when scrubbing quickly through
+    // the menu
+    size_t count = ChildCount();
+    for (size_t i = 0; i < count; ++i) {
+        if (ChildAt(i)->Type() == nsMenuObject::eType_Menu) {
+            static_cast<nsMenu *>(ChildAt(i))->OnClose();
+        }
+    }
+
+    SetPopupState(ePopupState_Closed);
+    DispatchMouseEvent(mPopupContent, eXULPopupHidden);
+
+    ContentNode()->AsElement()->UnsetAttr(kNameSpaceID_None, nsGkAtoms::open,
+                                          true);
+}
+
diff --git a/widget/gtk/nsMenu.h b/widget/gtk/nsMenu.h
new file mode 100644
index 0000000000..07a8068ea8
--- /dev/null
+++ b/widget/gtk/nsMenu.h
@@ -0,0 +1,123 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenu_h__
+#define __nsMenu_h__
+
+#include "mozilla/Attributes.h"
+#include "mozilla/UniquePtr.h"
+#include "nsCOMPtr.h"
+
+#include "nsDbusmenu.h"
+#include "nsMenuContainer.h"
+#include "nsMenuObject.h"
+
+#include <glib.h>
+
+class nsAtom;
+class nsIContent;
+class nsITimer;
+
+#define NSMENU_NUMBER_OF_POPUPSTATE_BITS 2U
+#define NSMENU_NUMBER_OF_FLAGS           4U
+
+// This class represents a menu
+class nsMenu final : public nsMenuContainer
+{
+public:
+    nsMenu(nsMenuContainer *aParent, nsIContent *aContent);
+    ~nsMenu();
+
+    nsMenuObject::EType Type() const override;
+
+    bool IsBeingDisplayed() const override;
+    bool NeedsRebuild() const override;
+
+    // Tell the desktop shell to display this menu
+    void OpenMenu();
+
+    // Normally called via the shell, but it's public so that child
+    // menuitems can do the shells work. Sigh....
+    void OnClose();
+
+private:
+    friend class nsMenuContentInsertedEvent;
+    friend class nsMenuContentRemovedEvent;
+
+    enum EPopupState {
+        ePopupState_Closed,
+        ePopupState_Showing,
+        ePopupState_Open,
+        ePopupState_Hiding
+    };
+
+    void SetPopupState(EPopupState aState);
+
+    static void DoOpenCallback(nsITimer *aTimer, void *aClosure);
+    static void menu_event_cb(DbusmenuMenuitem *menu,
+                              const gchar *name,
+                              GVariant *value,
+                              guint timestamp,
+                              gpointer user_data);
+
+    // We add a placeholder item to empty menus so that Unity actually treats
+    // us as a proper menu, rather than a menuitem without a submenu
+    void MaybeAddPlaceholderItem();
+
+    // Removes a placeholder item if it exists and asserts that this succeeds
+    void EnsureNoPlaceholderItem();
+
+    void OnOpen();
+    void Build();
+    void InitializePopup();
+    void RemoveChildAt(size_t aIndex);
+    void RemoveChild(nsIContent *aChild);
+    void InsertChildAfter(mozilla::UniquePtr<nsMenuObject> aChild,
+                          nsIContent *aPrevSibling);
+    void AppendChild(mozilla::UniquePtr<nsMenuObject> aChild);
+    bool IsInBatchedUpdate() const;
+    void StructureMutated();
+    bool CanOpen() const;
+
+    void HandleContentInserted(nsIContent *aContainer,
+                               nsIContent *aChild,
+                               nsIContent *aPrevSibling);
+    void HandleContentRemoved(nsIContent *aContainer,
+                              nsIContent *aChild);
+
+    void InitializeNativeData() override;
+    void Update(mozilla::ComputedStyle *aComputedStyle) override;
+    nsMenuObject::PropertyFlags SupportedProperties() const override;
+
+    void OnAttributeChanged(nsIContent *aContent, nsAtom *aAttribute) override;
+    void OnContentInserted(nsIContent *aContainer, nsIContent *aChild,
+                           nsIContent *aPrevSibling) override;
+    void OnContentRemoved(nsIContent *aContainer, nsIContent *aChild) override;
+    void OnBeginUpdates(nsIContent *aContent) override;
+    void OnEndUpdates() override;
+
+    bool mNeedsRebuild;
+    bool mNeedsUpdate;
+
+    DbusmenuMenuitem *mPlaceholderItem;
+
+    EPopupState mPopupState;
+
+    enum EBatchedUpdateState {
+        eBatchedUpdateState_Inactive,
+        eBatchedUpdateState_Active,
+        eBatchedUpdateState_DidMutate
+    };
+
+    EBatchedUpdateState mBatchedUpdateState;
+
+    nsCOMPtr<nsIContent> mPopupContent;
+
+    nsCOMPtr<nsITimer> mOpenDelayTimer;
+};
+
+#endif /* __nsMenu_h__ */
diff --git a/widget/gtk/nsMenuBar.cpp b/widget/gtk/nsMenuBar.cpp
new file mode 100644
index 0000000000..0dcae67943
--- /dev/null
+++ b/widget/gtk/nsMenuBar.cpp
@@ -0,0 +1,548 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/Assertions.h"
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/Document.h"
+#include "mozilla/dom/Element.h"
+#include "mozilla/dom/Event.h"
+#include "mozilla/dom/KeyboardEvent.h"
+#include "mozilla/dom/KeyboardEventBinding.h"
+#include "mozilla/Preferences.h"
+#include "nsContentUtils.h"
+#include "nsIDOMEventListener.h"
+#include "nsIRunnable.h"
+#include "nsIWidget.h"
+#include "nsTArray.h"
+#include "nsUnicharUtils.h"
+
+#include "nsMenu.h"
+#include "nsNativeMenuService.h"
+
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#include <glib.h>
+#include <glib-object.h>
+
+#include "nsMenuBar.h"
+
+using namespace mozilla;
+
+static bool
+ShouldHandleKeyEvent(dom::KeyboardEvent *aEvent)
+{
+    return !aEvent->DefaultPrevented() && aEvent->IsTrusted();
+}
+
+class nsMenuBarContentInsertedEvent : public Runnable
+{
+public:
+    nsMenuBarContentInsertedEvent(nsMenuBar *aMenuBar,
+                                  nsIContent *aChild,
+                                  nsIContent *aPrevSibling) :
+        Runnable("nsMenuBarContentInsertedEvent"),
+        mWeakMenuBar(aMenuBar),
+        mChild(aChild),
+        mPrevSibling(aPrevSibling) { }
+
+    NS_IMETHODIMP Run()
+    {
+        if (!mWeakMenuBar) {
+            return NS_OK;
+        }
+
+        static_cast<nsMenuBar *>(mWeakMenuBar.get())->HandleContentInserted(mChild,
+                                                                            mPrevSibling);
+        return NS_OK;
+    }
+
+private:
+    nsWeakMenuObject mWeakMenuBar;
+
+    nsCOMPtr<nsIContent> mChild;
+    nsCOMPtr<nsIContent> mPrevSibling;
+};
+
+class nsMenuBarContentRemovedEvent : public Runnable
+{
+public:
+    nsMenuBarContentRemovedEvent(nsMenuBar *aMenuBar,
+                                 nsIContent *aChild) :
+        Runnable("nsMenuBarContentRemovedEvent"),
+        mWeakMenuBar(aMenuBar),
+        mChild(aChild) { }
+
+    NS_IMETHODIMP Run()
+    {
+        if (!mWeakMenuBar) {
+            return NS_OK;
+        }
+
+        static_cast<nsMenuBar *>(mWeakMenuBar.get())->HandleContentRemoved(mChild);
+        return NS_OK;
+    }
+
+private:
+    nsWeakMenuObject mWeakMenuBar;
+
+    nsCOMPtr<nsIContent> mChild;
+};
+
+class nsMenuBar::DocEventListener final : public nsIDOMEventListener
+{
+public:
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIDOMEVENTLISTENER
+
+    DocEventListener(nsMenuBar *aOwner) : mOwner(aOwner) { };
+
+private:
+    ~DocEventListener() { };
+
+    nsMenuBar *mOwner;
+};
+
+NS_IMPL_ISUPPORTS(nsMenuBar::DocEventListener, nsIDOMEventListener)
+
+NS_IMETHODIMP
+nsMenuBar::DocEventListener::HandleEvent(dom::Event *aEvent)
+{
+    nsAutoString type;
+    aEvent->GetType(type);
+
+    if (type.Equals(u"focus"_ns)) {
+        mOwner->Focus();
+    } else if (type.Equals(u"blur"_ns)) {
+        mOwner->Blur();
+    }
+
+    RefPtr<dom::KeyboardEvent> keyEvent = aEvent->AsKeyboardEvent();
+    if (!keyEvent) {
+        return NS_OK;
+    }
+
+    if (type.Equals(u"keypress"_ns)) {
+        return mOwner->Keypress(keyEvent);
+    } else if (type.Equals(u"keydown"_ns)) {
+        return mOwner->KeyDown(keyEvent);
+    } else if (type.Equals(u"keyup"_ns)) {
+        return mOwner->KeyUp(keyEvent);
+    }
+
+    return NS_OK;
+}
+
+nsMenuBar::nsMenuBar(nsIContent *aMenuBarNode) :
+    nsMenuContainer(new nsNativeMenuDocListener(aMenuBarNode), aMenuBarNode),
+    mTopLevel(nullptr),
+    mServer(nullptr),
+    mIsActive(false)
+{
+    MOZ_COUNT_CTOR(nsMenuBar);
+}
+
+nsresult
+nsMenuBar::Init(nsIWidget *aParent)
+{
+    MOZ_ASSERT(aParent);
+
+    GdkWindow *gdkWin = static_cast<GdkWindow *>(
+        aParent->GetNativeData(NS_NATIVE_WINDOW));
+    if (!gdkWin) {
+        return NS_ERROR_FAILURE;
+    }
+
+    gpointer user_data = nullptr;
+    gdk_window_get_user_data(gdkWin, &user_data);
+    if (!user_data || !GTK_IS_CONTAINER(user_data)) {
+        return NS_ERROR_FAILURE;
+    }
+
+    mTopLevel = gtk_widget_get_toplevel(GTK_WIDGET(user_data));
+    if (!mTopLevel) {
+        return NS_ERROR_FAILURE;
+    }
+
+    g_object_ref(mTopLevel);
+
+    nsAutoCString path;
+    path.Append("/com/canonical/menu/"_ns);
+    char xid[10];
+    sprintf(xid, "%X", static_cast<uint32_t>(
+        GDK_WINDOW_XID(gtk_widget_get_window(mTopLevel))));
+    path.Append(xid);
+
+    mServer = dbusmenu_server_new(path.get());
+    if (!mServer) {
+        return NS_ERROR_FAILURE;
+    }
+
+    CreateNativeData();
+    if (!GetNativeData()) {
+        return NS_ERROR_FAILURE;
+    }
+
+    dbusmenu_server_set_root(mServer, GetNativeData());
+
+    mEventListener = new DocEventListener(this);
+
+    mDocument = do_QueryInterface(ContentNode()->OwnerDoc());
+
+    mAccessKey = Preferences::GetInt("ui.key.menuAccessKey");
+    if (mAccessKey == dom::KeyboardEvent_Binding::DOM_VK_SHIFT) {
+        mAccessKeyMask = eModifierShift;
+    } else if (mAccessKey == dom::KeyboardEvent_Binding::DOM_VK_CONTROL) {
+        mAccessKeyMask = eModifierCtrl;
+    } else if (mAccessKey == dom::KeyboardEvent_Binding::DOM_VK_ALT) {
+        mAccessKeyMask = eModifierAlt;
+    } else if (mAccessKey == dom::KeyboardEvent_Binding::DOM_VK_META) {
+        mAccessKeyMask = eModifierMeta;
+    } else {
+        mAccessKeyMask = eModifierAlt;
+    }
+
+    return NS_OK;
+}
+
+void
+nsMenuBar::Build()
+{
+    uint32_t count = ContentNode()->GetChildCount();
+    for (uint32_t i = 0; i < count; ++i) {
+        nsIContent *childContent = ContentNode()->GetChildAt_Deprecated(i);
+
+        UniquePtr<nsMenuObject> child = CreateChild(childContent);
+
+        if (!child) {
+            continue;
+        }
+
+        AppendChild(std::move(child));
+    }
+}
+
+void
+nsMenuBar::DisconnectDocumentEventListeners()
+{
+    mDocument->RemoveEventListener(u"focus"_ns,
+                                   mEventListener,
+                                   true);
+    mDocument->RemoveEventListener(u"blur"_ns,
+                                   mEventListener,
+                                   true);
+    mDocument->RemoveEventListener(u"keypress"_ns,
+                                   mEventListener,
+                                   false);
+    mDocument->RemoveEventListener(u"keydown"_ns,
+                                   mEventListener,
+                                   false);
+    mDocument->RemoveEventListener(u"keyup"_ns,
+                                   mEventListener,
+                                   false);
+}
+
+void
+nsMenuBar::SetShellShowingMenuBar(bool aShowing)
+{
+    ContentNode()->OwnerDoc()->GetRootElement()->SetAttr(
+        kNameSpaceID_None, nsGkAtoms::shellshowingmenubar,
+        aShowing ? u"true"_ns : u"false"_ns,
+        true);
+}
+
+void
+nsMenuBar::Focus()
+{
+    ContentNode()->AsElement()->SetAttr(kNameSpaceID_None,
+                                        nsGkAtoms::openedwithkey,
+                                        u"false"_ns, true);
+}
+
+void
+nsMenuBar::Blur()
+{
+    // We do this here in case we lose focus before getting the
+    // keyup event, which leaves the menubar state looking like
+    // the alt key is stuck down
+    dbusmenu_server_set_status(mServer, DBUSMENU_STATUS_NORMAL);
+}
+
+nsMenuBar::ModifierFlags
+nsMenuBar::GetModifiersFromEvent(dom::KeyboardEvent *aEvent)
+{
+    ModifierFlags modifiers = static_cast<ModifierFlags>(0);
+
+    if (aEvent->AltKey()) {
+        modifiers = static_cast<ModifierFlags>(modifiers | eModifierAlt);
+    }
+
+    if (aEvent->ShiftKey()) {
+        modifiers = static_cast<ModifierFlags>(modifiers | eModifierShift);
+    }
+
+    if (aEvent->CtrlKey()) {
+        modifiers = static_cast<ModifierFlags>(modifiers | eModifierCtrl);
+    }
+
+    if (aEvent->MetaKey()) {
+        modifiers = static_cast<ModifierFlags>(modifiers | eModifierMeta);
+    }
+
+    return modifiers;
+}
+
+nsresult
+nsMenuBar::Keypress(dom::KeyboardEvent *aEvent)
+{
+    if (!ShouldHandleKeyEvent(aEvent)) {
+        return NS_OK;
+    }
+
+    ModifierFlags modifiers = GetModifiersFromEvent(aEvent);
+    if (((modifiers & mAccessKeyMask) == 0) ||
+        ((modifiers & ~mAccessKeyMask) != 0)) {
+        return NS_OK;
+    }
+
+    uint32_t charCode = aEvent->CharCode();
+    if (charCode == 0) {
+        return NS_OK;
+    }
+
+    char16_t ch = char16_t(charCode);
+    char16_t chl = ToLowerCase(ch);
+    char16_t chu = ToUpperCase(ch);
+
+    nsMenuObject *found = nullptr;
+    uint32_t count = ChildCount();
+    for (uint32_t i = 0; i < count; ++i) {
+        nsAutoString accesskey;
+        ChildAt(i)->ContentNode()->AsElement()->GetAttr(kNameSpaceID_None,
+                                                        nsGkAtoms::accesskey,
+                                                        accesskey);
+        const nsAutoString::char_type *key = accesskey.BeginReading();
+        if (*key == chu || *key == chl) {
+            found = ChildAt(i);
+            break;
+        }
+    }
+
+    if (!found || found->Type() != nsMenuObject::eType_Menu) {
+        return NS_OK;
+    }
+
+    ContentNode()->AsElement()->SetAttr(kNameSpaceID_None,
+                                        nsGkAtoms::openedwithkey,
+                                        u"true"_ns, true);
+    static_cast<nsMenu *>(found)->OpenMenu();
+
+    aEvent->StopPropagation();
+    aEvent->PreventDefault();
+
+    return NS_OK;
+}
+
+nsresult
+nsMenuBar::KeyDown(dom::KeyboardEvent *aEvent)
+{
+    if (!ShouldHandleKeyEvent(aEvent)) {
+        return NS_OK;
+    }
+
+    uint32_t keyCode = aEvent->KeyCode();
+    ModifierFlags modifiers = GetModifiersFromEvent(aEvent);
+    if ((keyCode != mAccessKey) || ((modifiers & ~mAccessKeyMask) != 0)) {
+        return NS_OK;
+    }
+
+    dbusmenu_server_set_status(mServer, DBUSMENU_STATUS_NOTICE);
+
+    return NS_OK;
+}
+
+nsresult
+nsMenuBar::KeyUp(dom::KeyboardEvent *aEvent)
+{
+    if (!ShouldHandleKeyEvent(aEvent)) {
+        return NS_OK;
+    }
+
+    uint32_t keyCode = aEvent->KeyCode();
+    if (keyCode == mAccessKey) {
+        dbusmenu_server_set_status(mServer, DBUSMENU_STATUS_NORMAL);
+    }
+
+    return NS_OK;
+}
+
+void
+nsMenuBar::HandleContentInserted(nsIContent *aChild, nsIContent *aPrevSibling)
+{
+    UniquePtr<nsMenuObject> child = CreateChild(aChild);
+
+    if (!child) {
+        return;
+    }
+
+    InsertChildAfter(std::move(child), aPrevSibling);
+}
+
+void
+nsMenuBar::HandleContentRemoved(nsIContent *aChild)
+{
+    RemoveChild(aChild);
+}
+
+void
+nsMenuBar::OnContentInserted(nsIContent *aContainer, nsIContent *aChild,
+                             nsIContent *aPrevSibling)
+{
+    MOZ_ASSERT(aContainer == ContentNode(),
+               "Received an event that wasn't meant for us");
+
+    nsContentUtils::AddScriptRunner(
+        new nsMenuBarContentInsertedEvent(this, aChild, aPrevSibling));
+}
+
+void
+nsMenuBar::OnContentRemoved(nsIContent *aContainer, nsIContent *aChild)
+{
+    MOZ_ASSERT(aContainer == ContentNode(),
+               "Received an event that wasn't meant for us");
+
+    nsContentUtils::AddScriptRunner(
+        new nsMenuBarContentRemovedEvent(this, aChild));
+}
+
+nsMenuBar::~nsMenuBar()
+{
+    nsNativeMenuService *service = nsNativeMenuService::GetSingleton();
+    if (service) {
+        service->NotifyNativeMenuBarDestroyed(this);
+    }
+
+    if (ContentNode()) {
+        SetShellShowingMenuBar(false);
+    }
+
+    // We want to destroy all children before dropping our reference
+    // to the doc listener
+    while (ChildCount() > 0) {
+        RemoveChildAt(0);
+    }
+
+    if (mTopLevel) {
+        g_object_unref(mTopLevel);
+    }
+
+    if (DocListener()) {
+        DocListener()->Stop();
+    }
+
+    if (mDocument) {
+        DisconnectDocumentEventListeners();
+    }
+
+    if (mServer) {
+        g_object_unref(mServer);
+    }
+
+    MOZ_COUNT_DTOR(nsMenuBar);
+}
+
+/* static */ UniquePtr<nsMenuBar>
+nsMenuBar::Create(nsIWidget *aParent, nsIContent *aMenuBarNode)
+{
+    UniquePtr<nsMenuBar> menubar(new nsMenuBar(aMenuBarNode));
+    if (NS_FAILED(menubar->Init(aParent))) {
+        return nullptr;
+    }
+
+    return menubar;
+}
+
+nsMenuObject::EType
+nsMenuBar::Type() const
+{
+    return eType_MenuBar;
+}
+
+bool
+nsMenuBar::IsBeingDisplayed() const
+{
+    return true;
+}
+
+uint32_t
+nsMenuBar::WindowId() const
+{
+    return static_cast<uint32_t>(GDK_WINDOW_XID(gtk_widget_get_window(mTopLevel)));
+}
+
+nsCString
+nsMenuBar::ObjectPath() const
+{
+    gchar *tmp;
+    g_object_get(mServer, DBUSMENU_SERVER_PROP_DBUS_OBJECT, &tmp, NULL);
+
+    nsCString result;
+    result.Adopt(tmp);
+
+    return result;
+}
+
+void
+nsMenuBar::Activate()
+{
+    if (mIsActive) {
+        return;
+    }
+
+    mIsActive = true;
+
+    mDocument->AddEventListener(u"focus"_ns,
+                                mEventListener,
+                                true);
+    mDocument->AddEventListener(u"blur"_ns,
+                                mEventListener,
+                                true);
+    mDocument->AddEventListener(u"keypress"_ns,
+                                mEventListener,
+                                false);
+    mDocument->AddEventListener(u"keydown"_ns,
+                                mEventListener,
+                                false);
+    mDocument->AddEventListener(u"keyup"_ns,
+                                mEventListener,
+                                false);
+
+    // Clear this. Not sure if we really need to though
+    ContentNode()->AsElement()->SetAttr(kNameSpaceID_None,
+                                        nsGkAtoms::openedwithkey,
+                                        u"false"_ns, true);
+
+    DocListener()->Start();
+    Build();
+    SetShellShowingMenuBar(true);
+}
+
+void
+nsMenuBar::Deactivate()
+{
+    if (!mIsActive) {
+        return;
+    }
+
+    mIsActive = false;
+
+    SetShellShowingMenuBar(false);
+    while (ChildCount() > 0) {
+        RemoveChildAt(0);
+    }
+    DocListener()->Stop();
+    DisconnectDocumentEventListeners();
+}
diff --git a/widget/gtk/nsMenuBar.h b/widget/gtk/nsMenuBar.h
new file mode 100644
index 0000000000..7a04316330
--- /dev/null
+++ b/widget/gtk/nsMenuBar.h
@@ -0,0 +1,111 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenuBar_h__
+#define __nsMenuBar_h__
+
+#include "mozilla/Attributes.h"
+#include "mozilla/UniquePtr.h"
+#include "nsCOMPtr.h"
+#include "nsString.h"
+
+#include "nsDbusmenu.h"
+#include "nsMenuContainer.h"
+#include "nsMenuObject.h"
+
+#include <gtk/gtk.h>
+
+class nsIContent;
+class nsIWidget;
+class nsMenuBarDocEventListener;
+
+namespace mozilla {
+namespace dom {
+class Document;
+class KeyboardEvent;
+}
+}
+
+/*
+ * The menubar class. There is one of these per window (and the window
+ * owns its menubar). Each menubar has an object path, and the service is
+ * responsible for telling the desktop shell which object path corresponds
+ * to a particular window. A menubar and its hierarchy also own a
+ * nsNativeMenuDocListener.
+ */
+class nsMenuBar final : public nsMenuContainer
+{
+public:
+    ~nsMenuBar() override;
+
+    static mozilla::UniquePtr<nsMenuBar> Create(nsIWidget *aParent,
+                                                nsIContent *aMenuBarNode);
+
+    nsMenuObject::EType Type() const override;
+
+    bool IsBeingDisplayed() const override;
+
+    // Get the native window ID for this menubar
+    uint32_t WindowId() const;
+
+    // Get the object path for this menubar
+    nsCString ObjectPath() const;
+
+    // Get the top-level GtkWindow handle
+    GtkWidget* TopLevelWindow() { return mTopLevel; }
+
+    // Called from the menuservice when the menubar is about to be registered.
+    // Causes the native menubar to be created, and the XUL menubar to be hidden
+    void Activate();
+
+    // Called from the menuservice when the menubar is no longer registered
+    // with the desktop shell. Will cause the XUL menubar to be shown again
+    void Deactivate();
+
+private:
+    class DocEventListener;
+    friend class nsMenuBarContentInsertedEvent;
+    friend class nsMenuBarContentRemovedEvent;
+
+    enum ModifierFlags {
+        eModifierShift = (1 << 0),
+        eModifierCtrl = (1 << 1),
+        eModifierAlt = (1 << 2),
+        eModifierMeta = (1 << 3)
+    };
+
+    nsMenuBar(nsIContent *aMenuBarNode);
+    nsresult Init(nsIWidget *aParent);
+    void Build();
+    void DisconnectDocumentEventListeners();
+    void SetShellShowingMenuBar(bool aShowing);
+    void Focus();
+    void Blur();
+    ModifierFlags GetModifiersFromEvent(mozilla::dom::KeyboardEvent *aEvent);
+    nsresult Keypress(mozilla::dom::KeyboardEvent *aEvent);
+    nsresult KeyDown(mozilla::dom::KeyboardEvent *aEvent);
+    nsresult KeyUp(mozilla::dom::KeyboardEvent *aEvent);
+
+    void HandleContentInserted(nsIContent *aChild,
+                               nsIContent *aPrevSibling);
+    void HandleContentRemoved(nsIContent *aChild);
+
+    void OnContentInserted(nsIContent *aContainer, nsIContent *aChild,
+                           nsIContent *aPrevSibling) override;
+    void OnContentRemoved(nsIContent *aContainer, nsIContent *aChild) override;
+
+    GtkWidget *mTopLevel;
+    DbusmenuServer *mServer;
+    nsCOMPtr<mozilla::dom::Document> mDocument;
+    RefPtr<DocEventListener> mEventListener;
+
+    uint32_t mAccessKey;
+    ModifierFlags mAccessKeyMask;
+    bool mIsActive;
+};
+
+#endif /* __nsMenuBar_h__ */
diff --git a/widget/gtk/nsMenuContainer.cpp b/widget/gtk/nsMenuContainer.cpp
new file mode 100644
index 0000000000..f419201f63
--- /dev/null
+++ b/widget/gtk/nsMenuContainer.cpp
@@ -0,0 +1,170 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/DebugOnly.h"
+#include "nsGkAtoms.h"
+#include "nsIContent.h"
+
+#include "nsDbusmenu.h"
+#include "nsMenu.h"
+#include "nsMenuItem.h"
+#include "nsMenuSeparator.h"
+
+#include "nsMenuContainer.h"
+
+using namespace mozilla;
+
+const nsMenuContainer::ChildTArray::index_type nsMenuContainer::NoIndex = nsMenuContainer::ChildTArray::NoIndex;
+
+typedef UniquePtr<nsMenuObject> (*nsMenuObjectConstructor)(nsMenuContainer*,
+                                                           nsIContent*);
+
+template<class T>
+static UniquePtr<nsMenuObject> CreateMenuObject(nsMenuContainer *aContainer,
+                                                nsIContent *aContent)
+{
+    return UniquePtr<T>(new T(aContainer, aContent));
+}
+
+static nsMenuObjectConstructor
+GetMenuObjectConstructor(nsIContent *aContent)
+{
+    if (aContent->IsXULElement(nsGkAtoms::menuitem)) {
+        return CreateMenuObject<nsMenuItem>;
+    } else if (aContent->IsXULElement(nsGkAtoms::menu)) {
+        return CreateMenuObject<nsMenu>;
+    } else if (aContent->IsXULElement(nsGkAtoms::menuseparator)) {
+        return CreateMenuObject<nsMenuSeparator>;
+    }
+
+    return nullptr;
+}
+
+static bool
+ContentIsSupported(nsIContent *aContent)
+{
+    return GetMenuObjectConstructor(aContent) ? true : false;
+}
+
+nsMenuContainer::nsMenuContainer(nsMenuContainer *aParent,
+                                 nsIContent *aContent) :
+    nsMenuObject(aParent, aContent)
+{
+}
+
+nsMenuContainer::nsMenuContainer(nsNativeMenuDocListener *aListener,
+                                 nsIContent *aContent) :
+    nsMenuObject(aListener, aContent)
+{
+}
+
+UniquePtr<nsMenuObject>
+nsMenuContainer::CreateChild(nsIContent *aContent)
+{
+    nsMenuObjectConstructor ctor = GetMenuObjectConstructor(aContent);
+    if (!ctor) {
+        // There are plenty of node types we might stumble across that
+        // aren't supported
+        return nullptr;
+    }
+
+    UniquePtr<nsMenuObject> res = ctor(this, aContent);
+    return res;
+}
+
+size_t
+nsMenuContainer::IndexOf(nsIContent *aChild) const
+{
+    if (!aChild) {
+        return NoIndex;
+    }
+
+    size_t count = ChildCount();
+    for (size_t i = 0; i < count; ++i) {
+        if (ChildAt(i)->ContentNode() == aChild) {
+            return i;
+        }
+    }
+
+    return NoIndex;
+}
+
+void
+nsMenuContainer::RemoveChildAt(size_t aIndex, bool aUpdateNative)
+{
+    MOZ_ASSERT(aIndex < ChildCount());
+
+    if (aUpdateNative) {
+        MOZ_ALWAYS_TRUE(
+            dbusmenu_menuitem_child_delete(GetNativeData(),
+                                           ChildAt(aIndex)->GetNativeData()));
+    }
+
+    mChildren.RemoveElementAt(aIndex);
+}
+
+void
+nsMenuContainer::RemoveChild(nsIContent *aChild, bool aUpdateNative)
+{
+    size_t index = IndexOf(aChild);
+    if (index == NoIndex) {
+        return;
+    }
+
+    RemoveChildAt(index, aUpdateNative);
+}
+
+void
+nsMenuContainer::InsertChildAfter(UniquePtr<nsMenuObject> aChild,
+                                  nsIContent *aPrevSibling,
+                                  bool aUpdateNative)
+{
+    size_t index = IndexOf(aPrevSibling);
+    MOZ_ASSERT(!aPrevSibling || index != NoIndex);
+
+    ++index;
+
+    if (aUpdateNative) {
+        aChild->CreateNativeData();
+        MOZ_ALWAYS_TRUE(
+            dbusmenu_menuitem_child_add_position(GetNativeData(),
+                                                 aChild->GetNativeData(),
+                                                 index));
+    }
+
+    mChildren.InsertElementAt(index, std::move(aChild));
+}
+
+void
+nsMenuContainer::AppendChild(UniquePtr<nsMenuObject> aChild,
+                             bool aUpdateNative)
+{
+    if (aUpdateNative) {
+        aChild->CreateNativeData();
+        MOZ_ALWAYS_TRUE(
+            dbusmenu_menuitem_child_append(GetNativeData(),
+                                           aChild->GetNativeData()));
+    }
+
+    mChildren.AppendElement(std::move(aChild));
+}
+
+bool
+nsMenuContainer::NeedsRebuild() const
+{
+    return false;
+}
+
+/* static */ nsIContent*
+nsMenuContainer::GetPreviousSupportedSibling(nsIContent *aContent)
+{
+    do {
+        aContent = aContent->GetPreviousSibling();
+    } while (aContent && !ContentIsSupported(aContent));
+
+    return aContent;
+}
diff --git a/widget/gtk/nsMenuContainer.h b/widget/gtk/nsMenuContainer.h
new file mode 100644
index 0000000000..b7e8fa8db4
--- /dev/null
+++ b/widget/gtk/nsMenuContainer.h
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenuContainer_h__
+#define __nsMenuContainer_h__
+
+#include "mozilla/UniquePtr.h"
+#include "nsTArray.h"
+
+#include "nsMenuObject.h"
+
+class nsIContent;
+class nsNativeMenuDocListener;
+
+// Base class for containers (menus and menubars)
+class nsMenuContainer : public nsMenuObject
+{
+public:
+    typedef nsTArray<mozilla::UniquePtr<nsMenuObject> > ChildTArray;
+
+    // Determine if this container is being displayed on screen. Must be
+    // implemented by subclasses. Must return true if the container is
+    // in the fully open state, or false otherwise
+    virtual bool IsBeingDisplayed() const = 0;
+
+    // Determine if this container will be rebuilt the next time it opens.
+    // Returns false by default but can be overridden by subclasses
+    virtual bool NeedsRebuild() const;
+
+    // Return the first previous sibling that is of a type supported by the
+    // menu system
+    static nsIContent* GetPreviousSupportedSibling(nsIContent *aContent);
+
+    static const ChildTArray::index_type NoIndex;
+
+protected:
+    nsMenuContainer(nsMenuContainer *aParent, nsIContent *aContent);
+    nsMenuContainer(nsNativeMenuDocListener *aListener, nsIContent *aContent);
+
+    // Create a new child element for the specified content node
+    mozilla::UniquePtr<nsMenuObject> CreateChild(nsIContent *aContent);
+
+    // Return the index of the child for the specified content node
+    size_t IndexOf(nsIContent *aChild) const;
+
+    size_t ChildCount() const { return mChildren.Length(); }
+    nsMenuObject* ChildAt(size_t aIndex) const { return mChildren[aIndex].get(); }
+
+    void RemoveChildAt(size_t aIndex, bool aUpdateNative = true);
+
+    // Remove the child that owns the specified content node
+    void RemoveChild(nsIContent *aChild, bool aUpdateNative = true);
+
+    // Insert a new child after the child that owns the specified content node
+    void InsertChildAfter(mozilla::UniquePtr<nsMenuObject> aChild,
+                          nsIContent *aPrevSibling,
+                          bool aUpdateNative = true);
+
+    void AppendChild(mozilla::UniquePtr<nsMenuObject> aChild,
+                     bool aUpdateNative = true);
+
+private:
+    ChildTArray mChildren;
+};
+
+#endif /* __nsMenuContainer_h__ */
diff --git a/widget/gtk/nsMenuItem.cpp b/widget/gtk/nsMenuItem.cpp
new file mode 100644
index 0000000000..41bed9c165
--- /dev/null
+++ b/widget/gtk/nsMenuItem.cpp
@@ -0,0 +1,766 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/Assertions.h"
+#include "mozilla/dom/Document.h"
+#include "mozilla/dom/Element.h"
+#include "mozilla/dom/KeyboardEventBinding.h"
+#include "mozilla/dom/XULCommandEvent.h"
+#include "mozilla/Preferences.h"
+#include "mozilla/TextEvents.h"
+#include "nsContentUtils.h"
+#include "nsCRT.h"
+#include "nsGkAtoms.h"
+#include "nsGlobalWindowInner.h"
+#include "nsGtkUtils.h"
+#include "nsIContent.h"
+#include "nsIRunnable.h"
+#include "nsQueryObject.h"
+#include "nsReadableUtils.h"
+#include "nsString.h"
+#include "nsThreadUtils.h"
+
+#include "nsMenu.h"
+#include "nsMenuBar.h"
+#include "nsMenuContainer.h"
+#include "nsNativeMenuDocListener.h"
+
+#include <gdk/gdk.h>
+#include <gdk/gdkkeysyms.h>
+#include <gdk/gdkkeysyms-compat.h>
+#include <gdk/gdkx.h>
+#include <gtk/gtk.h>
+
+#include "nsMenuItem.h"
+
+using namespace mozilla;
+
+struct KeyCodeData {
+    const char* str;
+    size_t strlength;
+    uint32_t keycode;
+};
+
+static struct KeyCodeData gKeyCodes[] = {
+#define NS_DEFINE_VK(aDOMKeyName, aDOMKeyCode) \
+  { #aDOMKeyName, sizeof(#aDOMKeyName) - 1, aDOMKeyCode },
+#include "mozilla/VirtualKeyCodeList.h"
+#undef NS_DEFINE_VK
+  { nullptr, 0, 0 }
+};
+
+struct KeyPair {
+    uint32_t DOMKeyCode;
+    guint GDKKeyval;
+};
+
+//
+// Netscape keycodes are defined in widget/public/nsGUIEvent.h
+// GTK keycodes are defined in <gdk/gdkkeysyms.h>
+//
+static const KeyPair gKeyPairs[] = {
+    { NS_VK_CANCEL,     GDK_Cancel },
+    { NS_VK_BACK,       GDK_BackSpace },
+    { NS_VK_TAB,        GDK_Tab },
+    { NS_VK_TAB,        GDK_ISO_Left_Tab },
+    { NS_VK_CLEAR,      GDK_Clear },
+    { NS_VK_RETURN,     GDK_Return },
+    { NS_VK_SHIFT,      GDK_Shift_L },
+    { NS_VK_SHIFT,      GDK_Shift_R },
+    { NS_VK_SHIFT,      GDK_Shift_Lock },
+    { NS_VK_CONTROL,    GDK_Control_L },
+    { NS_VK_CONTROL,    GDK_Control_R },
+    { NS_VK_ALT,        GDK_Alt_L },
+    { NS_VK_ALT,        GDK_Alt_R },
+    { NS_VK_META,       GDK_Meta_L },
+    { NS_VK_META,       GDK_Meta_R },
+
+    // Assume that Super or Hyper is always mapped to physical Win key.
+    { NS_VK_WIN,        GDK_Super_L },
+    { NS_VK_WIN,        GDK_Super_R },
+    { NS_VK_WIN,        GDK_Hyper_L },
+    { NS_VK_WIN,        GDK_Hyper_R },
+
+    // GTK's AltGraph key is similar to Mac's Option (Alt) key.  However,
+    // unfortunately, browsers on Mac are using NS_VK_ALT for it even though
+    // it's really different from Alt key on Windows.
+    // On the other hand, GTK's AltGrapsh keys are really different from
+    // Alt key.  However, there is no AltGrapsh key on Windows.  On Windows,
+    // both Ctrl and Alt keys are pressed internally when AltGr key is pressed.
+    // For some languages' users, AltGraph key is important, so, web
+    // applications on such locale may want to know AltGraph key press.
+    // Therefore, we should map AltGr keycode for them only on GTK.
+    { NS_VK_ALTGR,      GDK_ISO_Level3_Shift },
+    { NS_VK_ALTGR,      GDK_ISO_Level5_Shift },
+    // We assume that Mode_switch is always used for level3 shift.
+    { NS_VK_ALTGR,      GDK_Mode_switch },
+
+    { NS_VK_PAUSE,      GDK_Pause },
+    { NS_VK_CAPS_LOCK,  GDK_Caps_Lock },
+    { NS_VK_KANA,       GDK_Kana_Lock },
+    { NS_VK_KANA,       GDK_Kana_Shift },
+    { NS_VK_HANGUL,     GDK_Hangul },
+    // { NS_VK_JUNJA,      GDK_XXX },
+    // { NS_VK_FINAL,      GDK_XXX },
+    { NS_VK_HANJA,      GDK_Hangul_Hanja },
+    { NS_VK_KANJI,      GDK_Kanji },
+    { NS_VK_ESCAPE,     GDK_Escape },
+    { NS_VK_CONVERT,    GDK_Henkan },
+    { NS_VK_NONCONVERT, GDK_Muhenkan },
+    // { NS_VK_ACCEPT,     GDK_XXX },
+    // { NS_VK_MODECHANGE, GDK_XXX },
+    { NS_VK_SPACE,      GDK_space },
+    { NS_VK_PAGE_UP,    GDK_Page_Up },
+    { NS_VK_PAGE_DOWN,  GDK_Page_Down },
+    { NS_VK_END,        GDK_End },
+    { NS_VK_HOME,       GDK_Home },
+    { NS_VK_LEFT,       GDK_Left },
+    { NS_VK_UP,         GDK_Up },
+    { NS_VK_RIGHT,      GDK_Right },
+    { NS_VK_DOWN,       GDK_Down },
+    { NS_VK_SELECT,     GDK_Select },
+    { NS_VK_PRINT,      GDK_Print },
+    { NS_VK_EXECUTE,    GDK_Execute },
+    { NS_VK_PRINTSCREEN, GDK_Print },
+    { NS_VK_INSERT,     GDK_Insert },
+    { NS_VK_DELETE,     GDK_Delete },
+    { NS_VK_HELP,       GDK_Help },
+
+    // keypad keys
+    { NS_VK_LEFT,       GDK_KP_Left },
+    { NS_VK_RIGHT,      GDK_KP_Right },
+    { NS_VK_UP,         GDK_KP_Up },
+    { NS_VK_DOWN,       GDK_KP_Down },
+    { NS_VK_PAGE_UP,    GDK_KP_Page_Up },
+    // Not sure what these are
+    //{ NS_VK_,       GDK_KP_Prior },
+    //{ NS_VK_,        GDK_KP_Next },
+    { NS_VK_CLEAR,      GDK_KP_Begin }, // Num-unlocked 5
+    { NS_VK_PAGE_DOWN,  GDK_KP_Page_Down },
+    { NS_VK_HOME,       GDK_KP_Home },
+    { NS_VK_END,        GDK_KP_End },
+    { NS_VK_INSERT,     GDK_KP_Insert },
+    { NS_VK_DELETE,     GDK_KP_Delete },
+    { NS_VK_RETURN,     GDK_KP_Enter },
+
+    { NS_VK_NUM_LOCK,   GDK_Num_Lock },
+    { NS_VK_SCROLL_LOCK,GDK_Scroll_Lock },
+
+    // Function keys
+    { NS_VK_F1,         GDK_F1 },
+    { NS_VK_F2,         GDK_F2 },
+    { NS_VK_F3,         GDK_F3 },
+    { NS_VK_F4,         GDK_F4 },
+    { NS_VK_F5,         GDK_F5 },
+    { NS_VK_F6,         GDK_F6 },
+    { NS_VK_F7,         GDK_F7 },
+    { NS_VK_F8,         GDK_F8 },
+    { NS_VK_F9,         GDK_F9 },
+    { NS_VK_F10,        GDK_F10 },
+    { NS_VK_F11,        GDK_F11 },
+    { NS_VK_F12,        GDK_F12 },
+    { NS_VK_F13,        GDK_F13 },
+    { NS_VK_F14,        GDK_F14 },
+    { NS_VK_F15,        GDK_F15 },
+    { NS_VK_F16,        GDK_F16 },
+    { NS_VK_F17,        GDK_F17 },
+    { NS_VK_F18,        GDK_F18 },
+    { NS_VK_F19,        GDK_F19 },
+    { NS_VK_F20,        GDK_F20 },
+    { NS_VK_F21,        GDK_F21 },
+    { NS_VK_F22,        GDK_F22 },
+    { NS_VK_F23,        GDK_F23 },
+    { NS_VK_F24,        GDK_F24 },
+
+    // context menu key, keysym 0xff67, typically keycode 117 on 105-key (Microsoft)
+    // x86 keyboards, located between right 'Windows' key and right Ctrl key
+    { NS_VK_CONTEXT_MENU, GDK_Menu },
+    { NS_VK_SLEEP,      GDK_Sleep },
+
+    { NS_VK_ATTN,       GDK_3270_Attn },
+    { NS_VK_CRSEL,      GDK_3270_CursorSelect },
+    { NS_VK_EXSEL,      GDK_3270_ExSelect },
+    { NS_VK_EREOF,      GDK_3270_EraseEOF },
+    { NS_VK_PLAY,       GDK_3270_Play },
+    //{ NS_VK_ZOOM,       GDK_XXX },
+    { NS_VK_PA1,        GDK_3270_PA1 },
+};
+
+static guint
+ConvertGeckoKeyNameToGDKKeyval(nsAString& aKeyName)
+{
+    NS_ConvertUTF16toUTF8 keyName(aKeyName);
+    ToUpperCase(keyName); // We want case-insensitive comparison with data
+                          // stored as uppercase.
+
+    uint32_t keyCode = 0;
+
+    uint32_t keyNameLength = keyName.Length();
+    const char* keyNameStr = keyName.get();
+    for (uint16_t i = 0; i < ArrayLength(gKeyCodes); ++i) {
+        if (keyNameLength == gKeyCodes[i].strlength &&
+            !nsCRT::strcmp(gKeyCodes[i].str, keyNameStr)) {
+            keyCode = gKeyCodes[i].keycode;
+            break;
+        }
+    }
+
+    // First, try to handle alphanumeric input, not listed in nsKeycodes:
+    // most likely, more letters will be getting typed in than things in
+    // the key list, so we will look through these first.
+
+    if (keyCode >= NS_VK_A && keyCode <= NS_VK_Z) {
+        // gdk and DOM both use the ASCII codes for these keys.
+        return keyCode;
+    }
+
+    // numbers
+    if (keyCode >= NS_VK_0 && keyCode <= NS_VK_9) {
+        // gdk and DOM both use the ASCII codes for these keys.
+        return keyCode - NS_VK_0 + GDK_0;
+    }
+
+    switch (keyCode) {
+        // keys in numpad
+        case NS_VK_MULTIPLY:  return GDK_KP_Multiply;
+        case NS_VK_ADD:       return GDK_KP_Add;
+        case NS_VK_SEPARATOR: return GDK_KP_Separator;
+        case NS_VK_SUBTRACT:  return GDK_KP_Subtract;
+        case NS_VK_DECIMAL:   return GDK_KP_Decimal;
+        case NS_VK_DIVIDE:    return GDK_KP_Divide;
+        case NS_VK_NUMPAD0:   return GDK_KP_0;
+        case NS_VK_NUMPAD1:   return GDK_KP_1;
+        case NS_VK_NUMPAD2:   return GDK_KP_2;
+        case NS_VK_NUMPAD3:   return GDK_KP_3;
+        case NS_VK_NUMPAD4:   return GDK_KP_4;
+        case NS_VK_NUMPAD5:   return GDK_KP_5;
+        case NS_VK_NUMPAD6:   return GDK_KP_6;
+        case NS_VK_NUMPAD7:   return GDK_KP_7;
+        case NS_VK_NUMPAD8:   return GDK_KP_8;
+        case NS_VK_NUMPAD9:   return GDK_KP_9;
+        // other prinable keys
+        case NS_VK_SPACE:               return GDK_space;
+        case NS_VK_COLON:               return GDK_colon;
+        case NS_VK_SEMICOLON:           return GDK_semicolon;
+        case NS_VK_LESS_THAN:           return GDK_less;
+        case NS_VK_EQUALS:              return GDK_equal;
+        case NS_VK_GREATER_THAN:        return GDK_greater;
+        case NS_VK_QUESTION_MARK:       return GDK_question;
+        case NS_VK_AT:                  return GDK_at;
+        case NS_VK_CIRCUMFLEX:          return GDK_asciicircum;
+        case NS_VK_EXCLAMATION:         return GDK_exclam;
+        case NS_VK_DOUBLE_QUOTE:        return GDK_quotedbl;
+        case NS_VK_HASH:                return GDK_numbersign;
+        case NS_VK_DOLLAR:              return GDK_dollar;
+        case NS_VK_PERCENT:             return GDK_percent;
+        case NS_VK_AMPERSAND:           return GDK_ampersand;
+        case NS_VK_UNDERSCORE:          return GDK_underscore;
+        case NS_VK_OPEN_PAREN:          return GDK_parenleft;
+        case NS_VK_CLOSE_PAREN:         return GDK_parenright;
+        case NS_VK_ASTERISK:            return GDK_asterisk;
+        case NS_VK_PLUS:                return GDK_plus;
+        case NS_VK_PIPE:                return GDK_bar;
+        case NS_VK_HYPHEN_MINUS:        return GDK_minus;
+        case NS_VK_OPEN_CURLY_BRACKET:  return GDK_braceleft;
+        case NS_VK_CLOSE_CURLY_BRACKET: return GDK_braceright;
+        case NS_VK_TILDE:               return GDK_asciitilde;
+        case NS_VK_COMMA:               return GDK_comma;
+        case NS_VK_PERIOD:              return GDK_period;
+        case NS_VK_SLASH:               return GDK_slash;
+        case NS_VK_BACK_QUOTE:          return GDK_grave;
+        case NS_VK_OPEN_BRACKET:        return GDK_bracketleft;
+        case NS_VK_BACK_SLASH:          return GDK_backslash;
+        case NS_VK_CLOSE_BRACKET:       return GDK_bracketright;
+        case NS_VK_QUOTE:               return GDK_apostrophe;
+    }
+
+    // misc other things
+    for (uint32_t i = 0; i < ArrayLength(gKeyPairs); ++i) {
+        if (gKeyPairs[i].DOMKeyCode == keyCode) {
+            return gKeyPairs[i].GDKKeyval;
+        }
+    }
+
+    return 0;
+}
+
+class nsMenuItemUncheckSiblingsRunnable final : public Runnable
+{
+public:
+    NS_IMETHODIMP Run()
+    {
+        if (mMenuItem) {
+            static_cast<nsMenuItem *>(mMenuItem.get())->UncheckSiblings();
+        }
+        return NS_OK;
+    }
+
+    nsMenuItemUncheckSiblingsRunnable(nsMenuItem *aMenuItem) :
+        Runnable("nsMenuItemUncheckSiblingsRunnable"),
+        mMenuItem(aMenuItem) { };
+
+private:
+    nsWeakMenuObject mMenuItem;
+};
+
+bool
+nsMenuItem::IsCheckboxOrRadioItem() const
+{
+    return mType == eMenuItemType_Radio ||
+           mType == eMenuItemType_CheckBox;
+}
+
+/* static */ void
+nsMenuItem::item_activated_cb(DbusmenuMenuitem *menuitem,
+                              guint timestamp,
+                              gpointer user_data)
+{
+    nsMenuItem *item = static_cast<nsMenuItem *>(user_data);
+    item->Activate(timestamp);
+}
+
+void
+nsMenuItem::Activate(uint32_t aTimestamp)
+{
+    GdkWindow *window = gtk_widget_get_window(MenuBar()->TopLevelWindow());
+    gdk_x11_window_set_user_time(
+        window, std::min(aTimestamp, gdk_x11_get_server_time(window)));
+
+    // We do this to avoid mutating our view of the menu until
+    // after we have finished
+    nsNativeMenuDocListener::BlockUpdatesScope updatesBlocker;
+
+    if (!ContentNode()->AsElement()->AttrValueIs(kNameSpaceID_None,
+                                                 nsGkAtoms::autocheck,
+                                                 nsGkAtoms::_false,
+                                                 eCaseMatters) &&
+        (mType == eMenuItemType_CheckBox ||
+         (mType == eMenuItemType_Radio && !mIsChecked))) {
+        ContentNode()->AsElement()->SetAttr(kNameSpaceID_None,
+                                            nsGkAtoms::checked,
+                                            mIsChecked ?
+                                                u"false"_ns
+                                                : u"true"_ns,
+                                            true);
+    }
+
+    dom::Document *doc = ContentNode()->OwnerDoc();
+    ErrorResult rv;
+    RefPtr<dom::Event> event =
+        doc->CreateEvent(u"xulcommandevent"_ns,
+                         dom::CallerType::System, rv);
+    if (!rv.Failed()) {
+        RefPtr<dom::XULCommandEvent> command = event->AsXULCommandEvent();
+        if (command) {
+            command->InitCommandEvent(u"command"_ns, true, true,
+                                      nsGlobalWindowInner::Cast(doc->GetInnerWindow()),
+                                      0, false, false, false, false, 0, nullptr, 0, rv);
+            if (!rv.Failed()) {
+                event->SetTrusted(true);
+                ContentNode()->DispatchEvent(*event, rv);
+                if (rv.Failed()) {
+                    NS_WARNING("Failed to dispatch event");
+                    rv.SuppressException();
+                }
+            } else {
+                NS_WARNING("Failed to initialize command event");
+                rv.SuppressException();
+            }
+        }
+    } else {
+        NS_WARNING("CreateEvent failed");
+        rv.SuppressException();
+    }
+
+    // This kinda sucks, but Unity doesn't send a closed event
+    // after activating a menuitem
+    nsMenuObject *ancestor = Parent();
+    while (ancestor && ancestor->Type() == eType_Menu) {
+        static_cast<nsMenu *>(ancestor)->OnClose();
+        ancestor = ancestor->Parent();
+    }
+}
+
+void
+nsMenuItem::CopyAttrFromNodeIfExists(nsIContent *aContent, nsAtom *aAttribute)
+{
+    nsAutoString value;
+    if (aContent->AsElement()->GetAttr(kNameSpaceID_None, aAttribute, value)) {
+        ContentNode()->AsElement()->SetAttr(kNameSpaceID_None, aAttribute,
+                                            value, true);
+    }
+}
+
+void
+nsMenuItem::UpdateState()
+{
+    if (!IsCheckboxOrRadioItem()) {
+        return;
+    }
+
+    mIsChecked = ContentNode()->AsElement()->AttrValueIs(kNameSpaceID_None,
+                                                         nsGkAtoms::checked,
+                                                         nsGkAtoms::_true,
+                                                         eCaseMatters);
+    dbusmenu_menuitem_property_set_int(GetNativeData(),
+                                       DBUSMENU_MENUITEM_PROP_TOGGLE_STATE,
+                                       mIsChecked ?
+                                         DBUSMENU_MENUITEM_TOGGLE_STATE_CHECKED :
+                                         DBUSMENU_MENUITEM_TOGGLE_STATE_UNCHECKED);
+}
+
+void
+nsMenuItem::UpdateTypeAndState()
+{
+    static mozilla::dom::Element::AttrValuesArray attrs[] =
+        { nsGkAtoms::checkbox, nsGkAtoms::radio, nullptr };
+    int32_t type = ContentNode()->AsElement()->FindAttrValueIn(kNameSpaceID_None,
+                                                               nsGkAtoms::type,
+                                                               attrs, eCaseMatters);
+
+    if (type >= 0 && type < 2) {
+        if (type == 0) {
+            dbusmenu_menuitem_property_set(GetNativeData(),
+                                           DBUSMENU_MENUITEM_PROP_TOGGLE_TYPE,
+                                           DBUSMENU_MENUITEM_TOGGLE_CHECK);
+            mType = eMenuItemType_CheckBox;
+        } else if (type == 1) {
+            dbusmenu_menuitem_property_set(GetNativeData(),
+                                           DBUSMENU_MENUITEM_PROP_TOGGLE_TYPE,
+                                           DBUSMENU_MENUITEM_TOGGLE_RADIO);
+            mType = eMenuItemType_Radio;
+        }
+
+        UpdateState();
+    } else {
+        dbusmenu_menuitem_property_remove(GetNativeData(),
+                                          DBUSMENU_MENUITEM_PROP_TOGGLE_TYPE);
+        dbusmenu_menuitem_property_remove(GetNativeData(),
+                                          DBUSMENU_MENUITEM_PROP_TOGGLE_STATE);
+        mType = eMenuItemType_Normal;
+    }
+}
+
+void
+nsMenuItem::UpdateAccel()
+{
+    dom::Document *doc = ContentNode()->GetUncomposedDoc();
+    if (doc) {
+        nsCOMPtr<nsIContent> oldKeyContent;
+        oldKeyContent.swap(mKeyContent);
+
+        nsAutoString key;
+        ContentNode()->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::key,
+                                            key);
+        if (!key.IsEmpty()) {
+            mKeyContent = doc->GetElementById(key);
+        }
+
+        if (mKeyContent != oldKeyContent) {
+            if (oldKeyContent) {
+                DocListener()->UnregisterForContentChanges(oldKeyContent);
+            }
+            if (mKeyContent) {
+                DocListener()->RegisterForContentChanges(mKeyContent, this);
+            }
+        }
+    }
+
+    if (!mKeyContent) {
+        dbusmenu_menuitem_property_remove(GetNativeData(),
+                                          DBUSMENU_MENUITEM_PROP_SHORTCUT);
+        return;
+    }
+
+    nsAutoString modifiers;
+    mKeyContent->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::modifiers,
+                                      modifiers);
+
+    uint32_t modifier = 0;
+
+    if (!modifiers.IsEmpty()) {
+        char* str = ToNewUTF8String(modifiers);
+        char *token = strtok(str, ", \t");
+        while(token) {
+            if (nsCRT::strcmp(token, "shift") == 0) {
+                modifier |= GDK_SHIFT_MASK;
+            } else if (nsCRT::strcmp(token, "alt") == 0) {
+                modifier |= GDK_MOD1_MASK;
+            } else if (nsCRT::strcmp(token, "meta") == 0) {
+                modifier |= GDK_META_MASK;
+            } else if (nsCRT::strcmp(token, "control") == 0) {
+                modifier |= GDK_CONTROL_MASK;
+            } else if (nsCRT::strcmp(token, "accel") == 0) {
+                int32_t accel = Preferences::GetInt("ui.key.accelKey");
+                if (accel == dom::KeyboardEvent_Binding::DOM_VK_META) {
+                    modifier |= GDK_META_MASK;
+                } else if (accel == dom::KeyboardEvent_Binding::DOM_VK_ALT) {
+                    modifier |= GDK_MOD1_MASK;
+                } else {
+                    modifier |= GDK_CONTROL_MASK;
+                }
+            }
+
+            token = strtok(nullptr, ", \t");
+        }
+
+        free(str);
+    }
+
+    nsAutoString keyStr;
+    mKeyContent->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::key,
+                                      keyStr);
+
+    guint key = 0;
+    if (!keyStr.IsEmpty()) {
+        key = gdk_unicode_to_keyval(*keyStr.BeginReading());
+    }
+
+    if (key == 0) {
+        mKeyContent->AsElement()->GetAttr(kNameSpaceID_None,
+                                          nsGkAtoms::keycode, keyStr);
+        if (!keyStr.IsEmpty()) {
+            key = ConvertGeckoKeyNameToGDKKeyval(keyStr);
+        }
+    }
+
+    if (key == 0) {
+        key = GDK_VoidSymbol;
+    }
+
+    if (key != GDK_VoidSymbol) {
+        dbusmenu_menuitem_property_set_shortcut(GetNativeData(), key,
+                                                static_cast<GdkModifierType>(modifier));
+    } else {
+        dbusmenu_menuitem_property_remove(GetNativeData(),
+                                          DBUSMENU_MENUITEM_PROP_SHORTCUT);
+    }
+}
+
+nsMenuBar*
+nsMenuItem::MenuBar()
+{
+    nsMenuObject *tmp = this;
+    while (tmp->Parent()) {
+        tmp = tmp->Parent();
+    }
+
+    MOZ_ASSERT(tmp->Type() == eType_MenuBar, "The top-level should be a menubar");
+
+    return static_cast<nsMenuBar *>(tmp);
+}
+
+void
+nsMenuItem::UncheckSiblings()
+{
+    if (!ContentNode()->AsElement()->AttrValueIs(kNameSpaceID_None,
+                                                 nsGkAtoms::type,
+                                                 nsGkAtoms::radio,
+                                                 eCaseMatters)) {
+        // If we're not a radio button, we don't care
+        return;
+    }
+
+    nsAutoString name;
+    ContentNode()->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::name,
+                                        name);
+
+    nsIContent *parent = ContentNode()->GetParent();
+    if (!parent) {
+        return;
+    }
+
+    uint32_t count = parent->GetChildCount();
+    for (uint32_t i = 0; i < count; ++i) {
+        nsIContent *sibling = parent->GetChildAt_Deprecated(i);
+
+        if (sibling->IsComment()) {
+            continue;
+        }
+
+        nsAutoString otherName;
+        sibling->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::name,
+                                      otherName);
+
+        if (sibling != ContentNode() && otherName == name &&
+            sibling->AsElement()->AttrValueIs(kNameSpaceID_None,
+                                              nsGkAtoms::type,
+                                              nsGkAtoms::radio,
+                                              eCaseMatters)) {
+            sibling->AsElement()->UnsetAttr(kNameSpaceID_None,
+                                            nsGkAtoms::checked, true);
+        }
+    }
+}
+
+void
+nsMenuItem::InitializeNativeData()
+{
+    g_signal_connect(G_OBJECT(GetNativeData()),
+                     DBUSMENU_MENUITEM_SIGNAL_ITEM_ACTIVATED,
+                     G_CALLBACK(item_activated_cb), this);
+    mNeedsUpdate = true;
+}
+
+void
+nsMenuItem::UpdateContentAttributes()
+{
+    dom::Document *doc = ContentNode()->GetUncomposedDoc();
+    if (!doc) {
+        return;
+    }
+
+    nsAutoString command;
+    ContentNode()->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::command,
+                                        command);
+    if (command.IsEmpty()) {
+        return;
+    }
+
+    nsCOMPtr<nsIContent> commandContent = doc->GetElementById(command);
+    if (!commandContent) {
+        return;
+    }
+
+    if (commandContent->AsElement()->AttrValueIs(kNameSpaceID_None,
+                                                 nsGkAtoms::disabled,
+                                                 nsGkAtoms::_true,
+                                                 eCaseMatters)) {
+        ContentNode()->AsElement()->SetAttr(kNameSpaceID_None,
+                                            nsGkAtoms::disabled,
+                                            u"true"_ns, true);
+    } else {
+        ContentNode()->AsElement()->UnsetAttr(kNameSpaceID_None,
+                                              nsGkAtoms::disabled, true);
+    }
+
+    CopyAttrFromNodeIfExists(commandContent, nsGkAtoms::checked);
+    CopyAttrFromNodeIfExists(commandContent, nsGkAtoms::accesskey);
+    CopyAttrFromNodeIfExists(commandContent, nsGkAtoms::label);
+    CopyAttrFromNodeIfExists(commandContent, nsGkAtoms::hidden);
+}
+
+void
+nsMenuItem::Update(ComputedStyle *aComputedStyle)
+{
+    if (mNeedsUpdate) {
+        mNeedsUpdate = false;
+
+        UpdateTypeAndState();
+        UpdateAccel();
+        UpdateLabel();
+        UpdateSensitivity();
+    }
+
+    UpdateVisibility(aComputedStyle);
+    UpdateIcon(aComputedStyle);
+}
+
+bool
+nsMenuItem::IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const
+{
+    return nsCRT::strcmp(dbusmenu_menuitem_property_get(aNativeData,
+                                                        DBUSMENU_MENUITEM_PROP_TYPE),
+                         "separator") != 0;
+}
+
+nsMenuObject::PropertyFlags
+nsMenuItem::SupportedProperties() const
+{
+    return static_cast<nsMenuObject::PropertyFlags>(
+        nsMenuObject::ePropLabel |
+        nsMenuObject::ePropEnabled |
+        nsMenuObject::ePropVisible |
+        nsMenuObject::ePropIconData |
+        nsMenuObject::ePropShortcut |
+        nsMenuObject::ePropToggleType |
+        nsMenuObject::ePropToggleState
+    );
+}
+
+void
+nsMenuItem::OnAttributeChanged(nsIContent *aContent, nsAtom *aAttribute)
+{
+    MOZ_ASSERT(aContent == ContentNode() || aContent == mKeyContent,
+               "Received an event that wasn't meant for us!");
+
+    if (aContent == ContentNode() && aAttribute == nsGkAtoms::checked &&
+        aContent->AsElement()->AttrValueIs(kNameSpaceID_None,
+                                           nsGkAtoms::checked,
+                                           nsGkAtoms::_true, eCaseMatters)) {
+        nsContentUtils::AddScriptRunner(
+            new nsMenuItemUncheckSiblingsRunnable(this));
+    }
+
+    if (mNeedsUpdate) {
+        return;
+    }
+
+    if (!Parent()->IsBeingDisplayed()) {
+        mNeedsUpdate = true;
+        return;
+    }
+
+    if (aContent == ContentNode()) {
+        if (aAttribute == nsGkAtoms::key) {
+            UpdateAccel();
+        } else if (aAttribute == nsGkAtoms::label ||
+                   aAttribute == nsGkAtoms::accesskey ||
+                   aAttribute == nsGkAtoms::crop) {
+            UpdateLabel();
+        } else if (aAttribute == nsGkAtoms::disabled) {
+            UpdateSensitivity();
+        } else if (aAttribute == nsGkAtoms::type) {
+            UpdateTypeAndState();
+        } else if (aAttribute == nsGkAtoms::checked) {
+            UpdateState();
+        } else if (aAttribute == nsGkAtoms::hidden ||
+                   aAttribute == nsGkAtoms::collapsed) {
+            RefPtr<ComputedStyle> style = GetComputedStyle();
+            UpdateVisibility(style);
+        } else if (aAttribute == nsGkAtoms::image) {
+            RefPtr<ComputedStyle> style = GetComputedStyle();
+            UpdateIcon(style);
+        }
+    } else if (aContent == mKeyContent &&
+               (aAttribute == nsGkAtoms::key ||
+                aAttribute == nsGkAtoms::keycode ||
+                aAttribute == nsGkAtoms::modifiers)) {
+        UpdateAccel();
+    }
+}
+
+nsMenuItem::nsMenuItem(nsMenuContainer *aParent, nsIContent *aContent) :
+    nsMenuObject(aParent, aContent),
+    mType(eMenuItemType_Normal),
+    mIsChecked(false),
+    mNeedsUpdate(false)
+{
+    MOZ_COUNT_CTOR(nsMenuItem);
+}
+
+nsMenuItem::~nsMenuItem()
+{
+    if (DocListener() && mKeyContent) {
+        DocListener()->UnregisterForContentChanges(mKeyContent);
+    }
+
+    if (GetNativeData()) {
+        g_signal_handlers_disconnect_by_func(GetNativeData(),
+                                             FuncToGpointer(item_activated_cb),
+                                             this);
+    }
+
+    MOZ_COUNT_DTOR(nsMenuItem);
+}
+
+nsMenuObject::EType
+nsMenuItem::Type() const
+{
+    return eType_MenuItem;
+}
diff --git a/widget/gtk/nsMenuItem.h b/widget/gtk/nsMenuItem.h
new file mode 100644
index 0000000000..0dfaf86ec6
--- /dev/null
+++ b/widget/gtk/nsMenuItem.h
@@ -0,0 +1,80 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenuItem_h__
+#define __nsMenuItem_h__
+
+#include "mozilla/Attributes.h"
+#include "nsCOMPtr.h"
+
+#include "nsDbusmenu.h"
+#include "nsMenuObject.h"
+
+#include <glib.h>
+
+class nsAtom;
+class nsIContent;
+class nsMenuBar;
+class nsMenuContainer;
+
+/*
+ * This class represents 3 main classes of menuitems: labels, checkboxes and
+ * radio buttons (with/without an icon)
+ */
+class nsMenuItem final : public nsMenuObject
+{
+public:
+    nsMenuItem(nsMenuContainer *aParent, nsIContent *aContent);
+    ~nsMenuItem() override;
+
+    nsMenuObject::EType Type() const override;
+
+private:
+    friend class nsMenuItemUncheckSiblingsRunnable;
+
+    enum {
+        eMenuItemFlag_ToggleState = (1 << 0)
+    };
+
+    enum EMenuItemType {
+        eMenuItemType_Normal,
+        eMenuItemType_Radio,
+        eMenuItemType_CheckBox
+    };
+
+    bool IsCheckboxOrRadioItem() const;
+
+    static void item_activated_cb(DbusmenuMenuitem *menuitem,
+                                  guint timestamp,
+                                  gpointer user_data);
+    void Activate(uint32_t aTimestamp);
+
+    void CopyAttrFromNodeIfExists(nsIContent *aContent, nsAtom *aAtom);
+    void UpdateState();
+    void UpdateTypeAndState();
+    void UpdateAccel();
+    nsMenuBar* MenuBar();
+    void UncheckSiblings();
+
+    void InitializeNativeData() override;
+    void UpdateContentAttributes() override;
+    void Update(mozilla::ComputedStyle *aComputedStyle) override;
+    bool IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const override;
+    nsMenuObject::PropertyFlags SupportedProperties() const override;
+
+    void OnAttributeChanged(nsIContent *aContent, nsAtom *aAttribute) override;
+
+    EMenuItemType mType;
+
+    bool mIsChecked;
+
+    bool mNeedsUpdate;
+
+    nsCOMPtr<nsIContent> mKeyContent;
+};
+
+#endif /* __nsMenuItem_h__ */
diff --git a/widget/gtk/nsMenuObject.cpp b/widget/gtk/nsMenuObject.cpp
new file mode 100644
index 0000000000..56c01591ce
--- /dev/null
+++ b/widget/gtk/nsMenuObject.cpp
@@ -0,0 +1,664 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ImageOps.h"
+#include "imgIContainer.h"
+#include "imgINotificationObserver.h"
+#include "imgLoader.h"
+#include "imgRequestProxy.h"
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/Assertions.h"
+#include "mozilla/dom/Document.h"
+#include "mozilla/dom/Element.h"
+#include "mozilla/Preferences.h"
+#include "mozilla/PresShell.h"
+#include "mozilla/PresShellInlines.h"
+#include "mozilla/GRefPtr.h"
+#include "nsAttrValue.h"
+#include "nsComputedDOMStyle.h"
+#include "nsContentUtils.h"
+#include "nsGkAtoms.h"
+#include "nsIContent.h"
+#include "nsIContentPolicy.h"
+#include "nsILoadGroup.h"
+#include "nsImageToPixbuf.h"
+#include "nsIURI.h"
+#include "nsNetUtil.h"
+#include "nsPresContext.h"
+#include "nsRect.h"
+#include "nsServiceManagerUtils.h"
+#include "nsString.h"
+#include "nsStyleConsts.h"
+#include "nsStyleStruct.h"
+#include "nsUnicharUtils.h"
+
+#include "nsMenuContainer.h"
+#include "nsNativeMenuDocListener.h"
+
+#include <gdk/gdk.h>
+#include <glib-object.h>
+#include <pango/pango.h>
+
+#include "nsMenuObject.h"
+
+// X11's None clashes with StyleDisplay::None
+#include "X11UndefineNone.h"
+
+#undef None
+
+using namespace mozilla;
+using mozilla::image::ImageOps;
+
+#define MAX_WIDTH 350000
+
+const char *gPropertyStrings[] = {
+#define DBUSMENU_PROPERTY(e, s, b) s,
+    DBUSMENU_PROPERTIES
+#undef DBUSMENU_PROPERTY
+    nullptr
+};
+
+nsWeakMenuObject* nsWeakMenuObject::sHead;
+PangoLayout* gPangoLayout = nullptr;
+
+class nsMenuObjectIconLoader final : public imgINotificationObserver
+{
+public:
+    NS_DECL_ISUPPORTS
+    NS_DECL_IMGINOTIFICATIONOBSERVER
+
+    nsMenuObjectIconLoader(nsMenuObject *aOwner) : mOwner(aOwner) { };
+
+    void LoadIcon(ComputedStyle *aComputedStyle);
+    void Destroy();
+
+private:
+    ~nsMenuObjectIconLoader() { };
+
+    nsMenuObject *mOwner;
+    RefPtr<imgRequestProxy> mImageRequest;
+    nsCOMPtr<nsIURI> mURI;
+    nsIntRect mImageRect;
+};
+
+NS_IMPL_ISUPPORTS(nsMenuObjectIconLoader, imgINotificationObserver)
+
+void
+nsMenuObjectIconLoader::Notify(imgIRequest *aProxy,
+                               int32_t aType, const nsIntRect *aRect)
+{
+    if (!mOwner) {
+        return;
+    }
+
+    if (aProxy != mImageRequest) {
+        return;
+    }
+
+    if (aType == imgINotificationObserver::LOAD_COMPLETE) {
+        uint32_t status = imgIRequest::STATUS_ERROR;
+        if (NS_FAILED(mImageRequest->GetImageStatus(&status)) ||
+            (status & imgIRequest::STATUS_ERROR)) {
+            mImageRequest->Cancel(NS_BINDING_ABORTED);
+            mImageRequest = nullptr;
+            return;
+        }
+
+        nsCOMPtr<imgIContainer> image;
+        mImageRequest->GetImage(getter_AddRefs(image));
+        MOZ_ASSERT(image);
+
+        // Ask the image to decode at its intrinsic size.
+        int32_t width = 0, height = 0;
+        image->GetWidth(&width);
+        image->GetHeight(&height);
+        image->RequestDecodeForSize(nsIntSize(width, height), imgIContainer::FLAG_NONE);
+        return;
+    }
+
+    if (aType == imgINotificationObserver::DECODE_COMPLETE) {
+        mImageRequest->Cancel(NS_BINDING_ABORTED);
+        mImageRequest = nullptr;
+        return;
+    }
+
+    if (aType != imgINotificationObserver::FRAME_COMPLETE) {
+        return;
+    }
+
+    nsCOMPtr<imgIContainer> img;
+    mImageRequest->GetImage(getter_AddRefs(img));
+    if (!img) {
+        return;
+    }
+
+    if (!mImageRect.IsEmpty()) {
+        img = ImageOps::Clip(img, mImageRect);
+    }
+
+    int32_t width, height;
+    img->GetWidth(&width);
+    img->GetHeight(&height);
+
+    if (width <= 0 || height <= 0) {
+        mOwner->ClearIcon();
+        return;
+    }
+
+    if (width > 100 || height > 100) {
+        // The icon data needs to go across DBus. Make sure the icon
+        // data isn't too large, else our connection gets terminated and
+        // GDbus helpfully aborts the application. Thank you :)
+        NS_WARNING("Icon data too large");
+        mOwner->ClearIcon();
+        return;
+    }
+
+    RefPtr<GdkPixbuf> pixbuf = nsImageToPixbuf::ImageToPixbuf(img);
+    if (pixbuf) {
+        dbusmenu_menuitem_property_set_image(mOwner->GetNativeData(),
+                                             DBUSMENU_MENUITEM_PROP_ICON_DATA,
+                                             pixbuf);
+    }
+
+    return;
+}
+
+void
+nsMenuObjectIconLoader::LoadIcon(ComputedStyle *aComputedStyle)
+{
+    dom::Document *doc = mOwner->ContentNode()->OwnerDoc();
+
+    nsCOMPtr<nsIURI> uri;
+    nsIntRect imageRect;
+    imgRequestProxy *imageRequest = nullptr;
+
+    nsAutoString uriString;
+    if (mOwner->ContentNode()->AsElement()->GetAttr(kNameSpaceID_None,
+                                                    nsGkAtoms::image,
+                                                    uriString)) {
+        NS_NewURI(getter_AddRefs(uri), uriString);
+    } else {
+        PresShell *shell = doc->GetPresShell();
+        if (!shell) {
+            return;
+        }
+
+        nsPresContext *pc = shell->GetPresContext();
+        if (!pc || !aComputedStyle) {
+            return;
+        }
+
+        const nsStyleList *list = aComputedStyle->StyleList();
+        imageRequest = list->mListStyleImage.GetImageRequest();
+        if (imageRequest) {
+            imageRequest->GetURI(getter_AddRefs(uri));
+            auto& rect = list->mImageRegion.AsRect();
+            imageRect = rect.ToLayoutRect().ToNearestPixels(
+                            pc->AppUnitsPerDevPixel());
+        }
+    }
+
+    if (!uri) {
+        mOwner->ClearIcon();
+        mURI = nullptr;
+
+        if (mImageRequest) {
+            mImageRequest->Cancel(NS_BINDING_ABORTED);
+            mImageRequest = nullptr;
+        }
+
+        return;
+    }
+
+    bool same;
+    if (mURI && NS_SUCCEEDED(mURI->Equals(uri, &same)) && same &&
+        (!imageRequest || imageRect == mImageRect)) {
+        return;
+    }
+
+    if (mImageRequest) {
+        mImageRequest->Cancel(NS_BINDING_ABORTED);
+        mImageRequest = nullptr;
+    }
+
+    mURI = uri;
+
+    if (imageRequest) {
+        mImageRect = imageRect;
+        imageRequest->Clone(this, nullptr, getter_AddRefs(mImageRequest));
+    } else {
+        mImageRect.SetEmpty();
+        nsCOMPtr<nsILoadGroup> loadGroup = doc->GetDocumentLoadGroup();
+        RefPtr<imgLoader> loader =
+            nsContentUtils::GetImgLoaderForDocument(doc);
+        if (!loader || !loadGroup) {
+            NS_WARNING("Failed to get loader or load group for image load");
+            return;
+        }
+
+        loader->LoadImage(uri, nullptr, nullptr,
+                          nullptr, 0, loadGroup, this, nullptr, nullptr,
+                          nsIRequest::LOAD_NORMAL, nullptr,
+                          nsIContentPolicy::TYPE_IMAGE, EmptyString(),
+                          false, false, getter_AddRefs(mImageRequest));
+    }
+}
+
+void
+nsMenuObjectIconLoader::Destroy()
+{
+    if (mImageRequest) {
+        mImageRequest->CancelAndForgetObserver(NS_BINDING_ABORTED);
+        mImageRequest = nullptr;
+    }
+
+    mOwner = nullptr;
+}
+
+static int
+CalculateTextWidth(const nsAString& aText)
+{
+    if (!gPangoLayout) {
+        PangoFontMap *fontmap = pango_cairo_font_map_get_default();
+        PangoContext *ctx = pango_font_map_create_context(fontmap);
+        gPangoLayout = pango_layout_new(ctx);
+        g_object_unref(ctx);
+    }
+
+    pango_layout_set_text(gPangoLayout, NS_ConvertUTF16toUTF8(aText).get(), -1);
+
+    int width, dummy;
+    pango_layout_get_size(gPangoLayout, &width, &dummy);
+
+    return width;
+}
+
+static const nsDependentString
+GetEllipsis()
+{
+    static char16_t sBuf[4] = { 0, 0, 0, 0 };
+    if (!sBuf[0]) {
+        nsString ellipsis;
+        Preferences::GetLocalizedString("intl.ellipsis", ellipsis);
+        if (!ellipsis.IsEmpty()) {
+            uint32_t l = ellipsis.Length();
+            const nsString::char_type *c = ellipsis.BeginReading();
+            uint32_t i = 0;
+            while (i < 3 && i < l) {
+                sBuf[i++] = *(c++);
+            }
+        } else {
+            sBuf[0] = '.';
+            sBuf[1] = '.';
+            sBuf[2] = '.';
+        }
+    }
+
+    return nsDependentString(sBuf);
+}
+
+static int
+GetEllipsisWidth()
+{
+    static int sEllipsisWidth = -1;
+
+    if (sEllipsisWidth == -1) {
+        sEllipsisWidth = CalculateTextWidth(GetEllipsis());
+    }
+
+    return sEllipsisWidth;
+}
+
+nsMenuObject::nsMenuObject(nsMenuContainer *aParent, nsIContent *aContent) :
+    mContent(aContent),
+    mListener(aParent->DocListener()),
+    mParent(aParent),
+    mNativeData(nullptr)
+{
+    MOZ_ASSERT(mContent);
+    MOZ_ASSERT(mListener);
+    MOZ_ASSERT(mParent);
+}
+
+nsMenuObject::nsMenuObject(nsNativeMenuDocListener *aListener,
+                           nsIContent *aContent) :
+    mContent(aContent),
+    mListener(aListener),
+    mParent(nullptr),
+    mNativeData(nullptr)
+{
+    MOZ_ASSERT(mContent);
+    MOZ_ASSERT(mListener);
+}
+
+void
+nsMenuObject::UpdateLabel()
+{
+    // Gecko stores the label and access key in separate attributes
+    // so we need to convert label="Foo_Bar"/accesskey="F" in to
+    // label="_Foo__Bar" for dbusmenu
+
+    nsAutoString label;
+    mContent->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::label, label);
+
+    nsAutoString accesskey;
+    mContent->AsElement()->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey,
+                                   accesskey);
+
+    const nsAutoString::char_type *akey = accesskey.BeginReading();
+    char16_t keyLower = ToLowerCase(*akey);
+    char16_t keyUpper = ToUpperCase(*akey);
+
+    const nsAutoString::char_type *iter = label.BeginReading();
+    const nsAutoString::char_type *end = label.EndReading();
+    uint32_t length = label.Length();
+    uint32_t pos = 0;
+    bool foundAccessKey = false;
+
+    while (iter != end) {
+        if (*iter != char16_t('_')) {
+            if ((*iter != keyLower && *iter != keyUpper) || foundAccessKey) {
+                ++iter;
+                ++pos;
+                continue;
+            }
+            foundAccessKey = true;
+        }
+
+        label.SetLength(++length);
+
+        iter = label.BeginReading() + pos;
+        end = label.EndReading();
+        nsAutoString::char_type *cur = label.BeginWriting() + pos;
+
+        memmove(cur + 1, cur, (length - 1 - pos) * sizeof(nsAutoString::char_type));
+        *cur = nsAutoString::char_type('_');
+
+        iter += 2;
+        pos += 2;
+    }
+
+    if (CalculateTextWidth(label) <= MAX_WIDTH) {
+        dbusmenu_menuitem_property_set(mNativeData,
+                                       DBUSMENU_MENUITEM_PROP_LABEL,
+                                       NS_ConvertUTF16toUTF8(label).get());
+        return;
+    }
+
+    // This sucks.
+    // This should be done at the point where the menu is drawn (hello Unity),
+    // but unfortunately it doesn't do that and will happily fill your entire
+    // screen width with a menu if you have a bookmark with a really long title.
+    // This leaves us with no other option but to ellipsize here, with no proper
+    // knowledge of Unity's render path, font size etc. This is better than nothing
+    nsAutoString truncated;
+    int target = MAX_WIDTH - GetEllipsisWidth();
+    length = label.Length();
+
+    static mozilla::dom::Element::AttrValuesArray strings[] = {
+        nsGkAtoms::left, nsGkAtoms::start,
+        nsGkAtoms::center, nsGkAtoms::right,
+        nsGkAtoms::end, nullptr
+    };
+
+    int32_t type = mContent->AsElement()->FindAttrValueIn(kNameSpaceID_None,
+                                                          nsGkAtoms::crop,
+                                                          strings, eCaseMatters);
+
+    switch (type) {
+        case 0:
+        case 1:
+            // FIXME: Implement left cropping
+        case 2:
+            // FIXME: Implement center cropping
+        case 3:
+        case 4:
+        default:
+            for (uint32_t i = 0; i < length; i++) {
+                truncated.Append(label.CharAt(i));
+                if (CalculateTextWidth(truncated) > target) {
+                    break;
+                }
+            }
+
+            truncated.Append(GetEllipsis());
+    }
+
+    dbusmenu_menuitem_property_set(mNativeData,
+                                   DBUSMENU_MENUITEM_PROP_LABEL,
+                                   NS_ConvertUTF16toUTF8(truncated).get());
+}
+
+void
+nsMenuObject::UpdateVisibility(ComputedStyle *aComputedStyle)
+{
+    bool vis = true;
+
+    if (aComputedStyle &&
+        (aComputedStyle->StyleDisplay()->mDisplay == StyleDisplay::None ||
+         aComputedStyle->StyleVisibility()->mVisible ==
+            StyleVisibility::Collapse)) {
+        vis = false;
+    }
+
+    dbusmenu_menuitem_property_set_bool(mNativeData,
+                                        DBUSMENU_MENUITEM_PROP_VISIBLE,
+                                        vis);
+}
+
+void
+nsMenuObject::UpdateSensitivity()
+{
+    bool disabled = mContent->AsElement()->AttrValueIs(kNameSpaceID_None,
+                                                       nsGkAtoms::disabled,
+                                                       nsGkAtoms::_true,
+                                                       eCaseMatters);
+
+    dbusmenu_menuitem_property_set_bool(mNativeData,
+                                        DBUSMENU_MENUITEM_PROP_ENABLED,
+                                        !disabled);
+
+}
+
+void
+nsMenuObject::UpdateIcon(ComputedStyle *aComputedStyle)
+{
+    if (ShouldShowIcon()) {
+        if (!mIconLoader) {
+            mIconLoader = new nsMenuObjectIconLoader(this);
+        }
+
+        mIconLoader->LoadIcon(aComputedStyle);
+    } else {
+        if (mIconLoader) {
+            mIconLoader->Destroy();
+            mIconLoader = nullptr;
+        }
+
+        ClearIcon();
+    }
+}
+
+already_AddRefed<ComputedStyle>
+nsMenuObject::GetComputedStyle()
+{
+    RefPtr<ComputedStyle> style =
+        nsComputedDOMStyle::GetComputedStyleNoFlush(
+            mContent->AsElement());
+
+    return style.forget();
+}
+
+void
+nsMenuObject::InitializeNativeData()
+{
+}
+
+nsMenuObject::PropertyFlags
+nsMenuObject::SupportedProperties() const
+{
+    return static_cast<nsMenuObject::PropertyFlags>(0);
+}
+
+bool
+nsMenuObject::IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const
+{
+    return true;
+}
+
+void
+nsMenuObject::UpdateContentAttributes()
+{
+}
+
+void
+nsMenuObject::Update(ComputedStyle *aComputedStyle)
+{
+}
+
+bool
+nsMenuObject::ShouldShowIcon() const
+{
+    // Ideally we want to know the visibility of the anonymous XUL image in
+    // our menuitem, but this isn't created because we don't have a frame.
+    // The following works by default (because xul.css hides images in menuitems
+    // that don't have the "menuitem-with-favicon" class). It's possible a third
+    // party theme could override this, but, oh well...
+    const nsAttrValue *classes = mContent->AsElement()->GetClasses();
+    if (!classes) {
+        return false;
+    }
+
+    for (uint32_t i = 0; i < classes->GetAtomCount(); ++i) {
+        if (classes->AtomAt(i) == nsGkAtoms::menuitem_with_favicon) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void
+nsMenuObject::ClearIcon()
+{
+    dbusmenu_menuitem_property_remove(mNativeData,
+                                      DBUSMENU_MENUITEM_PROP_ICON_DATA);
+}
+
+nsMenuObject::~nsMenuObject()
+{
+    nsWeakMenuObject::NotifyDestroyed(this);
+
+    if (mIconLoader) {
+        mIconLoader->Destroy();
+    }
+
+    if (mListener) {
+        mListener->UnregisterForContentChanges(mContent);
+    }
+
+    if (mNativeData) {
+        g_object_unref(mNativeData);
+        mNativeData = nullptr;
+    }
+}
+
+void
+nsMenuObject::CreateNativeData()
+{
+    MOZ_ASSERT(mNativeData == nullptr, "This node already has a DbusmenuMenuitem. The old one will be leaked");
+
+    mNativeData = dbusmenu_menuitem_new();
+    InitializeNativeData();
+    if (mParent && mParent->IsBeingDisplayed()) {
+        ContainerIsOpening();
+    }
+
+    mListener->RegisterForContentChanges(mContent, this);
+}
+
+nsresult
+nsMenuObject::AdoptNativeData(DbusmenuMenuitem *aNativeData)
+{
+    MOZ_ASSERT(mNativeData == nullptr, "This node already has a DbusmenuMenuitem. The old one will be leaked");
+
+    if (!IsCompatibleWithNativeData(aNativeData)) {
+        return NS_ERROR_FAILURE;
+    }
+
+    mNativeData = aNativeData;
+    g_object_ref(mNativeData);
+
+    PropertyFlags supported = SupportedProperties();
+    PropertyFlags mask = static_cast<PropertyFlags>(1);
+
+    for (uint32_t i = 0; gPropertyStrings[i]; ++i) {
+        if (!(mask & supported)) {
+            dbusmenu_menuitem_property_remove(mNativeData, gPropertyStrings[i]);
+        }
+        mask = static_cast<PropertyFlags>(mask << 1);
+    }
+
+    InitializeNativeData();
+    if (mParent && mParent->IsBeingDisplayed()) {
+        ContainerIsOpening();
+    }
+
+    mListener->RegisterForContentChanges(mContent, this);
+
+    return NS_OK;
+}
+
+void
+nsMenuObject::ContainerIsOpening()
+{
+    MOZ_ASSERT(nsContentUtils::IsSafeToRunScript());
+
+    UpdateContentAttributes();
+
+    RefPtr<ComputedStyle> style = GetComputedStyle();
+    Update(style);
+}
+
+/* static */ void
+nsWeakMenuObject::AddWeakReference(nsWeakMenuObject *aWeak)
+{
+    aWeak->mPrev = sHead;
+    sHead = aWeak;
+}
+
+/* static */ void
+nsWeakMenuObject::RemoveWeakReference(nsWeakMenuObject *aWeak)
+{
+    if (aWeak == sHead) {
+        sHead = aWeak->mPrev;
+        return;
+    }
+
+    nsWeakMenuObject *weak = sHead;
+    while (weak && weak->mPrev != aWeak) {
+        weak = weak->mPrev;
+    }
+
+    if (weak) {
+        weak->mPrev = aWeak->mPrev;
+    }
+}
+
+/* static */ void
+nsWeakMenuObject::NotifyDestroyed(nsMenuObject *aMenuObject)
+{
+    nsWeakMenuObject *weak = sHead;
+    while (weak) {
+        if (weak->mMenuObject == aMenuObject) {
+            weak->mMenuObject = nullptr;
+        }
+
+        weak = weak->mPrev;
+    }
+}
diff --git a/widget/gtk/nsMenuObject.h b/widget/gtk/nsMenuObject.h
new file mode 100644
index 0000000000..48f190bf5f
--- /dev/null
+++ b/widget/gtk/nsMenuObject.h
@@ -0,0 +1,169 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenuObject_h__
+#define __nsMenuObject_h__
+
+#include "mozilla/Attributes.h"
+#include "mozilla/ComputedStyleInlines.h"
+#include "nsCOMPtr.h"
+
+#include "nsDbusmenu.h"
+#include "nsNativeMenuDocListener.h"
+
+class nsIContent;
+class nsMenuContainer;
+class nsMenuObjectIconLoader;
+
+#define DBUSMENU_PROPERTIES \
+    DBUSMENU_PROPERTY(Label, DBUSMENU_MENUITEM_PROP_LABEL, 0) \
+    DBUSMENU_PROPERTY(Enabled, DBUSMENU_MENUITEM_PROP_ENABLED, 1) \
+    DBUSMENU_PROPERTY(Visible, DBUSMENU_MENUITEM_PROP_VISIBLE, 2) \
+    DBUSMENU_PROPERTY(IconData, DBUSMENU_MENUITEM_PROP_ICON_DATA, 3) \
+    DBUSMENU_PROPERTY(Type, DBUSMENU_MENUITEM_PROP_TYPE, 4) \
+    DBUSMENU_PROPERTY(Shortcut, DBUSMENU_MENUITEM_PROP_SHORTCUT, 5) \
+    DBUSMENU_PROPERTY(ToggleType, DBUSMENU_MENUITEM_PROP_TOGGLE_TYPE, 6) \
+    DBUSMENU_PROPERTY(ToggleState, DBUSMENU_MENUITEM_PROP_TOGGLE_STATE, 7) \
+    DBUSMENU_PROPERTY(ChildDisplay, DBUSMENU_MENUITEM_PROP_CHILD_DISPLAY, 8)
+
+/*
+ * This is the base class for all menu nodes. Each instance represents
+ * a single node in the menu hierarchy. It wraps the corresponding DOM node and
+ * native menu node, keeps them in sync and transfers events between the two.
+ * It is not reference counted - each node is owned by its parent (the top
+ * level menubar is owned by the window) and keeps a weak pointer to its
+ * parent (which is guaranteed to always be valid because a node will never
+ * outlive its parent). It is not safe to keep a reference to nsMenuObject
+ * externally.
+ */
+class nsMenuObject : public nsNativeMenuChangeObserver
+{
+public:
+    enum EType {
+        eType_MenuBar,
+        eType_Menu,
+        eType_MenuItem
+    };
+
+    virtual ~nsMenuObject();
+
+    // Get the native menu item node
+    DbusmenuMenuitem* GetNativeData() const { return mNativeData; }
+
+    // Get the parent menu object
+    nsMenuContainer* Parent() const { return mParent; }
+
+    // Get the content node
+    nsIContent* ContentNode() const { return mContent; }
+
+    // Get the type of this node. Must be provided by subclasses
+    virtual EType Type() const = 0;
+
+    // Get the document listener
+    nsNativeMenuDocListener* DocListener() const { return mListener; }
+
+    // Create the native menu item node (called by containers)
+    void CreateNativeData();
+
+    // Adopt the specified native menu item node (called by containers)
+    nsresult AdoptNativeData(DbusmenuMenuitem *aNativeData);
+
+    // Called by the container to tell us that it's opening
+    void ContainerIsOpening();
+
+protected:
+    nsMenuObject(nsMenuContainer *aParent, nsIContent *aContent);
+    nsMenuObject(nsNativeMenuDocListener *aListener, nsIContent *aContent);
+
+    enum PropertyFlags {
+#define DBUSMENU_PROPERTY(e, s, b) eProp##e = (1 << b),
+        DBUSMENU_PROPERTIES
+#undef DBUSMENU_PROPERTY
+    };
+
+    void UpdateLabel();
+    void UpdateVisibility(mozilla::ComputedStyle *aComputedStyle);
+    void UpdateSensitivity();
+    void UpdateIcon(mozilla::ComputedStyle *aComputedStyle);
+
+    already_AddRefed<mozilla::ComputedStyle> GetComputedStyle();
+
+private:
+    friend class nsMenuObjectIconLoader;
+
+    // Set up initial properties on the native data, connect to signals etc.
+    // This should be implemented by subclasses
+    virtual void InitializeNativeData();
+
+    // Return the properties that this menu object type supports
+    // This should be implemented by subclasses
+    virtual PropertyFlags SupportedProperties() const;
+
+    // Determine whether this menu object could use the specified
+    // native item. Returns true by default but can be overridden by subclasses
+    virtual bool
+    IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const;
+
+    // Update attributes on this objects content node when the container opens.
+    // This is called before style resolution, and should be implemented by
+    // subclasses who want to modify attributes that might affect style.
+    // This will not be called when there are script blockers
+    virtual void UpdateContentAttributes();
+
+    // Update properties that should be refreshed when the container opens.
+    // This should be implemented by subclasses that have properties which
+    // need refreshing
+    virtual void Update(mozilla::ComputedStyle *aComputedStyle);
+
+    bool ShouldShowIcon() const;
+    void ClearIcon();
+
+    nsCOMPtr<nsIContent> mContent;
+    // mListener is a strong ref for simplicity - someone in the tree needs to
+    // own it, and this only really needs to be the top-level object (as no
+    // children outlives their parent). However, we need to keep it alive until
+    // after running the nsMenuObject destructor for the top-level menu object,
+    // hence the strong ref
+    RefPtr<nsNativeMenuDocListener> mListener;
+    nsMenuContainer *mParent; // [weak]
+    DbusmenuMenuitem *mNativeData; // [strong]
+    RefPtr<nsMenuObjectIconLoader> mIconLoader;
+};
+
+// Keep a weak pointer to a menu object
+class nsWeakMenuObject
+{
+public:
+    nsWeakMenuObject() : mPrev(nullptr), mMenuObject(nullptr) {}
+
+    nsWeakMenuObject(nsMenuObject *aMenuObject) :
+        mPrev(nullptr), mMenuObject(aMenuObject)
+    {
+        AddWeakReference(this);
+    }
+
+    ~nsWeakMenuObject() { RemoveWeakReference(this); }
+
+    nsMenuObject* get() const { return mMenuObject; }
+
+    nsMenuObject* operator->() const { return mMenuObject; }
+
+    explicit operator bool() const { return !!mMenuObject; }
+
+    static void NotifyDestroyed(nsMenuObject *aMenuObject);
+
+private:
+    static void AddWeakReference(nsWeakMenuObject *aWeak);
+    static void RemoveWeakReference(nsWeakMenuObject *aWeak);
+
+    nsWeakMenuObject *mPrev;
+    static nsWeakMenuObject *sHead;
+
+    nsMenuObject *mMenuObject;
+};
+
+#endif /* __nsMenuObject_h__ */
diff --git a/widget/gtk/nsMenuSeparator.cpp b/widget/gtk/nsMenuSeparator.cpp
new file mode 100644
index 0000000000..1eca91cfc0
--- /dev/null
+++ b/widget/gtk/nsMenuSeparator.cpp
@@ -0,0 +1,82 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/Assertions.h"
+#include "nsCRT.h"
+#include "nsGkAtoms.h"
+
+#include "nsDbusmenu.h"
+
+#include "nsMenuContainer.h"
+#include "nsMenuSeparator.h"
+
+using namespace mozilla;
+
+void
+nsMenuSeparator::InitializeNativeData()
+{
+    dbusmenu_menuitem_property_set(GetNativeData(),
+                                   DBUSMENU_MENUITEM_PROP_TYPE,
+                                   "separator");
+}
+
+void
+nsMenuSeparator::Update(ComputedStyle *aComputedStyle)
+{
+    UpdateVisibility(aComputedStyle);
+}
+
+bool
+nsMenuSeparator::IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const
+{
+    return nsCRT::strcmp(dbusmenu_menuitem_property_get(aNativeData,
+                                                        DBUSMENU_MENUITEM_PROP_TYPE),
+                         "separator") == 0;
+}
+
+nsMenuObject::PropertyFlags
+nsMenuSeparator::SupportedProperties() const
+{
+    return static_cast<nsMenuObject::PropertyFlags>(
+        nsMenuObject::ePropVisible |
+        nsMenuObject::ePropType
+    );
+}
+
+void
+nsMenuSeparator::OnAttributeChanged(nsIContent *aContent, nsAtom *aAttribute)
+{
+    MOZ_ASSERT(aContent == ContentNode(), "Received an event that wasn't meant for us!");
+
+    if (!Parent()->IsBeingDisplayed()) {
+        return;
+    }
+
+    if (aAttribute == nsGkAtoms::hidden ||
+        aAttribute == nsGkAtoms::collapsed) {
+        RefPtr<ComputedStyle> style = GetComputedStyle();
+        UpdateVisibility(style);
+    }
+}
+
+nsMenuSeparator::nsMenuSeparator(nsMenuContainer *aParent,
+                                 nsIContent *aContent) :
+    nsMenuObject(aParent, aContent)
+{
+    MOZ_COUNT_CTOR(nsMenuSeparator);
+}
+
+nsMenuSeparator::~nsMenuSeparator()
+{
+    MOZ_COUNT_DTOR(nsMenuSeparator);
+}
+
+nsMenuObject::EType
+nsMenuSeparator::Type() const
+{
+    return eType_MenuItem;
+}
diff --git a/widget/gtk/nsMenuSeparator.h b/widget/gtk/nsMenuSeparator.h
new file mode 100644
index 0000000000..f9a3ea435c
--- /dev/null
+++ b/widget/gtk/nsMenuSeparator.h
@@ -0,0 +1,37 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenuSeparator_h__
+#define __nsMenuSeparator_h__
+
+#include "mozilla/Attributes.h"
+
+#include "nsMenuObject.h"
+
+class nsIContent;
+class nsAtom;
+class nsMenuContainer;
+
+// Menu separator class
+class nsMenuSeparator final : public nsMenuObject
+{
+public:
+    nsMenuSeparator(nsMenuContainer *aParent, nsIContent *aContent);
+    ~nsMenuSeparator();
+
+    nsMenuObject::EType Type() const override;
+
+private:
+    void InitializeNativeData() override;
+    void Update(mozilla::ComputedStyle *aComputedStyle) override;
+    bool IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const override;
+    nsMenuObject::PropertyFlags SupportedProperties() const override;
+
+    void OnAttributeChanged(nsIContent *aContent, nsAtom *aAttribute) override;
+};
+
+#endif /* __nsMenuSeparator_h__ */
diff --git a/widget/gtk/nsNativeMenuDocListener.cpp b/widget/gtk/nsNativeMenuDocListener.cpp
new file mode 100644
index 0000000000..2336ed6e3b
--- /dev/null
+++ b/widget/gtk/nsNativeMenuDocListener.cpp
@@ -0,0 +1,347 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/Assertions.h"
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/Document.h"
+#include "mozilla/dom/Element.h"
+#include "nsContentUtils.h"
+#include "nsAtom.h"
+#include "nsIContent.h"
+
+#include "nsMenuContainer.h"
+
+#include "nsNativeMenuDocListener.h"
+
+using namespace mozilla;
+
+uint32_t nsNativeMenuDocListener::sUpdateBlockersCount = 0;
+
+nsNativeMenuDocListenerTArray *gPendingListeners;
+
+/*
+ * Small helper which caches a single listener, so that consecutive
+ * events which go to the same node avoid multiple hash table lookups
+ */
+class MOZ_STACK_CLASS DispatchHelper
+{
+public:
+    DispatchHelper(nsNativeMenuDocListener *aListener,
+                   nsIContent *aContent) :
+                   mObserver(nullptr)
+    {
+        if (aContent == aListener->mLastSource) {
+            mObserver = aListener->mLastTarget;
+        } else {
+            mObserver = aListener->mContentToObserverTable.Get(aContent);
+            if (mObserver) {
+                aListener->mLastSource = aContent;
+                aListener->mLastTarget = mObserver;
+            }
+        }
+    }
+
+    ~DispatchHelper() { };
+
+    nsNativeMenuChangeObserver* Observer() const { return mObserver; }
+
+    bool HasObserver() const { return !!mObserver; }
+
+private:
+    nsNativeMenuChangeObserver *mObserver;
+};
+
+NS_IMPL_ISUPPORTS(nsNativeMenuDocListener, nsIMutationObserver)
+
+nsNativeMenuDocListener::~nsNativeMenuDocListener()
+{
+    MOZ_ASSERT(mContentToObserverTable.Count() == 0,
+               "Some nodes forgot to unregister listeners. This is bad! (and we're lucky we made it this far)");
+    MOZ_COUNT_DTOR(nsNativeMenuDocListener);
+}
+
+void
+nsNativeMenuDocListener::AttributeChanged(mozilla::dom::Element *aElement,
+                                          int32_t aNameSpaceID,
+                                          nsAtom *aAttribute,
+                                          int32_t aModType,
+                                          const nsAttrValue* aOldValue)
+{
+    if (sUpdateBlockersCount == 0) {
+        DoAttributeChanged(aElement, aAttribute);
+        return;
+    }
+
+    MutationRecord *m = mPendingMutations.AppendElement(MakeUnique<MutationRecord>())->get();
+    m->mType = MutationRecord::eAttributeChanged;
+    m->mTarget = aElement;
+    m->mAttribute = aAttribute;
+
+    ScheduleFlush(this);
+}
+
+void
+nsNativeMenuDocListener::ContentAppended(nsIContent *aFirstNewContent)
+{
+    for (nsIContent *c = aFirstNewContent; c; c = c->GetNextSibling()) {
+        ContentInserted(c);
+    }
+}
+
+void
+nsNativeMenuDocListener::ContentInserted(nsIContent *aChild)
+{
+    nsIContent* container = aChild->GetParent();
+    if (!container) {
+      return;
+    }
+
+    nsIContent *prevSibling = nsMenuContainer::GetPreviousSupportedSibling(aChild);
+
+    if (sUpdateBlockersCount == 0) {
+        DoContentInserted(container, aChild, prevSibling);
+        return;
+    }
+
+    MutationRecord *m = mPendingMutations.AppendElement(MakeUnique<MutationRecord>())->get();
+    m->mType = MutationRecord::eContentInserted;
+    m->mTarget = container;
+    m->mChild = aChild;
+    m->mPrevSibling = prevSibling;
+
+    ScheduleFlush(this);
+}
+
+void
+nsNativeMenuDocListener::ContentRemoved(nsIContent *aChild,
+                                        nsIContent *aPreviousSibling)
+{
+    nsIContent* container = aChild->GetParent();
+    if (!container) {
+      return;
+    }
+
+    if (sUpdateBlockersCount == 0) {
+        DoContentRemoved(container, aChild);
+        return;
+    }
+
+    MutationRecord *m = mPendingMutations.AppendElement(MakeUnique<MutationRecord>())->get();
+    m->mType = MutationRecord::eContentRemoved;
+    m->mTarget = container;
+    m->mChild = aChild;
+
+    ScheduleFlush(this);
+}
+
+void
+nsNativeMenuDocListener::NodeWillBeDestroyed(const nsINode *aNode)
+{
+    mDocument = nullptr;
+}
+
+void
+nsNativeMenuDocListener::DoAttributeChanged(nsIContent *aContent,
+                                            nsAtom *aAttribute)
+{
+    DispatchHelper h(this, aContent);
+    if (h.HasObserver()) {
+        h.Observer()->OnAttributeChanged(aContent, aAttribute);
+    }
+}
+
+void
+nsNativeMenuDocListener::DoContentInserted(nsIContent *aContainer,
+                                           nsIContent *aChild,
+                                           nsIContent *aPrevSibling)
+{
+    DispatchHelper h(this, aContainer);
+    if (h.HasObserver()) {
+        h.Observer()->OnContentInserted(aContainer, aChild, aPrevSibling);
+    }
+}
+
+void
+nsNativeMenuDocListener::DoContentRemoved(nsIContent *aContainer,
+                                          nsIContent *aChild)
+{
+    DispatchHelper h(this, aContainer);
+    if (h.HasObserver()) {
+        h.Observer()->OnContentRemoved(aContainer, aChild);
+    }
+}
+
+void
+nsNativeMenuDocListener::DoBeginUpdates(nsIContent *aTarget)
+{
+    DispatchHelper h(this, aTarget);
+    if (h.HasObserver()) {
+        h.Observer()->OnBeginUpdates(aTarget);
+    }
+}
+
+void
+nsNativeMenuDocListener::DoEndUpdates(nsIContent *aTarget)
+{
+    DispatchHelper h(this, aTarget);
+    if (h.HasObserver()) {
+        h.Observer()->OnEndUpdates();
+    }
+}
+
+void
+nsNativeMenuDocListener::FlushPendingMutations()
+{
+    nsIContent *currentTarget = nullptr;
+    bool inUpdateSequence = false;
+
+    while (mPendingMutations.Length() > 0) {
+        MutationRecord *m = mPendingMutations[0].get();
+
+        if (m->mTarget != currentTarget) {
+            if (inUpdateSequence) {
+                DoEndUpdates(currentTarget);
+                inUpdateSequence = false;
+            }
+
+            currentTarget = m->mTarget;
+
+            if (mPendingMutations.Length() > 1 &&
+                mPendingMutations[1]->mTarget == currentTarget) {
+                DoBeginUpdates(currentTarget);
+                inUpdateSequence = true;
+            }
+        }
+
+        switch (m->mType) {
+            case MutationRecord::eAttributeChanged:
+                DoAttributeChanged(m->mTarget, m->mAttribute);
+                break;
+            case MutationRecord::eContentInserted:
+                DoContentInserted(m->mTarget, m->mChild, m->mPrevSibling);
+                break;
+            case MutationRecord::eContentRemoved:
+                DoContentRemoved(m->mTarget, m->mChild);
+                break;
+            default:
+                MOZ_ASSERT_UNREACHABLE("Invalid type");
+        }
+
+        mPendingMutations.RemoveElementAt(0);
+    }
+
+    if (inUpdateSequence) {
+        DoEndUpdates(currentTarget);
+    }
+}
+
+/* static */ void
+nsNativeMenuDocListener::ScheduleFlush(nsNativeMenuDocListener *aListener)
+{
+    MOZ_ASSERT(sUpdateBlockersCount > 0, "Shouldn't be doing this now");
+
+    if (!gPendingListeners) {
+        gPendingListeners = new nsNativeMenuDocListenerTArray;
+    }
+
+    if (gPendingListeners->IndexOf(aListener) ==
+        nsNativeMenuDocListenerTArray::NoIndex) {
+        gPendingListeners->AppendElement(aListener);
+    }
+}
+
+/* static */ void
+nsNativeMenuDocListener::CancelFlush(nsNativeMenuDocListener *aListener)
+{
+    if (!gPendingListeners) {
+        return;
+    }
+
+    gPendingListeners->RemoveElement(aListener);
+}
+
+/* static */ void
+nsNativeMenuDocListener::RemoveUpdateBlocker()
+{
+    if (sUpdateBlockersCount == 1 && gPendingListeners) {
+        while (gPendingListeners->Length() > 0) {
+            (*gPendingListeners)[0]->FlushPendingMutations();
+            gPendingListeners->RemoveElementAt(0);
+        }
+    }
+
+    MOZ_ASSERT(sUpdateBlockersCount > 0, "Negative update blockers count!");
+    sUpdateBlockersCount--;
+}
+
+nsNativeMenuDocListener::nsNativeMenuDocListener(nsIContent *aRootNode) :
+    mRootNode(aRootNode),
+    mDocument(nullptr),
+    mLastSource(nullptr),
+    mLastTarget(nullptr)
+{
+    MOZ_COUNT_CTOR(nsNativeMenuDocListener);
+}
+
+void
+nsNativeMenuDocListener::RegisterForContentChanges(nsIContent *aContent,
+                                                   nsNativeMenuChangeObserver *aObserver)
+{
+    MOZ_ASSERT(aContent, "Need content parameter");
+    MOZ_ASSERT(aObserver, "Need observer parameter");
+    if (!aContent || !aObserver) {
+        return;
+    }
+
+    DebugOnly<nsNativeMenuChangeObserver *> old;
+    MOZ_ASSERT(!mContentToObserverTable.Get(aContent, &old) || old == aObserver,
+               "Multiple observers for the same content node are not supported");
+
+    mContentToObserverTable.InsertOrUpdate(aContent, aObserver);
+}
+
+void
+nsNativeMenuDocListener::UnregisterForContentChanges(nsIContent *aContent)
+{
+    MOZ_ASSERT(aContent, "Need content parameter");
+    if (!aContent) {
+        return;
+    }
+
+    mContentToObserverTable.Remove(aContent);
+    if (aContent == mLastSource) {
+        mLastSource = nullptr;
+        mLastTarget = nullptr;
+    }
+}
+
+void
+nsNativeMenuDocListener::Start()
+{
+    if (mDocument) {
+        return;
+    }
+
+    mDocument = mRootNode->OwnerDoc();
+    if (!mDocument) {
+        return;
+    }
+
+    mDocument->AddMutationObserver(this);
+}
+
+void
+nsNativeMenuDocListener::Stop()
+{
+    if (mDocument) {
+        mDocument->RemoveMutationObserver(this);
+        mDocument = nullptr;
+    }
+
+    CancelFlush(this);
+    mPendingMutations.Clear();
+}
diff --git a/widget/gtk/nsNativeMenuDocListener.h b/widget/gtk/nsNativeMenuDocListener.h
new file mode 100644
index 0000000000..5ee99cba70
--- /dev/null
+++ b/widget/gtk/nsNativeMenuDocListener.h
@@ -0,0 +1,152 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsNativeMenuDocListener_h__
+#define __nsNativeMenuDocListener_h__
+
+#include "mozilla/Attributes.h"
+#include "mozilla/RefPtr.h"
+#include "mozilla/UniquePtr.h"
+#include "nsTHashMap.h"
+#include "nsStubMutationObserver.h"
+#include "nsTArray.h"
+
+class nsAtom;
+class nsIContent;
+class nsNativeMenuChangeObserver;
+
+namespace mozilla {
+namespace dom {
+class Document;
+}
+}
+
+/*
+ * This class keeps a mapping of content nodes to observers and forwards DOM
+ * mutations to these. There is exactly one of these for every menubar.
+ */
+class nsNativeMenuDocListener final : nsStubMutationObserver
+{
+public:
+    NS_DECL_ISUPPORTS
+
+    nsNativeMenuDocListener(nsIContent *aRootNode);
+
+    // Register an observer to receive mutation events for the specified
+    // content node. The caller must keep the observer alive until
+    // UnregisterForContentChanges is called.
+    void RegisterForContentChanges(nsIContent *aContent,
+                                   nsNativeMenuChangeObserver *aObserver);
+
+    // Unregister the registered observer for the specified content node
+    void UnregisterForContentChanges(nsIContent *aContent);
+
+    // Start listening to the document and forwarding DOM mutations to
+    // registered observers.
+    void Start();
+
+    // Stop listening to the document. No DOM mutations will be forwarded
+    // to registered observers.
+    void Stop();
+
+    /*
+     * This class is intended to be used inside GObject signal handlers.
+     * It allows us to queue updates until we have finished delivering
+     * events to Gecko, and then we can batch updates to our view of the
+     * menu. This allows us to do menu updates without altering the structure
+     * seen by the OS.
+     */
+    class MOZ_STACK_CLASS BlockUpdatesScope
+    {
+    public:
+        BlockUpdatesScope()
+        {
+            nsNativeMenuDocListener::AddUpdateBlocker();
+        }
+
+        ~BlockUpdatesScope()
+        {
+            nsNativeMenuDocListener::RemoveUpdateBlocker();
+        }
+    };
+
+private:
+    friend class DispatchHelper;
+
+    struct MutationRecord {
+        enum RecordType {
+            eAttributeChanged,
+            eContentInserted,
+            eContentRemoved
+        } mType;
+
+        nsCOMPtr<nsIContent> mTarget;
+        nsCOMPtr<nsIContent> mChild;
+        nsCOMPtr<nsIContent> mPrevSibling;
+        RefPtr<nsAtom> mAttribute;
+    };
+
+    ~nsNativeMenuDocListener();
+
+    NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
+    NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
+    NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
+    NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
+    NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
+
+    void DoAttributeChanged(nsIContent *aContent, nsAtom *aAttribute);
+    void DoContentInserted(nsIContent *aContainer,
+                           nsIContent *aChild,
+                           nsIContent *aPrevSibling);
+    void DoContentRemoved(nsIContent *aContainer, nsIContent *aChild);
+    void DoBeginUpdates(nsIContent *aTarget);
+    void DoEndUpdates(nsIContent *aTarget);
+
+    void FlushPendingMutations();
+    static void ScheduleFlush(nsNativeMenuDocListener *aListener);
+    static void CancelFlush(nsNativeMenuDocListener *aListener);
+
+    static void AddUpdateBlocker() { ++sUpdateBlockersCount; }
+    static void RemoveUpdateBlocker();
+
+    nsCOMPtr<nsIContent> mRootNode;
+    mozilla::dom::Document *mDocument;
+    nsIContent *mLastSource;
+    nsNativeMenuChangeObserver *mLastTarget;
+    nsTArray<mozilla::UniquePtr<MutationRecord> > mPendingMutations;
+    nsTHashMap<nsPtrHashKey<nsIContent>, nsNativeMenuChangeObserver *> mContentToObserverTable;
+
+    static uint32_t sUpdateBlockersCount;
+};
+
+typedef nsTArray<RefPtr<nsNativeMenuDocListener> > nsNativeMenuDocListenerTArray;
+
+/*
+ * Implemented by classes that want to listen to mutation events from content
+ * nodes.
+ */
+class nsNativeMenuChangeObserver
+{
+public:
+    virtual void OnAttributeChanged(nsIContent *aContent, nsAtom *aAttribute) {}
+
+    virtual void OnContentInserted(nsIContent *aContainer,
+                                   nsIContent *aChild,
+                                   nsIContent *aPrevSibling) {}
+
+    virtual void OnContentRemoved(nsIContent *aContainer, nsIContent *aChild) {}
+
+    // Signals the start of a sequence of more than 1 event for the specified
+    // node. This only happens when events are flushed as all BlockUpdatesScope
+    // instances go out of scope
+    virtual void OnBeginUpdates(nsIContent *aContent) {};
+
+    // Signals the end of a sequence of events
+    virtual void OnEndUpdates() {};
+};
+
+#endif /* __nsNativeMenuDocListener_h__ */
diff --git a/widget/gtk/nsNativeMenuService.cpp b/widget/gtk/nsNativeMenuService.cpp
new file mode 100644
index 0000000000..5cf36a4470
--- /dev/null
+++ b/widget/gtk/nsNativeMenuService.cpp
@@ -0,0 +1,478 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/Element.h"
+#include "mozilla/Assertions.h"
+#include "mozilla/Preferences.h"
+#include "mozilla/UniquePtr.h"
+#include "nsCOMPtr.h"
+#include "nsCRT.h"
+#include "nsGtkUtils.h"
+#include "nsIContent.h"
+#include "nsIWidget.h"
+#include "nsServiceManagerUtils.h"
+#include "nsWindow.h"
+#include "prlink.h"
+
+#include "nsDbusmenu.h"
+#include "nsMenuBar.h"
+#include "nsNativeMenuDocListener.h"
+
+#include <glib-object.h>
+#include <pango/pango.h>
+#include <stdlib.h>
+
+#include "nsNativeMenuService.h"
+
+using namespace mozilla;
+
+nsNativeMenuService* nsNativeMenuService::sService = nullptr;
+
+extern PangoLayout* gPangoLayout;
+extern nsNativeMenuDocListenerTArray* gPendingListeners;
+
+#undef g_dbus_proxy_new_for_bus
+#undef g_dbus_proxy_new_for_bus_finish
+#undef g_dbus_proxy_call
+#undef g_dbus_proxy_call_finish
+#undef g_dbus_proxy_get_name_owner
+
+typedef void (*_g_dbus_proxy_new_for_bus_fn)(GBusType, GDBusProxyFlags,
+                                             GDBusInterfaceInfo*,
+                                             const gchar*, const gchar*,
+                                             const gchar*, GCancellable*,
+                                             GAsyncReadyCallback, gpointer);
+
+typedef GDBusProxy* (*_g_dbus_proxy_new_for_bus_finish_fn)(GAsyncResult*,
+                                                           GError**);
+typedef void (*_g_dbus_proxy_call_fn)(GDBusProxy*, const gchar*, GVariant*,
+                                      GDBusCallFlags, gint, GCancellable*,
+                                      GAsyncReadyCallback, gpointer);
+typedef GVariant* (*_g_dbus_proxy_call_finish_fn)(GDBusProxy*, GAsyncResult*,
+                                                  GError**);
+typedef gchar* (*_g_dbus_proxy_get_name_owner_fn)(GDBusProxy*);
+
+static _g_dbus_proxy_new_for_bus_fn _g_dbus_proxy_new_for_bus;
+static _g_dbus_proxy_new_for_bus_finish_fn _g_dbus_proxy_new_for_bus_finish;
+static _g_dbus_proxy_call_fn _g_dbus_proxy_call;
+static _g_dbus_proxy_call_finish_fn _g_dbus_proxy_call_finish;
+static _g_dbus_proxy_get_name_owner_fn _g_dbus_proxy_get_name_owner;
+
+#define g_dbus_proxy_new_for_bus _g_dbus_proxy_new_for_bus
+#define g_dbus_proxy_new_for_bus_finish _g_dbus_proxy_new_for_bus_finish
+#define g_dbus_proxy_call _g_dbus_proxy_call
+#define g_dbus_proxy_call_finish _g_dbus_proxy_call_finish
+#define g_dbus_proxy_get_name_owner _g_dbus_proxy_get_name_owner
+
+static PRLibrary *gGIOLib = nullptr;
+
+static nsresult
+GDBusInit()
+{
+    gGIOLib = PR_LoadLibrary("libgio-2.0.so.0");
+    if (!gGIOLib) {
+        return NS_ERROR_FAILURE;
+    }
+
+    g_dbus_proxy_new_for_bus = (_g_dbus_proxy_new_for_bus_fn)PR_FindFunctionSymbol(gGIOLib, "g_dbus_proxy_new_for_bus");
+    g_dbus_proxy_new_for_bus_finish = (_g_dbus_proxy_new_for_bus_finish_fn)PR_FindFunctionSymbol(gGIOLib, "g_dbus_proxy_new_for_bus_finish");
+    g_dbus_proxy_call = (_g_dbus_proxy_call_fn)PR_FindFunctionSymbol(gGIOLib, "g_dbus_proxy_call");
+    g_dbus_proxy_call_finish = (_g_dbus_proxy_call_finish_fn)PR_FindFunctionSymbol(gGIOLib, "g_dbus_proxy_call_finish");
+    g_dbus_proxy_get_name_owner = (_g_dbus_proxy_get_name_owner_fn)PR_FindFunctionSymbol(gGIOLib, "g_dbus_proxy_get_name_owner");
+
+    if (!g_dbus_proxy_new_for_bus ||
+        !g_dbus_proxy_new_for_bus_finish ||
+        !g_dbus_proxy_call ||
+        !g_dbus_proxy_call_finish ||
+        !g_dbus_proxy_get_name_owner) {
+        return NS_ERROR_FAILURE;
+    }
+
+    return NS_OK;
+}
+
+NS_IMPL_ISUPPORTS(nsNativeMenuService, nsINativeMenuService)
+
+nsNativeMenuService::nsNativeMenuService() :
+    mCreateProxyCancellable(nullptr), mDbusProxy(nullptr), mOnline(false)
+{
+}
+
+nsNativeMenuService::~nsNativeMenuService()
+{
+    SetOnline(false);
+
+    if (mCreateProxyCancellable) {
+        g_cancellable_cancel(mCreateProxyCancellable);
+        g_object_unref(mCreateProxyCancellable);
+        mCreateProxyCancellable = nullptr;
+    }
+
+    // Make sure we disconnect map-event handlers
+    while (mMenuBars.Length() > 0) {
+        NotifyNativeMenuBarDestroyed(mMenuBars[0]);
+    }
+
+    Preferences::UnregisterCallback(PrefChangedCallback,
+                                    "ui.use_unity_menubar");
+
+    if (mDbusProxy) {
+        g_signal_handlers_disconnect_by_func(mDbusProxy,
+                                             FuncToGpointer(name_owner_changed_cb),
+                                             NULL);
+        g_object_unref(mDbusProxy);
+    }
+
+    if (gPendingListeners) {
+        delete gPendingListeners;
+        gPendingListeners = nullptr;
+    }
+    if (gPangoLayout) {
+        g_object_unref(gPangoLayout);
+        gPangoLayout = nullptr;
+    }
+
+    MOZ_ASSERT(sService == this);
+    sService = nullptr;
+}
+
+nsresult
+nsNativeMenuService::Init()
+{
+    nsresult rv = nsDbusmenuFunctions::Init();
+    if (NS_FAILED(rv)) {
+        return rv;
+    }
+
+    rv = GDBusInit();
+    if (NS_FAILED(rv)) {
+        return rv;
+    }
+
+    Preferences::RegisterCallback(PrefChangedCallback,
+                                  "ui.use_unity_menubar");
+
+    mCreateProxyCancellable = g_cancellable_new();
+
+    g_dbus_proxy_new_for_bus(G_BUS_TYPE_SESSION,
+                             static_cast<GDBusProxyFlags>(
+                                 G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES |
+                                 G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS |
+                                 G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START),
+                             nullptr,
+                             "com.canonical.AppMenu.Registrar",
+                             "/com/canonical/AppMenu/Registrar",
+                             "com.canonical.AppMenu.Registrar",
+                             mCreateProxyCancellable, proxy_created_cb,
+                             nullptr);
+
+    /* We don't technically know that the shell will draw the menubar until
+     * we know whether anybody owns the name of the menubar service on the
+     * session bus. However, discovering this happens asynchronously so
+     * we optimize for the common case here by assuming that the shell will
+     * draw window menubars if we are running inside Unity. This should
+     * mean that we avoid temporarily displaying the window menubar ourselves
+     */
+    const char *desktop = getenv("XDG_CURRENT_DESKTOP");
+    if (nsCRT::strcmp(desktop, "Unity") == 0) {
+        SetOnline(true);
+    }
+
+    return NS_OK;
+}
+
+/* static */ void
+nsNativeMenuService::EnsureInitialized()
+{
+    if (sService) {
+        return;
+    }
+    nsCOMPtr<nsINativeMenuService> service =
+        do_GetService("@mozilla.org/widget/nativemenuservice;1");
+}
+
+void
+nsNativeMenuService::SetOnline(bool aOnline)
+{
+    if (!Preferences::GetBool("ui.use_unity_menubar", true)) {
+        aOnline = false;
+    }
+
+    mOnline = aOnline;
+    if (aOnline) {
+        for (uint32_t i = 0; i < mMenuBars.Length(); ++i) {
+            RegisterNativeMenuBar(mMenuBars[i]);
+        }
+    } else {
+        for (uint32_t i = 0; i < mMenuBars.Length(); ++i) {
+            mMenuBars[i]->Deactivate();
+        }
+    }
+}
+
+void
+nsNativeMenuService::RegisterNativeMenuBar(nsMenuBar *aMenuBar)
+{
+    if (!mOnline) {
+        return;
+    }
+
+    // This will effectively create the native menubar for
+    // exporting over the session bus, and hide the XUL menubar
+    aMenuBar->Activate();
+
+    if (!mDbusProxy ||
+        !gtk_widget_get_mapped(aMenuBar->TopLevelWindow()) ||
+        mMenuBarRegistrationCancellables.Get(aMenuBar, nullptr)) {
+        // Don't go further if we don't have a proxy for the shell menu
+        // service, the window isn't mapped or there is a request in progress.
+        return;
+    }
+
+    uint32_t xid = aMenuBar->WindowId();
+    nsCString path = aMenuBar->ObjectPath();
+    if (xid == 0 || path.IsEmpty()) {
+        NS_WARNING("Menubar has invalid XID or object path");
+        return;
+    }
+
+    GCancellable *cancellable = g_cancellable_new();
+    mMenuBarRegistrationCancellables.InsertOrUpdate(aMenuBar, cancellable);
+
+    // We keep a weak ref because we can't assume that GDBus cancellation
+    // is reliable (see https://launchpad.net/bugs/953562)
+
+    g_dbus_proxy_call(mDbusProxy, "RegisterWindow",
+                      g_variant_new("(uo)", xid, path.get()),
+                      G_DBUS_CALL_FLAGS_NONE, -1,
+                      cancellable,
+                      register_native_menubar_cb, aMenuBar);
+}
+
+/* static */ void
+nsNativeMenuService::name_owner_changed_cb(GObject *gobject,
+                                           GParamSpec *pspec,
+                                           gpointer user_data)
+{
+    nsNativeMenuService::GetSingleton()->OnNameOwnerChanged();
+}
+
+/* static */ void
+nsNativeMenuService::proxy_created_cb(GObject *source_object,
+                                      GAsyncResult *res,
+                                      gpointer user_data)
+{
+    GError *error = nullptr;
+    GDBusProxy *proxy = g_dbus_proxy_new_for_bus_finish(res, &error);
+    if (error && g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+        g_error_free(error);
+        return;
+    }
+
+    if (error) {
+        g_error_free(error);
+    }
+
+    // We need this check because we can't assume that GDBus cancellation
+    // is reliable (see https://launchpad.net/bugs/953562)
+    nsNativeMenuService *self = nsNativeMenuService::GetSingleton();
+    if (!self) {
+        if (proxy) {
+            g_object_unref(proxy);
+        }
+        return;
+    }
+
+    self->OnProxyCreated(proxy);
+}
+
+/* static */ void
+nsNativeMenuService::register_native_menubar_cb(GObject *source_object,
+                                                GAsyncResult *res,
+                                                gpointer user_data)
+{
+    nsMenuBar *menuBar = static_cast<nsMenuBar *>(user_data);
+
+    GError *error = nullptr;
+    GVariant *results = g_dbus_proxy_call_finish(G_DBUS_PROXY(source_object),
+                                                 res, &error);
+    if (results) {
+        // There's nothing useful in the response
+        g_variant_unref(results);
+    }
+
+    bool success = error ? false : true;
+    if (error && g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+        g_error_free(error);
+        return;
+    }
+
+    if (error) {
+        g_error_free(error);
+    }
+
+    nsNativeMenuService *self = nsNativeMenuService::GetSingleton();
+    if (!self) {
+        return;
+    }
+
+    self->OnNativeMenuBarRegistered(menuBar, success);
+}
+
+/* static */ gboolean
+nsNativeMenuService::map_event_cb(GtkWidget *widget,
+                                  GdkEvent *event,
+                                  gpointer user_data)
+{
+    nsMenuBar *menubar = static_cast<nsMenuBar *>(user_data);
+    nsNativeMenuService::GetSingleton()->RegisterNativeMenuBar(menubar);
+
+    return FALSE;
+}
+
+void
+nsNativeMenuService::OnNameOwnerChanged()
+{
+    char *owner = g_dbus_proxy_get_name_owner(mDbusProxy);
+    SetOnline(owner ? true : false);
+    g_free(owner);
+}
+
+void
+nsNativeMenuService::OnProxyCreated(GDBusProxy *aProxy)
+{
+    mDbusProxy = aProxy;
+
+    g_object_unref(mCreateProxyCancellable);
+    mCreateProxyCancellable = nullptr;
+
+    if (!mDbusProxy) {
+        SetOnline(false);
+        return;
+    }
+
+    g_signal_connect(mDbusProxy, "notify::g-name-owner",
+                     G_CALLBACK(name_owner_changed_cb), nullptr);
+
+    OnNameOwnerChanged();
+}
+
+void
+nsNativeMenuService::OnNativeMenuBarRegistered(nsMenuBar *aMenuBar,
+                                               bool aSuccess)
+{
+    // Don't assume that GDBus cancellation is reliable (ie, |aMenuBar| might
+    // have already been deleted (see https://launchpad.net/bugs/953562)
+    GCancellable *cancellable = nullptr;
+    if (!mMenuBarRegistrationCancellables.Get(aMenuBar, &cancellable)) {
+        return;
+    }
+
+    g_object_unref(cancellable);
+    mMenuBarRegistrationCancellables.Remove(aMenuBar);
+
+    if (!aSuccess) {
+        aMenuBar->Deactivate();
+    }
+}
+
+/* static */ void
+nsNativeMenuService::PrefChangedCallback(const char *aPref,
+                                         void *aClosure)
+{
+    nsNativeMenuService::GetSingleton()->PrefChanged();
+}
+
+void
+nsNativeMenuService::PrefChanged()
+{
+    if (!mDbusProxy) {
+        SetOnline(false);
+        return;
+    }
+
+    OnNameOwnerChanged();
+}
+
+NS_IMETHODIMP
+nsNativeMenuService::CreateNativeMenuBar(nsIWidget *aParent,
+                                         mozilla::dom::Element *aMenuBarNode)
+{
+    NS_ENSURE_ARG(aParent);
+    NS_ENSURE_ARG(aMenuBarNode);
+
+    if (aMenuBarNode->AttrValueIs(kNameSpaceID_None,
+                                  nsGkAtoms::_moz_menubarkeeplocal,
+                                  nsGkAtoms::_true,
+                                  eCaseMatters)) {
+        return NS_OK;
+    }
+
+    UniquePtr<nsMenuBar> menubar(nsMenuBar::Create(aParent, aMenuBarNode));
+    if (!menubar) {
+        NS_WARNING("Failed to create menubar");
+        return NS_ERROR_FAILURE;
+    }
+
+    // Unity forgets our window if it is unmapped by the application, which
+    // happens with some extensions that add "minimize to tray" type
+    // functionality. We hook on to the MapNotify event to re-register our menu
+    // with Unity
+    g_signal_connect(G_OBJECT(menubar->TopLevelWindow()),
+                     "map-event", G_CALLBACK(map_event_cb),
+                     menubar.get());
+
+    mMenuBars.AppendElement(menubar.get());
+    RegisterNativeMenuBar(menubar.get());
+
+    static_cast<nsWindow *>(aParent)->SetMenuBar(std::move(menubar));
+
+    return NS_OK;
+}
+
+/* static */ already_AddRefed<nsNativeMenuService>
+nsNativeMenuService::GetInstanceForServiceManager()
+{
+    RefPtr<nsNativeMenuService> service(sService);
+
+    if (service) {
+        return service.forget();
+    }
+
+    service = new nsNativeMenuService();
+
+    if (NS_FAILED(service->Init())) {
+        return nullptr;
+    }
+
+    sService = service.get();
+    return service.forget();
+}
+
+/* static */ nsNativeMenuService*
+nsNativeMenuService::GetSingleton()
+{
+    EnsureInitialized();
+    return sService;
+}
+
+void
+nsNativeMenuService::NotifyNativeMenuBarDestroyed(nsMenuBar *aMenuBar)
+{
+    g_signal_handlers_disconnect_by_func(aMenuBar->TopLevelWindow(),
+                                         FuncToGpointer(map_event_cb),
+                                         aMenuBar);
+
+    mMenuBars.RemoveElement(aMenuBar);
+
+    GCancellable *cancellable = nullptr;
+    if (mMenuBarRegistrationCancellables.Get(aMenuBar, &cancellable)) {
+        mMenuBarRegistrationCancellables.Remove(aMenuBar);
+        g_cancellable_cancel(cancellable);
+        g_object_unref(cancellable);
+    }
+}
diff --git a/widget/gtk/nsNativeMenuService.h b/widget/gtk/nsNativeMenuService.h
new file mode 100644
index 0000000000..2e0d429edd
--- /dev/null
+++ b/widget/gtk/nsNativeMenuService.h
@@ -0,0 +1,85 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsNativeMenuService_h__
+#define __nsNativeMenuService_h__
+
+#include "mozilla/Attributes.h"
+#include "nsCOMPtr.h"
+#include "nsTHashMap.h"
+#include "nsINativeMenuService.h"
+#include "nsTArray.h"
+
+#include <gdk/gdk.h>
+#include <gio/gio.h>
+#include <gtk/gtk.h>
+
+class nsMenuBar;
+
+/*
+ * The main native menu service singleton.
+ * NativeMenuSupport::CreateNativeMenuBar calls in to this when a new top level
+ * window is created.
+ *
+ * Menubars are owned by their nsWindow. This service holds a weak reference to
+ * each menubar for the purpose of re-registering them with the shell if it
+ * needs to. The menubar is responsible for notifying the service when the last
+ * reference to it is dropped.
+ */
+class nsNativeMenuService final : public nsINativeMenuService
+{
+public:
+    NS_DECL_ISUPPORTS
+
+    NS_IMETHOD CreateNativeMenuBar(nsIWidget* aParent, mozilla::dom::Element* aMenuBarNode) override;
+
+    // Returns the singleton addref'd for the service manager
+    static already_AddRefed<nsNativeMenuService> GetInstanceForServiceManager();
+
+    // Returns the singleton without increasing the reference count
+    static nsNativeMenuService* GetSingleton();
+
+    // Called by a menubar when it is deleted
+    void NotifyNativeMenuBarDestroyed(nsMenuBar *aMenuBar);
+
+private:
+    nsNativeMenuService();
+    ~nsNativeMenuService();
+    nsresult Init();
+
+    static void EnsureInitialized();
+    void SetOnline(bool aOnline);
+    void RegisterNativeMenuBar(nsMenuBar *aMenuBar);
+    static void name_owner_changed_cb(GObject *gobject,
+                                      GParamSpec *pspec,
+                                      gpointer user_data);
+    static void proxy_created_cb(GObject *source_object,
+                                 GAsyncResult *res,
+                                 gpointer user_data);
+    static void register_native_menubar_cb(GObject *source_object,
+                                           GAsyncResult *res,
+                                           gpointer user_data);
+    static gboolean map_event_cb(GtkWidget *widget, GdkEvent *event,
+                                 gpointer user_data);
+    void OnNameOwnerChanged();
+    void OnProxyCreated(GDBusProxy *aProxy);
+    void OnNativeMenuBarRegistered(nsMenuBar *aMenuBar,
+                                   bool aSuccess);
+    static void PrefChangedCallback(const char *aPref, void *aClosure);
+    void PrefChanged();
+
+    GCancellable *mCreateProxyCancellable;
+    GDBusProxy *mDbusProxy;
+    bool mOnline;
+    nsTArray<nsMenuBar *> mMenuBars;
+    nsTHashMap<nsPtrHashKey<nsMenuBar>, GCancellable*> mMenuBarRegistrationCancellables;
+
+    static bool sShutdown;
+    static nsNativeMenuService *sService;
+};
+
+#endif /* __nsNativeMenuService_h__ */
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
index c09386caef..5b63f588e5 100644
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -7121,6 +7121,10 @@ void nsWindow::HideWindowChrome(bool aShouldHide) {
   SetWindowDecoration(aShouldHide ? eBorderStyle_none : mBorderStyle);
 }
 
+void nsWindow::SetMenuBar(UniquePtr<nsMenuBar> aMenuBar) {
+  mMenuBar = std::move(aMenuBar);
+}
+
 bool nsWindow::CheckForRollup(gdouble aMouseX, gdouble aMouseY, bool aIsWheel,
                               bool aAlwaysRollup) {
   nsIRollupListener* rollupListener = GetActiveRollupListener();
diff --git a/widget/gtk/nsWindow.cpp.orig b/widget/gtk/nsWindow.cpp.orig
new file mode 100644
index 0000000000..c09386caef
--- /dev/null
+++ b/widget/gtk/nsWindow.cpp.orig
@@ -0,0 +1,9361 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:expandtab:shiftwidth=2:tabstop=2:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsWindow.h"
+
+#include <algorithm>
+#include <dlfcn.h>
+#include <gdk/gdkkeysyms.h>
+#include <wchar.h>
+
+#include "gfx2DGlue.h"
+#include "gfxContext.h"
+#include "gfxImageSurface.h"
+#include "gfxPlatformGtk.h"
+#include "gfxUtils.h"
+#include "GLContextProvider.h"
+#include "GLContext.h"
+#include "GtkCompositorWidget.h"
+#include "gtkdrawing.h"
+#include "imgIContainer.h"
+#include "InputData.h"
+#include "Layers.h"
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/Assertions.h"
+#include "mozilla/Components.h"
+#include "mozilla/GRefPtr.h"
+#include "mozilla/dom/Document.h"
+#include "mozilla/dom/WheelEventBinding.h"
+#include "mozilla/gfx/2D.h"
+#include "mozilla/gfx/gfxVars.h"
+#include "mozilla/gfx/GPUProcessManager.h"
+#include "mozilla/gfx/HelpersCairo.h"
+#include "mozilla/layers/LayersTypes.h"
+#include "mozilla/layers/CompositorBridgeChild.h"
+#include "mozilla/layers/CompositorBridgeParent.h"
+#include "mozilla/layers/CompositorThread.h"
+#include "mozilla/layers/KnowsCompositor.h"
+#include "mozilla/layers/WebRenderBridgeChild.h"
+#include "mozilla/layers/WebRenderLayerManager.h"
+#include "mozilla/layers/APZInputBridge.h"
+#include "mozilla/layers/IAPZCTreeManager.h"
+#include "mozilla/Likely.h"
+#include "mozilla/MiscEvents.h"
+#include "mozilla/MouseEvents.h"
+#include "mozilla/NativeKeyBindingsType.h"
+#include "mozilla/Preferences.h"
+#include "mozilla/PresShell.h"
+#include "mozilla/ProfilerLabels.h"
+#include "mozilla/ScopeExit.h"
+#include "mozilla/StaticPrefs_apz.h"
+#include "mozilla/StaticPrefs_mozilla.h"
+#include "mozilla/StaticPrefs_ui.h"
+#include "mozilla/StaticPrefs_widget.h"
+#include "mozilla/TextEventDispatcher.h"
+#include "mozilla/TextEvents.h"
+#include "mozilla/TimeStamp.h"
+#include "mozilla/UniquePtrExtensions.h"
+#include "mozilla/WidgetUtils.h"
+#include "mozilla/WritingModes.h"
+#ifdef MOZ_X11
+#  include "mozilla/X11Util.h"
+#endif
+#include "mozilla/XREAppData.h"
+#include "NativeKeyBindings.h"
+#include "nsAppDirectoryServiceDefs.h"
+#include "nsAppRunner.h"
+#include "nsDragService.h"
+#include "nsGTKToolkit.h"
+#include "nsGtkKeyUtils.h"
+#include "nsGtkCursors.h"
+#include "nsGfxCIID.h"
+#include "nsGtkUtils.h"
+#include "nsIFile.h"
+#include "nsIGSettingsService.h"
+#include "nsIInterfaceRequestorUtils.h"
+#include "nsImageToPixbuf.h"
+#include "nsINode.h"
+#include "nsIRollupListener.h"
+#include "nsIScreenManager.h"
+#include "nsIUserIdleServiceInternal.h"
+#include "nsIWidgetListener.h"
+#include "nsLayoutUtils.h"
+#include "nsMenuPopupFrame.h"
+#include "nsPresContext.h"
+#include "nsShmImage.h"
+#include "nsString.h"
+#include "nsWidgetsCID.h"
+#include "nsViewManager.h"
+#include "nsXPLookAndFeel.h"
+#include "prlink.h"
+#include "ScreenHelperGTK.h"
+#include "SystemTimeConverter.h"
+#include "WidgetUtilsGtk.h"
+
+#ifdef ACCESSIBILITY
+#  include "mozilla/a11y/LocalAccessible.h"
+#  include "mozilla/a11y/Platform.h"
+#  include "nsAccessibilityService.h"
+#endif
+
+#ifdef MOZ_X11
+#  include <gdk/gdkkeysyms-compat.h>
+#  include <X11/Xatom.h>
+#  include <X11/extensions/XShm.h>
+#  include <X11/extensions/shape.h>
+#  include "gfxXlibSurface.h"
+#  include "GLContextGLX.h"  // for GLContextGLX::FindVisual()
+#  include "GLContextEGL.h"  // for GLContextEGL::FindVisual()
+#  include "WindowSurfaceX11Image.h"
+#  include "WindowSurfaceX11SHM.h"
+#endif
+#ifdef MOZ_WAYLAND
+#  include <gdk/gdkkeysyms-compat.h>
+#  include "nsIClipboard.h"
+#  include "nsView.h"
+#endif
+
+using namespace mozilla;
+using namespace mozilla::gfx;
+using namespace mozilla::layers;
+using namespace mozilla::widget;
+#ifdef MOZ_X11
+using mozilla::gl::GLContextEGL;
+using mozilla::gl::GLContextGLX;
+#endif
+
+// Don't put more than this many rects in the dirty region, just fluff
+// out to the bounding-box if there are more
+#define MAX_RECTS_IN_REGION 100
+
+#if !GTK_CHECK_VERSION(3, 18, 0)
+
+struct _GdkEventTouchpadPinch {
+  GdkEventType type;
+  GdkWindow* window;
+  gint8 send_event;
+  gint8 phase;
+  gint8 n_fingers;
+  guint32 time;
+  gdouble x;
+  gdouble y;
+  gdouble dx;
+  gdouble dy;
+  gdouble angle_delta;
+  gdouble scale;
+  gdouble x_root, y_root;
+  guint state;
+};
+
+typedef enum {
+  GDK_TOUCHPAD_GESTURE_PHASE_BEGIN,
+  GDK_TOUCHPAD_GESTURE_PHASE_UPDATE,
+  GDK_TOUCHPAD_GESTURE_PHASE_END,
+  GDK_TOUCHPAD_GESTURE_PHASE_CANCEL
+} GdkTouchpadGesturePhase;
+
+GdkEventMask GDK_TOUCHPAD_GESTURE_MASK = static_cast<GdkEventMask>(1 << 24);
+GdkEventType GDK_TOUCHPAD_PINCH = static_cast<GdkEventType>(42);
+
+#endif
+
+const gint kEvents = GDK_TOUCHPAD_GESTURE_MASK | GDK_EXPOSURE_MASK |
+                     GDK_STRUCTURE_MASK | GDK_VISIBILITY_NOTIFY_MASK |
+                     GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
+                     GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+                     GDK_SMOOTH_SCROLL_MASK | GDK_TOUCH_MASK | GDK_SCROLL_MASK |
+                     GDK_POINTER_MOTION_MASK | GDK_PROPERTY_CHANGE_MASK;
+
+/* utility functions */
+static bool is_mouse_in_window(GdkWindow* aWindow, gdouble aMouseX,
+                               gdouble aMouseY);
+static nsWindow* get_window_for_gtk_widget(GtkWidget* widget);
+static nsWindow* get_window_for_gdk_window(GdkWindow* window);
+static GtkWidget* get_gtk_widget_for_gdk_window(GdkWindow* window);
+static GdkCursor* get_gtk_cursor(nsCursor aCursor);
+static GdkWindow* get_inner_gdk_window(GdkWindow* aWindow, gint x, gint y,
+                                       gint* retx, gint* rety);
+
+static int is_parent_ungrab_enter(GdkEventCrossing* aEvent);
+static int is_parent_grab_leave(GdkEventCrossing* aEvent);
+
+/* callbacks from widgets */
+static gboolean expose_event_cb(GtkWidget* widget, cairo_t* cr);
+static gboolean configure_event_cb(GtkWidget* widget, GdkEventConfigure* event);
+static void widget_map_cb(GtkWidget* widget);
+static void widget_unrealize_cb(GtkWidget* widget);
+static void size_allocate_cb(GtkWidget* widget, GtkAllocation* allocation);
+static void toplevel_window_size_allocate_cb(GtkWidget* widget,
+                                             GtkAllocation* allocation);
+static gboolean delete_event_cb(GtkWidget* widget, GdkEventAny* event);
+static gboolean enter_notify_event_cb(GtkWidget* widget,
+                                      GdkEventCrossing* event);
+static gboolean leave_notify_event_cb(GtkWidget* widget,
+                                      GdkEventCrossing* event);
+static gboolean motion_notify_event_cb(GtkWidget* widget,
+                                       GdkEventMotion* event);
+MOZ_CAN_RUN_SCRIPT static gboolean button_press_event_cb(GtkWidget* widget,
+                                                         GdkEventButton* event);
+static gboolean button_release_event_cb(GtkWidget* widget,
+                                        GdkEventButton* event);
+static gboolean focus_in_event_cb(GtkWidget* widget, GdkEventFocus* event);
+static gboolean focus_out_event_cb(GtkWidget* widget, GdkEventFocus* event);
+static gboolean key_press_event_cb(GtkWidget* widget, GdkEventKey* event);
+static gboolean key_release_event_cb(GtkWidget* widget, GdkEventKey* event);
+static gboolean property_notify_event_cb(GtkWidget* widget,
+                                         GdkEventProperty* event);
+static gboolean scroll_event_cb(GtkWidget* widget, GdkEventScroll* event);
+
+static void hierarchy_changed_cb(GtkWidget* widget,
+                                 GtkWidget* previous_toplevel);
+static gboolean window_state_event_cb(GtkWidget* widget,
+                                      GdkEventWindowState* event);
+static void settings_xft_dpi_changed_cb(GtkSettings* settings,
+                                        GParamSpec* pspec, nsWindow* data);
+static void check_resize_cb(GtkContainer* container, gpointer user_data);
+static void screen_composited_changed_cb(GdkScreen* screen, gpointer user_data);
+static void widget_composited_changed_cb(GtkWidget* widget, gpointer user_data);
+
+static void scale_changed_cb(GtkWidget* widget, GParamSpec* aPSpec,
+                             gpointer aPointer);
+static gboolean touch_event_cb(GtkWidget* aWidget, GdkEventTouch* aEvent);
+static gboolean generic_event_cb(GtkWidget* widget, GdkEvent* aEvent);
+
+static nsWindow* GetFirstNSWindowForGDKWindow(GdkWindow* aGdkWindow);
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#ifdef MOZ_X11
+static GdkFilterReturn popup_take_focus_filter(GdkXEvent* gdk_xevent,
+                                               GdkEvent* event, gpointer data);
+#endif /* MOZ_X11 */
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+static gboolean drag_motion_event_cb(GtkWidget* aWidget,
+                                     GdkDragContext* aDragContext, gint aX,
+                                     gint aY, guint aTime, gpointer aData);
+static void drag_leave_event_cb(GtkWidget* aWidget,
+                                GdkDragContext* aDragContext, guint aTime,
+                                gpointer aData);
+static gboolean drag_drop_event_cb(GtkWidget* aWidget,
+                                   GdkDragContext* aDragContext, gint aX,
+                                   gint aY, guint aTime, gpointer aData);
+static void drag_data_received_event_cb(GtkWidget* aWidget,
+                                        GdkDragContext* aDragContext, gint aX,
+                                        gint aY,
+                                        GtkSelectionData* aSelectionData,
+                                        guint aInfo, guint32 aTime,
+                                        gpointer aData);
+
+/* initialization static functions */
+static nsresult initialize_prefs(void);
+
+static guint32 sLastUserInputTime = GDK_CURRENT_TIME;
+static guint32 sRetryGrabTime;
+
+static SystemTimeConverter<guint32>& TimeConverter() {
+  static SystemTimeConverter<guint32> sTimeConverterSingleton;
+  return sTimeConverterSingleton;
+}
+
+bool nsWindow::sTransparentMainWindow = false;
+
+namespace mozilla {
+
+#ifdef MOZ_X11
+class CurrentX11TimeGetter {
+ public:
+  explicit CurrentX11TimeGetter(GdkWindow* aWindow)
+      : mWindow(aWindow), mAsyncUpdateStart() {}
+
+  guint32 GetCurrentTime() const { return gdk_x11_get_server_time(mWindow); }
+
+  void GetTimeAsyncForPossibleBackwardsSkew(const TimeStamp& aNow) {
+    // Check for in-flight request
+    if (!mAsyncUpdateStart.IsNull()) {
+      return;
+    }
+    mAsyncUpdateStart = aNow;
+
+    Display* xDisplay = GDK_WINDOW_XDISPLAY(mWindow);
+    Window xWindow = GDK_WINDOW_XID(mWindow);
+    unsigned char c = 'a';
+    Atom timeStampPropAtom = TimeStampPropAtom();
+    XChangeProperty(xDisplay, xWindow, timeStampPropAtom, timeStampPropAtom, 8,
+                    PropModeReplace, &c, 1);
+    XFlush(xDisplay);
+  }
+
+  gboolean PropertyNotifyHandler(GtkWidget* aWidget, GdkEventProperty* aEvent) {
+    if (aEvent->atom != gdk_x11_xatom_to_atom(TimeStampPropAtom())) {
+      return FALSE;
+    }
+
+    guint32 eventTime = aEvent->time;
+    TimeStamp lowerBound = mAsyncUpdateStart;
+
+    TimeConverter().CompensateForBackwardsSkew(eventTime, lowerBound);
+    mAsyncUpdateStart = TimeStamp();
+    return TRUE;
+  }
+
+ private:
+  static Atom TimeStampPropAtom() {
+    return gdk_x11_get_xatom_by_name_for_display(gdk_display_get_default(),
+                                                 "GDK_TIMESTAMP_PROP");
+  }
+
+  // This is safe because this class is stored as a member of mWindow and
+  // won't outlive it.
+  GdkWindow* mWindow;
+  TimeStamp mAsyncUpdateStart;
+};
+#endif
+
+}  // namespace mozilla
+
+// The window from which the focus manager asks us to dispatch key events.
+static nsWindow* gFocusWindow = nullptr;
+static bool gBlockActivateEvent = false;
+static bool gGlobalsInitialized = false;
+static bool gUseAspectRatio = true;
+static uint32_t gLastTouchID = 0;
+
+#define NS_WINDOW_TITLE_MAX_LENGTH 4095
+#define kWindowPositionSlop 20
+
+// cursor cache
+static GdkCursor* gCursorCache[eCursorCount];
+
+// Sometimes this actually also includes the state of the modifier keys, but
+// only the button state bits are used.
+static guint gButtonState;
+
+static inline int32_t GetBitmapStride(int32_t width) {
+#if defined(MOZ_X11)
+  return (width + 7) / 8;
+#else
+  return cairo_format_stride_for_width(CAIRO_FORMAT_A1, width);
+#endif
+}
+
+static inline bool TimestampIsNewerThan(guint32 a, guint32 b) {
+  // Timestamps are just the least significant bits of a monotonically
+  // increasing function, and so the use of unsigned overflow arithmetic.
+  return a - b <= G_MAXUINT32 / 2;
+}
+
+static void UpdateLastInputEventTime(void* aGdkEvent) {
+  nsCOMPtr<nsIUserIdleServiceInternal> idleService =
+      do_GetService("@mozilla.org/widget/useridleservice;1");
+  if (idleService) {
+    idleService->ResetIdleTimeOut(0);
+  }
+
+  guint timestamp = gdk_event_get_time(static_cast<GdkEvent*>(aGdkEvent));
+  if (timestamp == GDK_CURRENT_TIME) return;
+
+  sLastUserInputTime = timestamp;
+}
+
+nsWindow::nsWindow()
+    : mIsDestroyed(false),
+      mNeedsDispatchResized(false),
+      mIsShown(false),
+      mNeedsShow(false),
+      mIsMapped(false),
+      mEnabled(true),
+      mCreated(false),
+      mHandleTouchEvent(false),
+      mIsDragPopup(false),
+      mWindowScaleFactorChanged(true),
+      mCompositedScreen(gdk_screen_is_composited(gdk_screen_get_default())),
+      mIsAccelerated(false),
+      mWindowShouldStartDragging(false),
+      mHasMappedToplevel(false),
+      mRetryPointerGrab(false),
+      mDrawToContainer(false),
+      mTitlebarBackdropState(false),
+      mIsPIPWindow(false),
+      mIsWaylandPanelWindow(false),
+      mIsChildWindow(false),
+      mAlwaysOnTop(false),
+      mNoAutoHide(false),
+      mMouseTransparent(false),
+      mIsTransparent(false),
+      mBoundsAreValid(true),
+      mPopupTrackInHierarchy(false),
+      mPopupTrackInHierarchyConfigured(false),
+      mHiddenPopupPositioned(false),
+      mTransparencyBitmapForTitlebar(false),
+      mHasAlphaVisual(false),
+      mPopupAnchored(false),
+      mPopupContextMenu(false),
+      mPopupMatchesLayout(false),
+      mPopupChanged(false),
+      mPopupTemporaryHidden(false),
+      mPopupClosed(false),
+      mPopupUseMoveToRect(false),
+      mWaitingForMoveToRectCallback(false),
+      mConfiguredClearColor(false),
+      mGotNonBlankPaint(false) {
+  mWindowType = eWindowType_child;
+  mSizeConstraints.mMaxSize = GetSafeWindowSize(mSizeConstraints.mMaxSize);
+
+  if (!gGlobalsInitialized) {
+    gGlobalsInitialized = true;
+
+    // It's OK if either of these fail, but it may not be one day.
+    initialize_prefs();
+
+#ifdef MOZ_WAYLAND
+    // Wayland provides clipboard data to application on focus-in event
+    // so we need to init our clipboard hooks before we create window
+    // and get focus.
+    if (GdkIsWaylandDisplay()) {
+      nsCOMPtr<nsIClipboard> clipboard =
+          do_GetService("@mozilla.org/widget/clipboard;1");
+      NS_ASSERTION(clipboard, "Failed to init clipboard!");
+    }
+#endif
+  }
+}
+
+nsWindow::~nsWindow() {
+  LOG("nsWindow::~nsWindow()");
+
+  delete[] mTransparencyBitmap;
+  mTransparencyBitmap = nullptr;
+
+  Destroy();
+}
+
+/* static */
+void nsWindow::ReleaseGlobals() {
+  for (auto& cursor : gCursorCache) {
+    if (cursor) {
+      g_object_unref(cursor);
+      cursor = nullptr;
+    }
+  }
+}
+
+void nsWindow::DispatchActivateEvent(void) {
+  NS_ASSERTION(mContainer || mIsDestroyed,
+               "DispatchActivateEvent only intended for container windows");
+
+#ifdef ACCESSIBILITY
+  DispatchActivateEventAccessible();
+#endif  // ACCESSIBILITY
+
+  if (mWidgetListener) mWidgetListener->WindowActivated();
+}
+
+void nsWindow::DispatchDeactivateEvent(void) {
+  if (mWidgetListener) mWidgetListener->WindowDeactivated();
+
+#ifdef ACCESSIBILITY
+  DispatchDeactivateEventAccessible();
+#endif  // ACCESSIBILITY
+}
+
+void nsWindow::DispatchResized() {
+  LOG("nsWindow::DispatchResized() size [%d, %d]", (int)(mBounds.width),
+      (int)(mBounds.height));
+
+  mNeedsDispatchResized = false;
+  if (mWidgetListener) {
+    mWidgetListener->WindowResized(this, mBounds.width, mBounds.height);
+  }
+  if (mAttachedWidgetListener) {
+    mAttachedWidgetListener->WindowResized(this, mBounds.width, mBounds.height);
+  }
+}
+
+void nsWindow::MaybeDispatchResized() {
+  if (mNeedsDispatchResized && !mIsDestroyed) {
+    DispatchResized();
+  }
+}
+
+nsIWidgetListener* nsWindow::GetListener() {
+  return mAttachedWidgetListener ? mAttachedWidgetListener : mWidgetListener;
+}
+
+nsresult nsWindow::DispatchEvent(WidgetGUIEvent* aEvent,
+                                 nsEventStatus& aStatus) {
+#ifdef DEBUG
+  debug_DumpEvent(stdout, aEvent->mWidget, aEvent, "something", 0);
+#endif
+  aStatus = nsEventStatus_eIgnore;
+  nsIWidgetListener* listener = GetListener();
+  if (listener) {
+    aStatus = listener->HandleEvent(aEvent, mUseAttachedEvents);
+  }
+
+  return NS_OK;
+}
+
+void nsWindow::OnDestroy(void) {
+  if (mOnDestroyCalled) return;
+
+  mOnDestroyCalled = true;
+
+  // Prevent deletion.
+  nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
+
+  // release references to children, device context, toolkit + app shell
+  nsBaseWidget::OnDestroy();
+
+  // Remove association between this object and its parent and siblings.
+  nsBaseWidget::Destroy();
+  mParent = nullptr;
+
+  NotifyWindowDestroyed();
+}
+
+bool nsWindow::AreBoundsSane() {
+  return mBounds.width > 0 && mBounds.height > 0;
+}
+
+// Walk the list of child windows and call destroy on them.
+void nsWindow::DestroyChildWindows() {
+  LOG("nsWindow::DestroyChildWindows()");
+  if (!mGdkWindow) {
+    return;
+  }
+  while (GList* children = gdk_window_peek_children(mGdkWindow)) {
+    GdkWindow* child = GDK_WINDOW(children->data);
+    nsWindow* kid = get_window_for_gdk_window(child);
+    if (kid) {
+      kid->Destroy();
+    }
+  }
+}
+
+void nsWindow::Destroy() {
+  MOZ_DIAGNOSTIC_ASSERT(NS_IsMainThread());
+
+  if (mIsDestroyed || !mCreated) return;
+
+  LOG("nsWindow::Destroy\n");
+
+  // Clear up WebRender queue
+  RevokeTransactionIdAllocator();
+
+  DisableRenderingToWindow();
+
+  mIsDestroyed = true;
+  mCreated = false;
+
+  /** Need to clean our LayerManager up while still alive */
+  if (mWindowRenderer) {
+    mWindowRenderer->Destroy();
+  }
+  mWindowRenderer = nullptr;
+
+#ifdef MOZ_WAYLAND
+  // Shut down our local vsync source
+  if (mWaylandVsyncSource) {
+    mWaylandVsyncSource->Shutdown();
+    mWaylandVsyncSource = nullptr;
+  }
+  g_clear_pointer(&mXdgToken, xdg_activation_token_v1_destroy);
+#endif
+
+  if (mCompositorPauseTimeoutID) {
+    g_source_remove(mCompositorPauseTimeoutID);
+    mCompositorPauseTimeoutID = 0;
+  }
+
+  // It is safe to call DestroyeCompositor several times (here and
+  // in the parent class) since it will take effect only once.
+  // The reason we call it here is because on gtk platforms we need
+  // to destroy the compositor before we destroy the gdk window (which
+  // destroys the the gl context attached to it).
+  DestroyCompositor();
+
+  // Ensure any resources assigned to the window get cleaned up first
+  // to avoid double-freeing.
+  mSurfaceProvider.CleanupResources();
+
+  g_signal_handlers_disconnect_by_data(gtk_settings_get_default(), this);
+
+  nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
+  if (rollupListener) {
+    nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
+    if (static_cast<nsIWidget*>(this) == rollupWidget) {
+      rollupListener->Rollup(0, false, nullptr, nullptr);
+    }
+  }
+
+  // dragService will be null after shutdown of the service manager.
+  RefPtr<nsDragService> dragService = nsDragService::GetInstance();
+  if (dragService && this == dragService->GetMostRecentDestWindow()) {
+    dragService->ScheduleLeaveEvent();
+  }
+
+  NativeShow(false);
+
+  if (mIMContext) {
+    mIMContext->OnDestroyWindow(this);
+  }
+
+  // make sure that we remove ourself as the focus window
+  if (gFocusWindow == this) {
+    LOG("automatically losing focus...\n");
+    gFocusWindow = nullptr;
+  }
+
+  gtk_widget_destroy(mShell);
+  mShell = nullptr;
+  mContainer = nullptr;
+
+  MOZ_ASSERT(!mGdkWindow,
+             "mGdkWindow should be NULL when mContainer is destroyed");
+
+#ifdef ACCESSIBILITY
+  if (mRootAccessible) {
+    mRootAccessible = nullptr;
+  }
+#endif
+
+  // Save until last because OnDestroy() may cause us to be deleted.
+  OnDestroy();
+}
+
+nsIWidget* nsWindow::GetParent() { return mParent; }
+
+float nsWindow::GetDPI() {
+  float dpi = 96.0f;
+  nsCOMPtr<nsIScreen> screen = GetWidgetScreen();
+  if (screen) {
+    screen->GetDpi(&dpi);
+  }
+  return dpi;
+}
+
+double nsWindow::GetDefaultScaleInternal() {
+  return FractionalScaleFactor() * gfxPlatformGtk::GetFontScaleFactor();
+}
+
+DesktopToLayoutDeviceScale nsWindow::GetDesktopToDeviceScale() {
+#ifdef MOZ_WAYLAND
+  if (GdkIsWaylandDisplay()) {
+    return DesktopToLayoutDeviceScale(GdkCeiledScaleFactor());
+  }
+#endif
+
+  // In Gtk/X11, we manage windows using device pixels.
+  return DesktopToLayoutDeviceScale(1.0);
+}
+
+DesktopToLayoutDeviceScale nsWindow::GetDesktopToDeviceScaleByScreen() {
+#ifdef MOZ_WAYLAND
+  // In Wayland there's no way to get absolute position of the window and use it
+  // to determine the screen factor of the monitor on which the window is
+  // placed. The window is notified of the current scale factor but not at this
+  // point, so the GdkScaleFactor can return wrong value which can lead to wrong
+  // popup placement. We need to use parent's window scale factor for the new
+  // one.
+  if (GdkIsWaylandDisplay()) {
+    nsView* view = nsView::GetViewFor(this);
+    if (view) {
+      nsView* parentView = view->GetParent();
+      if (parentView) {
+        nsIWidget* parentWidget = parentView->GetNearestWidget(nullptr);
+        if (parentWidget) {
+          return DesktopToLayoutDeviceScale(
+              parentWidget->RoundsWidgetCoordinatesTo());
+        }
+        NS_WARNING("Widget has no parent");
+      }
+    } else {
+      NS_WARNING("Cannot find widget view");
+    }
+  }
+#endif
+  return nsBaseWidget::GetDesktopToDeviceScale();
+}
+
+// Reparent a child window to a new parent.
+void nsWindow::SetParent(nsIWidget* aNewParent) {
+  LOG("nsWindow::SetParent() new parent %p", aNewParent);
+  if (!mIsChildWindow) {
+    NS_WARNING("Used by child widgets only");
+    return;
+  }
+
+  nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
+  if (mParent) {
+    mParent->RemoveChild(this);
+  }
+  mParent = aNewParent;
+
+  // We're already deleted, quit.
+  if (!mGdkWindow || mIsDestroyed || !aNewParent) {
+    return;
+  }
+  aNewParent->AddChild(this);
+
+  auto* newParent = static_cast<nsWindow*>(aNewParent);
+
+  // New parent is deleted, quit.
+  if (newParent->mIsDestroyed) {
+    Destroy();
+    return;
+  }
+
+  GdkWindow* window = GetToplevelGdkWindow();
+  GdkWindow* parentWindow = newParent->GetToplevelGdkWindow();
+  LOG("  child GdkWindow %p set parent GdkWindow %p", window, parentWindow);
+  gdk_window_reparent(window, parentWindow, 0, 0);
+
+  bool parentHasMappedToplevel = newParent && newParent->mHasMappedToplevel;
+  if (mHasMappedToplevel != parentHasMappedToplevel) {
+    SetHasMappedToplevel(parentHasMappedToplevel);
+  }
+}
+
+bool nsWindow::WidgetTypeSupportsAcceleration() {
+  if (mWindowType == eWindowType_invisible) {
+    return false;
+  }
+
+  if (IsSmallPopup()) {
+    return false;
+  }
+  // Workaround for Bug 1479135
+  // We draw transparent popups on non-compositing screens by SW as we don't
+  // implement X shape masks in WebRender.
+  if (mWindowType == eWindowType_popup) {
+    return HasRemoteContent() && mCompositedScreen;
+  }
+
+  return true;
+}
+
+void nsWindow::ReparentNativeWidget(nsIWidget* aNewParent) {
+  MOZ_ASSERT(aNewParent, "null widget");
+  MOZ_ASSERT(!mIsDestroyed, "");
+  MOZ_ASSERT(!static_cast<nsWindow*>(aNewParent)->mIsDestroyed, "");
+  MOZ_ASSERT(
+      !mParent,
+      "nsWindow::ReparentNativeWidget() works on toplevel windows only.");
+
+  auto* newParent = static_cast<nsWindow*>(aNewParent);
+  GtkWindow* newParentWidget = GTK_WINDOW(newParent->GetGtkWidget());
+
+  LOG("nsWindow::ReparentNativeWidget new parent %p\n", newParent);
+  gtk_window_set_transient_for(GTK_WINDOW(mShell), newParentWidget);
+}
+
+void nsWindow::SetModal(bool aModal) {
+  LOG("nsWindow::SetModal %d\n", aModal);
+  if (mIsDestroyed) return;
+  gtk_window_set_modal(GTK_WINDOW(mShell), aModal ? TRUE : FALSE);
+}
+
+// nsIWidget method, which means IsShown.
+bool nsWindow::IsVisible() const { return mIsShown; }
+
+void nsWindow::RegisterTouchWindow() {
+  mHandleTouchEvent = true;
+  mTouches.Clear();
+}
+
+void nsWindow::ConstrainPosition(bool aAllowSlop, int32_t* aX, int32_t* aY) {
+  if (!mShell || GdkIsWaylandDisplay()) {
+    return;
+  }
+
+  double dpiScale = GetDefaultScale().scale;
+
+  // we need to use the window size in logical screen pixels
+  int32_t logWidth = std::max(NSToIntRound(mBounds.width / dpiScale), 1);
+  int32_t logHeight = std::max(NSToIntRound(mBounds.height / dpiScale), 1);
+
+  /* get our playing field. use the current screen, or failing that
+    for any reason, use device caps for the default screen. */
+  nsCOMPtr<nsIScreen> screen;
+  nsCOMPtr<nsIScreenManager> screenmgr =
+      do_GetService("@mozilla.org/gfx/screenmanager;1");
+  if (screenmgr) {
+    screenmgr->ScreenForRect(*aX, *aY, logWidth, logHeight,
+                             getter_AddRefs(screen));
+  }
+
+  // We don't have any screen so leave the coordinates as is
+  if (!screen) return;
+
+  nsIntRect screenRect;
+  if (mSizeMode != nsSizeMode_Fullscreen) {
+    // For normalized windows, use the desktop work area.
+    screen->GetAvailRectDisplayPix(&screenRect.x, &screenRect.y,
+                                   &screenRect.width, &screenRect.height);
+  } else {
+    // For full screen windows, use the desktop.
+    screen->GetRectDisplayPix(&screenRect.x, &screenRect.y, &screenRect.width,
+                              &screenRect.height);
+  }
+
+  if (aAllowSlop) {
+    if (*aX < screenRect.x - logWidth + kWindowPositionSlop) {
+      *aX = screenRect.x - logWidth + kWindowPositionSlop;
+    } else if (*aX >= screenRect.XMost() - kWindowPositionSlop) {
+      *aX = screenRect.XMost() - kWindowPositionSlop;
+    }
+
+    if (*aY < screenRect.y - logHeight + kWindowPositionSlop) {
+      *aY = screenRect.y - logHeight + kWindowPositionSlop;
+    } else if (*aY >= screenRect.YMost() - kWindowPositionSlop) {
+      *aY = screenRect.YMost() - kWindowPositionSlop;
+    }
+  } else {
+    if (*aX < screenRect.x) {
+      *aX = screenRect.x;
+    } else if (*aX >= screenRect.XMost() - logWidth) {
+      *aX = screenRect.XMost() - logWidth;
+    }
+
+    if (*aY < screenRect.y) {
+      *aY = screenRect.y;
+    } else if (*aY >= screenRect.YMost() - logHeight) {
+      *aY = screenRect.YMost() - logHeight;
+    }
+  }
+}
+
+void nsWindow::SetSizeConstraints(const SizeConstraints& aConstraints) {
+  mSizeConstraints.mMinSize = GetSafeWindowSize(aConstraints.mMinSize);
+  mSizeConstraints.mMaxSize = GetSafeWindowSize(aConstraints.mMaxSize);
+
+  ApplySizeConstraints();
+}
+
+void nsWindow::AddCSDDecorationSize(int* aWidth, int* aHeight) {
+  if (mSizeState == nsSizeMode_Normal &&
+      mGtkWindowDecoration == GTK_DECORATION_CLIENT && mDrawInTitlebar) {
+    GtkBorder decorationSize = GetCSDDecorationSize(IsPopup());
+    *aWidth += decorationSize.left + decorationSize.right;
+    *aHeight += decorationSize.top + decorationSize.bottom;
+  }
+}
+
+#ifdef MOZ_WAYLAND
+bool nsWindow::GetCSDDecorationOffset(int* aDx, int* aDy) {
+  if (mSizeState == nsSizeMode_Normal &&
+      mGtkWindowDecoration == GTK_DECORATION_CLIENT && mDrawInTitlebar) {
+    GtkBorder decorationSize = GetCSDDecorationSize(IsPopup());
+    *aDx = decorationSize.left;
+    *aDy = decorationSize.top;
+    return true;
+  }
+  return false;
+}
+#endif
+
+void nsWindow::ApplySizeConstraints(void) {
+  if (mShell) {
+    GdkGeometry geometry;
+    geometry.min_width =
+        DevicePixelsToGdkCoordRoundUp(mSizeConstraints.mMinSize.width);
+    geometry.min_height =
+        DevicePixelsToGdkCoordRoundUp(mSizeConstraints.mMinSize.height);
+    geometry.max_width =
+        DevicePixelsToGdkCoordRoundDown(mSizeConstraints.mMaxSize.width);
+    geometry.max_height =
+        DevicePixelsToGdkCoordRoundDown(mSizeConstraints.mMaxSize.height);
+
+    uint32_t hints = 0;
+    if (mSizeConstraints.mMinSize != LayoutDeviceIntSize(0, 0)) {
+      if (GdkIsWaylandDisplay()) {
+        gtk_widget_set_size_request(GTK_WIDGET(mContainer), geometry.min_width,
+                                    geometry.min_height);
+      }
+      AddCSDDecorationSize(&geometry.min_width, &geometry.min_height);
+      hints |= GDK_HINT_MIN_SIZE;
+    }
+    if (mSizeConstraints.mMaxSize !=
+        LayoutDeviceIntSize(NS_MAXSIZE, NS_MAXSIZE)) {
+      AddCSDDecorationSize(&geometry.max_width, &geometry.max_height);
+      hints |= GDK_HINT_MAX_SIZE;
+    }
+
+    if (mAspectRatio != 0.0f) {
+      geometry.min_aspect = mAspectRatio;
+      geometry.max_aspect = mAspectRatio;
+      hints |= GDK_HINT_ASPECT;
+    }
+
+    gtk_window_set_geometry_hints(GTK_WINDOW(mShell), nullptr, &geometry,
+                                  GdkWindowHints(hints));
+  }
+}
+
+void nsWindow::Show(bool aState) {
+  if (aState == mIsShown) return;
+
+  mIsShown = aState;
+
+  LOG("nsWindow::Show state %d frame %s\n", aState, GetFrameTag().get());
+
+  if (aState) {
+    // Now that this window is shown, mHasMappedToplevel needs to be
+    // tracked on viewable descendants.
+    SetHasMappedToplevel(mHasMappedToplevel);
+  }
+
+  // Ok, someone called show on a window that isn't sized to a sane
+  // value.  Mark this window as needing to have Show() called on it
+  // and return.
+  if ((aState && !AreBoundsSane()) || !mCreated) {
+    LOG("\tbounds are insane or window hasn't been created yet\n");
+    mNeedsShow = true;
+    return;
+  }
+
+  // If someone is hiding this widget, clear any needing show flag.
+  if (!aState) mNeedsShow = false;
+
+#ifdef ACCESSIBILITY
+  if (aState && a11y::ShouldA11yBeEnabled()) CreateRootAccessible();
+#endif
+
+  NativeShow(aState);
+}
+
+void nsWindow::ResizeInt(int aX, int aY, int aWidth, int aHeight, bool aMove) {
+  LOG("nsWindow::ResizeInt x:%d y:%d -> w:%d h:%d aMove %d\n", aX, aY, aWidth,
+      aHeight, aMove);
+
+  ConstrainSize(&aWidth, &aHeight);
+
+  LOG("  ConstrainSize: w:%d h;%d\n", aWidth, aHeight);
+
+  if (aMove) {
+    mBounds.x = aX;
+    mBounds.y = aY;
+  }
+
+  // For top-level windows, aWidth and aHeight should possibly be
+  // interpreted as frame bounds, but NativeResize treats these as window
+  // bounds (Bug 581866).
+  mBounds.SizeTo(aWidth, aHeight);
+
+  // We set correct mBounds in advance here. This can be invalided by state
+  // event.
+  mBoundsAreValid = true;
+
+  // Recalculate aspect ratio when resized from DOM
+  if (mAspectRatio != 0.0) {
+    LockAspectRatio(true);
+  }
+
+  if (!mCreated) {
+    return;
+  }
+
+  NativeMoveResize(aMove, true);
+  NotifyRollupGeometryChange();
+
+  DispatchResized();
+}
+
+void nsWindow::Resize(double aWidth, double aHeight, bool aRepaint) {
+  LOG("nsWindow::Resize %f %f\n", aWidth, aHeight);
+
+  double scale =
+      BoundsUseDesktopPixels() ? GetDesktopToDeviceScale().scale : 1.0;
+  int32_t width = NSToIntRound(scale * aWidth);
+  int32_t height = NSToIntRound(scale * aHeight);
+
+  ResizeInt(0, 0, width, height, /* aMove */ false);
+}
+
+void nsWindow::Resize(double aX, double aY, double aWidth, double aHeight,
+                      bool aRepaint) {
+  LOG("nsWindow::Resize [%f,%f] -> [%f x %f] repaint %d\n", aX, aY, aWidth,
+      aHeight, aRepaint);
+
+  double scale =
+      BoundsUseDesktopPixels() ? GetDesktopToDeviceScale().scale : 1.0;
+  int32_t width = NSToIntRound(scale * aWidth);
+  int32_t height = NSToIntRound(scale * aHeight);
+
+  int32_t x = NSToIntRound(scale * aX);
+  int32_t y = NSToIntRound(scale * aY);
+
+  ResizeInt(x, y, width, height, /* aMove */ true);
+}
+
+void nsWindow::Enable(bool aState) { mEnabled = aState; }
+
+bool nsWindow::IsEnabled() const { return mEnabled; }
+
+void nsWindow::Move(double aX, double aY) {
+  double scale =
+      BoundsUseDesktopPixels() ? GetDesktopToDeviceScale().scale : 1.0;
+  int32_t x = NSToIntRound(aX * scale);
+  int32_t y = NSToIntRound(aY * scale);
+
+  LOG("nsWindow::Move to %d %d\n", x, y);
+
+  if (mSizeState != nsSizeMode_Normal && (mWindowType == eWindowType_toplevel ||
+                                          mWindowType == eWindowType_dialog)) {
+    LOG("  size state is not normal, bailing");
+    return;
+  }
+
+  // Since a popup window's x/y coordinates are in relation to to
+  // the parent, the parent might have moved so we always move a
+  // popup window.
+  LOG("  bounds %d %d\n", mBounds.y, mBounds.y);
+  if (x == mBounds.x && y == mBounds.y && mWindowType != eWindowType_popup) {
+    LOG("  position is the same, return\n");
+    return;
+  }
+
+  // XXX Should we do some AreBoundsSane check here?
+
+  mBounds.x = x;
+  mBounds.y = y;
+
+  if (!mCreated) {
+    LOG("  is not created, return.\n");
+    return;
+  }
+
+  NativeMoveResize(/* move */ true, /* resize */ false);
+  NotifyRollupGeometryChange();
+}
+
+bool nsWindow::IsPopup() const { return mWindowType == eWindowType_popup; }
+
+bool nsWindow::IsWaylandPopup() const {
+  return GdkIsWaylandDisplay() && IsPopup();
+}
+
+static nsMenuPopupFrame* GetMenuPopupFrame(nsIFrame* aFrame) {
+  return do_QueryFrame(aFrame);
+}
+
+void nsWindow::AppendPopupToHierarchyList(nsWindow* aToplevelWindow) {
+  mWaylandToplevel = aToplevelWindow;
+
+  nsWindow* popup = aToplevelWindow;
+  while (popup && popup->mWaylandPopupNext) {
+    popup = popup->mWaylandPopupNext;
+  }
+  popup->mWaylandPopupNext = this;
+
+  mWaylandPopupPrev = popup;
+  mWaylandPopupNext = nullptr;
+  mPopupChanged = true;
+  mPopupClosed = false;
+}
+
+void nsWindow::RemovePopupFromHierarchyList() {
+  // We're already removed from the popup hierarchy
+  if (!IsInPopupHierarchy()) {
+    return;
+  }
+  mWaylandPopupPrev->mWaylandPopupNext = mWaylandPopupNext;
+  if (mWaylandPopupNext) {
+    mWaylandPopupNext->mWaylandPopupPrev = mWaylandPopupPrev;
+    mWaylandPopupNext->mPopupChanged = true;
+  }
+  mWaylandPopupNext = mWaylandPopupPrev = nullptr;
+}
+
+void nsWindow::HideWaylandWindow() {
+  LOG("nsWindow::HideWaylandWindow: [%p]\n", this);
+  PauseCompositorHiddenWindow();
+  gtk_widget_hide(mShell);
+}
+
+// Gtk refuses to map popup window with x < 0 && y < 0 relative coordinates
+// see https://gitlab.gnome.org/GNOME/gtk/-/issues/4071
+// as a workaround just fool around and place the popup temporary to 0,0.
+bool nsWindow::WaylandPopupRemoveNegativePosition(int* aX, int* aY) {
+  LOG("nsWindow::WaylandPopupRemoveNegativePosition() [%p]\n", this);
+
+  int x, y;
+  GdkWindow* window = gtk_widget_get_window(mShell);
+  gdk_window_get_origin(window, &x, &y);
+  if (x >= 0 || y >= 0) {
+    LOG("  coordinates are correct");
+    return false;
+  }
+
+  LOG("  wrong coord (%d, %d) move to 0,0", x, y);
+  gdk_window_move(window, 0, 0);
+
+  if (aX) {
+    *aX = x;
+  }
+  if (aY) {
+    *aY = y;
+  }
+
+  return true;
+}
+
+void nsWindow::ShowWaylandWindow() {
+  LOG("nsWindow::ShowWaylandWindow: [%p]\n", this);
+  if (!IsWaylandPopup()) {
+    LOG("  toplevel, show it now");
+    gtk_widget_show(mShell);
+    return;
+  }
+
+  if (!mPopupTrackInHierarchy) {
+    LOG("  popup is not tracked in popup hierarchy, show it now");
+    gtk_widget_show(mShell);
+    return;
+  }
+
+  // Popup position was checked before gdk_window_move_to_rect() callback
+  // so just show it.
+  if (mPopupUseMoveToRect && mWaitingForMoveToRectCallback) {
+    LOG("  active move-to-rect callback, show it as is");
+    gtk_widget_show(mShell);
+    return;
+  }
+
+  if (gtk_widget_is_visible(mShell)) {
+    LOG("  is already visible, quit");
+    return;
+  }
+
+  int x, y;
+  bool moved = WaylandPopupRemoveNegativePosition(&x, &y);
+  gtk_widget_show(mShell);
+  if (moved) {
+    LOG("  move back to (%d, %d) and show", x, y);
+    gdk_window_move(gtk_widget_get_window(mShell), x, y);
+  }
+}
+
+void nsWindow::WaylandPopupMarkAsClosed() {
+  LOG("nsWindow::WaylandPopupMarkAsClosed: [%p]\n", this);
+  mPopupClosed = true;
+  // If we have any child popup window notify it about
+  // parent switch.
+  if (mWaylandPopupNext) {
+    mWaylandPopupNext->mPopupChanged = true;
+  }
+}
+
+nsWindow* nsWindow::WaylandPopupFindLast(nsWindow* aPopup) {
+  while (aPopup && aPopup->mWaylandPopupNext) {
+    aPopup = aPopup->mWaylandPopupNext;
+  }
+  return aPopup;
+}
+
+// Hide and potentially removes popup from popup hierarchy.
+void nsWindow::HideWaylandPopupWindow(bool aTemporaryHide,
+                                      bool aRemoveFromPopupList) {
+  LOG("nsWindow::HideWaylandPopupWindow: remove from list %d\n",
+      aRemoveFromPopupList);
+  if (aRemoveFromPopupList) {
+    RemovePopupFromHierarchyList();
+  }
+
+  if (!mPopupClosed) {
+    mPopupClosed = !aTemporaryHide;
+  }
+
+  bool visible = gtk_widget_is_visible(mShell);
+  LOG("  gtk_widget_is_visible() = %d\n", visible);
+
+  // Restore only popups which are really visible
+  mPopupTemporaryHidden = aTemporaryHide && visible;
+
+  // Hide only visible popups or popups closed pernamently.
+  if (visible) {
+    HideWaylandWindow();
+
+    // If there's pending Move-To-Rect callback and we hide the popup
+    // the callback won't be called any more.
+    mWaitingForMoveToRectCallback = false;
+  }
+
+  if (mPopupClosed) {
+    // Clear rendering transactions of closed window and disable rendering to it
+    // (see https://bugzilla.mozilla.org/show_bug.cgi?id=1717451#c27 for
+    // details).
+    RevokeTransactionIdAllocator();
+
+    LOG("Clearing mMoveToRectPopupSize\n");
+    mMoveToRectPopupSize = {};
+  }
+}
+
+void nsWindow::HideWaylandToplevelWindow() {
+  LOG("nsWindow::HideWaylandToplevelWindow: [%p]\n", this);
+  if (mWaylandPopupNext) {
+    nsWindow* popup = WaylandPopupFindLast(mWaylandPopupNext);
+    while (popup->mWaylandToplevel != nullptr) {
+      nsWindow* prev = popup->mWaylandPopupPrev;
+      popup->HideWaylandPopupWindow(/* aTemporaryHide */ false,
+                                    /* aRemoveFromPopupList */ true);
+      popup = prev;
+    }
+  }
+  HideWaylandWindow();
+}
+
+void nsWindow::WaylandPopupRemoveClosedPopups() {
+  LOG("nsWindow::WaylandPopupRemoveClosedPopups: [%p]\n", this);
+  nsWindow* popup = this;
+  while (popup) {
+    nsWindow* next = popup->mWaylandPopupNext;
+    if (popup->mPopupClosed) {
+      popup->HideWaylandPopupWindow(/* aTemporaryHide */ false,
+                                    /* aRemoveFromPopupList */ true);
+    }
+    popup = next;
+  }
+}
+
+// Hide all tooltips except the latest one.
+void nsWindow::WaylandPopupHideTooltips() {
+  LOG("nsWindow::WaylandPopupHideTooltips");
+  MOZ_ASSERT(mWaylandToplevel == nullptr, "Should be called on toplevel only!");
+
+  nsWindow* popup = mWaylandPopupNext;
+  while (popup && popup->mWaylandPopupNext) {
+    if (popup->mPopupType == ePopupTypeTooltip) {
+      LOG("  hidding tooltip [%p]", popup);
+      popup->WaylandPopupMarkAsClosed();
+    }
+    popup = popup->mWaylandPopupNext;
+  }
+}
+
+// We can't show popups with remote content or overflow popups
+// on top of regular ones.
+// If there's any remote popup opened, close all parent popups of it.
+void nsWindow::CloseAllPopupsBeforeRemotePopup() {
+  LOG("nsWindow::CloseAllPopupsBeforeRemotePopup");
+  MOZ_ASSERT(mWaylandToplevel == nullptr, "Should be called on toplevel only!");
+
+  // Don't waste time when there's only one popup opened.
+  if (!mWaylandPopupNext || mWaylandPopupNext->mWaylandPopupNext == nullptr) {
+    return;
+  }
+
+  // Find the first opened remote content popup
+  nsWindow* remotePopup = mWaylandPopupNext;
+  while (remotePopup) {
+    if (remotePopup->HasRemoteContent() ||
+        remotePopup->IsWidgetOverflowWindow()) {
+      LOG("  remote popup [%p]", remotePopup);
+      break;
+    }
+    remotePopup = remotePopup->mWaylandPopupNext;
+  }
+
+  if (!remotePopup) {
+    return;
+  }
+
+  // ...hide opened popups before the remote one.
+  nsWindow* popup = mWaylandPopupNext;
+  while (popup && popup != remotePopup) {
+    LOG("  hidding popup [%p]", popup);
+    popup->WaylandPopupMarkAsClosed();
+    popup = popup->mWaylandPopupNext;
+  }
+}
+
+static void GetLayoutPopupWidgetChain(
+    nsTArray<nsIWidget*>* aLayoutWidgetHierarchy) {
+  nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
+  pm->GetSubmenuWidgetChain(aLayoutWidgetHierarchy);
+  aLayoutWidgetHierarchy->Reverse();
+}
+
+// Compare 'this' popup position in Wayland widget hierarchy
+// (mWaylandPopupPrev/mWaylandPopupNext) with
+// 'this' popup position in layout hierarchy.
+//
+// When aMustMatchParent is true we also request
+// 'this' parents match, i.e. 'this' has the same parent in
+// both layout and widget hierarchy.
+bool nsWindow::IsPopupInLayoutPopupChain(
+    nsTArray<nsIWidget*>* aLayoutWidgetHierarchy, bool aMustMatchParent) {
+  int len = (int)aLayoutWidgetHierarchy->Length();
+  for (int i = 0; i < len; i++) {
+    if (this == (*aLayoutWidgetHierarchy)[i]) {
+      if (!aMustMatchParent) {
+        return true;
+      }
+
+      // Find correct parent popup for 'this' according to widget
+      // hierarchy. That means we need to skip closed popups.
+      nsWindow* parentPopup = nullptr;
+      if (mWaylandPopupPrev != mWaylandToplevel) {
+        parentPopup = mWaylandPopupPrev;
+        while (parentPopup != mWaylandToplevel && parentPopup->mPopupClosed) {
+          parentPopup = parentPopup->mWaylandPopupPrev;
+        }
+      }
+
+      if (i == 0) {
+        // We found 'this' popups as a first popup in layout hierarchy.
+        // It matches layout hierarchy if it's first widget also in
+        // wayland widget hierarchy (i.e. parent is null).
+        return parentPopup == nullptr;
+      }
+
+      return parentPopup == (*aLayoutWidgetHierarchy)[i - 1];
+    }
+  }
+  return false;
+}
+
+// Hide popups which are not in popup chain.
+void nsWindow::WaylandPopupHierarchyHideByLayout(
+    nsTArray<nsIWidget*>* aLayoutWidgetHierarchy) {
+  LOG("nsWindow::WaylandPopupHierarchyHideByLayout");
+  MOZ_ASSERT(mWaylandToplevel == nullptr, "Should be called on toplevel only!");
+
+  // Hide all popups which are not in layout popup chain
+  nsWindow* popup = mWaylandPopupNext;
+  while (popup) {
+    // Tooltips are not tracked in layout chain
+    if (!popup->mPopupClosed && popup->mPopupType != ePopupTypeTooltip) {
+      if (!popup->IsPopupInLayoutPopupChain(aLayoutWidgetHierarchy,
+                                            /* aMustMatchParent */ false)) {
+        LOG("  hidding popup [%p]", popup);
+        popup->WaylandPopupMarkAsClosed();
+      }
+    }
+    popup = popup->mWaylandPopupNext;
+  }
+}
+
+// Mark popups outside of layout hierarchy
+void nsWindow::WaylandPopupHierarchyValidateByLayout(
+    nsTArray<nsIWidget*>* aLayoutWidgetHierarchy) {
+  LOG("nsWindow::WaylandPopupHierarchyValidateByLayout");
+  nsWindow* popup = mWaylandPopupNext;
+  while (popup) {
+    if (popup->mPopupType == ePopupTypeTooltip) {
+      popup->mPopupMatchesLayout = true;
+    } else if (!popup->mPopupClosed) {
+      popup->mPopupMatchesLayout = popup->IsPopupInLayoutPopupChain(
+          aLayoutWidgetHierarchy, /* aMustMatchParent */ true);
+      LOG("  popup [%p] parent window [%p] matches layout %d\n", (void*)popup,
+          (void*)popup->mWaylandPopupPrev, popup->mPopupMatchesLayout);
+    }
+    popup = popup->mWaylandPopupNext;
+  }
+}
+
+void nsWindow::WaylandPopupHierarchyHideTemporary() {
+  LOG("nsWindow::WaylandPopupHierarchyHideTemporary() [%p]", this);
+  nsWindow* popup = WaylandPopupFindLast(this);
+  while (popup && popup != this) {
+    LOG("  temporary hidding popup [%p]", popup);
+    nsWindow* prev = popup->mWaylandPopupPrev;
+    popup->HideWaylandPopupWindow(/* aTemporaryHide */ true,
+                                  /* aRemoveFromPopupList */ false);
+    popup = prev;
+  }
+}
+
+void nsWindow::WaylandPopupHierarchyShowTemporaryHidden() {
+  LOG("nsWindow::WaylandPopupHierarchyShowTemporaryHidden()");
+  nsWindow* popup = this;
+  while (popup) {
+    if (popup->mPopupTemporaryHidden) {
+      popup->mPopupTemporaryHidden = false;
+      LOG("  showing temporary hidden popup [%p]", popup);
+      popup->ShowWaylandWindow();
+    }
+    popup = popup->mWaylandPopupNext;
+  }
+}
+
+void nsWindow::WaylandPopupHierarchyCalculatePositions() {
+  LOG("nsWindow::WaylandPopupHierarchyCalculatePositions()");
+
+  // Set widget hierarchy in Gtk
+  nsWindow* popup = mWaylandToplevel->mWaylandPopupNext;
+  while (popup) {
+    LOG("  popup [%p] set parent window [%p]", (void*)popup,
+        (void*)popup->mWaylandPopupPrev);
+    gtk_window_set_transient_for(GTK_WINDOW(popup->mShell),
+                                 GTK_WINDOW(popup->mWaylandPopupPrev->mShell));
+    popup = popup->mWaylandPopupNext;
+  }
+
+  popup = this;
+  while (popup) {
+    // Anchored window has mPopupPosition already calculated against
+    // its parent, no need to recalculate.
+    LOG("  popup [%p] bounds [%d, %d] -> [%d x %d]", popup,
+        (int)(popup->mBounds.x / FractionalScaleFactor()),
+        (int)(popup->mBounds.y / FractionalScaleFactor()),
+        (int)(popup->mBounds.width / FractionalScaleFactor()),
+        (int)(popup->mBounds.height / FractionalScaleFactor()));
+#ifdef MOZ_LOGGING
+    if (LOG_ENABLED()) {
+      if (nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame())) {
+        auto r = LayoutDeviceRect::FromAppUnitsRounded(
+            popupFrame->GetRect(),
+            popupFrame->PresContext()->AppUnitsPerDevPixel());
+        LOG("  popup [%p] layout [%d, %d] -> [%d x %d]", popup, r.x, r.y,
+            r.width, r.height);
+      }
+    }
+#endif
+    if (popup->mPopupContextMenu && !popup->mPopupAnchored) {
+      LOG("  popup [%p] is first context menu", popup);
+      popup->mRelativePopupPosition = popup->mPopupPosition;
+    } else if (popup->mPopupAnchored) {
+      LOG("  popup [%p] is anchored", popup);
+      if (!popup->mPopupMatchesLayout) {
+        NS_WARNING("Anchored popup does not match layout!");
+      }
+      popup->mRelativePopupPosition = popup->mPopupPosition;
+    } else if (popup->mWaylandPopupPrev->mWaylandToplevel == nullptr) {
+      LOG("  popup [%p] has toplevel as parent", popup);
+      popup->mRelativePopupPosition = popup->mPopupPosition;
+    } else {
+      GdkPoint parent = WaylandGetParentPosition();
+
+      LOG("  popup [%p] uses transformed coordinates\n", popup);
+      LOG("    parent position [%d, %d]\n", parent.x, parent.y);
+      LOG("    popup position [%d, %d]\n", popup->mPopupPosition.x,
+          popup->mPopupPosition.y);
+
+      popup->mRelativePopupPosition.x = popup->mPopupPosition.x - parent.x;
+      popup->mRelativePopupPosition.y = popup->mPopupPosition.y - parent.y;
+    }
+    LOG("  popup [%p] transformed popup coordinates from [%d, %d] to [%d, %d]",
+        popup, popup->mPopupPosition.x, popup->mPopupPosition.y,
+        popup->mRelativePopupPosition.x, popup->mRelativePopupPosition.y);
+    popup = popup->mWaylandPopupNext;
+  }
+}
+
+// The MenuList popups are used as dropdown menus for example in WebRTC
+// microphone/camera chooser or autocomplete widgets.
+bool nsWindow::WaylandPopupIsMenu() {
+  nsMenuPopupFrame* menuPopupFrame = GetMenuPopupFrame(GetFrame());
+  if (menuPopupFrame) {
+    return mPopupType == ePopupTypeMenu && !menuPopupFrame->IsMenuList();
+  }
+  return false;
+}
+
+bool nsWindow::WaylandPopupIsContextMenu() {
+  nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame());
+  if (!popupFrame) {
+    return false;
+  }
+  return popupFrame->IsContextMenu();
+}
+
+bool nsWindow::WaylandPopupIsPermanent() {
+  nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame());
+  if (!popupFrame) {
+    // We can always hide popups without frames.
+    return false;
+  }
+  return popupFrame->IsNoAutoHide();
+}
+
+bool nsWindow::WaylandPopupIsAnchored() {
+  nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame());
+  if (!popupFrame) {
+    // We can always hide popups without frames.
+    return false;
+  }
+  return popupFrame->GetAnchor() != nullptr;
+}
+
+bool nsWindow::IsWidgetOverflowWindow() {
+  if (this->GetFrame() && this->GetFrame()->GetContent()->GetID()) {
+    nsCString nodeId;
+    this->GetFrame()->GetContent()->GetID()->ToUTF8String(nodeId);
+    return nodeId.Equals("widget-overflow");
+  }
+  return false;
+}
+
+GdkPoint nsWindow::WaylandGetParentPosition() {
+  // Don't call WaylandGetParentPosition on X11 as it causes X11 roundtrips.
+  // gdk_window_get_origin is very fast on Wayland as the
+  // window position is cached by Gtk.
+  MOZ_DIAGNOSTIC_ASSERT(GdkIsWaylandDisplay());
+
+  GtkWindow* parentGtkWindow = gtk_window_get_transient_for(GTK_WINDOW(mShell));
+  if (!parentGtkWindow || !GTK_IS_WIDGET(parentGtkWindow)) {
+    NS_WARNING("Popup has no parent!");
+    return {0, 0};
+  }
+  GdkWindow* window = gtk_widget_get_window(GTK_WIDGET(parentGtkWindow));
+  if (!window) {
+    NS_WARNING("Popup parrent is not mapped!");
+    return {0, 0};
+  }
+  gint x = 0, y = 0;
+  gdk_window_get_origin(window, &x, &y);
+  return {x, y};
+}
+
+#ifdef MOZ_LOGGING
+void nsWindow::LogPopupHierarchy() {
+  if (!LOG_ENABLED()) {
+    return;
+  }
+
+  LOG("Widget Popup Hierarchy:\n");
+  if (!mWaylandToplevel->mWaylandPopupNext) {
+    LOG("    Empty\n");
+  } else {
+    int indent = 4;
+    nsWindow* popup = mWaylandToplevel->mWaylandPopupNext;
+    while (popup) {
+      nsPrintfCString indentString("%*s", indent, " ");
+      LOG("%s %s %s nsWindow [%p] Menu %d Permanent %d ContextMenu %d "
+          "Anchored %d Visible %d\n",
+          indentString.get(), popup->GetFrameTag().get(),
+          popup->GetPopupTypeName().get(), popup, popup->WaylandPopupIsMenu(),
+          popup->WaylandPopupIsPermanent(), popup->mPopupContextMenu,
+          popup->mPopupAnchored, gtk_widget_is_visible(popup->mShell));
+      indent += 4;
+      popup = popup->mWaylandPopupNext;
+    }
+  }
+
+  LOG("Layout Popup Hierarchy:\n");
+  AutoTArray<nsIWidget*, 5> widgetChain;
+  GetLayoutPopupWidgetChain(&widgetChain);
+  if (widgetChain.Length() == 0) {
+    LOG("    Empty\n");
+  } else {
+    for (unsigned long i = 0; i < widgetChain.Length(); i++) {
+      nsWindow* window = static_cast<nsWindow*>(widgetChain[i]);
+      nsPrintfCString indentString("%*s", (int)(i + 1) * 4, " ");
+      if (window) {
+        LOG("%s %s %s nsWindow [%p] Menu %d Permanent %d ContextMenu %d "
+            "Anchored %d Visible %d\n",
+            indentString.get(), window->GetFrameTag().get(),
+            window->GetPopupTypeName().get(), window,
+            window->WaylandPopupIsMenu(), window->WaylandPopupIsPermanent(),
+            window->mPopupContextMenu, window->mPopupAnchored,
+            gtk_widget_is_visible(window->mShell));
+      } else {
+        LOG("%s null window\n", indentString.get());
+      }
+    }
+  }
+}
+#endif
+
+nsWindow* nsWindow::WaylandPopupGetTopmostWindow() {
+  nsView* view = nsView::GetViewFor(this);
+  if (view) {
+    nsView* parentView = view->GetParent();
+    if (parentView) {
+      nsIWidget* parentWidget = parentView->GetNearestWidget(nullptr);
+      if (parentWidget) {
+        nsWindow* parentnsWindow = static_cast<nsWindow*>(parentWidget);
+        LOG("  Topmost window: %p [nsWindow]\n", parentnsWindow);
+        return parentnsWindow;
+      }
+    }
+  }
+  return nullptr;
+}
+
+// Configure Wayland popup. If true is returned we need to track popup
+// in popup hierarchy. Otherwise we just show it as is.
+bool nsWindow::WaylandPopupConfigure() {
+  if (mIsDragPopup) {
+    return false;
+  }
+
+  // Don't track popups without frame
+  nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame());
+  if (!popupFrame) {
+    return false;
+  }
+
+  // Popup state can be changed, see Bug 1728952.
+  bool permanentStateMatches =
+      mPopupTrackInHierarchy == !WaylandPopupIsPermanent();
+
+  // Popup permanent state (noautohide attribute) can change during popup life.
+  if (mPopupTrackInHierarchyConfigured && permanentStateMatches) {
+    return mPopupTrackInHierarchy;
+  }
+
+  // Configure persistent popup params only once.
+  // WaylandPopupIsAnchored() can give it wrong value after
+  // nsMenuPopupFrame::MoveTo() call which we use in move-to-rect callback
+  // to position popup after wayland position change.
+  if (!mPopupTrackInHierarchyConfigured) {
+    mPopupAnchored = WaylandPopupIsAnchored();
+    mPopupContextMenu = WaylandPopupIsContextMenu();
+  }
+
+  LOG("nsWindow::WaylandPopupConfigure tracked %d anchored %d\n",
+      mPopupTrackInHierarchy, mPopupAnchored);
+
+  // Permanent state changed and popup is mapped.
+  // We need to switch popup type but that's done when popup is mapped
+  // by Gtk so we need to unmap the popup here.
+  // It will be mapped again by gtk_widget_show().
+  if (!permanentStateMatches && mIsMapped) {
+    LOG("  permanent state change from %d to %d, unmapping",
+        mPopupTrackInHierarchy, !WaylandPopupIsPermanent());
+    gtk_widget_unmap(mShell);
+  }
+
+  mPopupTrackInHierarchy = !WaylandPopupIsPermanent();
+  LOG("  tracked in hierarchy %d\n", mPopupTrackInHierarchy);
+
+  // See gdkwindow-wayland.c and
+  // should_map_as_popup()/should_map_as_subsurface()
+  GdkWindowTypeHint gtkTypeHint;
+  switch (mPopupHint) {
+    case ePopupTypeMenu:
+      // GDK_WINDOW_TYPE_HINT_POPUP_MENU is mapped as xdg_popup by default.
+      // We use this type for all menu popups.
+      gtkTypeHint = GDK_WINDOW_TYPE_HINT_POPUP_MENU;
+      LOG("  popup type Menu");
+      break;
+    case ePopupTypeTooltip:
+      gtkTypeHint = GDK_WINDOW_TYPE_HINT_TOOLTIP;
+      LOG("  popup type Tooltip");
+      break;
+    default:  // popup panel type
+      // GDK_WINDOW_TYPE_HINT_UTILITY is mapped as wl_subsurface
+      // by default. It's used for panels attached to toplevel
+      // window.
+      gtkTypeHint = GDK_WINDOW_TYPE_HINT_UTILITY;
+      LOG("  popup type Utility");
+      break;
+  }
+
+  if (!mPopupTrackInHierarchy) {
+    gtkTypeHint = GDK_WINDOW_TYPE_HINT_UTILITY;
+  }
+  gtk_window_set_type_hint(GTK_WINDOW(mShell), gtkTypeHint);
+
+  mPopupTrackInHierarchyConfigured = true;
+  return mPopupTrackInHierarchy;
+}
+
+bool nsWindow::IsInPopupHierarchy() {
+  return mPopupTrackInHierarchy && mWaylandToplevel && mWaylandPopupPrev;
+}
+
+void nsWindow::AddWindowToPopupHierarchy() {
+  LOG("nsWindow::AddWindowToPopupHierarchy\n");
+  if (!GetFrame()) {
+    LOG("  Window without frame cannot be added as popup!\n");
+    return;
+  }
+
+  // Check if we're already in the hierarchy
+  if (!IsInPopupHierarchy()) {
+    mWaylandToplevel = WaylandPopupGetTopmostWindow();
+    AppendPopupToHierarchyList(mWaylandToplevel);
+  }
+}
+
+// Wayland keeps strong popup window hierarchy. We need to track active
+// (visible) popup windows and make sure we hide popup on the same level
+// before we open another one on that level. It means that every open
+// popup needs to have an unique parent.
+void nsWindow::UpdateWaylandPopupHierarchy() {
+  LOG("nsWindow::UpdateWaylandPopupHierarchy\n");
+
+  // This popup hasn't been added to popup hierarchy yet so no need to
+  // do any configurations.
+  if (!IsInPopupHierarchy()) {
+    LOG("  popup isn't in hierarchy\n");
+    return;
+  }
+
+#ifdef MOZ_LOGGING
+  LogPopupHierarchy();
+  auto printPopupHierarchy = MakeScopeExit([&] { LogPopupHierarchy(); });
+#endif
+
+  // Hide all tooltips without the last one. Tooltip can't be popup parent.
+  mWaylandToplevel->WaylandPopupHideTooltips();
+
+  // Check if we have any remote content / overflow window in hierarchy.
+  // We can't attach such widget on top of other popup.
+  mWaylandToplevel->CloseAllPopupsBeforeRemotePopup();
+
+  // Check if your popup hierarchy matches layout hierarchy.
+  // For instance we should not connect hamburger menu on top
+  // of context menu.
+  // Close all popups from different layout chains if possible.
+  AutoTArray<nsIWidget*, 5> layoutPopupWidgetChain;
+  GetLayoutPopupWidgetChain(&layoutPopupWidgetChain);
+
+  mWaylandToplevel->WaylandPopupHierarchyHideByLayout(&layoutPopupWidgetChain);
+  mWaylandToplevel->WaylandPopupHierarchyValidateByLayout(
+      &layoutPopupWidgetChain);
+
+  // Now we have Popup hierarchy complete.
+  // Find first unchanged (and still open) popup to start with hierarchy
+  // changes.
+  nsWindow* changedPopup = mWaylandToplevel->mWaylandPopupNext;
+  while (changedPopup) {
+    // Stop when parent of this popup was changed and we need to recalc
+    // popup position.
+    if (changedPopup->mPopupChanged) {
+      break;
+    }
+    // Stop when this popup is closed.
+    if (changedPopup->mPopupClosed) {
+      break;
+    }
+    changedPopup = changedPopup->mWaylandPopupNext;
+  }
+
+  // We don't need to recompute popup positions, quit now.
+  if (!changedPopup) {
+    LOG("  changed Popup is null, quit.\n");
+    return;
+  }
+
+  LOG("  first changed popup [%p]\n", (void*)changedPopup);
+
+  // Hide parent popups if necessary (there are layout discontinuity)
+  // reposition the popup and show them again.
+  changedPopup->WaylandPopupHierarchyHideTemporary();
+
+  nsWindow* parentOfchangedPopup = nullptr;
+  if (changedPopup->mPopupClosed) {
+    parentOfchangedPopup = changedPopup->mWaylandPopupPrev;
+  }
+  changedPopup->WaylandPopupRemoveClosedPopups();
+
+  // It's possible that changedPopup was removed from widget hierarchy,
+  // in such case use child popup of the removed one if there's any.
+  if (!changedPopup->IsInPopupHierarchy()) {
+    if (!parentOfchangedPopup || !parentOfchangedPopup->mWaylandPopupNext) {
+      LOG("  last popup was removed, quit.\n");
+      return;
+    }
+    changedPopup = parentOfchangedPopup->mWaylandPopupNext;
+  }
+
+  GetLayoutPopupWidgetChain(&layoutPopupWidgetChain);
+  mWaylandToplevel->WaylandPopupHierarchyValidateByLayout(
+      &layoutPopupWidgetChain);
+
+  changedPopup->WaylandPopupHierarchyCalculatePositions();
+
+  nsWindow* popup = changedPopup;
+  while (popup) {
+    const bool useMoveToRect = [&] {
+      if (!StaticPrefs::widget_wayland_use_move_to_rect_AtStartup()) {
+        return false;  // Not available.
+      }
+      if (!popup->mPopupMatchesLayout) {
+        // We can use move_to_rect only when popups in popup hierarchy matches
+        // layout hierarchy as move_to_rect request that parent/child
+        // popups are adjacent.
+        return false;
+      }
+      // We use move_to_rect when:
+      // - Popup is tooltip
+      // - Popup is anchored, i.e. it has an anchor defined by layout
+      //   (mPopupAnchored).
+      // - Popup isn't anchored but it has toplevel as parent, i.e.
+      //   it's first popup.
+      bool useIt = mPopupType == ePopupTypeTooltip || popup->mPopupAnchored ||
+                   !popup->mWaylandPopupPrev->mWaylandToplevel;
+      if (!useIt) {
+        return false;
+      }
+      if (WaylandPopupFitsToplevelWindow()) {
+        // Workaround for https://gitlab.gnome.org/GNOME/gtk/-/issues/1986
+        // Bug 1760276 - don't use move-to-rect when popup is inside main
+        // Firefox window.
+        return false;
+      }
+      return true;
+    }();
+
+    LOG("  popup [%p] matches layout [%d] anchored [%d] first popup [%d] use "
+        "move-to-rect %d\n",
+        popup, popup->mPopupMatchesLayout, popup->mPopupAnchored,
+        popup->mWaylandPopupPrev->mWaylandToplevel == nullptr, useMoveToRect);
+
+    popup->mPopupUseMoveToRect = useMoveToRect;
+    popup->WaylandPopupMove();
+    popup->mPopupChanged = false;
+    popup = popup->mWaylandPopupNext;
+  }
+
+  changedPopup->WaylandPopupHierarchyShowTemporaryHidden();
+}
+
+static void NativeMoveResizeCallback(GdkWindow* window,
+                                     const GdkRectangle* flipped_rect,
+                                     const GdkRectangle* final_rect,
+                                     gboolean flipped_x, gboolean flipped_y,
+                                     void* aWindow) {
+  LOG_POPUP("[%p] NativeMoveResizeCallback flipped_x %d flipped_y %d\n",
+            aWindow, flipped_x, flipped_y);
+  LOG_POPUP("[%p]   new position [%d, %d] -> [%d x %d]", aWindow, final_rect->x,
+            final_rect->y, final_rect->width, final_rect->height);
+  nsWindow* wnd = get_window_for_gdk_window(window);
+
+  wnd->NativeMoveResizeWaylandPopupCallback(final_rect, flipped_x, flipped_y);
+}
+
+// When popup is repositioned by widget code, we need to notify
+// layout about it. It's because we control popup placement
+// on widget on Wayland so layout may have old popup size/coordinates.
+void nsWindow::WaylandPopupPropagateChangesToLayout(bool aMove, bool aResize) {
+  LOG("nsWindow::WaylandPopupPropagateChangesToLayout()");
+
+  if (aResize) {
+    LOG("  needSizeUpdate\n");
+    if (nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame())) {
+      RefPtr<PresShell> presShell = popupFrame->PresShell();
+      presShell->FrameNeedsReflow(popupFrame, IntrinsicDirty::Resize,
+                                  NS_FRAME_IS_DIRTY);
+    }
+  }
+  if (aMove) {
+    LOG("  needPositionUpdate, bounds [%d, %d]", mBounds.x, mBounds.y);
+    NotifyWindowMoved(mBounds.x, mBounds.y);
+    if (nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame())) {
+      auto p = CSSIntPoint::Round(
+          mBounds.TopLeft() / popupFrame->PresContext()->CSSToDevPixelScale());
+      popupFrame->MoveTo(p, true);
+    }
+  }
+}
+
+void nsWindow::NativeMoveResizeWaylandPopupCallback(
+    const GdkRectangle* aFinalSize, bool aFlippedX, bool aFlippedY) {
+  mWaitingForMoveToRectCallback = false;
+
+  bool movedByLayout =
+      mNewBoundsAfterMoveToRect.x || mNewBoundsAfterMoveToRect.y;
+  bool resizedByLayout =
+      mNewBoundsAfterMoveToRect.width || mNewBoundsAfterMoveToRect.height;
+
+  // Popup was moved between move-to-rect call and move-to-rect callback
+  // and the coordinates from move-to-rect callback are outdated.
+  if (movedByLayout || resizedByLayout) {
+    LOG("  Another move/resize called during waiting for callback\n");
+    if (movedByLayout) {
+      mBounds.x = mNewBoundsAfterMoveToRect.x;
+      mBounds.y = mNewBoundsAfterMoveToRect.y;
+    }
+    if (resizedByLayout) {
+      mBounds.width = mNewBoundsAfterMoveToRect.width;
+      mBounds.height = mNewBoundsAfterMoveToRect.height;
+    }
+    mNewBoundsAfterMoveToRect = LayoutDeviceIntRect(0, 0, 0, 0);
+
+    // Fire another round of move/resize to reflect latest request
+    // from layout.
+    NativeMoveResize(movedByLayout, resizedByLayout);
+    return;
+  }
+
+  LOG("  orig mBounds [%d, %d] -> [%d x %d]\n", mBounds.x, mBounds.y,
+      mBounds.width, mBounds.height);
+
+  LayoutDeviceIntRect newBounds = [&] {
+    GdkRectangle finalRect = *aFinalSize;
+    GdkPoint parent = WaylandGetParentPosition();
+    finalRect.x += parent.x;
+    finalRect.y += parent.y;
+    return GdkRectToDevicePixels(finalRect);
+  }();
+
+  LOG("  new mBounds [%d, %d] -> [%d x %d]", newBounds.x, newBounds.y,
+      newBounds.width, newBounds.height);
+
+  bool needsPositionUpdate = newBounds.TopLeft() != mBounds.TopLeft();
+  bool needsSizeUpdate = newBounds.Size() != mBounds.Size();
+
+  if (needsPositionUpdate) {
+    // See Bug 1735095
+    // Font scale causes rounding errors which we can't handle by move-to-rect.
+    // The font scale should not be used, but let's handle it somehow to
+    // avoid endless move calls.
+    if (StaticPrefs::layout_css_devPixelsPerPx() > 0 ||
+        gfxPlatformGtk::GetFontScaleFactor() != 1) {
+      bool roundingError = (abs(newBounds.x - mBounds.x) < 2 &&
+                            abs(newBounds.y - mBounds.y) < 2);
+      if (roundingError) {
+        // Keep the window where it is.
+        GdkPoint topLeft = DevicePixelsToGdkPointRoundDown(mBounds.TopLeft());
+        LOG("  apply rounding error workaround, move to %d, %d", topLeft.x,
+            topLeft.y);
+        gtk_window_move(GTK_WINDOW(mShell), topLeft.x, topLeft.y);
+        needsPositionUpdate = false;
+      }
+    }
+  }
+
+  if (needsSizeUpdate) {
+    // Wayland compositor changed popup size request from layout.
+    // Set the constraints to use them in nsMenuPopupFrame::SetPopupPosition().
+    if (newBounds.width < mBounds.width) {
+      mMoveToRectPopupSize.width = newBounds.width;
+    }
+    if (newBounds.height < mBounds.height) {
+      mMoveToRectPopupSize.height = newBounds.height;
+    }
+    LOG("  mMoveToRectPopupSize set to [%d, %d]", mMoveToRectPopupSize.width,
+        mMoveToRectPopupSize.height);
+  }
+  mBounds = newBounds;
+  WaylandPopupPropagateChangesToLayout(needsPositionUpdate, needsSizeUpdate);
+}
+
+static GdkGravity PopupAlignmentToGdkGravity(int8_t aAlignment) {
+  switch (aAlignment) {
+    case POPUPALIGNMENT_NONE:
+      return GDK_GRAVITY_NORTH_WEST;
+    case POPUPALIGNMENT_TOPLEFT:
+      return GDK_GRAVITY_NORTH_WEST;
+    case POPUPALIGNMENT_TOPRIGHT:
+      return GDK_GRAVITY_NORTH_EAST;
+    case POPUPALIGNMENT_BOTTOMLEFT:
+      return GDK_GRAVITY_SOUTH_WEST;
+    case POPUPALIGNMENT_BOTTOMRIGHT:
+      return GDK_GRAVITY_SOUTH_EAST;
+    case POPUPALIGNMENT_LEFTCENTER:
+      return GDK_GRAVITY_WEST;
+    case POPUPALIGNMENT_RIGHTCENTER:
+      return GDK_GRAVITY_EAST;
+    case POPUPALIGNMENT_TOPCENTER:
+      return GDK_GRAVITY_NORTH;
+    case POPUPALIGNMENT_BOTTOMCENTER:
+      return GDK_GRAVITY_SOUTH;
+  }
+  return GDK_GRAVITY_STATIC;
+}
+
+bool nsWindow::IsPopupDirectionRTL() {
+  nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame());
+  return popupFrame && popupFrame->IsDirectionRTL();
+}
+
+// Position the popup directly by gtk_window_move() and try to keep it
+// on screen by just moving it in scope of it's parent window.
+//
+// It's used when we position noautihode popup and we don't use xdg_positioner.
+// See Bug 1718867
+void nsWindow::WaylandPopupSetDirectPosition() {
+  GdkRectangle rect = DevicePixelsToGdkRectRoundOut(mBounds);
+
+  LOG("nsWindow::WaylandPopupSetDirectPosition %d,%d -> %d x %d\n", rect.x,
+      rect.y, rect.width, rect.height);
+
+  mPopupPosition = {rect.x, rect.y};
+
+  if (mIsDragPopup) {
+    gtk_window_move(GTK_WINDOW(mShell), rect.x, rect.y);
+    gtk_window_resize(GTK_WINDOW(mShell), rect.width, rect.height);
+    // DND window is placed inside container so we need to make hard size
+    // request to ensure parent container is resized too.
+    gtk_widget_set_size_request(GTK_WIDGET(mShell), rect.width, rect.height);
+    return;
+  }
+
+  GtkWindow* parentGtkWindow = gtk_window_get_transient_for(GTK_WINDOW(mShell));
+  nsWindow* window = get_window_for_gtk_widget(GTK_WIDGET(parentGtkWindow));
+  GdkWindow* gdkWindow =
+      gtk_widget_get_window(GTK_WIDGET(window->GetMozContainer()));
+
+  int parentWidth = gdk_window_get_width(gdkWindow);
+  int popupWidth = rect.width;
+
+  int x;
+  gdk_window_get_position(gdkWindow, &x, nullptr);
+
+  // If popup is bigger than main window just center it.
+  if (popupWidth > parentWidth) {
+    mPopupPosition.x = -(parentWidth - popupWidth) / 2 + x;
+  } else {
+    if (IsPopupDirectionRTL()) {
+      // Stick with right window edge
+      if (mPopupPosition.x < x) {
+        mPopupPosition.x = x;
+      }
+    } else {
+      // Stick with left window edge
+      if (mPopupPosition.x + popupWidth > parentWidth + x) {
+        mPopupPosition.x = parentWidth + x - popupWidth;
+      }
+    }
+  }
+
+  LOG("  set position [%d, %d]\n", mPopupPosition.x, mPopupPosition.y);
+  gtk_window_move(GTK_WINDOW(mShell), mPopupPosition.x, mPopupPosition.y);
+
+  LOG("  set size [%d, %d]\n", rect.width, rect.height);
+  gtk_window_resize(GTK_WINDOW(mShell), rect.width, rect.height);
+
+  if (mPopupPosition.x != rect.x) {
+    mBounds = LayoutDeviceIntRect(GdkPointToDevicePixels(mPopupPosition),
+                                  mBounds.Size());
+    LOG("  setting new bounds [%d, %d]\n", mBounds.x, mBounds.y);
+    WaylandPopupPropagateChangesToLayout(/* move */ true, /* resize */ false);
+  }
+}
+
+bool nsWindow::WaylandPopupFitsToplevelWindow() {
+  LOG("nsWindow::WaylandPopupFitsToplevelWindow()");
+
+  GtkWindow* parent = gtk_window_get_transient_for(GTK_WINDOW(mShell));
+  GtkWindow* tmp = parent;
+  while ((tmp = gtk_window_get_transient_for(GTK_WINDOW(parent)))) {
+    parent = tmp;
+  }
+  GdkWindow* toplevelGdkWindow = gtk_widget_get_window(GTK_WIDGET(parent));
+
+  if (!toplevelGdkWindow) {
+    NS_WARNING("Toplevel widget without GdkWindow?");
+    return false;
+  }
+
+  int parentWidth = gdk_window_get_width(toplevelGdkWindow);
+  int parentHeight = gdk_window_get_height(toplevelGdkWindow);
+  LOG("  parent size %d x %d", parentWidth, parentHeight);
+
+  GdkRectangle rect = DevicePixelsToGdkRectRoundOut(mBounds);
+  int fits = rect.x >= 0 && rect.y >= 0 && rect.x + rect.width <= parentWidth &&
+             rect.y + rect.height <= parentHeight;
+
+  LOG("  fits %d", fits);
+  return fits;
+}
+
+void nsWindow::NativeMoveResizeWaylandPopup(bool aMove, bool aResize) {
+  GdkRectangle rect = DevicePixelsToGdkRectRoundOut(mBounds);
+
+  LOG("nsWindow::NativeMoveResizeWaylandPopup Bounds %d,%d -> %d x %d move %d "
+      "resize %d\n",
+      rect.x, rect.y, rect.width, rect.height, aMove, aResize);
+
+  // Compositor may be confused by windows with width/height = 0
+  // and positioning such windows leads to Bug 1555866.
+  if (!AreBoundsSane()) {
+    LOG("  Bounds are not sane (width: %d height: %d)\n", mBounds.width,
+        mBounds.height);
+    return;
+  }
+
+  if (mWaitingForMoveToRectCallback) {
+    LOG("  waiting for move to rect, schedulling");
+    if (aMove) {
+      mNewBoundsAfterMoveToRect.x = mBounds.x;
+      mNewBoundsAfterMoveToRect.y = mBounds.y;
+    }
+    if (aResize) {
+      mNewBoundsAfterMoveToRect.width = mBounds.width;
+      mNewBoundsAfterMoveToRect.height = mBounds.height;
+    }
+    return;
+  }
+
+  mNewBoundsAfterMoveToRect = LayoutDeviceIntRect(0, 0, 0, 0);
+
+  bool trackedInHierarchy = WaylandPopupConfigure();
+
+  // Read popup position from layout if it was moved.
+  // This position is used by move-to-rect method as we need anchor and other
+  // info to place popup correctly.
+  // We need WaylandPopupConfigure() to be called before to have all needed
+  // popup info in place (mainly the anchored flag).
+  if (aMove) {
+    mPopupMoveToRectParams = WaylandPopupGetPositionFromLayout();
+  }
+
+  if (!trackedInHierarchy) {
+    WaylandPopupSetDirectPosition();
+    return;
+  }
+
+  if (aResize) {
+    LOG("  set size [%d, %d]\n", rect.width, rect.height);
+    gtk_window_resize(GTK_WINDOW(mShell), rect.width, rect.height);
+  }
+
+  if (!aMove && WaylandPopupFitsToplevelWindow()) {
+    // Popup position has not been changed and its position/size fits
+    // parent window so no need to reposition the window.
+    LOG("  fits parent window size, just resize\n");
+    return;
+  }
+
+  // Mark popup as changed as we're updating position/size.
+  mPopupChanged = true;
+
+  // Save popup position for former re-calculations when popup hierarchy
+  // is changed.
+  LOG("  popup position changed from [%d, %d] to [%d, %d]\n", mPopupPosition.x,
+      mPopupPosition.y, rect.x, rect.y);
+  mPopupPosition = {rect.x, rect.y};
+
+  UpdateWaylandPopupHierarchy();
+}
+
+struct PopupSides {
+  Maybe<Side> mVertical;
+  Maybe<Side> mHorizontal;
+};
+
+static PopupSides SidesForPopupAlignment(int8_t aAlignment) {
+  switch (aAlignment) {
+    case POPUPALIGNMENT_NONE:
+      break;
+    case POPUPALIGNMENT_TOPLEFT:
+      return {Some(eSideTop), Some(eSideLeft)};
+    case POPUPALIGNMENT_TOPRIGHT:
+      return {Some(eSideTop), Some(eSideRight)};
+    case POPUPALIGNMENT_BOTTOMLEFT:
+      return {Some(eSideBottom), Some(eSideLeft)};
+    case POPUPALIGNMENT_BOTTOMRIGHT:
+      return {Some(eSideBottom), Some(eSideRight)};
+    case POPUPALIGNMENT_LEFTCENTER:
+      return {Nothing(), Some(eSideLeft)};
+    case POPUPALIGNMENT_RIGHTCENTER:
+      return {Nothing(), Some(eSideRight)};
+    case POPUPALIGNMENT_TOPCENTER:
+      return {Some(eSideTop), Nothing()};
+    case POPUPALIGNMENT_BOTTOMCENTER:
+      return {Some(eSideBottom), Nothing()};
+  }
+  return {};
+}
+
+// We want to apply margins based on popup alignment (which would generally be
+// just an offset to apply to the popup). However, to deal with flipping
+// correctly, we apply the margin to the anchor when possible.
+struct ResolvedPopupMargin {
+  // A margin to be applied to the anchor.
+  nsMargin mAnchorMargin;
+  // An offset in app units to be applied to the popup for when we need to tell
+  // GTK to center inside the anchor precisely (so we can't really do better in
+  // presence of flips).
+  nsPoint mPopupOffset;
+};
+
+static ResolvedPopupMargin ResolveMargin(nsMenuPopupFrame* aFrame,
+                                         int8_t aPopupAlign,
+                                         int8_t aAnchorAlign,
+                                         bool aAnchoredToPoint,
+                                         bool aIsContextMenu) {
+  nsMargin margin = aFrame->GetMargin();
+  nsPoint offset;
+
+  if (aAnchoredToPoint) {
+    // Since GTK doesn't allow us to specify margins itself, when anchored to a
+    // point we can just assume we'll be aligned correctly... This is kind of
+    // annoying but alas.
+    //
+    // This calculation must match the relevant unanchored popup calculation in
+    // nsMenuPopupFrame::SetPopupPosition(), which should itself be the inverse
+    // inverse of nsMenuPopupFrame::MoveTo().
+    if (aIsContextMenu && aFrame->IsDirectionRTL()) {
+      offset.x = -margin.right;
+    } else {
+      offset.x = margin.left;
+    }
+    offset.y = margin.top;
+    return {nsMargin(), offset};
+  }
+
+  auto popupSides = SidesForPopupAlignment(aPopupAlign);
+  auto anchorSides = SidesForPopupAlignment(aAnchorAlign);
+  // Matched sides: Invert the margin, so that we pull in the right direction.
+  // Popup not aligned to any anchor side: We give up and use the offset,
+  // applying the margin from the popup side.
+  // Mismatched sides: We swap the margins so that we pull in the right
+  // direction, e.g. margin-left: -10px should shrink 10px the _right_ of the
+  // box, not the left of the box.
+  if (popupSides.mHorizontal == anchorSides.mHorizontal) {
+    margin.left = -margin.left;
+    margin.right = -margin.right;
+  } else if (!anchorSides.mHorizontal) {
+    auto popupSide = *popupSides.mHorizontal;
+    offset.x += popupSide == eSideRight ? -margin.Side(popupSide)
+                                        : margin.Side(popupSide);
+    margin.left = margin.right = 0;
+  } else {
+    std::swap(margin.left, margin.right);
+  }
+
+  // Same logic as above, but in the vertical direction.
+  if (popupSides.mVertical == anchorSides.mVertical) {
+    margin.top = -margin.top;
+    margin.bottom = -margin.bottom;
+  } else if (!anchorSides.mVertical) {
+    auto popupSide = *popupSides.mVertical;
+    offset.y += popupSide == eSideBottom ? -margin.Side(popupSide)
+                                         : margin.Side(popupSide);
+    margin.top = margin.bottom = 0;
+  } else {
+    std::swap(margin.top, margin.bottom);
+  }
+
+  return {margin, offset};
+}
+
+const nsWindow::WaylandPopupMoveToRectParams
+nsWindow::WaylandPopupGetPositionFromLayout() {
+  LOG("nsWindow::WaylandPopupGetPositionFromLayout\n");
+
+  nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame());
+
+  const bool isTopContextMenu = mPopupContextMenu && !mPopupAnchored;
+  const bool isRTL = IsPopupDirectionRTL();
+  int8_t popupAlign(popupFrame->GetPopupAlignment());
+  int8_t anchorAlign(popupFrame->GetPopupAnchor());
+  if (isTopContextMenu) {
+    anchorAlign = POPUPALIGNMENT_BOTTOMRIGHT;
+    popupAlign = POPUPALIGNMENT_TOPLEFT;
+  }
+  if (isRTL) {
+    popupAlign = -popupAlign;
+    anchorAlign = -anchorAlign;
+  }
+
+  // Although we have mPopupPosition / mRelativePopupPosition here
+  // we can't use it. move-to-rect needs anchor rectangle to position a popup
+  // but we have only a point from Resize().
+  //
+  // So we need to extract popup position from nsMenuPopupFrame() and duplicate
+  // the layout work here.
+  LayoutDeviceIntRect anchorRect;
+  ResolvedPopupMargin popupMargin;
+  {
+    nsRect anchorRectAppUnits = popupFrame->GetUntransformedAnchorRect();
+    // This is a somewhat hacky way of applying the popup margin. We don't know
+    // if GTK will end up flipping the popup, in which case the offset we
+    // compute is just wrong / applied to the wrong side.
+    //
+    // Instead, we tell it to anchor us at a smaller or bigger rect depending on
+    // the margin, which achieves the same result if the popup is positioned
+    // correctly, but doesn't misposition the popup when flipped across the
+    // anchor.
+    popupMargin = ResolveMargin(popupFrame, popupAlign, anchorAlign,
+                                anchorRectAppUnits.IsEmpty(), isTopContextMenu);
+    LOG("  layout popup CSS anchor (%d, %d) %s, margin %s offset %s\n",
+        popupAlign, anchorAlign, ToString(anchorRectAppUnits).c_str(),
+        ToString(popupMargin.mAnchorMargin).c_str(),
+        ToString(popupMargin.mPopupOffset).c_str());
+    anchorRectAppUnits.Inflate(popupMargin.mAnchorMargin);
+    LOG("    after margins %s\n", ToString(anchorRectAppUnits).c_str());
+    nscoord auPerDev = popupFrame->PresContext()->AppUnitsPerDevPixel();
+    anchorRect = LayoutDeviceIntRect::FromAppUnitsToNearest(anchorRectAppUnits,
+                                                            auPerDev);
+    if (anchorRect.width < 0) {
+      auto w = -anchorRect.width;
+      anchorRect.width += w + 1;
+      anchorRect.x += w;
+    }
+    LOG("    final %s\n", ToString(anchorRect).c_str());
+  }
+
+  LOG("  relative popup rect position [%d, %d] -> [%d x %d]\n", anchorRect.x,
+      anchorRect.y, anchorRect.width, anchorRect.height);
+
+  // Get gravity and flip type
+  GdkGravity rectAnchor = PopupAlignmentToGdkGravity(anchorAlign);
+  GdkGravity menuAnchor = PopupAlignmentToGdkGravity(popupAlign);
+
+  LOG("  parentRect gravity: %d anchor gravity: %d\n", rectAnchor, menuAnchor);
+
+  // Gtk default is: GDK_ANCHOR_FLIP | GDK_ANCHOR_SLIDE | GDK_ANCHOR_RESIZE.
+  // We want to SLIDE_X menu on the dual monitor setup rather than resize it
+  // on the other monitor.
+  GdkAnchorHints hints =
+      GdkAnchorHints(GDK_ANCHOR_FLIP | GDK_ANCHOR_SLIDE_X | GDK_ANCHOR_RESIZE);
+
+  // slideHorizontal from nsMenuPopupFrame::SetPopupPosition
+  int8_t position = popupFrame->GetAlignmentPosition();
+  if (position >= POPUPPOSITION_BEFORESTART &&
+      position <= POPUPPOSITION_AFTEREND) {
+    hints = GdkAnchorHints(hints | GDK_ANCHOR_SLIDE_X);
+  }
+  // slideVertical from nsMenuPopupFrame::SetPopupPosition
+  if (position >= POPUPPOSITION_STARTBEFORE &&
+      position <= POPUPPOSITION_ENDAFTER) {
+    hints = GdkAnchorHints(hints | GDK_ANCHOR_SLIDE_Y);
+  }
+
+  FlipType flipType = popupFrame->GetFlipType();
+  if (rectAnchor == GDK_GRAVITY_CENTER && menuAnchor == GDK_GRAVITY_CENTER) {
+    // only slide
+    hints = GdkAnchorHints(hints | GDK_ANCHOR_SLIDE);
+  } else {
+    switch (flipType) {
+      case FlipType_Both:
+        hints = GdkAnchorHints(hints | GDK_ANCHOR_FLIP);
+        break;
+      case FlipType_Slide:
+        hints = GdkAnchorHints(hints | GDK_ANCHOR_SLIDE);
+        break;
+      case FlipType_Default:
+        hints = GdkAnchorHints(hints | GDK_ANCHOR_FLIP);
+        break;
+      default:
+        break;
+    }
+  }
+  if (!WaylandPopupIsMenu()) {
+    // we don't want to slide menus to fit the screen rather resize them
+    hints = GdkAnchorHints(hints | GDK_ANCHOR_SLIDE);
+  }
+
+  return {
+      anchorRect, rectAnchor, menuAnchor, hints,
+      DevicePixelsToGdkPointRoundDown(LayoutDevicePoint::FromAppUnitsToNearest(
+          popupMargin.mPopupOffset,
+          popupFrame->PresContext()->AppUnitsPerDevPixel()))};
+}
+
+void nsWindow::WaylandPopupMove() {
+  LOG("nsWindow::WaylandPopupMove\n");
+
+  // Available as of GTK 3.24+
+  static auto sGdkWindowMoveToRect = (void (*)(
+      GdkWindow*, const GdkRectangle*, GdkGravity, GdkGravity, GdkAnchorHints,
+      gint, gint))dlsym(RTLD_DEFAULT, "gdk_window_move_to_rect");
+
+  GdkWindow* gdkWindow = gtk_widget_get_window(GTK_WIDGET(mShell));
+  nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame());
+
+  LOG("  original widget popup position [%d, %d]\n", mPopupPosition.x,
+      mPopupPosition.y);
+  LOG("  relative widget popup position [%d, %d]\n", mRelativePopupPosition.x,
+      mRelativePopupPosition.y);
+
+  if (mPopupUseMoveToRect) {
+    mPopupUseMoveToRect = sGdkWindowMoveToRect && gdkWindow && popupFrame;
+  }
+
+  LOG(" popup use move to rect %d\n", mPopupUseMoveToRect);
+
+  if (!mPopupUseMoveToRect) {
+    if (mNeedsShow && mPopupType != ePopupTypeTooltip) {
+      // Workaround for https://gitlab.gnome.org/GNOME/gtk/-/issues/4308
+      // Tooltips are created as subsurfaces with relative position.
+      LOG("  use gtk_window_move(%d, %d) for hidden widget\n", mPopupPosition.x,
+          mPopupPosition.y);
+      gtk_window_move(GTK_WINDOW(mShell), mPopupPosition.x, mPopupPosition.y);
+    } else {
+      LOG("  use gtk_window_move(%d, %d) for visible widget\n",
+          mRelativePopupPosition.x, mRelativePopupPosition.y);
+      gtk_window_move(GTK_WINDOW(mShell), mRelativePopupPosition.x,
+                      mRelativePopupPosition.y);
+    }
+    // Layout already should be aware of our bounds, since we didn't change it
+    // from the widget side for flipping or so.
+    return;
+  }
+
+  // See https://gitlab.gnome.org/GNOME/gtk/-/issues/1986
+  // We're likely fail to reposition already visible widget.
+  if (gtk_widget_is_visible(mShell)) {
+    HideWaylandPopupWindow(/* aTemporaryHide */ true,
+                           /* aRemoveFromPopupList */ false);
+  }
+
+  // Correct popup position now. It will be updated by gdk_window_move_to_rect()
+  // anyway but we need to set it now to avoid a race condition here.
+  WaylandPopupRemoveNegativePosition();
+
+  if (!g_signal_handler_find(gdkWindow, G_SIGNAL_MATCH_FUNC, 0, 0, nullptr,
+                             FuncToGpointer(NativeMoveResizeCallback), this)) {
+    g_signal_connect(gdkWindow, "moved-to-rect",
+                     G_CALLBACK(NativeMoveResizeCallback), this);
+  }
+  mWaitingForMoveToRectCallback = true;
+
+  // Update popup layout coordinates from layout by recent popup hierarchy
+  // (calculate correct position according to parent window)
+  // and convert to Gtk coordinates.
+  LayoutDeviceIntRect anchorRect = mPopupMoveToRectParams.mAnchorRect;
+  if (mWaylandPopupPrev->mWaylandToplevel) {
+    GdkPoint parent = WaylandGetParentPosition();
+    LOG("  subtract parent position from anchor [%d, %d]\n", parent.x,
+        parent.y);
+    anchorRect.MoveBy(-GdkPointToDevicePixels(parent));
+  }
+  GdkRectangle gtkAnchorRect = DevicePixelsToGdkRectRoundOut(anchorRect);
+
+  LOG("  move-to-rect call, anchor [%d,%d] -> [%d x %d]", gtkAnchorRect.x,
+      gtkAnchorRect.y, mPopupMoveToRectParams.mAnchorRect.width,
+      mPopupMoveToRectParams.mAnchorRect.height);
+  sGdkWindowMoveToRect(
+      gdkWindow, &gtkAnchorRect, mPopupMoveToRectParams.mAnchorRectType,
+      mPopupMoveToRectParams.mPopupAnchorType, mPopupMoveToRectParams.mHints,
+      mPopupMoveToRectParams.mOffset.x, mPopupMoveToRectParams.mOffset.y);
+}
+
+void nsWindow::SetZIndex(int32_t aZIndex) {
+  nsIWidget* oldPrev = GetPrevSibling();
+
+  nsBaseWidget::SetZIndex(aZIndex);
+
+  if (GetPrevSibling() == oldPrev) {
+    return;
+  }
+
+  NS_ASSERTION(!mContainer, "Expected Mozilla child widget");
+
+  // We skip the nsWindows that don't have mGdkWindows.
+  // These are probably in the process of being destroyed.
+  if (!mGdkWindow) {
+    return;
+  }
+
+  if (!GetNextSibling()) {
+    // We're to be on top.
+    if (mGdkWindow) {
+      gdk_window_raise(mGdkWindow);
+    }
+  } else {
+    // All the siblings before us need to be below our widget.
+    for (nsWindow* w = this; w;
+         w = static_cast<nsWindow*>(w->GetPrevSibling())) {
+      if (w->mGdkWindow) {
+        gdk_window_lower(w->mGdkWindow);
+      }
+    }
+  }
+}
+
+void nsWindow::SetSizeMode(nsSizeMode aMode) {
+  LOG("nsWindow::SetSizeMode %d\n", aMode);
+
+  // Save the requested state.
+  nsBaseWidget::SetSizeMode(aMode);
+
+  // return if there's no shell or our current state is the same as
+  // the mode we were just set to.
+  if (!mShell || mSizeState == mSizeMode) {
+    LOG("    already set");
+    return;
+  }
+
+  switch (aMode) {
+    case nsSizeMode_Maximized:
+      LOG("    set maximized");
+      gtk_window_maximize(GTK_WINDOW(mShell));
+      break;
+    case nsSizeMode_Minimized:
+      LOG("    set minimized");
+      gtk_window_iconify(GTK_WINDOW(mShell));
+      break;
+    case nsSizeMode_Fullscreen:
+      LOG("    set fullscreen");
+      MakeFullScreen(true);
+      break;
+
+    default:
+      LOG("    set normal");
+      // nsSizeMode_Normal, really.
+      if (mSizeState == nsSizeMode_Minimized) {
+        gtk_window_deiconify(GTK_WINDOW(mShell));
+      } else if (mSizeState == nsSizeMode_Maximized) {
+        gtk_window_unmaximize(GTK_WINDOW(mShell));
+      } else if (mSizeState == nsSizeMode_Fullscreen) {
+        MakeFullScreen(false);
+      }
+      break;
+  }
+
+  // Request mBounds update from configure event as we may not get
+  // OnSizeAllocate for size state changes (Bug 1489463).
+  mBoundsAreValid = false;
+
+  mSizeState = mSizeMode;
+}
+
+static bool GetWindowManagerName(GdkWindow* gdk_window, nsACString& wmName) {
+  if (!GdkIsX11Display()) {
+    return false;
+  }
+
+#ifdef MOZ_X11
+  Display* xdisplay = gdk_x11_get_default_xdisplay();
+  GdkScreen* screen = gdk_window_get_screen(gdk_window);
+  Window root_win = GDK_WINDOW_XID(gdk_screen_get_root_window(screen));
+
+  int actual_format_return;
+  Atom actual_type_return;
+  unsigned long nitems_return;
+  unsigned long bytes_after_return;
+  unsigned char* prop_return = nullptr;
+  auto releaseXProperty = MakeScopeExit([&] {
+    if (prop_return) {
+      XFree(prop_return);
+    }
+  });
+
+  Atom property = XInternAtom(xdisplay, "_NET_SUPPORTING_WM_CHECK", true);
+  Atom req_type = XInternAtom(xdisplay, "WINDOW", true);
+  if (!property || !req_type) {
+    return false;
+  }
+  int result =
+      XGetWindowProperty(xdisplay, root_win, property,
+                         0L,                  // offset
+                         sizeof(Window) / 4,  // length
+                         false,               // delete
+                         req_type, &actual_type_return, &actual_format_return,
+                         &nitems_return, &bytes_after_return, &prop_return);
+
+  if (result != Success || bytes_after_return != 0 || nitems_return != 1) {
+    return false;
+  }
+
+  Window wmWindow = reinterpret_cast<Window*>(prop_return)[0];
+  if (!wmWindow) {
+    return false;
+  }
+
+  XFree(prop_return);
+  prop_return = nullptr;
+
+  property = XInternAtom(xdisplay, "_NET_WM_NAME", true);
+  req_type = XInternAtom(xdisplay, "UTF8_STRING", true);
+  if (!property || !req_type) {
+    return false;
+  }
+  {
+    // Suppress fatal errors for a missing window.
+    ScopedXErrorHandler handler;
+    result =
+        XGetWindowProperty(xdisplay, wmWindow, property,
+                           0L,         // offset
+                           INT32_MAX,  // length
+                           false,      // delete
+                           req_type, &actual_type_return, &actual_format_return,
+                           &nitems_return, &bytes_after_return, &prop_return);
+  }
+
+  if (result != Success || bytes_after_return != 0) {
+    return false;
+  }
+
+  wmName = reinterpret_cast<const char*>(prop_return);
+  return true;
+#endif
+}
+
+#define kDesktopMutterSchema "org.gnome.mutter"
+#define kDesktopDynamicWorkspacesKey "dynamic-workspaces"
+
+static bool WorkspaceManagementDisabled(GdkWindow* gdk_window) {
+  if (Preferences::GetBool("widget.disable-workspace-management", false)) {
+    return true;
+  }
+  if (Preferences::HasUserValue("widget.workspace-management")) {
+    return Preferences::GetBool("widget.workspace-management");
+  }
+
+  static const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
+  if (currentDesktop && strstr(currentDesktop, "GNOME")) {
+    // Gnome uses dynamic workspaces by default so disable workspace management
+    // in that case.
+    bool usesDynamicWorkspaces = true;
+    nsCOMPtr<nsIGSettingsService> gsettings =
+        do_GetService(NS_GSETTINGSSERVICE_CONTRACTID);
+    if (gsettings) {
+      nsCOMPtr<nsIGSettingsCollection> mutterSettings;
+      gsettings->GetCollectionForSchema(nsLiteralCString(kDesktopMutterSchema),
+                                        getter_AddRefs(mutterSettings));
+      if (mutterSettings) {
+        if (NS_SUCCEEDED(mutterSettings->GetBoolean(
+                nsLiteralCString(kDesktopDynamicWorkspacesKey),
+                &usesDynamicWorkspaces))) {
+        }
+      }
+    }
+    return usesDynamicWorkspaces;
+  }
+
+  // When XDG_CURRENT_DESKTOP is missing, try to get window manager name.
+  if (!currentDesktop) {
+    nsAutoCString wmName;
+    if (GetWindowManagerName(gdk_window, wmName)) {
+      if (wmName.EqualsLiteral("bspwm")) {
+        return true;
+      }
+      if (wmName.EqualsLiteral("i3")) {
+        return true;
+      }
+    }
+  }
+
+  return false;
+}
+
+void nsWindow::GetWorkspaceID(nsAString& workspaceID) {
+  workspaceID.Truncate();
+
+  if (!GdkIsX11Display() || !mShell) {
+    return;
+  }
+
+#ifdef MOZ_X11
+  LOG("nsWindow::GetWorkspaceID()\n");
+
+  // Get the gdk window for this widget.
+  GdkWindow* gdk_window = gtk_widget_get_window(mShell);
+  if (!gdk_window) {
+    LOG("  missing Gdk window, quit.");
+    return;
+  }
+
+  if (WorkspaceManagementDisabled(gdk_window)) {
+    LOG("  WorkspaceManagementDisabled, quit.");
+    return;
+  }
+
+  GdkAtom cardinal_atom = gdk_x11_xatom_to_atom(XA_CARDINAL);
+  GdkAtom type_returned;
+  int format_returned;
+  int length_returned;
+  long* wm_desktop;
+
+  if (!gdk_property_get(gdk_window, gdk_atom_intern("_NET_WM_DESKTOP", FALSE),
+                        cardinal_atom,
+                        0,          // offset
+                        INT32_MAX,  // length
+                        FALSE,      // delete
+                        &type_returned, &format_returned, &length_returned,
+                        (guchar**)&wm_desktop)) {
+    LOG("  gdk_property_get() failed, quit.");
+    return;
+  }
+
+  LOG("  got workspace ID %d", (int32_t)wm_desktop[0]);
+  workspaceID.AppendInt((int32_t)wm_desktop[0]);
+  g_free(wm_desktop);
+#endif
+}
+
+void nsWindow::MoveToWorkspace(const nsAString& workspaceIDStr) {
+  nsresult rv = NS_OK;
+  int32_t workspaceID = workspaceIDStr.ToInteger(&rv);
+
+  LOG("nsWindow::MoveToWorkspace() ID %d", workspaceID);
+  if (NS_FAILED(rv) || !workspaceID || !GdkIsX11Display() || !mShell) {
+    LOG("  MoveToWorkspace disabled, quit");
+    return;
+  }
+
+#ifdef MOZ_X11
+  // Get the gdk window for this widget.
+  GdkWindow* gdk_window = gtk_widget_get_window(mShell);
+  if (!gdk_window) {
+    LOG("  failed to get GdkWindow, quit.");
+    return;
+  }
+
+  // This code is inspired by some found in the 'gxtuner' project.
+  // https://github.com/brummer10/gxtuner/blob/792d453da0f3a599408008f0f1107823939d730d/deskpager.cpp#L50
+  XEvent xevent;
+  Display* xdisplay = gdk_x11_get_default_xdisplay();
+  GdkScreen* screen = gdk_window_get_screen(gdk_window);
+  Window root_win = GDK_WINDOW_XID(gdk_screen_get_root_window(screen));
+  GdkDisplay* display = gdk_window_get_display(gdk_window);
+  Atom type = gdk_x11_get_xatom_by_name_for_display(display, "_NET_WM_DESKTOP");
+
+  xevent.type = ClientMessage;
+  xevent.xclient.type = ClientMessage;
+  xevent.xclient.serial = 0;
+  xevent.xclient.send_event = TRUE;
+  xevent.xclient.display = xdisplay;
+  xevent.xclient.window = GDK_WINDOW_XID(gdk_window);
+  xevent.xclient.message_type = type;
+  xevent.xclient.format = 32;
+  xevent.xclient.data.l[0] = workspaceID;
+  xevent.xclient.data.l[1] = X11CurrentTime;
+  xevent.xclient.data.l[2] = 0;
+  xevent.xclient.data.l[3] = 0;
+  xevent.xclient.data.l[4] = 0;
+
+  XSendEvent(xdisplay, root_win, FALSE,
+             SubstructureNotifyMask | SubstructureRedirectMask, &xevent);
+
+  XFlush(xdisplay);
+  LOG("  moved to workspace");
+#endif
+}
+
+using SetUserTimeFunc = void (*)(GdkWindow*, guint32);
+
+static void SetUserTimeAndStartupIDForActivatedWindow(GtkWidget* aWindow) {
+  nsGTKToolkit* GTKToolkit = nsGTKToolkit::GetToolkit();
+  if (!GTKToolkit) return;
+
+  nsAutoCString desktopStartupID;
+  GTKToolkit->GetDesktopStartupID(&desktopStartupID);
+  if (desktopStartupID.IsEmpty()) {
+    // We don't have the data we need. Fall back to an
+    // approximation ... using the timestamp of the remote command
+    // being received as a guess for the timestamp of the user event
+    // that triggered it.
+    uint32_t timestamp = GTKToolkit->GetFocusTimestamp();
+    if (timestamp) {
+      gdk_window_focus(gtk_widget_get_window(aWindow), timestamp);
+      GTKToolkit->SetFocusTimestamp(0);
+    }
+    return;
+  }
+
+  gtk_window_set_startup_id(GTK_WINDOW(aWindow), desktopStartupID.get());
+
+  // If we used the startup ID, that already contains the focus timestamp;
+  // we don't want to reuse the timestamp next time we raise the window
+  GTKToolkit->SetFocusTimestamp(0);
+  GTKToolkit->SetDesktopStartupID(""_ns);
+}
+
+/* static */
+guint32 nsWindow::GetLastUserInputTime() {
+  // gdk_x11_display_get_user_time/gtk_get_current_event_time tracks
+  // button and key presses, DESKTOP_STARTUP_ID used to start the app,
+  // drop events from external drags,
+  // WM_DELETE_WINDOW delete events, but not usually mouse motion nor
+  // button and key releases.  Therefore use the most recent of
+  // gdk_x11_display_get_user_time and the last time that we have seen.
+#ifdef MOZ_X11
+  GdkDisplay* gdkDisplay = gdk_display_get_default();
+  guint32 timestamp = GdkIsX11Display(gdkDisplay)
+                          ? gdk_x11_display_get_user_time(gdkDisplay)
+                          : gtk_get_current_event_time();
+#else
+  guint32 timestamp = gtk_get_current_event_time();
+#endif
+
+  if (sLastUserInputTime != GDK_CURRENT_TIME &&
+      TimestampIsNewerThan(sLastUserInputTime, timestamp)) {
+    return sLastUserInputTime;
+  }
+
+  return timestamp;
+}
+
+#ifdef MOZ_WAYLAND
+void nsWindow::FocusWaylandWindow(const char* aTokenID) {
+  auto releaseToken = mozilla::MakeScopeExit(
+      [&]() { g_clear_pointer(&mXdgToken, xdg_activation_token_v1_destroy); });
+
+  LOG("nsWindow::SetFocusWayland");
+  if (IsDestroyed()) {
+    LOG("  already destroyed, quit.");
+    return;
+  }
+  wl_surface* surface =
+      mGdkWindow ? gdk_wayland_window_get_wl_surface(mGdkWindow) : nullptr;
+  if (!surface) {
+    LOG("  mGdkWindow is not visible, quit.");
+    return;
+  }
+
+  LOG("  requesting xdg-activation, surface ID %d",
+      wl_proxy_get_id((struct wl_proxy*)surface));
+
+  xdg_activation_v1* xdg_activation = WaylandDisplayGet()->GetXdgActivation();
+  xdg_activation_v1_activate(xdg_activation, aTokenID, surface);
+}
+
+// We've got activation token from Wayland compositor so it's time to use it.
+static void token_done(gpointer data, struct xdg_activation_token_v1* provider,
+                       const char* token) {
+  // Compensate aWindow->AddRef() from nsWindow::RequestFocusWaylandWindow().
+  RefPtr<nsWindow> window = dont_AddRef(static_cast<nsWindow*>(data));
+  window->FocusWaylandWindow(token);
+}
+
+static const struct xdg_activation_token_v1_listener token_listener = {
+    token_done,
+};
+
+void nsWindow::RequestFocusWaylandWindow(RefPtr<nsWindow> aWindow) {
+  LOGW("nsWindow::RequestFocusWaylandWindow(%p) gFocusWindow %p",
+       (void*)aWindow, gFocusWindow);
+
+  if (!gFocusWindow || gFocusWindow->IsDestroyed()) {
+    LOGW("  missing gFocusWindow, quit.");
+    return;
+  }
+
+  RefPtr<nsWaylandDisplay> display = WaylandDisplayGet();
+  xdg_activation_v1* xdg_activation = display->GetXdgActivation();
+  if (!xdg_activation) {
+    LOGW("  xdg-activation is missing, quit.");
+    return;
+  }
+
+  wl_surface* focusSurface;
+  uint32_t focusSerial;
+  KeymapWrapper::GetFocusInfo(&focusSurface, &focusSerial);
+  if (!focusSurface) {
+    LOGW("  We're missing KeymapWrapper focused window, quit.");
+    return;
+  }
+
+  GdkWindow* gdkWindow = gtk_widget_get_window(gFocusWindow->mShell);
+  if (!gdkWindow) {
+    LOGW("  gFocusWindow is not mapped, quit.");
+    return;
+  }
+  wl_surface* surface = gdk_wayland_window_get_wl_surface(gdkWindow);
+  if (focusSurface != surface) {
+    LOGW("  focused surface %p and gFocusWindow surface %p don't match, quit.",
+         focusSurface, surface);
+    return;
+  }
+
+  LOGW(
+      "  requesting xdg-activation token, surface %p ID %d serial %d seat ID "
+      "%d",
+      focusSurface,
+      focusSurface ? wl_proxy_get_id((struct wl_proxy*)focusSurface) : 0,
+      focusSerial, wl_proxy_get_id((struct wl_proxy*)KeymapWrapper::GetSeat()));
+
+  // Store activation token at activated window for further release.
+  g_clear_pointer(&aWindow->mXdgToken, xdg_activation_token_v1_destroy);
+  aWindow->mXdgToken = xdg_activation_v1_get_activation_token(xdg_activation);
+
+  // Addref aWindow to avoid potential release untill we get token_done
+  // callback.
+  xdg_activation_token_v1_add_listener(aWindow->mXdgToken, &token_listener,
+                                       do_AddRef(aWindow).take());
+  xdg_activation_token_v1_set_serial(aWindow->mXdgToken, focusSerial,
+                                     KeymapWrapper::GetSeat());
+  xdg_activation_token_v1_set_surface(aWindow->mXdgToken, focusSurface);
+  xdg_activation_token_v1_commit(aWindow->mXdgToken);
+}
+#endif
+
+// Request activation of this window or give focus to this widget.
+// aRaise means whether we should request activation of this widget's
+// toplevel window.
+//
+// nsWindow::SetFocus(Raise::Yes) - Raise and give focus to toplevel window.
+// nsWindow::SetFocus(Raise::No) - Give focus to this window.
+void nsWindow::SetFocus(Raise aRaise, mozilla::dom::CallerType aCallerType) {
+  LOG("nsWindow::SetFocus Raise %d\n", aRaise == Raise::Yes);
+
+  // Raise the window if someone passed in true and the prefs are
+  // set properly.
+  GtkWidget* toplevelWidget = gtk_widget_get_toplevel(GTK_WIDGET(mContainer));
+
+  LOG("  gFocusWindow [%p]\n", gFocusWindow);
+  LOG("  mContainer [%p]\n", GTK_WIDGET(mContainer));
+  LOG("  Toplevel widget [%p]\n", toplevelWidget);
+
+  // Make sure that our owning widget has focus.  If it doesn't try to
+  // grab it.  Note that we don't set our focus flag in this case.
+  if (StaticPrefs::mozilla_widget_raise_on_setfocus_AtStartup() &&
+      aRaise == Raise::Yes && toplevelWidget &&
+      !gtk_widget_has_focus(toplevelWidget)) {
+    if (gtk_widget_get_visible(mShell)) {
+      gdk_window_show_unraised(gtk_widget_get_window(mShell));
+      // Unset the urgency hint if possible.
+      SetUrgencyHint(mShell, false);
+    }
+  }
+
+  RefPtr<nsWindow> toplevelWindow = get_window_for_gtk_widget(toplevelWidget);
+  if (!toplevelWindow) {
+    LOG("  missing toplevel nsWindow, quit\n");
+    return;
+  }
+
+  if (aRaise == Raise::Yes) {
+    // means request toplevel activation.
+
+    // This is asynchronous.
+    // If and when the window manager accepts the request, then the focus
+    // widget will get a focus-in-event signal.
+    if (StaticPrefs::mozilla_widget_raise_on_setfocus_AtStartup() &&
+        toplevelWindow->mIsShown && toplevelWindow->mShell &&
+        !gtk_window_is_active(GTK_WINDOW(toplevelWindow->mShell))) {
+      uint32_t timestamp = GDK_CURRENT_TIME;
+
+      nsGTKToolkit* GTKToolkit = nsGTKToolkit::GetToolkit();
+      if (GTKToolkit) {
+        timestamp = GTKToolkit->GetFocusTimestamp();
+        GTKToolkit->SetFocusTimestamp(0);
+      }
+      if (!timestamp) {
+        timestamp = GetLastUserInputTime();
+      }
+
+      LOG("  requesting toplevel activation [%p]\n", (void*)toplevelWindow);
+      gtk_window_present_with_time(GTK_WINDOW(toplevelWindow->mShell),
+                                   timestamp);
+
+#ifdef MOZ_WAYLAND
+      if (GdkIsWaylandDisplay()) {
+        RequestFocusWaylandWindow(toplevelWindow);
+      }
+#endif
+    }
+    return;
+  }
+
+  // aRaise == No means that keyboard events should be dispatched from this
+  // widget.
+
+  // Ensure GTK_WIDGET(mContainer) is the focused GtkWidget within its toplevel
+  // window.
+  //
+  // For eWindowType_popup, this GtkWidget may not actually be the one that
+  // receives the key events as it may be the parent window that is active.
+  if (!gtk_widget_is_focus(GTK_WIDGET(mContainer))) {
+    // This is synchronous.  It takes focus from a plugin or from a widget
+    // in an embedder.  The focus manager already knows that this window
+    // is active so gBlockActivateEvent avoids another (unnecessary)
+    // activate notification.
+    gBlockActivateEvent = true;
+    gtk_widget_grab_focus(GTK_WIDGET(mContainer));
+    gBlockActivateEvent = false;
+  }
+
+  // If this is the widget that already has focus, return.
+  if (gFocusWindow == this) {
+    LOG("  already have focus");
+    return;
+  }
+
+  // Set this window to be the focused child window
+  gFocusWindow = this;
+
+  if (mIMContext) {
+    mIMContext->OnFocusWindow(this);
+  }
+
+  LOG("  widget now has focus in SetFocus()");
+}
+
+LayoutDeviceIntRect nsWindow::GetScreenBounds() {
+  LayoutDeviceIntRect rect;
+  if (mContainer) {
+    // use the point including window decorations
+    gint x, y;
+    gdk_window_get_root_origin(gtk_widget_get_window(GTK_WIDGET(mContainer)),
+                               &x, &y);
+    rect.MoveTo(GdkPointToDevicePixels({x, y}));
+  } else {
+    rect.MoveTo(WidgetToScreenOffset());
+  }
+  // mBounds.Size() is the window bounds, not the window-manager frame
+  // bounds (bug 581863).  gdk_window_get_frame_extents would give the
+  // frame bounds, but mBounds.Size() is returned here for consistency
+  // with Resize.
+  rect.SizeTo(mBounds.Size());
+#if MOZ_LOGGING
+  gint scale = GdkCeiledScaleFactor();
+  LOG("GetScreenBounds %d,%d -> %d x %d, unscaled %d,%d -> %d x %d\n", rect.x,
+      rect.y, rect.width, rect.height, rect.x / scale, rect.y / scale,
+      rect.width / scale, rect.height / scale);
+#endif
+  return rect;
+}
+
+LayoutDeviceIntSize nsWindow::GetClientSize() {
+  return LayoutDeviceIntSize(mBounds.width, mBounds.height);
+}
+
+LayoutDeviceIntRect nsWindow::GetClientBounds() {
+  // GetBounds returns a rect whose top left represents the top left of the
+  // outer bounds, but whose width/height represent the size of the inner
+  // bounds (which is messed up).
+  LayoutDeviceIntRect rect = GetBounds();
+  rect.MoveBy(GetClientOffset());
+  return rect;
+}
+
+void nsWindow::UpdateClientOffsetFromFrameExtents() {
+  AUTO_PROFILER_LABEL("nsWindow::UpdateClientOffsetFromFrameExtents", OTHER);
+
+  if (mGtkWindowDecoration == GTK_DECORATION_CLIENT && mDrawInTitlebar) {
+    return;
+  }
+
+  if (!mShell ||
+      gtk_window_get_window_type(GTK_WINDOW(mShell)) == GTK_WINDOW_POPUP) {
+    mClientOffset = nsIntPoint(0, 0);
+    return;
+  }
+
+#ifdef MOZ_X11
+  GdkAtom cardinal_atom = gdk_x11_xatom_to_atom(XA_CARDINAL);
+
+  GdkAtom type_returned;
+  int format_returned;
+  int length_returned;
+  long* frame_extents;
+
+  if (!gdk_property_get(gtk_widget_get_window(mShell),
+                        gdk_atom_intern("_NET_FRAME_EXTENTS", FALSE),
+                        cardinal_atom,
+                        0,      // offset
+                        4 * 4,  // length
+                        FALSE,  // delete
+                        &type_returned, &format_returned, &length_returned,
+                        (guchar**)&frame_extents) ||
+      length_returned / sizeof(glong) != 4) {
+    mClientOffset = nsIntPoint(0, 0);
+  } else {
+    // data returned is in the order left, right, top, bottom
+    auto left = int32_t(frame_extents[0]);
+    auto top = int32_t(frame_extents[2]);
+    g_free(frame_extents);
+
+    mClientOffset = nsIntPoint(left, top);
+  }
+
+  // Send a WindowMoved notification. This ensures that BrowserParent
+  // picks up the new client offset and sends it to the child process
+  // if appropriate.
+  NotifyWindowMoved(mBounds.x, mBounds.y);
+
+  LOG("nsWindow::UpdateClientOffsetFromFrameExtents %d,%d\n", mClientOffset.x,
+      mClientOffset.y);
+#endif
+}
+
+LayoutDeviceIntPoint nsWindow::GetClientOffset() {
+  return GdkIsX11Display()
+             ? LayoutDeviceIntPoint::FromUnknownPoint(mClientOffset)
+             : LayoutDeviceIntPoint(0, 0);
+}
+
+gboolean nsWindow::OnPropertyNotifyEvent(GtkWidget* aWidget,
+                                         GdkEventProperty* aEvent) {
+  if (aEvent->atom == gdk_atom_intern("_NET_FRAME_EXTENTS", FALSE)) {
+    UpdateClientOffsetFromFrameExtents();
+    return FALSE;
+  }
+  if (!mGdkWindow) {
+    return FALSE;
+  }
+#ifdef MOZ_X11
+  if (GetCurrentTimeGetter()->PropertyNotifyHandler(aWidget, aEvent)) {
+    return TRUE;
+  }
+#endif
+  return FALSE;
+}
+
+static GdkCursor* GetCursorForImage(const nsIWidget::Cursor& aCursor,
+                                    int32_t aWidgetScaleFactor) {
+  if (!aCursor.IsCustom()) {
+    return nullptr;
+  }
+  nsIntSize size = nsIWidget::CustomCursorSize(aCursor);
+
+  // NOTE: GTK only allows integer scale factors, so we ceil to the larger scale
+  // factor and then tell gtk to scale it down. We ensure to scale at least to
+  // the GDK scale factor, so that cursors aren't downsized in HiDPI on wayland,
+  // see bug 1707533.
+  int32_t gtkScale = std::max(
+      aWidgetScaleFactor, int32_t(std::ceil(std::max(aCursor.mResolution.mX,
+                                                     aCursor.mResolution.mY))));
+
+  // Reject cursors greater than 128 pixels in some direction, to prevent
+  // spoofing.
+  // XXX ideally we should rescale. Also, we could modify the API to
+  // allow trusted content to set larger cursors.
+  //
+  // TODO(emilio, bug 1445844): Unify the solution for this with other
+  // platforms.
+  if (size.width > 128 || size.height > 128) {
+    return nullptr;
+  }
+
+  nsIntSize rasterSize = size * gtkScale;
+  RefPtr<GdkPixbuf> pixbuf =
+      nsImageToPixbuf::ImageToPixbuf(aCursor.mContainer, Some(rasterSize));
+  if (!pixbuf) {
+    return nullptr;
+  }
+
+  // Looks like all cursors need an alpha channel (tested on Gtk 2.4.4). This
+  // is of course not documented anywhere...
+  // So add one if there isn't one yet
+  if (!gdk_pixbuf_get_has_alpha(pixbuf)) {
+    RefPtr<GdkPixbuf> alphaBuf =
+        dont_AddRef(gdk_pixbuf_add_alpha(pixbuf, FALSE, 0, 0, 0));
+    pixbuf = std::move(alphaBuf);
+    if (!pixbuf) {
+      return nullptr;
+    }
+  }
+
+  cairo_surface_t* surface =
+      gdk_cairo_surface_create_from_pixbuf(pixbuf, gtkScale, nullptr);
+  if (!surface) {
+    return nullptr;
+  }
+
+  auto CleanupSurface =
+      MakeScopeExit([&]() { cairo_surface_destroy(surface); });
+
+  return gdk_cursor_new_from_surface(gdk_display_get_default(), surface,
+                                     aCursor.mHotspotX, aCursor.mHotspotY);
+}
+
+void nsWindow::SetCursor(const Cursor& aCursor) {
+  // if we're not the toplevel window pass up the cursor request to
+  // the toplevel window to handle it.
+  if (!mContainer && mGdkWindow) {
+    if (nsWindow* window = GetContainerWindow()) {
+      window->SetCursor(aCursor);
+    }
+    return;
+  }
+
+  // Only change cursor if it's actually been changed
+  if (!mUpdateCursor && mCursor == aCursor) {
+    return;
+  }
+
+  mUpdateCursor = false;
+  mCursor = aCursor;
+
+  // Try to set the cursor image first, and fall back to the numeric cursor.
+  bool fromImage = true;
+  GdkCursor* newCursor = GetCursorForImage(aCursor, GdkCeiledScaleFactor());
+  if (!newCursor) {
+    fromImage = false;
+    newCursor = get_gtk_cursor(aCursor.mDefaultCursor);
+  }
+
+  auto CleanupCursor = mozilla::MakeScopeExit([&]() {
+    // get_gtk_cursor returns a weak reference, which we shouldn't unref.
+    if (fromImage) {
+      g_object_unref(newCursor);
+    }
+  });
+
+  if (!newCursor || !mContainer) {
+    return;
+  }
+
+  gdk_window_set_cursor(gtk_widget_get_window(GTK_WIDGET(mContainer)),
+                        newCursor);
+}
+
+void nsWindow::Invalidate(const LayoutDeviceIntRect& aRect) {
+  if (!mGdkWindow) return;
+
+  GdkRectangle rect = DevicePixelsToGdkRectRoundOut(aRect);
+  gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
+
+  LOG("Invalidate (rect): %d %d %d %d\n", rect.x, rect.y, rect.width,
+      rect.height);
+}
+
+void* nsWindow::GetNativeData(uint32_t aDataType) {
+  switch (aDataType) {
+    case NS_NATIVE_WINDOW:
+    case NS_NATIVE_WIDGET: {
+      return mGdkWindow;
+    }
+
+    case NS_NATIVE_DISPLAY: {
+#ifdef MOZ_X11
+      GdkDisplay* gdkDisplay = gdk_display_get_default();
+      if (GdkIsX11Display(gdkDisplay)) {
+        return GDK_DISPLAY_XDISPLAY(gdkDisplay);
+      }
+#endif /* MOZ_X11 */
+      // Don't bother to return native display on Wayland as it's for
+      // X11 only NPAPI plugins.
+      return nullptr;
+    }
+    case NS_NATIVE_SHELLWIDGET:
+      return GetToplevelWidget();
+
+    case NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID:
+#ifdef MOZ_X11
+      if (GdkIsX11Display()) {
+        return (void*)GDK_WINDOW_XID(gdk_window_get_toplevel(mGdkWindow));
+      }
+#endif
+      NS_WARNING(
+          "nsWindow::GetNativeData(): NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID is not "
+          "handled on Wayland!");
+      return nullptr;
+    case NS_RAW_NATIVE_IME_CONTEXT: {
+      void* pseudoIMEContext = GetPseudoIMEContext();
+      if (pseudoIMEContext) {
+        return pseudoIMEContext;
+      }
+      // If IME context isn't available on this widget, we should set |this|
+      // instead of nullptr.
+      if (!mIMContext) {
+        return this;
+      }
+      return mIMContext.get();
+    }
+    case NS_NATIVE_OPENGL_CONTEXT:
+      return nullptr;
+    case NS_NATIVE_EGL_WINDOW: {
+      void* eglWindow = nullptr;
+#ifdef MOZ_X11
+      if (GdkIsX11Display()) {
+        eglWindow = mGdkWindow ? (void*)GDK_WINDOW_XID(mGdkWindow) : nullptr;
+      }
+#endif
+#ifdef MOZ_WAYLAND
+      if (GdkIsWaylandDisplay()) {
+        eglWindow = moz_container_wayland_get_egl_window(
+            mContainer, FractionalScaleFactor());
+      }
+#endif
+      LOG("Get NS_NATIVE_EGL_WINDOW window %p", eglWindow);
+      return eglWindow;
+    }
+    default:
+      NS_WARNING("nsWindow::GetNativeData called with bad value");
+      return nullptr;
+  }
+}
+
+nsresult nsWindow::SetTitle(const nsAString& aTitle) {
+  if (!mShell) return NS_OK;
+
+    // convert the string into utf8 and set the title.
+#define UTF8_FOLLOWBYTE(ch) (((ch)&0xC0) == 0x80)
+  NS_ConvertUTF16toUTF8 titleUTF8(aTitle);
+  if (titleUTF8.Length() > NS_WINDOW_TITLE_MAX_LENGTH) {
+    // Truncate overlong titles (bug 167315). Make sure we chop after a
+    // complete sequence by making sure the next char isn't a follow-byte.
+    uint32_t len = NS_WINDOW_TITLE_MAX_LENGTH;
+    while (UTF8_FOLLOWBYTE(titleUTF8[len])) --len;
+    titleUTF8.Truncate(len);
+  }
+  gtk_window_set_title(GTK_WINDOW(mShell), (const char*)titleUTF8.get());
+
+  return NS_OK;
+}
+
+void nsWindow::SetIcon(const nsAString& aIconSpec) {
+  if (!mShell) return;
+
+  nsAutoCString iconName;
+
+  if (aIconSpec.EqualsLiteral("default")) {
+    nsAutoString brandName;
+    WidgetUtils::GetBrandShortName(brandName);
+    if (brandName.IsEmpty()) {
+      brandName.AssignLiteral(u"Mozilla");
+    }
+    AppendUTF16toUTF8(brandName, iconName);
+    ToLowerCase(iconName);
+  } else {
+    AppendUTF16toUTF8(aIconSpec, iconName);
+  }
+
+  nsCOMPtr<nsIFile> iconFile;
+  nsAutoCString path;
+
+  gint* iconSizes = gtk_icon_theme_get_icon_sizes(gtk_icon_theme_get_default(),
+                                                  iconName.get());
+  bool foundIcon = (iconSizes[0] != 0);
+  g_free(iconSizes);
+
+  if (!foundIcon) {
+    // Look for icons with the following suffixes appended to the base name
+    // The last two entries (for the old XPM format) will be ignored unless
+    // no icons are found using other suffixes. XPM icons are deprecated.
+
+    const char16_t extensions[9][8] = {u".png",    u"16.png", u"32.png",
+                                       u"48.png",  u"64.png", u"128.png",
+                                       u"256.png", u".xpm",   u"16.xpm"};
+
+    for (uint32_t i = 0; i < ArrayLength(extensions); i++) {
+      // Don't bother looking for XPM versions if we found a PNG.
+      if (i == ArrayLength(extensions) - 2 && foundIcon) break;
+
+      ResolveIconName(aIconSpec, nsDependentString(extensions[i]),
+                      getter_AddRefs(iconFile));
+      if (iconFile) {
+        iconFile->GetNativePath(path);
+        GdkPixbuf* icon = gdk_pixbuf_new_from_file(path.get(), nullptr);
+        if (icon) {
+          gtk_icon_theme_add_builtin_icon(iconName.get(),
+                                          gdk_pixbuf_get_height(icon), icon);
+          g_object_unref(icon);
+          foundIcon = true;
+        }
+      }
+    }
+  }
+
+  // leave the default icon intact if no matching icons were found
+  if (foundIcon) {
+    gtk_window_set_icon_name(GTK_WINDOW(mShell), iconName.get());
+  }
+}
+
+/* TODO(bug 1655924): gdk_window_get_origin is can block waiting for the X
+   server for a long time, we would like to use the implementation below
+   instead. However, removing the synchronous x server queries causes a race
+   condition to surface, causing issues such as bug 1652743 and bug 1653711.
+
+
+   This code can be used instead of gdk_window_get_origin() but it cuases
+   such issues:
+
+    *aX = 0;
+    *aY = 0;
+    if (!aWindow) {
+      return;
+    }
+
+    GdkWindow* current = aWindow;
+    while (GdkWindow* parent = gdk_window_get_parent(current)) {
+      if (parent == current) {
+        break;
+      }
+
+      int x = 0;
+      int y = 0;
+      gdk_window_get_position(current, &x, &y);
+      *aX += x;
+      *aY += y;
+
+      current = parent;
+    }
+*/
+LayoutDeviceIntPoint nsWindow::WidgetToScreenOffset() {
+  nsIntPoint origin(0, 0);
+  if (mGdkWindow) {
+    gdk_window_get_origin(mGdkWindow, &origin.x, &origin.y);
+  }
+  return GdkPointToDevicePixels({origin.x, origin.y});
+}
+
+void nsWindow::CaptureMouse(bool aCapture) {
+  LOG("nsWindow::CaptureMouse()");
+
+  if (mIsDestroyed) {
+    return;
+  }
+
+  if (aCapture) {
+    gtk_grab_add(GTK_WIDGET(mContainer));
+    GrabPointer(GetLastUserInputTime());
+  } else {
+    ReleaseGrabs();
+    gtk_grab_remove(GTK_WIDGET(mContainer));
+  }
+}
+
+void nsWindow::CaptureRollupEvents(nsIRollupListener* aListener,
+                                   bool aDoCapture) {
+  LOG("CaptureRollupEvents() %i\n", int(aDoCapture));
+
+  if (mIsDestroyed) {
+    return;
+  }
+
+  if (aDoCapture) {
+    gRollupListener = aListener;
+    // Don't add a grab if a drag is in progress, or if the widget is a drag
+    // feedback popup. (panels with type="drag").
+    if (!GdkIsWaylandDisplay() && !mIsDragPopup &&
+        !nsWindow::DragInProgress()) {
+      gtk_grab_add(GTK_WIDGET(mContainer));
+      GrabPointer(GetLastUserInputTime());
+    }
+  } else {
+    if (!nsWindow::DragInProgress()) {
+      ReleaseGrabs();
+    }
+    // There may not have been a drag in process when aDoCapture was set,
+    // so make sure to remove any added grab.  This is a no-op if the grab
+    // was not added to this widget.
+    LOG("  remove mContainer grab [%p]\n", this);
+    gtk_grab_remove(GTK_WIDGET(mContainer));
+    gRollupListener = nullptr;
+  }
+}
+
+nsresult nsWindow::GetAttention(int32_t aCycleCount) {
+  LOG("nsWindow::GetAttention");
+
+  GtkWidget* top_window = GetToplevelWidget();
+  GtkWidget* top_focused_window =
+      gFocusWindow ? gFocusWindow->GetToplevelWidget() : nullptr;
+
+  // Don't get attention if the window is focused anyway.
+  if (top_window && (gtk_widget_get_visible(top_window)) &&
+      top_window != top_focused_window) {
+    SetUrgencyHint(top_window, true);
+  }
+
+  return NS_OK;
+}
+
+bool nsWindow::HasPendingInputEvent() {
+  // This sucks, but gtk/gdk has no way to answer the question we want while
+  // excluding paint events, and there's no X API that will let us peek
+  // without blocking or removing.  To prevent event reordering, peek
+  // anything except expose events.  Reordering expose and others should be
+  // ok, hopefully.
+  bool haveEvent = false;
+#ifdef MOZ_X11
+  XEvent ev;
+  if (GdkIsX11Display()) {
+    Display* display = GDK_DISPLAY_XDISPLAY(gdk_display_get_default());
+    haveEvent = XCheckMaskEvent(
+        display,
+        KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask |
+            EnterWindowMask | LeaveWindowMask | PointerMotionMask |
+            PointerMotionHintMask | Button1MotionMask | Button2MotionMask |
+            Button3MotionMask | Button4MotionMask | Button5MotionMask |
+            ButtonMotionMask | KeymapStateMask | VisibilityChangeMask |
+            StructureNotifyMask | ResizeRedirectMask | SubstructureNotifyMask |
+            SubstructureRedirectMask | FocusChangeMask | PropertyChangeMask |
+            ColormapChangeMask | OwnerGrabButtonMask,
+        &ev);
+    if (haveEvent) {
+      XPutBackEvent(display, &ev);
+    }
+  }
+#endif
+  return haveEvent;
+}
+
+#ifdef cairo_copy_clip_rectangle_list
+#  error "Looks like we're including Mozilla's cairo instead of system cairo"
+#endif
+static bool ExtractExposeRegion(LayoutDeviceIntRegion& aRegion, cairo_t* cr) {
+  cairo_rectangle_list_t* rects = cairo_copy_clip_rectangle_list(cr);
+  if (rects->status != CAIRO_STATUS_SUCCESS) {
+    NS_WARNING("Failed to obtain cairo rectangle list.");
+    return false;
+  }
+
+  for (int i = 0; i < rects->num_rectangles; i++) {
+    const cairo_rectangle_t& r = rects->rectangles[i];
+    aRegion.Or(aRegion,
+               LayoutDeviceIntRect::Truncate((float)r.x, (float)r.y,
+                                             (float)r.width, (float)r.height));
+  }
+
+  cairo_rectangle_list_destroy(rects);
+  return true;
+}
+
+#ifdef MOZ_WAYLAND
+void nsWindow::CreateCompositorVsyncDispatcher() {
+  LOG_VSYNC("nsWindow::CreateCompositorVsyncDispatcher()");
+  if (!mWaylandVsyncSource) {
+    LOG_VSYNC(
+        "  mWaylandVsyncSource is missing, create "
+        "nsBaseWidget::CompositorVsyncDispatcher()");
+    nsBaseWidget::CreateCompositorVsyncDispatcher();
+    return;
+  }
+
+  if (XRE_IsParentProcess()) {
+    if (!mCompositorVsyncDispatcherLock) {
+      mCompositorVsyncDispatcherLock =
+          MakeUnique<Mutex>("mCompositorVsyncDispatcherLock");
+    }
+    MutexAutoLock lock(*mCompositorVsyncDispatcherLock);
+    if (!mCompositorVsyncDispatcher) {
+      LOG_VSYNC("  create CompositorVsyncDispatcher()");
+      mCompositorVsyncDispatcher =
+          new CompositorVsyncDispatcher(mWaylandVsyncSource);
+    }
+  }
+}
+#endif
+
+gboolean nsWindow::OnExposeEvent(cairo_t* cr) {
+  // Send any pending resize events so that layout can update.
+  // May run event loop.
+  MaybeDispatchResized();
+
+  if (mIsDestroyed) {
+    return FALSE;
+  }
+
+  // Windows that are not visible will be painted after they become visible.
+  if (!mGdkWindow || !mHasMappedToplevel) {
+    return FALSE;
+  }
+#ifdef MOZ_WAYLAND
+  if (GdkIsWaylandDisplay() && !moz_container_wayland_can_draw(mContainer)) {
+    return FALSE;
+  }
+#endif
+
+  nsIWidgetListener* listener = GetListener();
+  if (!listener) return FALSE;
+
+  LOG("received expose event %p 0x%lx (rects follow):\n", mGdkWindow,
+      GetX11Window());
+  LayoutDeviceIntRegion exposeRegion;
+  if (!ExtractExposeRegion(exposeRegion, cr)) {
+    return FALSE;
+  }
+
+  gint scale = GdkCeiledScaleFactor();
+  LayoutDeviceIntRegion region = exposeRegion;
+  region.ScaleRoundOut(scale, scale);
+
+  WindowRenderer* renderer = GetWindowRenderer();
+  WebRenderLayerManager* layerManager = renderer->AsWebRender();
+  KnowsCompositor* knowsCompositor = renderer->AsKnowsCompositor();
+
+  if (knowsCompositor && layerManager && mCompositorSession) {
+    if (!mConfiguredClearColor && !IsPopup()) {
+      layerManager->WrBridge()->SendSetDefaultClearColor(LookAndFeel::Color(
+          LookAndFeel::ColorID::Window, LookAndFeel::ColorSchemeForChrome(),
+          LookAndFeel::UseStandins::No));
+      mConfiguredClearColor = true;
+    }
+
+    // We need to paint to the screen even if nothing changed, since if we
+    // don't have a compositing window manager, our pixels could be stale.
+    layerManager->SetNeedsComposite(true);
+    layerManager->SendInvalidRegion(region.ToUnknownRegion());
+  }
+
+  RefPtr<nsWindow> strongThis(this);
+
+  // Dispatch WillPaintWindow notification to allow scripts etc. to run
+  // before we paint
+  {
+    listener->WillPaintWindow(this);
+
+    // If the window has been destroyed during the will paint notification,
+    // there is nothing left to do.
+    if (!mGdkWindow) return TRUE;
+
+    // Re-get the listener since the will paint notification might have
+    // killed it.
+    listener = GetListener();
+    if (!listener) return FALSE;
+  }
+
+  if (knowsCompositor && layerManager && layerManager->NeedsComposite()) {
+    layerManager->ScheduleComposite(wr::RenderReasons::WIDGET);
+    layerManager->SetNeedsComposite(false);
+  }
+
+  // Our bounds may have changed after calling WillPaintWindow.  Clip
+  // to the new bounds here.  The region is relative to this
+  // window.
+  region.And(region, LayoutDeviceIntRect(0, 0, mBounds.width, mBounds.height));
+
+  bool shaped = false;
+  if (eTransparencyTransparent == GetTransparencyMode()) {
+    auto* window = static_cast<nsWindow*>(GetTopLevelWidget());
+    if (mTransparencyBitmapForTitlebar) {
+      if (mSizeState == nsSizeMode_Normal) {
+        window->UpdateTitlebarTransparencyBitmap();
+      } else {
+        window->ClearTransparencyBitmap();
+      }
+    } else {
+      if (mHasAlphaVisual) {
+        // Remove possible shape mask from when window manger was not
+        // previously compositing.
+        window->ClearTransparencyBitmap();
+      } else {
+        shaped = true;
+      }
+    }
+  }
+
+  if (region.IsEmpty()) {
+    return TRUE;
+  }
+
+  // If this widget uses OMTC...
+  if (renderer->GetBackendType() == LayersBackend::LAYERS_WR) {
+    listener->PaintWindow(this, region);
+
+    // Re-get the listener since the will paint notification might have
+    // killed it.
+    listener = GetListener();
+    if (!listener) return TRUE;
+
+    listener->DidPaintWindow();
+    return TRUE;
+  }
+
+  BufferMode layerBuffering = BufferMode::BUFFERED;
+  RefPtr<DrawTarget> dt = StartRemoteDrawingInRegion(region, &layerBuffering);
+  if (!dt || !dt->IsValid()) {
+    return FALSE;
+  }
+  RefPtr<gfxContext> ctx;
+  IntRect boundsRect = region.GetBounds().ToUnknownRect();
+  IntPoint offset(0, 0);
+  if (dt->GetSize() == boundsRect.Size()) {
+    offset = boundsRect.TopLeft();
+    dt->SetTransform(Matrix::Translation(-offset));
+  }
+
+#ifdef MOZ_X11
+  if (shaped) {
+    // Collapse update area to the bounding box. This is so we only have to
+    // call UpdateTranslucentWindowAlpha once. After we have dropped
+    // support for non-Thebes graphics, UpdateTranslucentWindowAlpha will be
+    // our private interface so we can rework things to avoid this.
+    dt->PushClipRect(Rect(boundsRect));
+
+    // The double buffering is done here to extract the shape mask.
+    // (The shape mask won't be necessary when a visual with an alpha
+    // channel is used on compositing window managers.)
+    layerBuffering = BufferMode::BUFFER_NONE;
+    RefPtr<DrawTarget> destDT =
+        dt->CreateSimilarDrawTarget(boundsRect.Size(), SurfaceFormat::B8G8R8A8);
+    if (!destDT || !destDT->IsValid()) {
+      return FALSE;
+    }
+    destDT->SetTransform(Matrix::Translation(-boundsRect.TopLeft()));
+    ctx = gfxContext::CreatePreservingTransformOrNull(destDT);
+  } else {
+    gfxUtils::ClipToRegion(dt, region.ToUnknownRegion());
+    ctx = gfxContext::CreatePreservingTransformOrNull(dt);
+  }
+  MOZ_ASSERT(ctx);  // checked both dt and destDT valid draw target above
+
+#  if 0
+    // NOTE: Paint flashing region would be wrong for cairo, since
+    // cairo inflates the update region, etc.  So don't paint flash
+    // for cairo.
+#    ifdef DEBUG
+    // XXX aEvent->region may refer to a newly-invalid area.  FIXME
+    if (0 && WANT_PAINT_FLASHING && gtk_widget_get_window(aEvent))
+        gdk_window_flash(mGdkWindow, 1, 100, aEvent->region);
+#    endif
+#  endif
+
+#endif  // MOZ_X11
+
+  bool painted = false;
+  {
+    if (renderer->GetBackendType() == LayersBackend::LAYERS_NONE) {
+      if (GetTransparencyMode() == eTransparencyTransparent &&
+          layerBuffering == BufferMode::BUFFER_NONE && mHasAlphaVisual) {
+        // If our draw target is unbuffered and we use an alpha channel,
+        // clear the image beforehand to ensure we don't get artifacts from a
+        // reused SHM image. See bug 1258086.
+        dt->ClearRect(Rect(boundsRect));
+      }
+      AutoLayerManagerSetup setupLayerManager(this, ctx, layerBuffering);
+      painted = listener->PaintWindow(this, region);
+
+      // Re-get the listener since the will paint notification might have
+      // killed it.
+      listener = GetListener();
+      if (!listener) return TRUE;
+    }
+  }
+
+#ifdef MOZ_X11
+  // PaintWindow can Destroy us (bug 378273), avoid doing any paint
+  // operations below if that happened - it will lead to XError and exit().
+  if (shaped) {
+    if (MOZ_LIKELY(!mIsDestroyed)) {
+      if (painted) {
+        RefPtr<SourceSurface> surf = ctx->GetDrawTarget()->Snapshot();
+
+        UpdateAlpha(surf, boundsRect);
+
+        dt->DrawSurface(surf, Rect(boundsRect),
+                        Rect(0, 0, boundsRect.width, boundsRect.height),
+                        DrawSurfaceOptions(SamplingFilter::POINT),
+                        DrawOptions(1.0f, CompositionOp::OP_SOURCE));
+      }
+    }
+  }
+
+  ctx = nullptr;
+  dt->PopClip();
+
+#endif  // MOZ_X11
+
+  EndRemoteDrawingInRegion(dt, region);
+
+  listener->DidPaintWindow();
+
+  // Synchronously flush any new dirty areas
+  cairo_region_t* dirtyArea = gdk_window_get_update_area(mGdkWindow);
+
+  if (dirtyArea) {
+    gdk_window_invalidate_region(mGdkWindow, dirtyArea, false);
+    cairo_region_destroy(dirtyArea);
+    gdk_window_process_updates(mGdkWindow, false);
+  }
+
+  // check the return value!
+  return TRUE;
+}
+
+void nsWindow::UpdateAlpha(SourceSurface* aSourceSurface,
+                           nsIntRect aBoundsRect) {
+  // We need to create our own buffer to force the stride to match the
+  // expected stride.
+  int32_t stride =
+      GetAlignedStride<4>(aBoundsRect.width, BytesPerPixel(SurfaceFormat::A8));
+  if (stride == 0) {
+    return;
+  }
+  int32_t bufferSize = stride * aBoundsRect.height;
+  auto imageBuffer = MakeUniqueFallible<uint8_t[]>(bufferSize);
+  {
+    RefPtr<DrawTarget> drawTarget = gfxPlatform::CreateDrawTargetForData(
+        imageBuffer.get(), aBoundsRect.Size(), stride, SurfaceFormat::A8);
+
+    if (drawTarget) {
+      drawTarget->DrawSurface(aSourceSurface,
+                              Rect(0, 0, aBoundsRect.width, aBoundsRect.height),
+                              Rect(0, 0, aSourceSurface->GetSize().width,
+                                   aSourceSurface->GetSize().height),
+                              DrawSurfaceOptions(SamplingFilter::POINT),
+                              DrawOptions(1.0f, CompositionOp::OP_SOURCE));
+    }
+  }
+  UpdateTranslucentWindowAlphaInternal(aBoundsRect, imageBuffer.get(), stride);
+}
+
+gboolean nsWindow::OnConfigureEvent(GtkWidget* aWidget,
+                                    GdkEventConfigure* aEvent) {
+  // These events are only received on toplevel windows.
+  //
+  // GDK ensures that the coordinates are the client window top-left wrt the
+  // root window.
+  //
+  //   GDK calculates the cordinates for real ConfigureNotify events on
+  //   managed windows (that would normally be relative to the parent
+  //   window).
+  //
+  //   Synthetic ConfigureNotify events are from the window manager and
+  //   already relative to the root window.  GDK creates all X windows with
+  //   border_width = 0, so synthetic events also indicate the top-left of
+  //   the client window.
+  //
+  //   Override-redirect windows are children of the root window so parent
+  //   coordinates are root coordinates.
+
+  LOG("configure event %d,%d -> %d x %d scale %d\n", aEvent->x, aEvent->y,
+      aEvent->width, aEvent->height,
+      mGdkWindow ? gdk_window_get_scale_factor(mGdkWindow) : -1);
+
+  if (mPendingConfigures > 0) {
+    mPendingConfigures--;
+  }
+
+  // Don't fire configure event for scale changes, we handle that
+  // OnScaleChanged event. Skip that for toplevel windows only.
+  if (mWindowType == eWindowType_toplevel) {
+    MOZ_DIAGNOSTIC_ASSERT(mGdkWindow,
+                          "Getting configure for invisible window?");
+    if (mWindowScaleFactor != gdk_window_get_scale_factor(mGdkWindow)) {
+      LOG("  scale factor changed to %d,return early",
+          gdk_window_get_scale_factor(mGdkWindow));
+      return FALSE;
+    }
+  }
+
+  LayoutDeviceIntRect screenBounds = GetScreenBounds();
+
+  if (mWindowType == eWindowType_toplevel ||
+      mWindowType == eWindowType_dialog) {
+    // This check avoids unwanted rollup on spurious configure events from
+    // Cygwin/X (bug 672103).
+    if (mBounds.x != screenBounds.x || mBounds.y != screenBounds.y) {
+      CheckForRollup(0, 0, false, true);
+    }
+  }
+
+  NS_ASSERTION(GTK_IS_WINDOW(aWidget),
+               "Configure event on widget that is not a GtkWindow");
+  if (gtk_window_get_window_type(GTK_WINDOW(aWidget)) == GTK_WINDOW_POPUP) {
+    // Override-redirect window
+    //
+    // These windows should not be moved by the window manager, and so any
+    // change in position is a result of our direction.  mBounds has
+    // already been set in std::move() or Resize(), and that is more
+    // up-to-date than the position in the ConfigureNotify event if the
+    // event is from an earlier window move.
+    //
+    // Skipping the WindowMoved call saves context menus from an infinite
+    // loop when nsXULPopupManager::PopupMoved moves the window to the new
+    // position and nsMenuPopupFrame::SetPopupPosition adds
+    // offsetForContextMenu on each iteration.
+
+    // Our back buffer might have been invalidated while we drew the last
+    // frame, and its contents might be incorrect. See bug 1280653 comment 7
+    // and comment 10. Specifically we must ensure we recomposite the frame
+    // as soon as possible to avoid the corrupted frame being displayed.
+    GetWindowRenderer()->FlushRendering(wr::RenderReasons::WIDGET);
+    return FALSE;
+  }
+
+  mBounds.MoveTo(screenBounds.TopLeft());
+
+  // XXX mozilla will invalidate the entire window after this move
+  // complete.  wtf?
+  NotifyWindowMoved(mBounds.x, mBounds.y);
+
+  // A GTK app would usually update its client area size in response to
+  // a "size-allocate" signal.
+  // However, we need to set mBounds in advance at Resize()
+  // as JS code expects immediate window size change.
+  // If Gecko requests a resize from GTK, but subsequently,
+  // before a corresponding "size-allocate" signal is emitted, the window is
+  // resized to its former size via other means, such as maximizing,
+  // then there is no "size-allocate" signal from which to update
+  // the value of mBounds. Similarly, if Gecko's resize request is refused
+  // by the window manager, then there will be no "size-allocate" signal.
+  // In the refused request case, the window manager is required to dispatch
+  // a ConfigureNotify event. mBounds can then be updated here.
+  // This seems to also be sufficient to update mBounds when Gecko resizes
+  // the window from maximized size and then immediately maximizes again.
+  if (!mBoundsAreValid) {
+    GtkAllocation allocation = {-1, -1, 0, 0};
+    gtk_window_get_size(GTK_WINDOW(mShell), &allocation.width,
+                        &allocation.height);
+    OnSizeAllocate(&allocation);
+  }
+
+  return FALSE;
+}
+
+void nsWindow::OnMap() {
+  LOG("nsWindow::OnMap");
+  // Gtk mapped out widget to screen. Configure underlying GdkWindow properly
+  // as our rendering target.
+  // This call means we have X11 (or Wayland) window we can render to by GL
+  // so we need to notify compositor about it.
+  mIsMapped = true;
+  ConfigureGdkWindow();
+}
+
+void nsWindow::OnUnrealize() {
+  // The GdkWindows are about to be destroyed (but not deleted), so remove
+  // their references back to their container widget while the GdkWindow
+  // hierarchy is still available.
+  // This call means we *don't* have X11 (or Wayland) window we can render to.
+  LOG("nsWindow::OnUnrealize GdkWindow %p", mGdkWindow);
+  mIsMapped = false;
+  ReleaseGdkWindow();
+}
+
+void nsWindow::OnSizeAllocate(GtkAllocation* aAllocation) {
+  LOG("nsWindow::OnSizeAllocate %d,%d -> %d x %d\n", aAllocation->x,
+      aAllocation->y, aAllocation->width, aAllocation->height);
+
+  // Client offset are updated by _NET_FRAME_EXTENTS on X11 when system titlebar
+  // is enabled. In either cases (Wayland or system titlebar is off on X11)
+  // we don't get _NET_FRAME_EXTENTS X11 property notification so we derive
+  // it from mContainer position.
+  if (mGtkWindowDecoration == GTK_DECORATION_CLIENT) {
+    if (GdkIsWaylandDisplay() || (GdkIsX11Display() && mDrawInTitlebar)) {
+      UpdateClientOffsetFromCSDWindow();
+    }
+  }
+
+  mBoundsAreValid = true;
+
+  LayoutDeviceIntSize size = GdkRectToDevicePixels(*aAllocation).Size();
+  if (mBounds.Size() == size) {
+    LOG("  Already the same size");
+    // We were already resized at nsWindow::OnConfigureEvent() so skip it.
+    return;
+  }
+
+  // Invalidate the new part of the window now for the pending paint to
+  // minimize background flashes (GDK does not do this for external resizes
+  // of toplevels.)
+  if (mGdkWindow) {
+    if (mBounds.width < size.width) {
+      GdkRectangle rect = DevicePixelsToGdkRectRoundOut(LayoutDeviceIntRect(
+          mBounds.width, 0, size.width - mBounds.width, size.height));
+      gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
+    }
+    if (mBounds.height < size.height) {
+      GdkRectangle rect = DevicePixelsToGdkRectRoundOut(LayoutDeviceIntRect(
+          0, mBounds.height, size.width, size.height - mBounds.height));
+      gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
+    }
+  }
+
+  mBounds.SizeTo(size);
+
+  // Notify the GtkCompositorWidget of a ClientSizeChange
+  if (mCompositorWidgetDelegate) {
+    mCompositorWidgetDelegate->NotifyClientSizeChanged(GetClientSize());
+  }
+
+  // Gecko permits running nested event loops during processing of events,
+  // GtkWindow callers of gtk_widget_size_allocate expect the signal
+  // handlers to return sometime in the near future.
+  mNeedsDispatchResized = true;
+  NS_DispatchToCurrentThread(NewRunnableMethod(
+      "nsWindow::MaybeDispatchResized", this, &nsWindow::MaybeDispatchResized));
+}
+
+void nsWindow::OnDeleteEvent() {
+  if (mWidgetListener) mWidgetListener->RequestWindowClose(this);
+}
+
+void nsWindow::OnEnterNotifyEvent(GdkEventCrossing* aEvent) {
+  // This skips NotifyVirtual and NotifyNonlinearVirtual enter notify events
+  // when the pointer enters a child window.  If the destination window is a
+  // Gecko window then we'll catch the corresponding event on that window,
+  // but we won't notice when the pointer directly enters a foreign (plugin)
+  // child window without passing over a visible portion of a Gecko window.
+  if (aEvent->subwindow != nullptr) return;
+
+  // Check before is_parent_ungrab_enter() as the button state may have
+  // changed while a non-Gecko ancestor window had a pointer grab.
+  DispatchMissedButtonReleases(aEvent);
+
+  if (is_parent_ungrab_enter(aEvent)) {
+    return;
+  }
+
+  WidgetMouseEvent event(true, eMouseEnterIntoWidget, this,
+                         WidgetMouseEvent::eReal);
+
+  event.mRefPoint = GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+  event.AssignEventTime(GetWidgetEventTime(aEvent->time));
+
+  LOG("OnEnterNotify");
+
+  DispatchInputEvent(&event);
+}
+
+// XXX Is this the right test for embedding cases?
+static bool is_top_level_mouse_exit(GdkWindow* aWindow,
+                                    GdkEventCrossing* aEvent) {
+  auto x = gint(aEvent->x_root);
+  auto y = gint(aEvent->y_root);
+  GdkDevice* pointer = GdkGetPointer();
+  GdkWindow* winAtPt = gdk_device_get_window_at_position(pointer, &x, &y);
+  if (!winAtPt) return true;
+  GdkWindow* topLevelAtPt = gdk_window_get_toplevel(winAtPt);
+  GdkWindow* topLevelWidget = gdk_window_get_toplevel(aWindow);
+  return topLevelAtPt != topLevelWidget;
+}
+
+void nsWindow::OnLeaveNotifyEvent(GdkEventCrossing* aEvent) {
+  // This ignores NotifyVirtual and NotifyNonlinearVirtual leave notify
+  // events when the pointer leaves a child window.  If the destination
+  // window is a Gecko window then we'll catch the corresponding event on
+  // that window.
+  //
+  // XXXkt However, we will miss toplevel exits when the pointer directly
+  // leaves a foreign (plugin) child window without passing over a visible
+  // portion of a Gecko window.
+  if (!mGdkWindow || aEvent->subwindow != nullptr) {
+    return;
+  }
+
+  WidgetMouseEvent event(true, eMouseExitFromWidget, this,
+                         WidgetMouseEvent::eReal);
+
+  event.mRefPoint = GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+  event.AssignEventTime(GetWidgetEventTime(aEvent->time));
+
+  event.mExitFrom = Some(is_top_level_mouse_exit(mGdkWindow, aEvent)
+                             ? WidgetMouseEvent::ePlatformTopLevel
+                             : WidgetMouseEvent::ePlatformChild);
+
+  LOG("OnLeaveNotify");
+
+  DispatchInputEvent(&event);
+}
+
+bool nsWindow::CheckResizerEdge(LayoutDeviceIntPoint aPoint,
+                                GdkWindowEdge& aOutEdge) {
+  // We only need to handle resizers for PIP window.
+  if (!mIsPIPWindow) {
+    return false;
+  }
+
+  // Don't allow resizing maximized windows.
+  if (mSizeState != nsSizeMode_Normal) {
+    return false;
+  }
+
+#define RESIZER_SIZE 15
+  int resizerSize = RESIZER_SIZE * GdkCeiledScaleFactor();
+  int topDist = aPoint.y;
+  int leftDist = aPoint.x;
+  int rightDist = mBounds.width - aPoint.x;
+  int bottomDist = mBounds.height - aPoint.y;
+
+  if (leftDist <= resizerSize && topDist <= resizerSize) {
+    aOutEdge = GDK_WINDOW_EDGE_NORTH_WEST;
+  } else if (rightDist <= resizerSize && topDist <= resizerSize) {
+    aOutEdge = GDK_WINDOW_EDGE_NORTH_EAST;
+  } else if (leftDist <= resizerSize && bottomDist <= resizerSize) {
+    aOutEdge = GDK_WINDOW_EDGE_SOUTH_WEST;
+  } else if (rightDist <= resizerSize && bottomDist <= resizerSize) {
+    aOutEdge = GDK_WINDOW_EDGE_SOUTH_EAST;
+  } else if (topDist <= resizerSize) {
+    aOutEdge = GDK_WINDOW_EDGE_NORTH;
+  } else if (leftDist <= resizerSize) {
+    aOutEdge = GDK_WINDOW_EDGE_WEST;
+  } else if (rightDist <= resizerSize) {
+    aOutEdge = GDK_WINDOW_EDGE_EAST;
+  } else if (bottomDist <= resizerSize) {
+    aOutEdge = GDK_WINDOW_EDGE_SOUTH;
+  } else {
+    return false;
+  }
+  return true;
+}
+
+template <typename Event>
+static LayoutDeviceIntPoint GetRefPoint(nsWindow* aWindow, Event* aEvent) {
+  if (aEvent->window == aWindow->GetGdkWindow()) {
+    // we are the window that the event happened on so no need for expensive
+    // WidgetToScreenOffset
+    return aWindow->GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+  }
+  // XXX we're never quite sure which GdkWindow the event came from due to our
+  // custom bubbling in scroll_event_cb(), so use ScreenToWidget to translate
+  // the screen root coordinates into coordinates relative to this widget.
+  return aWindow->GdkEventCoordsToDevicePixels(aEvent->x_root, aEvent->y_root) -
+         aWindow->WidgetToScreenOffset();
+}
+
+void nsWindow::OnMotionNotifyEvent(GdkEventMotion* aEvent) {
+  if (!mGdkWindow) {
+    return;
+  }
+
+  if (mWindowShouldStartDragging) {
+    mWindowShouldStartDragging = false;
+    // find the top-level window
+    GdkWindow* gdk_window = gdk_window_get_toplevel(mGdkWindow);
+    MOZ_ASSERT(gdk_window, "gdk_window_get_toplevel should not return null");
+
+    bool canDrag = true;
+#ifdef MOZ_X11
+    if (GdkIsX11Display()) {
+      // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
+      // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
+      // See _should_perform_ewmh_drag() at gdkwindow-x11.c
+      GdkScreen* screen = gdk_window_get_screen(gdk_window);
+      GdkAtom atom = gdk_atom_intern("_NET_WM_MOVERESIZE", FALSE);
+      if (!gdk_x11_screen_supports_net_wm_hint(screen, atom)) {
+        canDrag = false;
+      }
+    }
+#endif
+
+    if (canDrag) {
+      gdk_window_begin_move_drag(gdk_window, 1, aEvent->x_root, aEvent->y_root,
+                                 aEvent->time);
+      return;
+    }
+  }
+
+  GdkWindowEdge edge;
+  if (CheckResizerEdge(GetRefPoint(this, aEvent), edge)) {
+    nsCursor cursor = eCursor_none;
+    switch (edge) {
+      case GDK_WINDOW_EDGE_NORTH:
+        cursor = eCursor_n_resize;
+        break;
+      case GDK_WINDOW_EDGE_NORTH_WEST:
+        cursor = eCursor_nw_resize;
+        break;
+      case GDK_WINDOW_EDGE_NORTH_EAST:
+        cursor = eCursor_ne_resize;
+        break;
+      case GDK_WINDOW_EDGE_WEST:
+        cursor = eCursor_w_resize;
+        break;
+      case GDK_WINDOW_EDGE_EAST:
+        cursor = eCursor_e_resize;
+        break;
+      case GDK_WINDOW_EDGE_SOUTH:
+        cursor = eCursor_s_resize;
+        break;
+      case GDK_WINDOW_EDGE_SOUTH_WEST:
+        cursor = eCursor_sw_resize;
+        break;
+      case GDK_WINDOW_EDGE_SOUTH_EAST:
+        cursor = eCursor_se_resize;
+        break;
+    }
+    SetCursor(Cursor{cursor});
+    return;
+  }
+
+  WidgetMouseEvent event(true, eMouseMove, this, WidgetMouseEvent::eReal);
+
+  gdouble pressure = 0;
+  gdk_event_get_axis((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+  // Sometime gdk generate 0 pressure value between normal values
+  // We have to ignore that and use last valid value
+  if (pressure) mLastMotionPressure = pressure;
+  event.mPressure = mLastMotionPressure;
+  event.mRefPoint = GetRefPoint(this, aEvent);
+  event.AssignEventTime(GetWidgetEventTime(aEvent->time));
+
+  KeymapWrapper::InitInputEvent(event, aEvent->state);
+
+  DispatchInputEvent(&event);
+}
+
+// If the automatic pointer grab on ButtonPress has deactivated before
+// ButtonRelease, and the mouse button is released while the pointer is not
+// over any a Gecko window, then the ButtonRelease event will not be received.
+// (A similar situation exists when the pointer is grabbed with owner_events
+// True as the ButtonRelease may be received on a foreign [plugin] window).
+// Use this method to check for released buttons when the pointer returns to a
+// Gecko window.
+void nsWindow::DispatchMissedButtonReleases(GdkEventCrossing* aGdkEvent) {
+  guint changed = aGdkEvent->state ^ gButtonState;
+  // Only consider button releases.
+  // (Ignore button presses that occurred outside Gecko.)
+  guint released = changed & gButtonState;
+  gButtonState = aGdkEvent->state;
+
+  // Loop over each button, excluding mouse wheel buttons 4 and 5 for which
+  // GDK ignores releases.
+  for (guint buttonMask = GDK_BUTTON1_MASK; buttonMask <= GDK_BUTTON3_MASK;
+       buttonMask <<= 1) {
+    if (released & buttonMask) {
+      int16_t buttonType;
+      switch (buttonMask) {
+        case GDK_BUTTON1_MASK:
+          buttonType = MouseButton::ePrimary;
+          break;
+        case GDK_BUTTON2_MASK:
+          buttonType = MouseButton::eMiddle;
+          break;
+        default:
+          NS_ASSERTION(buttonMask == GDK_BUTTON3_MASK,
+                       "Unexpected button mask");
+          buttonType = MouseButton::eSecondary;
+      }
+
+      LOG("Synthesized button %u release", guint(buttonType + 1));
+
+      // Dispatch a synthesized button up event to tell Gecko about the
+      // change in state.  This event is marked as synthesized so that
+      // it is not dispatched as a DOM event, because we don't know the
+      // position, widget, modifiers, or time/order.
+      WidgetMouseEvent synthEvent(true, eMouseUp, this,
+                                  WidgetMouseEvent::eSynthesized);
+      synthEvent.mButton = buttonType;
+      DispatchInputEvent(&synthEvent);
+    }
+  }
+}
+
+void nsWindow::InitButtonEvent(WidgetMouseEvent& aEvent,
+                               GdkEventButton* aGdkEvent) {
+  aEvent.mRefPoint = GetRefPoint(this, aGdkEvent);
+
+  guint modifierState = aGdkEvent->state;
+  // aEvent's state includes the button state from immediately before this
+  // event.  If aEvent is a mousedown or mouseup event, we need to update
+  // the button state.
+  guint buttonMask = 0;
+  switch (aGdkEvent->button) {
+    case 1:
+      buttonMask = GDK_BUTTON1_MASK;
+      break;
+    case 2:
+      buttonMask = GDK_BUTTON2_MASK;
+      break;
+    case 3:
+      buttonMask = GDK_BUTTON3_MASK;
+      break;
+  }
+  if (aGdkEvent->type == GDK_BUTTON_RELEASE) {
+    modifierState &= ~buttonMask;
+  } else {
+    modifierState |= buttonMask;
+  }
+
+  KeymapWrapper::InitInputEvent(aEvent, modifierState);
+
+  aEvent.AssignEventTime(GetWidgetEventTime(aGdkEvent->time));
+
+  switch (aGdkEvent->type) {
+    case GDK_2BUTTON_PRESS:
+      aEvent.mClickCount = 2;
+      break;
+    case GDK_3BUTTON_PRESS:
+      aEvent.mClickCount = 3;
+      break;
+      // default is one click
+    default:
+      aEvent.mClickCount = 1;
+  }
+}
+
+static guint ButtonMaskFromGDKButton(guint button) {
+  return GDK_BUTTON1_MASK << (button - 1);
+}
+
+void nsWindow::DispatchContextMenuEventFromMouseEvent(uint16_t domButton,
+                                                      GdkEventButton* aEvent) {
+  if (domButton == MouseButton::eSecondary && MOZ_LIKELY(!mIsDestroyed)) {
+    WidgetMouseEvent contextMenuEvent(true, eContextMenu, this,
+                                      WidgetMouseEvent::eReal);
+    InitButtonEvent(contextMenuEvent, aEvent);
+    contextMenuEvent.mPressure = mLastMotionPressure;
+    DispatchInputEvent(&contextMenuEvent);
+  }
+}
+
+void nsWindow::OnButtonPressEvent(GdkEventButton* aEvent) {
+  LOG("Button %u press\n", aEvent->button);
+
+  // If you double click in GDK, it will actually generate a second
+  // GDK_BUTTON_PRESS before sending the GDK_2BUTTON_PRESS, and this is
+  // different than the DOM spec.  GDK puts this in the queue
+  // programatically, so it's safe to assume that if there's a
+  // double click in the queue, it was generated so we can just drop
+  // this click.
+  GdkEvent* peekedEvent = gdk_event_peek();
+  if (peekedEvent) {
+    GdkEventType type = peekedEvent->any.type;
+    gdk_event_free(peekedEvent);
+    if (type == GDK_2BUTTON_PRESS || type == GDK_3BUTTON_PRESS) return;
+  }
+
+  nsWindow* containerWindow = GetContainerWindow();
+  if (!gFocusWindow && containerWindow) {
+    containerWindow->DispatchActivateEvent();
+  }
+
+  // check to see if we should rollup
+  if (CheckForRollup(aEvent->x_root, aEvent->y_root, false, false)) return;
+
+  // Check to see if the event is within our window's resize region
+  GdkWindowEdge edge;
+  if (CheckResizerEdge(GetRefPoint(this, aEvent), edge)) {
+    gdk_window_begin_resize_drag(gtk_widget_get_window(mShell), edge,
+                                 aEvent->button, aEvent->x_root, aEvent->y_root,
+                                 aEvent->time);
+    return;
+  }
+
+  gdouble pressure = 0;
+  gdk_event_get_axis((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+  mLastMotionPressure = pressure;
+
+  uint16_t domButton;
+  switch (aEvent->button) {
+    case 1:
+      domButton = MouseButton::ePrimary;
+      break;
+    case 2:
+      domButton = MouseButton::eMiddle;
+      break;
+    case 3:
+      domButton = MouseButton::eSecondary;
+      break;
+    // These are mapped to horizontal scroll
+    case 6:
+    case 7:
+      NS_WARNING("We're not supporting legacy horizontal scroll event");
+      return;
+    // Map buttons 8-9 to back/forward
+    case 8:
+      if (!Preferences::GetBool("mousebutton.4th.enabled", true)) {
+        return;
+      }
+      DispatchCommandEvent(nsGkAtoms::Back);
+      return;
+    case 9:
+      if (!Preferences::GetBool("mousebutton.5th.enabled", true)) {
+        return;
+      }
+      DispatchCommandEvent(nsGkAtoms::Forward);
+      return;
+    default:
+      return;
+  }
+
+  gButtonState |= ButtonMaskFromGDKButton(aEvent->button);
+
+  WidgetMouseEvent event(true, eMouseDown, this, WidgetMouseEvent::eReal);
+  event.mButton = domButton;
+  InitButtonEvent(event, aEvent);
+  event.mPressure = mLastMotionPressure;
+
+  nsIWidget::ContentAndAPZEventStatus eventStatus = DispatchInputEvent(&event);
+
+  LayoutDeviceIntPoint refPoint =
+      GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+  if ((mIsWaylandPanelWindow ||
+       mDraggableRegion.Contains(refPoint.x, refPoint.y)) &&
+      domButton == MouseButton::ePrimary &&
+      eventStatus.mContentStatus != nsEventStatus_eConsumeNoDefault) {
+    mWindowShouldStartDragging = true;
+  }
+
+  // right menu click on linux should also pop up a context menu
+  if (!StaticPrefs::ui_context_menus_after_mouseup() &&
+      eventStatus.mApzStatus != nsEventStatus_eConsumeNoDefault) {
+    DispatchContextMenuEventFromMouseEvent(domButton, aEvent);
+  }
+}
+
+void nsWindow::OnButtonReleaseEvent(GdkEventButton* aEvent) {
+  LOG("Button %u release\n", aEvent->button);
+  if (!mGdkWindow) {
+    return;
+  }
+
+  if (mWindowShouldStartDragging) {
+    mWindowShouldStartDragging = false;
+  }
+
+  uint16_t domButton;
+  switch (aEvent->button) {
+    case 1:
+      domButton = MouseButton::ePrimary;
+      break;
+    case 2:
+      domButton = MouseButton::eMiddle;
+      break;
+    case 3:
+      domButton = MouseButton::eSecondary;
+      break;
+    default:
+      return;
+  }
+
+  gButtonState &= ~ButtonMaskFromGDKButton(aEvent->button);
+
+  WidgetMouseEvent event(true, eMouseUp, this, WidgetMouseEvent::eReal);
+  event.mButton = domButton;
+  InitButtonEvent(event, aEvent);
+  gdouble pressure = 0;
+  gdk_event_get_axis((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+  event.mPressure = pressure ? (float)pressure : (float)mLastMotionPressure;
+
+  // The mRefPoint is manipulated in DispatchInputEvent, we're saving it
+  // to use it for the doubleclick position check.
+  LayoutDeviceIntPoint pos = event.mRefPoint;
+
+  nsIWidget::ContentAndAPZEventStatus eventStatus = DispatchInputEvent(&event);
+
+  bool defaultPrevented =
+      (eventStatus.mContentStatus == nsEventStatus_eConsumeNoDefault);
+  // Check if mouse position in titlebar and doubleclick happened to
+  // trigger restore/maximize.
+  if (!defaultPrevented && mDrawInTitlebar &&
+      event.mButton == MouseButton::ePrimary && event.mClickCount == 2 &&
+      mDraggableRegion.Contains(pos.x, pos.y)) {
+    if (mSizeState == nsSizeMode_Maximized) {
+      SetSizeMode(nsSizeMode_Normal);
+    } else {
+      SetSizeMode(nsSizeMode_Maximized);
+    }
+  }
+  mLastMotionPressure = pressure;
+
+  // right menu click on linux should also pop up a context menu
+  if (StaticPrefs::ui_context_menus_after_mouseup() &&
+      eventStatus.mApzStatus != nsEventStatus_eConsumeNoDefault) {
+    DispatchContextMenuEventFromMouseEvent(domButton, aEvent);
+  }
+
+  // Open window manager menu on PIP window to allow user
+  // to place it on top / all workspaces.
+  if (mIsPIPWindow && aEvent->button == 3) {
+    static auto sGdkWindowShowWindowMenu =
+        (gboolean(*)(GdkWindow * window, GdkEvent*))
+            dlsym(RTLD_DEFAULT, "gdk_window_show_window_menu");
+    if (sGdkWindowShowWindowMenu) {
+      sGdkWindowShowWindowMenu(mGdkWindow, (GdkEvent*)aEvent);
+    }
+  }
+}
+
+void nsWindow::OnContainerFocusInEvent(GdkEventFocus* aEvent) {
+  LOG("OnContainerFocusInEvent");
+
+  // Unset the urgency hint, if possible
+  GtkWidget* top_window = GetToplevelWidget();
+  if (top_window && (gtk_widget_get_visible(top_window))) {
+    SetUrgencyHint(top_window, false);
+  }
+
+  // Return if being called within SetFocus because the focus manager
+  // already knows that the window is active.
+  if (gBlockActivateEvent) {
+    LOG("activated notification is blocked");
+    return;
+  }
+
+  // If keyboard input will be accepted, the focus manager will call
+  // SetFocus to set the correct window.
+  gFocusWindow = nullptr;
+
+  DispatchActivateEvent();
+
+  if (!gFocusWindow) {
+    // We don't really have a window for dispatching key events, but
+    // setting a non-nullptr value here prevents OnButtonPressEvent() from
+    // dispatching an activation notification if the widget is already
+    // active.
+    gFocusWindow = this;
+  }
+
+  LOG("Events sent from focus in event");
+}
+
+void nsWindow::OnContainerFocusOutEvent(GdkEventFocus* aEvent) {
+  LOG("OnContainerFocusOutEvent");
+
+  if (mWindowType == eWindowType_toplevel ||
+      mWindowType == eWindowType_dialog) {
+    nsCOMPtr<nsIDragService> dragService =
+        do_GetService("@mozilla.org/widget/dragservice;1");
+    nsCOMPtr<nsIDragSession> dragSession;
+    dragService->GetCurrentSession(getter_AddRefs(dragSession));
+
+    // Rollup popups when a window is focused out unless a drag is occurring.
+    // This check is because drags grab the keyboard and cause a focus out on
+    // versions of GTK before 2.18.
+    bool shouldRollup = !dragSession;
+    if (!shouldRollup) {
+      // we also roll up when a drag is from a different application
+      nsCOMPtr<nsINode> sourceNode;
+      dragSession->GetSourceNode(getter_AddRefs(sourceNode));
+      shouldRollup = (sourceNode == nullptr);
+    }
+
+    if (shouldRollup) {
+      CheckForRollup(0, 0, false, true);
+    }
+  }
+
+  if (gFocusWindow) {
+    RefPtr<nsWindow> kungFuDeathGrip = gFocusWindow;
+    if (gFocusWindow->mIMContext) {
+      gFocusWindow->mIMContext->OnBlurWindow(gFocusWindow);
+    }
+    gFocusWindow = nullptr;
+  }
+
+  DispatchDeactivateEvent();
+
+  if (IsChromeWindowTitlebar()) {
+    // DispatchDeactivateEvent() ultimately results in a call to
+    // BrowsingContext::SetIsActiveBrowserWindow(), which resets
+    // the state.  We call UpdateMozWindowActive() to keep it in
+    // sync with GDK_WINDOW_STATE_FOCUSED.
+    UpdateMozWindowActive();
+  }
+
+  LOG("Done with container focus out");
+}
+
+bool nsWindow::DispatchCommandEvent(nsAtom* aCommand) {
+  nsEventStatus status;
+  WidgetCommandEvent appCommandEvent(true, aCommand, this);
+  DispatchEvent(&appCommandEvent, status);
+  return TRUE;
+}
+
+bool nsWindow::DispatchContentCommandEvent(EventMessage aMsg) {
+  nsEventStatus status;
+  WidgetContentCommandEvent event(true, aMsg, this);
+  DispatchEvent(&event, status);
+  return TRUE;
+}
+
+WidgetEventTime nsWindow::GetWidgetEventTime(guint32 aEventTime) {
+  return WidgetEventTime(aEventTime, GetEventTimeStamp(aEventTime));
+}
+
+TimeStamp nsWindow::GetEventTimeStamp(guint32 aEventTime) {
+  if (MOZ_UNLIKELY(!mGdkWindow)) {
+    // nsWindow has been Destroy()ed.
+    return TimeStamp::Now();
+  }
+  if (aEventTime == 0) {
+    // Some X11 and GDK events may be received with a time of 0 to indicate
+    // that they are synthetic events. Some input method editors do this.
+    // In this case too, just return the current timestamp.
+    return TimeStamp::Now();
+  }
+
+  TimeStamp eventTimeStamp;
+
+  if (GdkIsWaylandDisplay()) {
+    // Wayland compositors use monotonic time to set timestamps.
+    int64_t timestampTime = g_get_monotonic_time() / 1000;
+    guint32 refTimeTruncated = guint32(timestampTime);
+
+    timestampTime -= refTimeTruncated - aEventTime;
+    int64_t tick =
+        BaseTimeDurationPlatformUtils::TicksFromMilliseconds(timestampTime);
+    eventTimeStamp = TimeStamp::FromSystemTime(tick);
+  } else {
+#ifdef MOZ_X11
+    CurrentX11TimeGetter* getCurrentTime = GetCurrentTimeGetter();
+    MOZ_ASSERT(getCurrentTime,
+               "Null current time getter despite having a window");
+    eventTimeStamp =
+        TimeConverter().GetTimeStampFromSystemTime(aEventTime, *getCurrentTime);
+#endif
+  }
+  return eventTimeStamp;
+}
+
+#ifdef MOZ_X11
+mozilla::CurrentX11TimeGetter* nsWindow::GetCurrentTimeGetter() {
+  MOZ_ASSERT(mGdkWindow, "Expected mGdkWindow to be set");
+  if (MOZ_UNLIKELY(!mCurrentTimeGetter)) {
+    mCurrentTimeGetter = MakeUnique<CurrentX11TimeGetter>(mGdkWindow);
+  }
+  return mCurrentTimeGetter.get();
+}
+#endif
+
+gboolean nsWindow::OnKeyPressEvent(GdkEventKey* aEvent) {
+  LOG("OnKeyPressEvent");
+
+  RefPtr<nsWindow> self(this);
+  KeymapWrapper::HandleKeyPressEvent(self, aEvent);
+  return TRUE;
+}
+
+gboolean nsWindow::OnKeyReleaseEvent(GdkEventKey* aEvent) {
+  LOG("OnKeyReleaseEvent");
+
+  RefPtr<nsWindow> self(this);
+  if (NS_WARN_IF(!KeymapWrapper::HandleKeyReleaseEvent(self, aEvent))) {
+    return FALSE;
+  }
+  return TRUE;
+}
+
+void nsWindow::OnScrollEvent(GdkEventScroll* aEvent) {
+  // check to see if we should rollup
+  if (CheckForRollup(aEvent->x_root, aEvent->y_root, true, false)) {
+    return;
+  }
+
+  // check for duplicate legacy scroll event, see GNOME bug 726878
+  if (aEvent->direction != GDK_SCROLL_SMOOTH &&
+      mLastScrollEventTime == aEvent->time) {
+    LOG("[%d] duplicate legacy scroll event %d\n", aEvent->time,
+        aEvent->direction);
+    return;
+  }
+  WidgetWheelEvent wheelEvent(true, eWheel, this);
+  wheelEvent.mDeltaMode = dom::WheelEvent_Binding::DOM_DELTA_LINE;
+  switch (aEvent->direction) {
+    case GDK_SCROLL_SMOOTH: {
+      // As of GTK 3.4, all directional scroll events are provided by
+      // the GDK_SCROLL_SMOOTH direction on XInput2 and Wayland devices.
+      mLastScrollEventTime = aEvent->time;
+
+      // Special handling for touchpads to support flings
+      // (also known as kinetic/inertial/momentum scrolling)
+      GdkDevice* device = gdk_event_get_source_device((GdkEvent*)aEvent);
+      GdkInputSource source = gdk_device_get_source(device);
+      if (source == GDK_SOURCE_TOUCHSCREEN || source == GDK_SOURCE_TOUCHPAD) {
+        if (StaticPrefs::apz_gtk_kinetic_scroll_enabled() &&
+            gtk_check_version(3, 20, 0) == nullptr) {
+          static auto sGdkEventIsScrollStopEvent =
+              (gboolean(*)(const GdkEvent*))dlsym(
+                  RTLD_DEFAULT, "gdk_event_is_scroll_stop_event");
+
+          LOG("[%d] pan smooth event dx=%f dy=%f inprogress=%d\n", aEvent->time,
+              aEvent->delta_x, aEvent->delta_y, mPanInProgress);
+          PanGestureInput::PanGestureType eventType =
+              PanGestureInput::PANGESTURE_PAN;
+          if (sGdkEventIsScrollStopEvent((GdkEvent*)aEvent)) {
+            eventType = PanGestureInput::PANGESTURE_END;
+            mPanInProgress = false;
+          } else if (!mPanInProgress) {
+            eventType = PanGestureInput::PANGESTURE_START;
+            mPanInProgress = true;
+          }
+
+          const bool isPageMode =
+              StaticPrefs::apz_gtk_kinetic_scroll_delta_mode() != 2;
+          const double multiplier =
+              isPageMode
+                  ? StaticPrefs::
+                        apz_gtk_kinetic_scroll_page_delta_mode_multiplier()
+                  : StaticPrefs::
+                            apz_gtk_kinetic_scroll_pixel_delta_mode_multiplier() *
+                        FractionalScaleFactor();
+          ScreenPoint deltas(float(aEvent->delta_x * multiplier),
+                             float(aEvent->delta_y * multiplier));
+
+          LayoutDeviceIntPoint touchPoint = GetRefPoint(this, aEvent);
+          PanGestureInput panEvent(
+              eventType, aEvent->time, GetEventTimeStamp(aEvent->time),
+              ScreenPoint(touchPoint.x, touchPoint.y), deltas,
+              KeymapWrapper::ComputeKeyModifiers(aEvent->state));
+          panEvent.mDeltaType = isPageMode ? PanGestureInput::PANDELTA_PAGE
+                                           : PanGestureInput::PANDELTA_PIXEL;
+          panEvent.mSimulateMomentum = true;
+
+          DispatchPanGestureInput(panEvent);
+
+          return;
+        }
+
+        // Older GTK doesn't support stop events, so we can't support fling
+        wheelEvent.mScrollType = WidgetWheelEvent::SCROLL_ASYNCHRONOUSLY;
+      }
+
+      // TODO - use a more appropriate scrolling unit than lines.
+      // Multiply event deltas by 3 to emulate legacy behaviour.
+      wheelEvent.mDeltaX = aEvent->delta_x * 3;
+      wheelEvent.mDeltaY = aEvent->delta_y * 3;
+      wheelEvent.mWheelTicksX = aEvent->delta_x;
+      wheelEvent.mWheelTicksY = aEvent->delta_y;
+      wheelEvent.mIsNoLineOrPageDelta = true;
+
+      break;
+    }
+    case GDK_SCROLL_UP:
+      wheelEvent.mDeltaY = wheelEvent.mLineOrPageDeltaY = -3;
+      wheelEvent.mWheelTicksY = -1;
+      break;
+    case GDK_SCROLL_DOWN:
+      wheelEvent.mDeltaY = wheelEvent.mLineOrPageDeltaY = 3;
+      wheelEvent.mWheelTicksY = 1;
+      break;
+    case GDK_SCROLL_LEFT:
+      wheelEvent.mDeltaX = wheelEvent.mLineOrPageDeltaX = -1;
+      wheelEvent.mWheelTicksX = -1;
+      break;
+    case GDK_SCROLL_RIGHT:
+      wheelEvent.mDeltaX = wheelEvent.mLineOrPageDeltaX = 1;
+      wheelEvent.mWheelTicksX = 1;
+      break;
+  }
+
+  wheelEvent.mRefPoint = GetRefPoint(this, aEvent);
+
+  KeymapWrapper::InitInputEvent(wheelEvent, aEvent->state);
+
+  wheelEvent.AssignEventTime(GetWidgetEventTime(aEvent->time));
+
+  DispatchInputEvent(&wheelEvent);
+}
+
+void nsWindow::OnWindowStateEvent(GtkWidget* aWidget,
+                                  GdkEventWindowState* aEvent) {
+  LOG("nsWindow::OnWindowStateEvent for %p changed 0x%x new_window_state "
+      "0x%x\n",
+      aWidget, aEvent->changed_mask, aEvent->new_window_state);
+
+  if (IS_MOZ_CONTAINER(aWidget)) {
+    // This event is notifying the container widget of changes to the
+    // toplevel window.  Just detect changes affecting whether windows are
+    // viewable.
+    //
+    // (A visibility notify event is sent to each window that becomes
+    // viewable when the toplevel is mapped, but we can't rely on that for
+    // setting mHasMappedToplevel because these toplevel window state
+    // events are asynchronous.  The windows in the hierarchy now may not
+    // be the same windows as when the toplevel was mapped, so they may
+    // not get VisibilityNotify events.)
+    bool mapped = !(aEvent->new_window_state &
+                    (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_WITHDRAWN));
+    if (mHasMappedToplevel != mapped) {
+      SetHasMappedToplevel(mapped);
+    }
+    LOG("\tquick return because IS_MOZ_CONTAINER(aWidget) is true\n");
+    return;
+  }
+  // else the widget is a shell widget.
+
+  // The block below is a bit evil.
+  //
+  // When a window is resized before it is shown, gtk_window_resize() delays
+  // resizes until the window is shown.  If gtk_window_state_event() sees a
+  // GDK_WINDOW_STATE_MAXIMIZED change [1] before the window is shown, then
+  // gtk_window_compute_configure_request_size() ignores the values from the
+  // resize [2].  See bug 1449166 for an example of how this could happen.
+  //
+  // [1] https://gitlab.gnome.org/GNOME/gtk/blob/3.22.30/gtk/gtkwindow.c#L7967
+  // [2] https://gitlab.gnome.org/GNOME/gtk/blob/3.22.30/gtk/gtkwindow.c#L9377
+  //
+  // In order to provide a sensible size for the window when the user exits
+  // maximized state, we hide the GDK_WINDOW_STATE_MAXIMIZED change from
+  // gtk_window_state_event() so as to trick GTK into using the values from
+  // gtk_window_resize() in its configure request.
+  //
+  // We instead notify gtk_window_state_event() of the maximized state change
+  // once the window is shown.
+  //
+  // See https://gitlab.gnome.org/GNOME/gtk/issues/1044
+  //
+  // This may be fixed in Gtk 3.24+ but some DE still have this issue
+  // (Bug 1624199) so let's remove it for Wayland only.
+#ifdef MOZ_X11
+  if (GdkIsX11Display()) {
+    if (!mIsShown) {
+      aEvent->changed_mask = static_cast<GdkWindowState>(
+          aEvent->changed_mask & ~GDK_WINDOW_STATE_MAXIMIZED);
+    } else if (aEvent->changed_mask & GDK_WINDOW_STATE_WITHDRAWN &&
+               aEvent->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) {
+      aEvent->changed_mask = static_cast<GdkWindowState>(
+          aEvent->changed_mask | GDK_WINDOW_STATE_MAXIMIZED);
+    }
+  }
+#endif
+
+  // This is a workaround for https://gitlab.gnome.org/GNOME/gtk/issues/1395
+  // Gtk+ controls window active appearance by window-state-event signal.
+  if (IsChromeWindowTitlebar() &&
+      (aEvent->changed_mask & GDK_WINDOW_STATE_FOCUSED)) {
+    // Emulate what Gtk+ does at gtk_window_state_event().
+    // We can't check GTK_STATE_FLAG_BACKDROP directly as it's set by Gtk+
+    // *after* this window-state-event handler.
+    mTitlebarBackdropState =
+        !(aEvent->new_window_state & GDK_WINDOW_STATE_FOCUSED);
+
+    // keep IsActiveBrowserWindow in sync with GDK_WINDOW_STATE_FOCUSED
+    UpdateMozWindowActive();
+
+    ForceTitlebarRedraw();
+  }
+
+  // We don't care about anything but changes in the maximized/icon/fullscreen
+  // states but we need a workaround for bug in Wayland:
+  // https://gitlab.gnome.org/GNOME/gtk/issues/67
+  // Under wayland the gtk_window_iconify implementation does NOT synthetize
+  // window_state_event where the GDK_WINDOW_STATE_ICONIFIED is set.
+  // During restore we  won't get aEvent->changed_mask with
+  // the GDK_WINDOW_STATE_ICONIFIED so to detect that change we use the stored
+  // mSizeState and obtaining a focus.
+  bool waylandWasIconified =
+      (GdkIsWaylandDisplay() &&
+       aEvent->changed_mask & GDK_WINDOW_STATE_FOCUSED &&
+       aEvent->new_window_state & GDK_WINDOW_STATE_FOCUSED &&
+       mSizeState == nsSizeMode_Minimized);
+  if (!waylandWasIconified &&
+      (aEvent->changed_mask &
+       (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED |
+        GDK_WINDOW_STATE_TILED | GDK_WINDOW_STATE_FULLSCREEN)) == 0) {
+    LOG("\tearly return because no interesting bits changed\n");
+    return;
+  }
+
+  if (aEvent->new_window_state & GDK_WINDOW_STATE_ICONIFIED) {
+    LOG("\tIconified\n");
+    mSizeState = nsSizeMode_Minimized;
+#ifdef ACCESSIBILITY
+    DispatchMinimizeEventAccessible();
+#endif  // ACCESSIBILITY
+  } else if (aEvent->new_window_state & GDK_WINDOW_STATE_FULLSCREEN) {
+    LOG("\tFullscreen\n");
+    mSizeState = nsSizeMode_Fullscreen;
+  } else if (aEvent->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) {
+    LOG("\tMaximized\n");
+    mSizeState = nsSizeMode_Maximized;
+#ifdef ACCESSIBILITY
+    DispatchMaximizeEventAccessible();
+#endif  // ACCESSIBILITY
+  } else {
+    LOG("\tNormal\n");
+    mSizeState = nsSizeMode_Normal;
+#ifdef ACCESSIBILITY
+    DispatchRestoreEventAccessible();
+#endif  // ACCESSIBILITY
+  }
+
+  if (aEvent->new_window_state & GDK_WINDOW_STATE_TILED) {
+    LOG("\tTiled\n");
+    mIsTiled = true;
+  } else {
+    LOG("\tNot tiled\n");
+    mIsTiled = false;
+  }
+
+  if (mWidgetListener) {
+    mWidgetListener->SizeModeChanged(mSizeState);
+    if (aEvent->changed_mask & GDK_WINDOW_STATE_FULLSCREEN) {
+      mWidgetListener->FullscreenChanged(aEvent->new_window_state &
+                                         GDK_WINDOW_STATE_FULLSCREEN);
+    }
+  }
+
+  if (mDrawInTitlebar && mTransparencyBitmapForTitlebar) {
+    if (mSizeState == nsSizeMode_Normal && !mIsTiled) {
+      UpdateTitlebarTransparencyBitmap();
+    } else {
+      ClearTransparencyBitmap();
+    }
+  }
+}
+
+void nsWindow::OnDPIChanged() {
+  // Update menu's font size etc.
+  // This affects style / layout because it affects system font sizes.
+  if (mWidgetListener) {
+    if (PresShell* presShell = mWidgetListener->GetPresShell()) {
+      presShell->BackingScaleFactorChanged();
+    }
+    mWidgetListener->UIResolutionChanged();
+  }
+  NotifyThemeChanged(ThemeChangeKind::StyleAndLayout);
+}
+
+void nsWindow::OnCheckResize() { mPendingConfigures++; }
+
+void nsWindow::OnCompositedChanged() {
+  // Update CSD after the change in alpha visibility. This only affects
+  // system metrics, not other theme shenanigans.
+  NotifyThemeChanged(ThemeChangeKind::MediaQueriesOnly);
+  mCompositedScreen = gdk_screen_is_composited(gdk_screen_get_default());
+}
+
+void nsWindow::OnScaleChanged() {
+  // Force scale factor recalculation
+  if (!mGdkWindow) {
+    mWindowScaleFactorChanged = true;
+    return;
+  }
+
+  // Gtk supply us sometimes with doubled events so stay calm in such case.
+  if (gdk_window_get_scale_factor(mGdkWindow) == mWindowScaleFactor) {
+    return;
+  }
+
+  // We pause compositor to avoid rendering of obsoleted remote content which
+  // produces flickering.
+  // Re-enable compositor again when remote content is updated or
+  // timeout happens.
+  PauseCompositor();
+
+  // Force scale factor recalculation
+  mWindowScaleFactorChanged = true;
+
+  GtkAllocation allocation;
+  gtk_widget_get_allocation(GTK_WIDGET(mContainer), &allocation);
+  LayoutDeviceIntSize size = GdkRectToDevicePixels(allocation).Size();
+  mBoundsAreValid = true;
+  mBounds.SizeTo(size);
+
+  if (mWidgetListener) {
+    if (PresShell* presShell = mWidgetListener->GetPresShell()) {
+      presShell->BackingScaleFactorChanged();
+    }
+  }
+  // This affects style / layout because it affects system font sizes.
+  // Update menu's font size etc.
+  NotifyThemeChanged(ThemeChangeKind::StyleAndLayout);
+
+  DispatchResized();
+
+  if (mCompositorWidgetDelegate) {
+    mCompositorWidgetDelegate->NotifyClientSizeChanged(GetClientSize());
+  }
+
+  if (mCursor.IsCustom()) {
+    mUpdateCursor = true;
+    SetCursor(Cursor{mCursor});
+  }
+}
+
+void nsWindow::DispatchDragEvent(EventMessage aMsg,
+                                 const LayoutDeviceIntPoint& aRefPoint,
+                                 guint aTime) {
+  WidgetDragEvent event(true, aMsg, this);
+
+  InitDragEvent(event);
+
+  event.mRefPoint = aRefPoint;
+  event.AssignEventTime(GetWidgetEventTime(aTime));
+
+  DispatchInputEvent(&event);
+}
+
+void nsWindow::OnDragDataReceivedEvent(GtkWidget* aWidget,
+                                       GdkDragContext* aDragContext, gint aX,
+                                       gint aY,
+                                       GtkSelectionData* aSelectionData,
+                                       guint aInfo, guint aTime,
+                                       gpointer aData) {
+  LOGDRAG("nsWindow::OnDragDataReceived(%p)\n", (void*)this);
+
+  RefPtr<nsDragService> dragService = nsDragService::GetInstance();
+  dragService->TargetDataReceived(aWidget, aDragContext, aX, aY, aSelectionData,
+                                  aInfo, aTime);
+}
+
+nsWindow* nsWindow::GetTransientForWindowIfPopup() {
+  if (mWindowType != eWindowType_popup) {
+    return nullptr;
+  }
+  GtkWindow* toplevel = gtk_window_get_transient_for(GTK_WINDOW(mShell));
+  if (toplevel) {
+    return get_window_for_gtk_widget(GTK_WIDGET(toplevel));
+  }
+  return nullptr;
+}
+
+bool nsWindow::IsHandlingTouchSequence(GdkEventSequence* aSequence) {
+  return mHandleTouchEvent && mTouches.Contains(aSequence);
+}
+
+gboolean nsWindow::OnTouchpadPinchEvent(GdkEventTouchpadPinch* aEvent) {
+  if (!StaticPrefs::apz_gtk_touchpad_pinch_enabled()) {
+    return TRUE;
+  }
+  // Do not respond to pinch gestures involving more than two fingers
+  // unless specifically preffed on. These are sometimes hooked up to other
+  // actions at the desktop environment level and having the browser also
+  // pinch can be undesirable.
+  if (aEvent->n_fingers > 2 &&
+      !StaticPrefs::apz_gtk_touchpad_pinch_three_fingers_enabled()) {
+    return FALSE;
+  }
+  auto pinchGestureType = PinchGestureInput::PINCHGESTURE_SCALE;
+  ScreenCoord currentSpan;
+  ScreenCoord previousSpan;
+
+  switch (aEvent->phase) {
+    case GDK_TOUCHPAD_GESTURE_PHASE_BEGIN:
+      pinchGestureType = PinchGestureInput::PINCHGESTURE_START;
+      currentSpan = aEvent->scale;
+
+      // Assign PreviousSpan --> 0.999 to make mDeltaY field of the
+      // WidgetWheelEvent that this PinchGestureInput event will be converted
+      // to not equal Zero as our discussion because we observed that the
+      // scale of the PHASE_BEGIN event is 1.
+      previousSpan = 0.999;
+      break;
+
+    case GDK_TOUCHPAD_GESTURE_PHASE_UPDATE:
+      pinchGestureType = PinchGestureInput::PINCHGESTURE_SCALE;
+      if (aEvent->scale == mLastPinchEventSpan) {
+        return FALSE;
+      }
+      currentSpan = aEvent->scale;
+      previousSpan = mLastPinchEventSpan;
+      break;
+
+    case GDK_TOUCHPAD_GESTURE_PHASE_END:
+      pinchGestureType = PinchGestureInput::PINCHGESTURE_END;
+      currentSpan = aEvent->scale;
+      previousSpan = mLastPinchEventSpan;
+      break;
+
+    default:
+      return FALSE;
+  }
+
+  LayoutDeviceIntPoint touchpadPoint = GetRefPoint(this, aEvent);
+  PinchGestureInput event(
+      pinchGestureType, PinchGestureInput::TRACKPAD, aEvent->time,
+      GetEventTimeStamp(aEvent->time), ExternalPoint(0, 0),
+      ScreenPoint(touchpadPoint.x, touchpadPoint.y),
+      100.0 * ((aEvent->phase == GDK_TOUCHPAD_GESTURE_PHASE_END)
+                   ? ScreenCoord(1.f)
+                   : currentSpan),
+      100.0 * ((aEvent->phase == GDK_TOUCHPAD_GESTURE_PHASE_END)
+                   ? ScreenCoord(1.f)
+                   : previousSpan),
+      KeymapWrapper::ComputeKeyModifiers(aEvent->state));
+
+  if (!event.SetLineOrPageDeltaY(this)) {
+    return FALSE;
+  }
+
+  mLastPinchEventSpan = aEvent->scale;
+  DispatchPinchGestureInput(event);
+  return TRUE;
+}
+
+gboolean nsWindow::OnTouchEvent(GdkEventTouch* aEvent) {
+  LOG("OnTouchEvent: x=%f y=%f type=%d\n", aEvent->x, aEvent->y, aEvent->type);
+  if (!mHandleTouchEvent) {
+    // If a popup window was spawned (e.g. as the result of a long-press)
+    // and touch events got diverted to that window within a touch sequence,
+    // ensure the touch event gets sent to the original window instead. We
+    // keep the checks here very conservative so that we only redirect
+    // events in this specific scenario.
+    nsWindow* targetWindow = GetTransientForWindowIfPopup();
+    if (targetWindow &&
+        targetWindow->IsHandlingTouchSequence(aEvent->sequence)) {
+      return targetWindow->OnTouchEvent(aEvent);
+    }
+
+    return FALSE;
+  }
+
+  EventMessage msg;
+  switch (aEvent->type) {
+    case GDK_TOUCH_BEGIN:
+      // check to see if we should rollup
+      if (CheckForRollup(aEvent->x_root, aEvent->y_root, false, false)) {
+        return FALSE;
+      }
+      msg = eTouchStart;
+      break;
+    case GDK_TOUCH_UPDATE:
+      msg = eTouchMove;
+      // Start dragging when motion events happens in the dragging area
+      if (mWindowShouldStartDragging) {
+        mWindowShouldStartDragging = false;
+        GdkWindow* gdk_window = gdk_window_get_toplevel(mGdkWindow);
+        MOZ_ASSERT(gdk_window,
+                   "gdk_window_get_toplevel should not return null");
+
+        LOG("  start window dragging window\n");
+        gdk_window_begin_move_drag(gdk_window, 1, aEvent->x_root,
+                                   aEvent->y_root, aEvent->time);
+
+        // Cancel the event sequence. gdk will steal all subsequent events
+        // (including TOUCH_END).
+        msg = eTouchCancel;
+      }
+      break;
+    case GDK_TOUCH_END:
+      msg = eTouchEnd;
+      if (mWindowShouldStartDragging) {
+        LOG("  end of window dragging window\n");
+        mWindowShouldStartDragging = false;
+      }
+      break;
+    case GDK_TOUCH_CANCEL:
+      msg = eTouchCancel;
+      break;
+    default:
+      return FALSE;
+  }
+
+  LayoutDeviceIntPoint touchPoint = GetRefPoint(this, aEvent);
+
+  int32_t id;
+  RefPtr<dom::Touch> touch;
+  if (mTouches.Remove(aEvent->sequence, getter_AddRefs(touch))) {
+    id = touch->mIdentifier;
+  } else {
+    id = ++gLastTouchID & 0x7FFFFFFF;
+  }
+
+  touch =
+      new dom::Touch(id, touchPoint, LayoutDeviceIntPoint(1, 1), 0.0f, 0.0f);
+
+  WidgetTouchEvent event(true, msg, this);
+  KeymapWrapper::InitInputEvent(event, aEvent->state);
+  event.mTime = aEvent->time;
+
+  if (msg == eTouchStart || msg == eTouchMove) {
+    mTouches.InsertOrUpdate(aEvent->sequence, std::move(touch));
+    // add all touch points to event object
+    for (const auto& data : mTouches.Values()) {
+      event.mTouches.AppendElement(new dom::Touch(*data));
+    }
+  } else if (msg == eTouchEnd || msg == eTouchCancel) {
+    *event.mTouches.AppendElement() = std::move(touch);
+  }
+
+  nsIWidget::ContentAndAPZEventStatus eventStatus = DispatchInputEvent(&event);
+
+  // There's a chance that we are in drag area and the event is not consumed
+  // by something on it.
+  LayoutDeviceIntPoint refPoint =
+      GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+  if (msg == eTouchStart && mDraggableRegion.Contains(refPoint.x, refPoint.y) &&
+      eventStatus.mApzStatus != nsEventStatus_eConsumeNoDefault) {
+    mWindowShouldStartDragging = true;
+  }
+  return TRUE;
+}
+
+// Return true if toplevel window is transparent.
+// It's transparent when we're running on composited screens
+// and we can draw main window without system titlebar.
+bool nsWindow::IsToplevelWindowTransparent() {
+  static bool transparencyConfigured = false;
+
+  if (!transparencyConfigured) {
+    if (gdk_screen_is_composited(gdk_screen_get_default())) {
+      // Some Gtk+ themes use non-rectangular toplevel windows. To fully
+      // support such themes we need to make toplevel window transparent
+      // with ARGB visual.
+      // It may cause performanance issue so make it configurable
+      // and enable it by default for selected window managers.
+      if (Preferences::HasUserValue("mozilla.widget.use-argb-visuals")) {
+        // argb visual is explicitly required so use it
+        sTransparentMainWindow =
+            Preferences::GetBool("mozilla.widget.use-argb-visuals");
+      } else {
+        // Enable transparent toplevel window if we can draw main window
+        // without system titlebar as Gtk+ themes use titlebar round corners.
+        sTransparentMainWindow =
+            GetSystemGtkWindowDecoration() != GTK_DECORATION_NONE;
+      }
+    }
+    transparencyConfigured = true;
+  }
+
+  return sTransparentMainWindow;
+}
+
+#ifdef MOZ_X11
+// Configure GL visual on X11.
+bool nsWindow::ConfigureX11GLVisual() {
+  auto* screen = gtk_widget_get_screen(mShell);
+  int visualId = 0;
+  bool haveVisual = false;
+
+  if (gfxVars::UseEGL()) {
+    haveVisual = GLContextEGL::FindVisual(&visualId);
+  }
+
+  // We are on GLX or use it as a fallback on Mesa, see
+  // https://gitlab.freedesktop.org/mesa/mesa/-/issues/149
+  if (!haveVisual) {
+    auto* display = GDK_DISPLAY_XDISPLAY(gtk_widget_get_display(mShell));
+    int screenNumber = GDK_SCREEN_XNUMBER(screen);
+    haveVisual = GLContextGLX::FindVisual(display, screenNumber, &visualId);
+  }
+
+  GdkVisual* gdkVisual = nullptr;
+  if (haveVisual) {
+    // If we're using CSD, rendering will go through mContainer, but
+    // it will inherit this visual as it is a child of mShell.
+    gdkVisual = gdk_x11_screen_lookup_visual(screen, visualId);
+  }
+  if (!gdkVisual) {
+    NS_WARNING("We're missing X11 Visual!");
+    // We try to use a fallback alpha visual
+    GdkScreen* screen = gtk_widget_get_screen(mShell);
+    gdkVisual = gdk_screen_get_rgba_visual(screen);
+  }
+  if (gdkVisual) {
+    gtk_widget_set_visual(mShell, gdkVisual);
+    mHasAlphaVisual = true;
+    return true;
+  }
+
+  return false;
+}
+#endif
+
+nsAutoCString nsWindow::GetFrameTag() const {
+  if (nsIFrame* frame = GetFrame()) {
+#ifdef DEBUG_FRAME_DUMP
+    return frame->ListTag();
+#else
+    nsAutoCString buf;
+    buf.AppendPrintf("Frame(%p)", frame);
+    if (nsIContent* content = frame->GetContent()) {
+      buf.Append(' ');
+      AppendUTF16toUTF8(content->NodeName(), buf);
+    }
+    return buf;
+#endif
+  }
+  return nsAutoCString("(no frame)");
+}
+
+nsCString nsWindow::GetPopupTypeName() {
+  switch (mPopupHint) {
+    case ePopupTypeMenu:
+      return nsCString("Menu");
+    case ePopupTypeTooltip:
+      return nsCString("Tooltip");
+    case ePopupTypePanel:
+      return nsCString("Panel/Utility");
+    default:
+      return nsCString("Unknown");
+  }
+}
+
+// Disables all rendering of GtkWidget from Gtk side.
+// We do our best to persuade Gtk/Gdk to ignore all painting
+// to the widget.
+static void GtkWidgetDisableUpdates(GtkWidget* aWidget) {
+  // Clear exposure mask - it disabled synthesized events.
+  GdkWindow* window = gtk_widget_get_window(aWidget);
+  gdk_window_set_events(window, (GdkEventMask)(gdk_window_get_events(window) &
+                                               (~GDK_EXPOSURE_MASK)));
+
+  // Remove before/after paint handles from frame clock.
+  // It disables widget content updates.
+  GdkFrameClock* frame_clock = gdk_window_get_frame_clock(window);
+  g_signal_handlers_disconnect_by_data(frame_clock, window);
+}
+
+void nsWindow::EnableRenderingToWindow() {
+  LOG("nsWindow::EnableRenderingToWindow()");
+
+  if (mCompositorWidgetDelegate) {
+    mCompositorWidgetDelegate->EnableRendering(GetX11Window(),
+                                               GetShapedState());
+  }
+
+  if (GdkIsWaylandDisplay()) {
+#ifdef MOZ_WAYLAND
+    moz_container_wayland_add_initial_draw_callback(
+        mContainer, [self = RefPtr{this}, this]() -> void {
+          LOG("moz_container_wayland initial create "
+              "ResumeCompositorHiddenWindow()");
+          self->ResumeCompositorHiddenWindow();
+          self->WaylandStartVsync();
+        });
+#endif
+  } else {
+    ResumeCompositorHiddenWindow();
+    WaylandStartVsync();
+  }
+}
+
+void nsWindow::DisableRenderingToWindow() {
+  LOG("nsWindow::DisableRenderingToWindow()");
+
+  PauseCompositorHiddenWindow();
+  WaylandStopVsync();
+  if (mCompositorWidgetDelegate) {
+    mCompositorWidgetDelegate->DisableRendering();
+  }
+}
+
+Window nsWindow::GetX11Window() {
+#ifdef MOZ_X11
+  if (GdkIsX11Display()) {
+    return mGdkWindow ? gdk_x11_window_get_xid(mGdkWindow) : X11None;
+  }
+#endif
+  return (Window) nullptr;
+}
+
+void nsWindow::EnsureGdkWindow() {
+  if (!mGdkWindow) {
+    mGdkWindow = gtk_widget_get_window(mDrawToContainer ? GTK_WIDGET(mContainer)
+                                                        : mShell);
+    g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", this);
+  }
+}
+
+bool nsWindow::GetShapedState() {
+  return mIsTransparent && !mHasAlphaVisual && !mTransparencyBitmapForTitlebar;
+}
+
+void nsWindow::ConfigureGdkWindow() {
+  LOG("nsWindow::ConfigureGdkWindow() [%p]", this);
+
+  EnsureGdkWindow();
+
+#ifdef MOZ_X11
+  if (GdkIsX11Display()) {
+    GdkVisual* gdkVisual = gdk_window_get_visual(mGdkWindow);
+    Visual* visual = gdk_x11_visual_get_xvisual(gdkVisual);
+    int depth = gdk_visual_get_depth(gdkVisual);
+    mSurfaceProvider.Initialize(GetX11Window(), visual, depth,
+                                GetShapedState());
+
+    // Set window manager hint to keep fullscreen windows composited.
+    //
+    // If the window were to get unredirected, there could be visible
+    // tearing because Gecko does not align its framebuffer updates with
+    // vblank.
+    SetCompositorHint(GTK_WIDGET_COMPOSIDED_ENABLED);
+
+    // Dummy call to a function in mozgtk to prevent the linker from removing
+    // the dependency with --as-needed.
+    XShmQueryExtension(DefaultXDisplay());
+  }
+#endif
+#ifdef MOZ_WAYLAND
+  if (GdkIsWaylandDisplay()) {
+    mSurfaceProvider.Initialize(this);
+  }
+#endif
+
+  if (mIsDragPopup) {
+    if (GdkIsWaylandDisplay()) {
+      // Disable painting to the widget on Wayland as we paint directly to the
+      // widget. Wayland compositors does not paint wl_subsurface
+      // of D&D widget.
+      if (GtkWidget* parent = gtk_widget_get_parent(mShell)) {
+        GtkWidgetDisableUpdates(parent);
+      }
+      GtkWidgetDisableUpdates(mShell);
+      GtkWidgetDisableUpdates(GTK_WIDGET(mContainer));
+    } else {
+      // Disable rendering of parent container on X11 to avoid flickering.
+      if (GtkWidget* parent = gtk_widget_get_parent(mShell)) {
+        gtk_widget_set_opacity(parent, 0.0);
+      }
+    }
+  }
+
+  if (mWindowType == eWindowType_popup) {
+    if (mNoAutoHide) {
+      gint wmd = ConvertBorderStyles(mBorderStyle);
+      if (wmd != -1) {
+        gdk_window_set_decorations(mGdkWindow, (GdkWMDecoration)wmd);
+      }
+    }
+    // If the popup ignores mouse events, set an empty input shape.
+    SetWindowMouseTransparent(mMouseTransparent);
+  }
+
+  RefreshWindowClass();
+
+  if (mCompositorState == COMPOSITOR_PAUSED_INITIALLY) {
+    mCompositorState = COMPOSITOR_PAUSED_MISSING_WINDOW;
+  }
+
+  EnableRenderingToWindow();
+
+  if (mHasMappedToplevel) {
+    EnsureGrabs();
+  }
+
+  LOG("  finished, new GdkWindow %p XID 0x%lx\n", mGdkWindow, GetX11Window());
+}
+
+void nsWindow::ReleaseGdkWindow() {
+  LOG("nsWindow::ReleaseGdkWindow() [%p]", this);
+
+  DestroyChildWindows();
+  DisableRenderingToWindow();
+
+  if (mGdkWindow) {
+    g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", nullptr);
+    mGdkWindow = nullptr;
+  }
+
+  mSurfaceProvider.CleanupResources();
+}
+
+nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
+                          const LayoutDeviceIntRect& aRect,
+                          nsWidgetInitData* aInitData) {
+  LOG("nsWindow::Create\n");
+
+  // only set the base parent if we're going to be a dialog or a
+  // toplevel
+  nsIWidget* baseParent =
+      aInitData && (aInitData->mWindowType == eWindowType_dialog ||
+                    aInitData->mWindowType == eWindowType_toplevel ||
+                    aInitData->mWindowType == eWindowType_invisible)
+          ? nullptr
+          : aParent;
+
+#ifdef ACCESSIBILITY
+  // Send a DBus message to check whether a11y is enabled
+  a11y::PreInit();
+#endif
+
+#ifdef MOZ_WAYLAND
+  // Ensure that KeymapWrapper is created on Wayland as we need it for
+  // keyboard focus tracking.
+  if (GdkIsWaylandDisplay()) {
+    KeymapWrapper::EnsureInstance();
+  }
+#endif
+
+  // Ensure that the toolkit is created.
+  nsGTKToolkit::GetToolkit();
+
+  // initialize all the common bits of this class
+  BaseCreate(baseParent, aInitData);
+
+  // and do our common creation
+  mParent = aParent;
+  mCreated = true;
+  // save our bounds
+  mBounds = aRect;
+  LOG("  mBounds: x:%d y:%d w:%d h:%d\n", mBounds.x, mBounds.y, mBounds.width,
+      mBounds.height);
+
+  ConstrainSize(&mBounds.width, &mBounds.height);
+
+  GtkWidget* eventWidget = nullptr;
+  bool popupNeedsAlphaVisual = (mWindowType == eWindowType_popup &&
+                                (aInitData && aInitData->mSupportTranslucency));
+
+  // Figure out our parent window - only used for eWindowType_child
+  GdkWindow* parentGdkWindow = nullptr;
+  nsWindow* parentnsWindow = nullptr;
+
+  if (aParent) {
+    parentnsWindow = static_cast<nsWindow*>(aParent);
+    parentGdkWindow = parentnsWindow->mGdkWindow;
+  } else if (aNativeParent && GDK_IS_WINDOW(aNativeParent)) {
+    parentGdkWindow = GDK_WINDOW(aNativeParent);
+    parentnsWindow = get_window_for_gdk_window(parentGdkWindow);
+    if (!parentnsWindow) {
+      return NS_ERROR_FAILURE;
+    }
+  }
+
+  if (mWindowType == eWindowType_child) {
+    // We don't support eWindowType_child directly but emulate it by popup
+    // windows.
+    mWindowType = eWindowType_popup;
+    if (!parentnsWindow) {
+      if (aNativeParent && GTK_IS_CONTAINER(aNativeParent)) {
+        parentnsWindow = get_window_for_gtk_widget(GTK_WIDGET(aNativeParent));
+      }
+    }
+    mIsChildWindow = true;
+    LOG("  child widget, switch to popup. parent nsWindow %p", parentnsWindow);
+  }
+
+  if (mWindowType == eWindowType_popup && !parentnsWindow) {
+    LOG("  popup window without parent!");
+    if (GdkIsWaylandDisplay()) {
+      LOG("  switch to toplevel on Wayland.");
+      // Wayland does not allow to create popup without parent so switch to
+      // toplevel and mark as wayland panel.
+      mIsWaylandPanelWindow = true;
+      mWindowType = eWindowType_toplevel;
+    }
+  }
+
+  if (mWindowType != eWindowType_dialog && mWindowType != eWindowType_popup &&
+      mWindowType != eWindowType_toplevel &&
+      mWindowType != eWindowType_invisible) {
+    MOZ_ASSERT_UNREACHABLE("Unexpected eWindowType");
+    return NS_ERROR_FAILURE;
+  }
+
+  mAlwaysOnTop = aInitData && aInitData->mAlwaysOnTop;
+  mIsPIPWindow = aInitData && aInitData->mPIPWindow;
+  // mNoAutoHide seems to be always false here.
+  // The mNoAutoHide state is set later on nsMenuPopupFrame level
+  // and can be changed so we use WaylandPopupIsPermanent() to get
+  // recent popup config (Bug 1728952).
+  mNoAutoHide = aInitData && aInitData->mNoAutoHide;
+  mMouseTransparent = aInitData && aInitData->mMouseTransparent;
+
+  // Popups that are not noautohide are only temporary. The are used
+  // for menus and the like and disappear when another window is used.
+  // For most popups, use the standard GtkWindowType GTK_WINDOW_POPUP,
+  // which will use a Window with the override-redirect attribute
+  // (for temporary windows).
+  // For long-lived windows, their stacking order is managed by the
+  // window manager, as indicated by GTK_WINDOW_TOPLEVEL.
+  // For Wayland we have to always use GTK_WINDOW_POPUP to control
+  // popup window position.
+  GtkWindowType type = GTK_WINDOW_TOPLEVEL;
+  if (mWindowType == eWindowType_popup) {
+    MOZ_ASSERT(aInitData);
+    type = GTK_WINDOW_POPUP;
+    if (GdkIsX11Display() && mNoAutoHide) {
+      type = GTK_WINDOW_TOPLEVEL;
+    }
+  }
+  mShell = gtk_window_new(type);
+
+  // Ensure gfxPlatform is initialized, since that is what initializes
+  // gfxVars, used below.
+  Unused << gfxPlatform::GetPlatform();
+
+  if (mWindowType == eWindowType_toplevel ||
+      mWindowType == eWindowType_dialog) {
+    mGtkWindowDecoration = GetSystemGtkWindowDecoration();
+  }
+
+  // Don't use transparency for PictureInPicture windows.
+  bool toplevelNeedsAlphaVisual = false;
+  if (mWindowType == eWindowType_toplevel && !mIsPIPWindow) {
+    toplevelNeedsAlphaVisual = IsToplevelWindowTransparent();
+  }
+
+  bool isGLVisualSet = false;
+  mIsAccelerated = ComputeShouldAccelerate();
+#ifdef MOZ_X11
+  if (GdkIsX11Display() && mIsAccelerated) {
+    isGLVisualSet = ConfigureX11GLVisual();
+  }
+#endif
+  if (!isGLVisualSet && (popupNeedsAlphaVisual || toplevelNeedsAlphaVisual)) {
+    // We're running on composited screen so we can use alpha visual
+    // for both toplevel and popups.
+    if (mCompositedScreen) {
+      GdkVisual* visual =
+          gdk_screen_get_rgba_visual(gtk_widget_get_screen(mShell));
+      if (visual) {
+        gtk_widget_set_visual(mShell, visual);
+        mHasAlphaVisual = true;
+      }
+    }
+  }
+
+  // Use X shape mask to draw round corners of Firefox titlebar.
+  // We don't use shape masks any more as we switched to ARGB visual
+  // by default and non-compositing screens use solid-csd decorations
+  // without round corners.
+  // Leave the shape mask code here as it can be used to draw round
+  // corners on EGL (https://gitlab.freedesktop.org/mesa/mesa/-/issues/149)
+  // or when custom titlebar theme is used.
+  mTransparencyBitmapForTitlebar = TitlebarUseShapeMask();
+
+  // We have a toplevel window with transparency.
+  // Calls to UpdateTitlebarTransparencyBitmap() from OnExposeEvent()
+  // occur before SetTransparencyMode() receives eTransparencyTransparent
+  // from layout, so set mIsTransparent here.
+  if (mWindowType == eWindowType_toplevel &&
+      (mHasAlphaVisual || mTransparencyBitmapForTitlebar)) {
+    mIsTransparent = true;
+  }
+
+  // We only move a general managed toplevel window if someone has
+  // actually placed the window somewhere.  If no placement has taken
+  // place, we just let the window manager Do The Right Thing.
+  if (AreBoundsSane()) {
+    GdkRectangle size = DevicePixelsToGdkSizeRoundUp(mBounds.Size());
+    LOG("nsWindow::Create() Initial resize to %d x %d\n", size.width,
+        size.height);
+    gtk_window_resize(GTK_WINDOW(mShell), size.width, size.height);
+  }
+
+  if (mWindowType == eWindowType_dialog) {
+    mGtkWindowRoleName = "Dialog";
+
+    SetDefaultIcon();
+    gtk_window_set_type_hint(GTK_WINDOW(mShell), GDK_WINDOW_TYPE_HINT_DIALOG);
+    LOG("nsWindow::Create(): dialog");
+    if (parentnsWindow) {
+      gtk_window_set_transient_for(GTK_WINDOW(mShell),
+                                   GTK_WINDOW(parentnsWindow->GetGtkWidget()));
+      LOG("    set parent window [%p]\n", parentnsWindow);
+    }
+  } else if (mWindowType == eWindowType_popup) {
+    MOZ_ASSERT(aInitData);
+    mGtkWindowRoleName = "Popup";
+    mPopupHint = aInitData->mPopupHint;
+
+    LOG("nsWindow::Create() Popup");
+
+    if (mNoAutoHide) {
+      // ... but the window manager does not decorate this window,
+      // nor provide a separate taskbar icon.
+      if (mBorderStyle == eBorderStyle_default) {
+        gtk_window_set_decorated(GTK_WINDOW(mShell), FALSE);
+      } else {
+        bool decorate = mBorderStyle & eBorderStyle_title;
+        gtk_window_set_decorated(GTK_WINDOW(mShell), decorate);
+        if (decorate) {
+          gtk_window_set_deletable(GTK_WINDOW(mShell),
+                                   mBorderStyle & eBorderStyle_close);
+        }
+      }
+      gtk_window_set_skip_taskbar_hint(GTK_WINDOW(mShell), TRUE);
+      // Element focus is managed by the parent window so the
+      // WM_HINTS input field is set to False to tell the window
+      // manager not to set input focus to this window ...
+      gtk_window_set_accept_focus(GTK_WINDOW(mShell), FALSE);
+#ifdef MOZ_X11
+      // ... but when the window manager offers focus through
+      // WM_TAKE_FOCUS, focus is requested on the parent window.
+      if (GdkIsX11Display()) {
+        gtk_widget_realize(mShell);
+        gdk_window_add_filter(gtk_widget_get_window(mShell),
+                              popup_take_focus_filter, nullptr);
+      }
+#endif
+    }
+
+    if (aInitData->mIsDragPopup) {
+      gtk_window_set_type_hint(GTK_WINDOW(mShell), GDK_WINDOW_TYPE_HINT_DND);
+      mIsDragPopup = true;
+      LOG("nsWindow::Create() Drag popup\n");
+    } else if (GdkIsX11Display()) {
+      // Set the window hints on X11 only. Wayland popups are configured
+      // at WaylandPopupConfigure().
+      GdkWindowTypeHint gtkTypeHint;
+      switch (mPopupHint) {
+        case ePopupTypeMenu:
+          gtkTypeHint = GDK_WINDOW_TYPE_HINT_POPUP_MENU;
+          break;
+        case ePopupTypeTooltip:
+          gtkTypeHint = GDK_WINDOW_TYPE_HINT_TOOLTIP;
+          break;
+        default:
+          gtkTypeHint = GDK_WINDOW_TYPE_HINT_UTILITY;
+          break;
+      }
+      gtk_window_set_type_hint(GTK_WINDOW(mShell), gtkTypeHint);
+      LOG("nsWindow::Create() popup type %s", GetPopupTypeName().get());
+    }
+    if (parentnsWindow) {
+      LOG("    set parent window [%p] %s", parentnsWindow,
+          parentnsWindow->mGtkWindowRoleName.get());
+      GtkWindow* parentWidget = GTK_WINDOW(parentnsWindow->GetGtkWidget());
+      gtk_window_set_transient_for(GTK_WINDOW(mShell), parentWidget);
+      if (GdkIsWaylandDisplay() && gtk_window_get_modal(parentWidget)) {
+        gtk_window_set_modal(GTK_WINDOW(mShell), true);
+      }
+    }
+
+    // We need realized mShell at NativeMoveResize().
+    gtk_widget_realize(mShell);
+
+    // With popup windows, we want to set their position.
+    // Place them immediately on X11 and save initial popup position
+    // on Wayland as we place Wayland popup on show.
+    if (GdkIsX11Display()) {
+      NativeMoveResize(/* move */ true, /* resize */ false);
+    } else if (AreBoundsSane()) {
+      GdkRectangle rect = DevicePixelsToGdkRectRoundOut(mBounds);
+      mPopupPosition = {rect.x, rect.y};
+    }
+  } else {  // must be eWindowType_toplevel
+    mGtkWindowRoleName = "Toplevel";
+    SetDefaultIcon();
+
+    LOG("nsWindow::Create() Toplevel\n");
+
+    if (mIsPIPWindow) {
+      LOG("    Is PIP Window\n");
+      gtk_window_set_type_hint(GTK_WINDOW(mShell),
+                               GDK_WINDOW_TYPE_HINT_UTILITY);
+    }
+
+    // each toplevel window gets its own window group
+    GtkWindowGroup* group = gtk_window_group_new();
+    gtk_window_group_add_window(group, GTK_WINDOW(mShell));
+    g_object_unref(group);
+  }
+
+  if (mAlwaysOnTop) {
+    gtk_window_set_keep_above(GTK_WINDOW(mShell), TRUE);
+  }
+
+  // Create a container to hold child windows and child GtkWidgets.
+  GtkWidget* container = moz_container_new();
+  mContainer = MOZ_CONTAINER(container);
+
+  // Don't render to invisible window.
+  mCompositorState = COMPOSITOR_PAUSED_INITIALLY;
+
+  // "csd" style is set when widget is realized so we need to call
+  // it explicitly now.
+  gtk_widget_realize(mShell);
+
+  /* There are several cases here:
+   *
+   * 1) We're running on Gtk+ without client side decorations.
+   *    Content is rendered to mShell window and we listen
+   *    to the Gtk+ events on mShell
+   * 2) We're running on Gtk+ and client side decorations
+   *    are drawn by Gtk+ to mShell. Content is rendered to mContainer
+   *    and we listen to the Gtk+ events on mContainer.
+   * 3) We're running on Wayland. All gecko content is rendered
+   *    to mContainer and we listen to the Gtk+ events on mContainer.
+   */
+  GtkStyleContext* style = gtk_widget_get_style_context(mShell);
+  mDrawToContainer = GdkIsWaylandDisplay() ||
+                     (mGtkWindowDecoration == GTK_DECORATION_CLIENT) ||
+                     gtk_style_context_has_class(style, "csd");
+  eventWidget = mDrawToContainer ? container : mShell;
+
+  // Prevent GtkWindow from painting a background to avoid flickering.
+  gtk_widget_set_app_paintable(
+      eventWidget, StaticPrefs::widget_transparent_windows_AtStartup());
+
+  gtk_widget_add_events(eventWidget, kEvents);
+
+  if (mDrawToContainer) {
+    gtk_widget_add_events(mShell, GDK_PROPERTY_CHANGE_MASK);
+    gtk_widget_set_app_paintable(
+        mShell, StaticPrefs::widget_transparent_windows_AtStartup());
+  }
+  if (mTransparencyBitmapForTitlebar) {
+    moz_container_force_default_visual(mContainer);
+  }
+
+  // If we draw to mContainer window then configure it now because
+  // gtk_container_add() realizes the child widget.
+  gtk_widget_set_has_window(container, mDrawToContainer);
+
+  gtk_container_add(GTK_CONTAINER(mShell), container);
+
+  // alwaysontop windows are generally used for peripheral indicators,
+  // so we don't focus them by default.
+  if (mAlwaysOnTop) {
+    gtk_window_set_focus_on_map(GTK_WINDOW(mShell), FALSE);
+  }
+
+  gtk_widget_realize(container);
+
+  // make sure this is the focus widget in the container
+  gtk_widget_show(container);
+
+  if (!mAlwaysOnTop) {
+    gtk_widget_grab_focus(container);
+  }
+
+  if (mIsWaylandPanelWindow) {
+    gtk_window_set_decorated(GTK_WINDOW(mShell), false);
+  }
+
+#ifdef MOZ_WAYLAND
+  if (mIsDragPopup && GdkIsWaylandDisplay()) {
+    LOG("  set commit to parent");
+    moz_container_wayland_set_commit_to_parent(mContainer);
+  }
+#endif
+
+  if (mWindowType == eWindowType_popup) {
+    MOZ_ASSERT(aInitData);
+    // gdk does not automatically set the cursor for "temporary"
+    // windows, which are what gtk uses for popups.
+
+    // force SetCursor to actually set the cursor, even though our internal
+    // state indicates that we already have the standard cursor.
+    mUpdateCursor = true;
+    SetCursor(Cursor{eCursor_standard});
+  }
+
+  if (mIsChildWindow && parentnsWindow) {
+    GdkWindow* window = GetToplevelGdkWindow();
+    GdkWindow* parentWindow = parentnsWindow->GetToplevelGdkWindow();
+    LOG("  child GdkWindow %p set parent GdkWindow %p", window, parentWindow);
+    gdk_window_reparent(window, parentWindow,
+                        DevicePixelsToGdkCoordRoundDown(mBounds.x),
+                        DevicePixelsToGdkCoordRoundDown(mBounds.y));
+  }
+
+  if (mDrawToContainer) {
+    // Also label mShell toplevel window,
+    // property_notify_event_cb callback also needs to find its way home
+    g_object_set_data(G_OBJECT(gtk_widget_get_window(mShell)), "nsWindow",
+                      this);
+  }
+
+  g_object_set_data(G_OBJECT(mContainer), "nsWindow", this);
+  g_object_set_data(G_OBJECT(mShell), "nsWindow", this);
+
+  // attach listeners for events
+  g_signal_connect(mShell, "configure_event", G_CALLBACK(configure_event_cb),
+                   nullptr);
+  g_signal_connect(mShell, "delete_event", G_CALLBACK(delete_event_cb),
+                   nullptr);
+  g_signal_connect(mShell, "window_state_event",
+                   G_CALLBACK(window_state_event_cb), nullptr);
+  g_signal_connect(mShell, "check-resize", G_CALLBACK(check_resize_cb),
+                   nullptr);
+  g_signal_connect(mShell, "composited-changed",
+                   G_CALLBACK(widget_composited_changed_cb), nullptr);
+  g_signal_connect(mShell, "property-notify-event",
+                   G_CALLBACK(property_notify_event_cb), nullptr);
+  g_signal_connect(mShell, "map", G_CALLBACK(widget_map_cb), nullptr);
+  g_signal_connect(mShell, "unrealize", G_CALLBACK(widget_unrealize_cb),
+                   nullptr);
+
+  if (mWindowType == eWindowType_toplevel) {
+    g_signal_connect_after(mShell, "size_allocate",
+                           G_CALLBACK(toplevel_window_size_allocate_cb),
+                           nullptr);
+  }
+
+  GdkScreen* screen = gtk_widget_get_screen(mShell);
+  if (!g_signal_handler_find(screen, G_SIGNAL_MATCH_FUNC, 0, 0, nullptr,
+                             FuncToGpointer(screen_composited_changed_cb),
+                             nullptr)) {
+    g_signal_connect(screen, "composited-changed",
+                     G_CALLBACK(screen_composited_changed_cb), nullptr);
+  }
+
+  gtk_drag_dest_set((GtkWidget*)mShell, (GtkDestDefaults)0, nullptr, 0,
+                    (GdkDragAction)0);
+  g_signal_connect(mShell, "drag_motion", G_CALLBACK(drag_motion_event_cb),
+                   nullptr);
+  g_signal_connect(mShell, "drag_leave", G_CALLBACK(drag_leave_event_cb),
+                   nullptr);
+  g_signal_connect(mShell, "drag_drop", G_CALLBACK(drag_drop_event_cb),
+                   nullptr);
+  g_signal_connect(mShell, "drag_data_received",
+                   G_CALLBACK(drag_data_received_event_cb), nullptr);
+
+  GtkSettings* default_settings = gtk_settings_get_default();
+  g_signal_connect_after(default_settings, "notify::gtk-xft-dpi",
+                         G_CALLBACK(settings_xft_dpi_changed_cb), this);
+
+  // Widget signals
+  g_signal_connect_after(mContainer, "size_allocate",
+                         G_CALLBACK(size_allocate_cb), nullptr);
+  g_signal_connect(mContainer, "hierarchy-changed",
+                   G_CALLBACK(hierarchy_changed_cb), nullptr);
+  g_signal_connect(mContainer, "notify::scale-factor",
+                   G_CALLBACK(scale_changed_cb), nullptr);
+  // Initialize mHasMappedToplevel.
+  hierarchy_changed_cb(GTK_WIDGET(mContainer), nullptr);
+  // Expose, focus, key, and drag events are sent even to GTK_NO_WINDOW
+  // widgets.
+  g_signal_connect(G_OBJECT(mContainer), "draw", G_CALLBACK(expose_event_cb),
+                   nullptr);
+  g_signal_connect(mContainer, "focus_in_event", G_CALLBACK(focus_in_event_cb),
+                   nullptr);
+  g_signal_connect(mContainer, "focus_out_event",
+                   G_CALLBACK(focus_out_event_cb), nullptr);
+  g_signal_connect(mContainer, "key_press_event",
+                   G_CALLBACK(key_press_event_cb), nullptr);
+  g_signal_connect(mContainer, "key_release_event",
+                   G_CALLBACK(key_release_event_cb), nullptr);
+
+#ifdef MOZ_X11
+  if (GdkIsX11Display()) {
+    GtkWidget* widgets[] = {GTK_WIDGET(mContainer),
+                            !mDrawToContainer ? mShell : nullptr};
+    for (size_t i = 0; i < ArrayLength(widgets) && widgets[i]; ++i) {
+      // Double buffering is controlled by the window's owning
+      // widget. Disable double buffering for painting directly to the
+      // X Window.
+      gtk_widget_set_double_buffered(widgets[i], FALSE);
+    }
+  }
+#endif
+#ifdef MOZ_WAYLAND
+  // Initialize the window specific VsyncSource early in order to avoid races
+  // with BrowserParent::UpdateVsyncParentVsyncSource().
+  // Only use for toplevel windows for now, see bug 1619246.
+  if (GdkIsWaylandDisplay() &&
+      StaticPrefs::widget_wayland_vsync_enabled_AtStartup() &&
+      mWindowType == eWindowType_toplevel) {
+    mWaylandVsyncSource = new WaylandVsyncSource();
+    LOG_VSYNC("  created WaylandVsyncSource)");
+    MOZ_RELEASE_ASSERT(mWaylandVsyncSource);
+  }
+#endif
+
+  // We create input contexts for all containers, except for
+  // toplevel popup windows
+  if (mWindowType != eWindowType_popup) {
+    mIMContext = new IMContextWrapper(this);
+  }
+
+  // These events are sent to the owning widget of the relevant window
+  // and propagate up to the first widget that handles the events, so we
+  // need only connect on mShell, if it exists, to catch events on its
+  // window and windows of mContainer.
+  g_signal_connect(eventWidget, "enter-notify-event",
+                   G_CALLBACK(enter_notify_event_cb), nullptr);
+  g_signal_connect(eventWidget, "leave-notify-event",
+                   G_CALLBACK(leave_notify_event_cb), nullptr);
+  g_signal_connect(eventWidget, "motion-notify-event",
+                   G_CALLBACK(motion_notify_event_cb), nullptr);
+  g_signal_connect(eventWidget, "button-press-event",
+                   G_CALLBACK(button_press_event_cb), nullptr);
+  g_signal_connect(eventWidget, "button-release-event",
+                   G_CALLBACK(button_release_event_cb), nullptr);
+  g_signal_connect(eventWidget, "scroll-event", G_CALLBACK(scroll_event_cb),
+                   nullptr);
+  if (gtk_check_version(3, 18, 0) == nullptr) {
+    g_signal_connect(eventWidget, "event", G_CALLBACK(generic_event_cb),
+                     nullptr);
+  }
+  g_signal_connect(eventWidget, "touch-event", G_CALLBACK(touch_event_cb),
+                   nullptr);
+
+  LOG("  nsWindow type %d %s\n", mWindowType, mIsPIPWindow ? "PIP window" : "");
+  LOG("  mShell %p mContainer %p mGdkWindow %p XID 0x%lx\n", mShell, mContainer,
+      mGdkWindow, GetX11Window());
+
+  // Set default application name when it's empty.
+  if (mGtkWindowAppName.IsEmpty()) {
+    mGtkWindowAppName = gAppData->name;
+  }
+
+  return NS_OK;
+}
+
+void nsWindow::RefreshWindowClass(void) {
+  GdkWindow* gdkWindow = gtk_widget_get_window(mShell);
+  if (!gdkWindow) {
+    return;
+  }
+
+  if (!mGtkWindowRoleName.IsEmpty()) {
+    gdk_window_set_role(gdkWindow, mGtkWindowRoleName.get());
+  }
+
+#ifdef MOZ_X11
+  if (!mGtkWindowAppName.IsEmpty() && GdkIsX11Display()) {
+    XClassHint* class_hint = XAllocClassHint();
+    if (!class_hint) {
+      return;
+    }
+    const char* res_class = gdk_get_program_class();
+    if (!res_class) return;
+
+    class_hint->res_name = const_cast<char*>(mGtkWindowAppName.get());
+    class_hint->res_class = const_cast<char*>(res_class);
+
+    // Can't use gtk_window_set_wmclass() for this; it prints
+    // a warning & refuses to make the change.
+    GdkDisplay* display = gdk_display_get_default();
+    XSetClassHint(GDK_DISPLAY_XDISPLAY(display),
+                  gdk_x11_window_get_xid(gdkWindow), class_hint);
+    XFree(class_hint);
+  }
+#endif /* MOZ_X11 */
+}
+
+void nsWindow::SetWindowClass(const nsAString& xulWinType) {
+  if (!mShell) return;
+
+  char* res_name = ToNewCString(xulWinType, mozilla::fallible);
+  if (!res_name) return;
+
+  const char* role = nullptr;
+
+  // Parse res_name into a name and role. Characters other than
+  // [A-Za-z0-9_-] are converted to '_'. Anything after the first
+  // colon is assigned to role; if there's no colon, assign the
+  // whole thing to both role and res_name.
+  for (char* c = res_name; *c; c++) {
+    if (':' == *c) {
+      *c = 0;
+      role = c + 1;
+    } else if (!isascii(*c) || (!isalnum(*c) && ('_' != *c) && ('-' != *c))) {
+      *c = '_';
+    }
+  }
+  res_name[0] = (char)toupper(res_name[0]);
+  if (!role) role = res_name;
+
+  mGtkWindowAppName = res_name;
+  mGtkWindowRoleName = role;
+  free(res_name);
+
+  RefreshWindowClass();
+}
+
+nsAutoCString nsWindow::GetDebugTag() const {
+  nsAutoCString tag;
+  tag.AppendPrintf("[%p]", this);
+  return tag;
+}
+
+void nsWindow::NativeMoveResize(bool aMoved, bool aResized) {
+  GdkRectangle rect = DevicePixelsToGdkRectRoundOut(mBounds);
+
+  LOG("nsWindow::NativeMoveResize move %d resize %d to %d,%d -> %d x %d\n",
+      aMoved, aResized, rect.x, rect.y, rect.width, rect.height);
+
+  if (aResized && !AreBoundsSane()) {
+    LOG("  bounds are insane, hidding the window");
+    // We have been resized but to incorrect size.
+    // If someone has set this so that the needs show flag is false
+    // and it needs to be hidden, update the flag and hide the
+    // window.  This flag will be cleared the next time someone
+    // hides the window or shows it.  It also prevents us from
+    // calling NativeShow(false) excessively on the window which
+    // causes unneeded X traffic.
+    if (!mNeedsShow && mIsShown) {
+      mNeedsShow = true;
+      NativeShow(false);
+    }
+    if (aMoved) {
+      LOG("  moving to %d x %d", rect.x, rect.y);
+      gtk_window_move(GTK_WINDOW(mShell), rect.x, rect.y);
+    }
+    return;
+  }
+
+  // Set position to hidden window on X11 may fail, so save the position
+  // and move it when it's shown.
+  if (aMoved && GdkIsX11Display() && IsPopup() &&
+      !gtk_widget_get_visible(GTK_WIDGET(mShell))) {
+    LOG("  store position of hidden popup window");
+    mHiddenPopupPositioned = true;
+    mPopupPosition = {rect.x, rect.y};
+  }
+
+  if (IsWaylandPopup()) {
+    NativeMoveResizeWaylandPopup(aMoved, aResized);
+  } else {
+    // x and y give the position of the window manager frame top-left.
+    if (aMoved) {
+      gtk_window_move(GTK_WINDOW(mShell), rect.x, rect.y);
+    }
+    if (aResized) {
+      gtk_window_resize(GTK_WINDOW(mShell), rect.width, rect.height);
+      if (mIsDragPopup) {
+        // DND window is placed inside container so we need to make hard size
+        // request to ensure parent container is resized too.
+        gtk_widget_set_size_request(GTK_WIDGET(mShell), rect.width,
+                                    rect.height);
+      }
+    }
+  }
+
+  // Notify the GtkCompositorWidget of a ClientSizeChange
+  // This is different than OnSizeAllocate to catch initial sizing
+  if (mCompositorWidgetDelegate && aResized) {
+    mCompositorWidgetDelegate->NotifyClientSizeChanged(GetClientSize());
+  }
+
+  // Does it need to be shown because bounds were previously insane?
+  if (mNeedsShow && mIsShown && aResized) {
+    NativeShow(true);
+  }
+}
+
+void nsWindow::ResumeCompositorHiddenWindow() {
+  MOZ_RELEASE_ASSERT(NS_IsMainThread());
+
+  LOG("nsWindow::ResumeCompositorHiddenWindow\n");
+  if (mIsDestroyed || mCompositorState == COMPOSITOR_ENABLED) {
+    LOG("  early quit\n");
+    return;
+  }
+
+  if (CompositorBridgeChild* remoteRenderer = GetRemoteRenderer()) {
+    LOG("  resume\n");
+    MOZ_ASSERT(mCompositorWidgetDelegate);
+    if (mCompositorWidgetDelegate) {
+      mCompositorState = COMPOSITOR_ENABLED;
+      remoteRenderer->SendResumeAsync();
+    }
+    remoteRenderer->SendForcePresent(wr::RenderReasons::WIDGET);
+  } else {
+    LOG("  quit, failed to get remote renderer.\n");
+  }
+}
+
+// Because wl_egl_window is destroyed on moz_container_unmap(),
+// the current compositor cannot use it anymore. To avoid crash,
+// pause the compositor and destroy EGLSurface & resume the compositor
+// and re-create EGLSurface on next expose event.
+void nsWindow::PauseCompositorHiddenWindow() {
+  LOG("nsWindow::PauseCompositorHiddenWindow");
+
+  if (mCompositorState != COMPOSITOR_ENABLED) {
+    LOG("  quit early, compositor is disabled");
+    return;
+  }
+
+  mCompositorState = COMPOSITOR_PAUSED_MISSING_WINDOW;
+
+  // Without remote widget / renderer we can't pause compositor.
+  // So delete LayerManager to avoid EGLSurface access.
+  CompositorBridgeChild* remoteRenderer = GetRemoteRenderer();
+  if (!remoteRenderer || !mCompositorWidgetDelegate) {
+    LOG("  deleted layer manager");
+    DestroyLayerManager();
+    return;
+  }
+
+  // XXX slow sync IPC
+  LOG("  paused compositor");
+  remoteRenderer->SendPause();
+}
+
+static int WindowResumeCompositor(void* data) {
+  nsWindow* window = static_cast<nsWindow*>(data);
+  window->ResumeCompositor();
+  return true;
+}
+
+// We pause compositor to avoid rendering of obsoleted remote content which
+// produces flickering.
+// Re-enable compositor again when remote content is updated or
+// timeout happens.
+
+// Define maximal compositor pause when it's paused to avoid flickering,
+// in milliseconds.
+#define COMPOSITOR_PAUSE_TIMEOUT (1000)
+
+void nsWindow::PauseCompositor() {
+  bool pauseCompositor = (mWindowType == eWindowType_toplevel) &&
+                         mCompositorState == COMPOSITOR_ENABLED &&
+                         mCompositorWidgetDelegate && !mIsDestroyed;
+  if (!pauseCompositor) {
+    return;
+  }
+
+  LOG("nsWindow::PauseCompositor()");
+
+  if (mCompositorPauseTimeoutID) {
+    g_source_remove(mCompositorPauseTimeoutID);
+    mCompositorPauseTimeoutID = 0;
+  }
+
+  CompositorBridgeChild* remoteRenderer = GetRemoteRenderer();
+  if (remoteRenderer) {
+    remoteRenderer->SendPause();
+    mCompositorState = COMPOSITOR_PAUSED_FLICKERING;
+    mCompositorPauseTimeoutID = (int)g_timeout_add(
+        COMPOSITOR_PAUSE_TIMEOUT, &WindowResumeCompositor, this);
+  }
+}
+
+bool nsWindow::IsWaitingForCompositorResume() {
+  return mCompositorState == COMPOSITOR_PAUSED_FLICKERING;
+}
+
+void nsWindow::ResumeCompositor() {
+  MOZ_RELEASE_ASSERT(NS_IsMainThread());
+
+  LOG("nsWindow::ResumeCompositor()\n");
+
+  if (mIsDestroyed || !IsWaitingForCompositorResume()) {
+    LOG("  early quit\n");
+    return;
+  }
+
+  if (mCompositorPauseTimeoutID) {
+    g_source_remove(mCompositorPauseTimeoutID);
+    mCompositorPauseTimeoutID = 0;
+  }
+
+  // We're expected to have mCompositorWidgetDelegate present
+  // as we don't delete LayerManager (in PauseCompositor())
+  // to avoid flickering.
+  MOZ_RELEASE_ASSERT(mCompositorWidgetDelegate);
+
+  CompositorBridgeChild* remoteRenderer = GetRemoteRenderer();
+  if (remoteRenderer) {
+    mCompositorState = COMPOSITOR_ENABLED;
+    remoteRenderer->SendResumeAsync();
+    remoteRenderer->SendForcePresent(wr::RenderReasons::WIDGET);
+  }
+}
+
+void nsWindow::ResumeCompositorFromCompositorThread() {
+  nsCOMPtr<nsIRunnable> event = NewRunnableMethod(
+      "nsWindow::ResumeCompositor", this, &nsWindow::ResumeCompositor);
+  NS_DispatchToMainThread(event.forget());
+}
+
+void nsWindow::WaylandStartVsync() {
+#ifdef MOZ_WAYLAND
+  if (!mWaylandVsyncSource) {
+    return;
+  }
+
+  LOG_VSYNC("nsWindow::WaylandStartVsync");
+
+  if (mCompositorWidgetDelegate) {
+    if (RefPtr<layers::NativeLayerRoot> nativeLayerRoot =
+            mCompositorWidgetDelegate->AsGtkCompositorWidget()
+                ->GetNativeLayerRoot()) {
+      LOG_VSYNC("  use source NativeLayerRootWayland");
+      mWaylandVsyncSource->MaybeUpdateSource(
+          nativeLayerRoot->AsNativeLayerRootWayland());
+    } else {
+      LOG_VSYNC("  use source mContainer");
+      mWaylandVsyncSource->MaybeUpdateSource(mContainer);
+    }
+  }
+  mWaylandVsyncSource->EnableMonitor();
+#endif
+}
+
+void nsWindow::WaylandStopVsync() {
+#ifdef MOZ_WAYLAND
+  if (!mWaylandVsyncSource) {
+    return;
+  }
+
+  LOG_VSYNC("nsWindow::WaylandStopVsync");
+
+  // The widget is going to be hidden, so clear the surface of our
+  // vsync source.
+  mWaylandVsyncSource->DisableMonitor();
+  mWaylandVsyncSource->MaybeUpdateSource(nullptr);
+#endif
+}
+
+void nsWindow::NativeShow(bool aAction) {
+  if (aAction) {
+    // unset our flag now that our window has been shown
+    mNeedsShow = true;
+    auto removeShow = MakeScopeExit([&] { mNeedsShow = false; });
+
+    LOG("nsWindow::NativeShow show\n");
+
+    if (IsWaylandPopup()) {
+      mPopupClosed = false;
+      if (WaylandPopupConfigure()) {
+        AddWindowToPopupHierarchy();
+        UpdateWaylandPopupHierarchy();
+        if (mPopupClosed) {
+          return;
+        }
+      }
+    }
+    // Set up usertime/startupID metadata for the created window.
+    if (mWindowType != eWindowType_invisible) {
+      SetUserTimeAndStartupIDForActivatedWindow(mShell);
+    }
+    if (GdkIsWaylandDisplay()) {
+      ShowWaylandWindow();
+    } else {
+      LOG("  calling gtk_widget_show(mShell)\n");
+      gtk_widget_show(mShell);
+    }
+
+    if (mHiddenPopupPositioned && IsPopup()) {
+      LOG("  re-position hidden popup window");
+      gtk_window_move(GTK_WINDOW(mShell), mPopupPosition.x, mPopupPosition.y);
+      mHiddenPopupPositioned = false;
+    }
+  } else {
+    LOG("nsWindow::NativeShow hide\n");
+    if (GdkIsWaylandDisplay()) {
+      if (IsWaylandPopup()) {
+        // We can't close tracked popups directly as they may have visible
+        // child popups. Just mark is as closed and let
+        // UpdateWaylandPopupHierarchy() do the job.
+        if (IsInPopupHierarchy()) {
+          WaylandPopupMarkAsClosed();
+          UpdateWaylandPopupHierarchy();
+        } else {
+          // Close untracked popups directly.
+          HideWaylandPopupWindow(/* aTemporaryHide */ false,
+                                 /* aRemoveFromPopupList */ true);
+        }
+      } else {
+        HideWaylandToplevelWindow();
+      }
+    } else {
+      // Workaround window freezes on GTK versions before 3.21.2 by
+      // ensuring that configure events get dispatched to windows before
+      // they are unmapped. See bug 1225044.
+      if (gtk_check_version(3, 21, 2) != nullptr && mPendingConfigures > 0) {
+        GtkAllocation allocation;
+        gtk_widget_get_allocation(GTK_WIDGET(mShell), &allocation);
+
+        GdkEventConfigure event;
+        PodZero(&event);
+        event.type = GDK_CONFIGURE;
+        event.window = mGdkWindow;
+        event.send_event = TRUE;
+        event.x = allocation.x;
+        event.y = allocation.y;
+        event.width = allocation.width;
+        event.height = allocation.height;
+
+        auto* shellClass = GTK_WIDGET_GET_CLASS(mShell);
+        for (unsigned int i = 0; i < mPendingConfigures; i++) {
+          Unused << shellClass->configure_event(mShell, &event);
+        }
+        mPendingConfigures = 0;
+      }
+      gtk_widget_hide(mShell);
+
+      ClearTransparencyBitmap();  // Release some resources
+    }
+  }
+}
+
+void nsWindow::SetHasMappedToplevel(bool aState) {
+  LOG("nsWindow::SetHasMappedToplevel() state %d", aState);
+
+  // Even when aState == mHasMappedToplevel (as when this method is called
+  // from Show()), child windows need to have their state checked, so don't
+  // return early.
+  bool oldState = mHasMappedToplevel;
+  mHasMappedToplevel = aState;
+
+  // mHasMappedToplevel is not updated for children of windows that are
+  // hidden; GDK knows not to send expose events for these windows.  The
+  // state is recorded on the hidden window itself, but, for child trees of
+  // hidden windows, their state essentially becomes disconnected from their
+  // hidden parent.  When the hidden parent gets shown, the child trees are
+  // reconnected, and the state of the window being shown can be easily
+  // propagated.
+  if (!mIsShown || !mGdkWindow) {
+    LOG("  hidden, quit.\n");
+    return;
+  }
+
+  if (aState && !oldState) {
+    // Check that a grab didn't fail due to the window not being
+    // viewable.
+    EnsureGrabs();
+  }
+}
+
+LayoutDeviceIntSize nsWindow::GetSafeWindowSize(LayoutDeviceIntSize aSize) {
+  // The X protocol uses CARD32 for window sizes, but the server (1.11.3)
+  // reads it as CARD16.  Sizes of pixmaps, used for drawing, are (unsigned)
+  // CARD16 in the protocol, but the server's ProcCreatePixmap returns
+  // BadAlloc if dimensions cannot be represented by signed shorts.
+  // Because we are creating Cairo surfaces to represent window buffers,
+  // we also must ensure that the window can fit in a Cairo surface.
+  LayoutDeviceIntSize result = aSize;
+  int32_t maxSize = 32767;
+  if (mWindowRenderer && mWindowRenderer->AsKnowsCompositor()) {
+    maxSize = std::min(
+        maxSize, mWindowRenderer->AsKnowsCompositor()->GetMaxTextureSize());
+  }
+  if (result.width > maxSize) {
+    result.width = maxSize;
+  }
+  if (result.height > maxSize) {
+    result.height = maxSize;
+  }
+  return result;
+}
+
+void nsWindow::EnsureGrabs(void) {
+  if (mRetryPointerGrab) {
+    GrabPointer(sRetryGrabTime);
+  }
+}
+
+void nsWindow::CleanLayerManagerRecursive(void) {
+  if (mWindowRenderer) {
+    mWindowRenderer->Destroy();
+    mWindowRenderer = nullptr;
+  }
+
+  DestroyCompositor();
+}
+
+void nsWindow::SetTransparencyMode(nsTransparencyMode aMode) {
+  bool isTransparent = aMode == eTransparencyTransparent;
+
+  if (mIsTransparent == isTransparent) {
+    return;
+  }
+
+  if (mWindowType != eWindowType_popup) {
+    // https://bugzilla.mozilla.org/show_bug.cgi?id=1344839 reported
+    // problems cleaning the layer manager for toplevel windows.
+    // Ignore the request so as to workaround that.
+    // mIsTransparent is set in Create() if transparency may be required.
+    if (isTransparent) {
+      NS_WARNING("Transparent mode not supported on non-popup windows.");
+    }
+    return;
+  }
+
+  if (!isTransparent) {
+    ClearTransparencyBitmap();
+  }  // else the new default alpha values are "all 1", so we don't
+  // need to change anything yet
+
+  mIsTransparent = isTransparent;
+
+  if (!mHasAlphaVisual) {
+    // The choice of layer manager depends on
+    // GtkCompositorWidgetInitData::Shaped(), which will need to change, so
+    // clean out the old layer manager.
+    CleanLayerManagerRecursive();
+  }
+}
+
+nsTransparencyMode nsWindow::GetTransparencyMode() {
+  return mIsTransparent ? eTransparencyTransparent : eTransparencyOpaque;
+}
+
+void nsWindow::SetWindowMouseTransparent(bool aIsTransparent) {
+  mMouseTransparent = aIsTransparent;
+
+  GdkWindow* window =
+      mDrawToContainer ? gtk_widget_get_window(mShell) : mGdkWindow;
+  if (!window) {
+    return;
+  }
+
+  LOG("nsWindow::SetWindowMouseTransparent(%d)", aIsTransparent);
+
+  cairo_rectangle_int_t emptyRect = {0, 0, 0, 0};
+  cairo_region_t* region =
+      aIsTransparent ? cairo_region_create_rectangle(&emptyRect) : nullptr;
+  gdk_window_input_shape_combine_region(window, region, 0, 0);
+  if (region) {
+    cairo_region_destroy(region);
+  }
+
+  // On Wayland gdk_window_input_shape_combine_region() call is cached and
+  // applied to underlying wl_surface when GdkWindow is repainted.
+  // Force repaint of GdkWindow to apply the change immediately.
+  if (GdkIsWaylandDisplay()) {
+    gdk_window_invalidate_rect(window, nullptr, false);
+  }
+}
+
+// For setting the draggable titlebar region from CSS
+// with -moz-window-dragging: drag.
+void nsWindow::UpdateWindowDraggingRegion(
+    const LayoutDeviceIntRegion& aRegion) {
+  if (mDraggableRegion != aRegion) {
+    mDraggableRegion = aRegion;
+  }
+}
+
+LayoutDeviceIntCoord nsWindow::GetTitlebarRadius() {
+  MOZ_RELEASE_ASSERT(NS_IsMainThread());
+  int32_t cssCoord = LookAndFeel::GetInt(LookAndFeel::IntID::TitlebarRadius);
+  return GdkCoordToDevicePixels(cssCoord);
+}
+
+// See subtract_corners_from_region() at gtk/gtkwindow.c
+// We need to subtract corners from toplevel window opaque region
+// to draw transparent corners of default Gtk titlebar.
+// Both implementations (cairo_region_t and wl_region) needs to be synced.
+static void SubtractTitlebarCorners(cairo_region_t* aRegion, int aX, int aY,
+                                    int aWindowWidth, int aTitlebarRadius) {
+  if (!aTitlebarRadius) {
+    return;
+  }
+  cairo_rectangle_int_t rect = {aX, aY, aTitlebarRadius, aTitlebarRadius};
+  cairo_region_subtract_rectangle(aRegion, &rect);
+  rect = {
+      aX + aWindowWidth - aTitlebarRadius,
+      aY,
+      aTitlebarRadius,
+      aTitlebarRadius,
+  };
+  cairo_region_subtract_rectangle(aRegion, &rect);
+}
+
+void nsWindow::UpdateTopLevelOpaqueRegion(void) {
+  if (!mCompositedScreen) {
+    return;
+  }
+
+  GdkWindow* window =
+      mDrawToContainer ? gtk_widget_get_window(mShell) : mGdkWindow;
+  if (!window) {
+    return;
+  }
+  MOZ_ASSERT(gdk_window_get_window_type(window) == GDK_WINDOW_TOPLEVEL);
+
+  int x = 0;
+  int y = 0;
+
+  if (mDrawToContainer) {
+    gdk_window_get_position(mGdkWindow, &x, &y);
+  }
+
+  int width = DevicePixelsToGdkCoordRoundDown(mBounds.width);
+  int height = DevicePixelsToGdkCoordRoundDown(mBounds.height);
+
+  cairo_region_t* region = cairo_region_create();
+  cairo_rectangle_int_t rect = {x, y, width, height};
+  cairo_region_union_rectangle(region, &rect);
+
+  int radius = DoDrawTilebarCorners() ? int(GetTitlebarRadius()) : 0;
+  SubtractTitlebarCorners(region, x, y, width, radius);
+
+  gdk_window_set_opaque_region(window, region);
+
+  cairo_region_destroy(region);
+
+#ifdef MOZ_WAYLAND
+  if (GdkIsWaylandDisplay()) {
+    moz_container_wayland_update_opaque_region(mContainer, radius);
+  }
+#endif
+}
+
+bool nsWindow::IsChromeWindowTitlebar() {
+  return mDrawInTitlebar && !mIsPIPWindow &&
+         mWindowType == eWindowType_toplevel;
+}
+
+bool nsWindow::DoDrawTilebarCorners() {
+  return IsChromeWindowTitlebar() && mSizeState == nsSizeMode_Normal &&
+         !mIsTiled;
+}
+
+void nsWindow::ResizeTransparencyBitmap() {
+  if (!mTransparencyBitmap) return;
+
+  if (mBounds.width == mTransparencyBitmapWidth &&
+      mBounds.height == mTransparencyBitmapHeight) {
+    return;
+  }
+
+  int32_t newRowBytes = GetBitmapStride(mBounds.width);
+  int32_t newSize = newRowBytes * mBounds.height;
+  auto* newBits = new gchar[newSize];
+  // fill new mask with "transparent", first
+  memset(newBits, 0, newSize);
+
+  // Now copy the intersection of the old and new areas into the new mask
+  int32_t copyWidth = std::min(mBounds.width, mTransparencyBitmapWidth);
+  int32_t copyHeight = std::min(mBounds.height, mTransparencyBitmapHeight);
+  int32_t oldRowBytes = GetBitmapStride(mTransparencyBitmapWidth);
+  int32_t copyBytes = GetBitmapStride(copyWidth);
+
+  int32_t i;
+  gchar* fromPtr = mTransparencyBitmap;
+  gchar* toPtr = newBits;
+  for (i = 0; i < copyHeight; i++) {
+    memcpy(toPtr, fromPtr, copyBytes);
+    fromPtr += oldRowBytes;
+    toPtr += newRowBytes;
+  }
+
+  delete[] mTransparencyBitmap;
+  mTransparencyBitmap = newBits;
+  mTransparencyBitmapWidth = mBounds.width;
+  mTransparencyBitmapHeight = mBounds.height;
+}
+
+static bool ChangedMaskBits(gchar* aMaskBits, int32_t aMaskWidth,
+                            int32_t aMaskHeight, const nsIntRect& aRect,
+                            uint8_t* aAlphas, int32_t aStride) {
+  int32_t x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
+  int32_t maskBytesPerRow = GetBitmapStride(aMaskWidth);
+  for (y = aRect.y; y < yMax; y++) {
+    gchar* maskBytes = aMaskBits + y * maskBytesPerRow;
+    uint8_t* alphas = aAlphas;
+    for (x = aRect.x; x < xMax; x++) {
+      bool newBit = *alphas > 0x7f;
+      alphas++;
+
+      gchar maskByte = maskBytes[x >> 3];
+      bool maskBit = (maskByte & (1 << (x & 7))) != 0;
+
+      if (maskBit != newBit) {
+        return true;
+      }
+    }
+    aAlphas += aStride;
+  }
+
+  return false;
+}
+
+static void UpdateMaskBits(gchar* aMaskBits, int32_t aMaskWidth,
+                           int32_t aMaskHeight, const nsIntRect& aRect,
+                           uint8_t* aAlphas, int32_t aStride) {
+  int32_t x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
+  int32_t maskBytesPerRow = GetBitmapStride(aMaskWidth);
+  for (y = aRect.y; y < yMax; y++) {
+    gchar* maskBytes = aMaskBits + y * maskBytesPerRow;
+    uint8_t* alphas = aAlphas;
+    for (x = aRect.x; x < xMax; x++) {
+      bool newBit = *alphas > 0x7f;
+      alphas++;
+
+      gchar mask = 1 << (x & 7);
+      gchar maskByte = maskBytes[x >> 3];
+      // Note: '-newBit' turns 0 into 00...00 and 1 into 11...11
+      maskBytes[x >> 3] = (maskByte & ~mask) | (-newBit & mask);
+    }
+    aAlphas += aStride;
+  }
+}
+
+void nsWindow::ApplyTransparencyBitmap() {
+#ifdef MOZ_X11
+  // We use X11 calls where possible, because GDK handles expose events
+  // for shaped windows in a way that's incompatible with us (Bug 635903).
+  // It doesn't occur when the shapes are set through X.
+  Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
+  Window xDrawable = GDK_WINDOW_XID(mGdkWindow);
+  Pixmap maskPixmap = XCreateBitmapFromData(
+      xDisplay, xDrawable, mTransparencyBitmap, mTransparencyBitmapWidth,
+      mTransparencyBitmapHeight);
+  XShapeCombineMask(xDisplay, xDrawable, ShapeBounding, 0, 0, maskPixmap,
+                    ShapeSet);
+  XFreePixmap(xDisplay, maskPixmap);
+#endif  // MOZ_X11
+}
+
+void nsWindow::ClearTransparencyBitmap() {
+  if (!mTransparencyBitmap) return;
+
+  delete[] mTransparencyBitmap;
+  mTransparencyBitmap = nullptr;
+  mTransparencyBitmapWidth = 0;
+  mTransparencyBitmapHeight = 0;
+
+  if (!mShell) return;
+
+#ifdef MOZ_X11
+  if (MOZ_UNLIKELY(!mGdkWindow)) {
+    return;
+  }
+
+  Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
+  Window xWindow = gdk_x11_window_get_xid(mGdkWindow);
+
+  XShapeCombineMask(xDisplay, xWindow, ShapeBounding, 0, 0, X11None, ShapeSet);
+#endif
+}
+
+nsresult nsWindow::UpdateTranslucentWindowAlphaInternal(const nsIntRect& aRect,
+                                                        uint8_t* aAlphas,
+                                                        int32_t aStride) {
+  NS_ASSERTION(mIsTransparent, "Window is not transparent");
+  NS_ASSERTION(!mTransparencyBitmapForTitlebar,
+               "Transparency bitmap is already used for titlebar rendering");
+
+  if (mTransparencyBitmap == nullptr) {
+    int32_t size = GetBitmapStride(mBounds.width) * mBounds.height;
+    mTransparencyBitmap = new gchar[size];
+    memset(mTransparencyBitmap, 255, size);
+    mTransparencyBitmapWidth = mBounds.width;
+    mTransparencyBitmapHeight = mBounds.height;
+  } else {
+    ResizeTransparencyBitmap();
+  }
+
+  nsIntRect rect;
+  rect.IntersectRect(aRect, nsIntRect(0, 0, mBounds.width, mBounds.height));
+
+  if (!ChangedMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height, rect,
+                       aAlphas, aStride)) {
+    // skip the expensive stuff if the mask bits haven't changed; hopefully
+    // this is the common case
+    return NS_OK;
+  }
+
+  UpdateMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height, rect,
+                 aAlphas, aStride);
+
+  if (!mNeedsShow) {
+    ApplyTransparencyBitmap();
+  }
+  return NS_OK;
+}
+
+#define TITLEBAR_HEIGHT 10
+
+LayoutDeviceIntRect nsWindow::GetTitlebarRect() {
+  if (!mGdkWindow || !mDrawInTitlebar) {
+    return LayoutDeviceIntRect();
+  }
+
+  int height = 0;
+  if (DoDrawTilebarCorners()) {
+    height = GdkCeiledScaleFactor() * TITLEBAR_HEIGHT;
+  }
+  return LayoutDeviceIntRect(0, 0, mBounds.width, height);
+}
+
+void nsWindow::UpdateTitlebarTransparencyBitmap() {
+  NS_ASSERTION(mTransparencyBitmapForTitlebar,
+               "Transparency bitmap is already used to draw window shape");
+
+  if (!mGdkWindow || !mDrawInTitlebar ||
+      (mBounds.width == mTransparencyBitmapWidth &&
+       mBounds.height == mTransparencyBitmapHeight)) {
+    return;
+  }
+
+  bool maskCreate =
+      !mTransparencyBitmap || mBounds.width > mTransparencyBitmapWidth;
+
+  bool maskUpdate =
+      !mTransparencyBitmap || mBounds.width != mTransparencyBitmapWidth;
+
+  LayoutDeviceIntCoord radius = GetTitlebarRadius();
+  if (maskCreate) {
+    delete[] mTransparencyBitmap;
+    int32_t size = GetBitmapStride(mBounds.width) * radius;
+    mTransparencyBitmap = new gchar[size];
+    mTransparencyBitmapWidth = mBounds.width;
+  } else {
+    mTransparencyBitmapWidth = mBounds.width;
+  }
+  mTransparencyBitmapHeight = mBounds.height;
+
+  if (maskUpdate) {
+    cairo_surface_t* surface = cairo_image_surface_create(
+        CAIRO_FORMAT_A8, mTransparencyBitmapWidth, radius);
+    if (!surface) return;
+
+    cairo_t* cr = cairo_create(surface);
+
+    GtkWidgetState state;
+    memset((void*)&state, 0, sizeof(state));
+    GdkRectangle rect = {0, 0, mTransparencyBitmapWidth, radius};
+
+    moz_gtk_widget_paint(MOZ_GTK_HEADER_BAR, cr, &rect, &state, 0,
+                         GTK_TEXT_DIR_NONE);
+
+    cairo_destroy(cr);
+    cairo_surface_mark_dirty(surface);
+    cairo_surface_flush(surface);
+
+    UpdateMaskBits(mTransparencyBitmap, mTransparencyBitmapWidth, radius,
+                   nsIntRect(0, 0, mTransparencyBitmapWidth, radius),
+                   cairo_image_surface_get_data(surface),
+                   cairo_format_stride_for_width(CAIRO_FORMAT_A8,
+                                                 mTransparencyBitmapWidth));
+
+    cairo_surface_destroy(surface);
+  }
+
+#ifdef MOZ_X11
+  if (!mNeedsShow) {
+    Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
+    Window xDrawable = GDK_WINDOW_XID(mGdkWindow);
+
+    Pixmap maskPixmap =
+        XCreateBitmapFromData(xDisplay, xDrawable, mTransparencyBitmap,
+                              mTransparencyBitmapWidth, radius);
+
+    XShapeCombineMask(xDisplay, xDrawable, ShapeBounding, 0, 0, maskPixmap,
+                      ShapeSet);
+
+    if (mTransparencyBitmapHeight > radius) {
+      XRectangle rect = {0, 0, (unsigned short)mTransparencyBitmapWidth,
+                         (unsigned short)(mTransparencyBitmapHeight - radius)};
+      XShapeCombineRectangles(xDisplay, xDrawable, ShapeBounding, 0, radius,
+                              &rect, 1, ShapeUnion, 0);
+    }
+
+    XFreePixmap(xDisplay, maskPixmap);
+  }
+#endif
+}
+
+void nsWindow::GrabPointer(guint32 aTime) {
+  LOG("GrabPointer time=0x%08x retry=%d\n", (unsigned int)aTime,
+      mRetryPointerGrab);
+
+  // Don't to the grab on Wayland as it causes a regression
+  // from Bug 1377084.
+  if (mIsDestroyed || GdkIsWaylandDisplay()) {
+    return;
+  }
+
+  mRetryPointerGrab = false;
+  sRetryGrabTime = aTime;
+
+  // If the window isn't visible, just set the flag to retry the
+  // grab.  When this window becomes visible, the grab will be
+  // retried.
+  if (!mHasMappedToplevel || !mGdkWindow) {
+    LOG("  quit, window not visible, mHasMappedToplevel = %d, mGdkWindow = %p",
+        mHasMappedToplevel, mGdkWindow);
+    mRetryPointerGrab = true;
+    return;
+  }
+
+#ifdef MOZ_X11
+  gint retval;
+  // Note that we need GDK_TOUCH_MASK below to work around a GDK/X11 bug that
+  // causes touch events that would normally be received by this client on
+  // other windows to be discarded during the grab.
+  retval = gdk_pointer_grab(
+      mGdkWindow, TRUE,
+      (GdkEventMask)(GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+                     GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
+                     GDK_POINTER_MOTION_MASK | GDK_TOUCH_MASK),
+      (GdkWindow*)nullptr, nullptr, aTime);
+
+  if (retval == GDK_GRAB_NOT_VIEWABLE) {
+    LOG("  failed: window not viewable; will retry\n");
+    mRetryPointerGrab = true;
+  } else if (retval != GDK_GRAB_SUCCESS) {
+    LOG("  pointer grab failed: %i\n", retval);
+    // A failed grab indicates that another app has grabbed the pointer.
+    // Check for rollup now, because, without the grab, we likely won't
+    // get subsequent button press events. Do this with an event so that
+    // popups don't rollup while potentially adjusting the grab for
+    // this popup.
+    nsCOMPtr<nsIRunnable> event =
+        NewRunnableMethod("nsWindow::CheckForRollupDuringGrab", this,
+                          &nsWindow::CheckForRollupDuringGrab);
+    NS_DispatchToCurrentThread(event.forget());
+  }
+#endif
+}
+
+void nsWindow::ReleaseGrabs(void) {
+  LOG("ReleaseGrabs\n");
+
+  mRetryPointerGrab = false;
+
+  if (GdkIsWaylandDisplay()) {
+    // Don't to the ungrab on Wayland as it causes a regression
+    // from Bug 1377084.
+    return;
+  }
+
+#ifdef MOZ_X11
+  gdk_pointer_ungrab(GDK_CURRENT_TIME);
+#endif
+}
+
+GtkWidget* nsWindow::GetToplevelWidget() { return mShell; }
+
+GdkWindow* nsWindow::GetToplevelGdkWindow() {
+  return gtk_widget_get_window(mShell);
+}
+
+nsWindow* nsWindow::GetContainerWindow() {
+  GtkWidget* owningWidget = GTK_WIDGET(mContainer);
+  if (!owningWidget) return nullptr;
+
+  nsWindow* window = get_window_for_gtk_widget(owningWidget);
+  NS_ASSERTION(window, "No nsWindow for container widget");
+  return window;
+}
+
+void nsWindow::SetUrgencyHint(GtkWidget* top_window, bool state) {
+  LOG("  nsWindow::SetUrgencyHint widget %p\n", top_window);
+
+  if (!top_window) return;
+
+  // TODO: Use xdg-activation on Wayland?
+  gdk_window_set_urgency_hint(gtk_widget_get_window(top_window), state);
+}
+
+void nsWindow::SetDefaultIcon(void) { SetIcon(u"default"_ns); }
+
+gint nsWindow::ConvertBorderStyles(nsBorderStyle aStyle) {
+  gint w = 0;
+
+  if (aStyle == eBorderStyle_default) return -1;
+
+  // note that we don't handle eBorderStyle_close yet
+  if (aStyle & eBorderStyle_all) w |= GDK_DECOR_ALL;
+  if (aStyle & eBorderStyle_border) w |= GDK_DECOR_BORDER;
+  if (aStyle & eBorderStyle_resizeh) w |= GDK_DECOR_RESIZEH;
+  if (aStyle & eBorderStyle_title) w |= GDK_DECOR_TITLE;
+  if (aStyle & eBorderStyle_menu) w |= GDK_DECOR_MENU;
+  if (aStyle & eBorderStyle_minimize) w |= GDK_DECOR_MINIMIZE;
+  if (aStyle & eBorderStyle_maximize) w |= GDK_DECOR_MAXIMIZE;
+
+  return w;
+}
+
+class FullscreenTransitionWindow final : public nsISupports {
+ public:
+  NS_DECL_ISUPPORTS
+
+  explicit FullscreenTransitionWindow(GtkWidget* aWidget);
+
+  GtkWidget* mWindow;
+
+ private:
+  ~FullscreenTransitionWindow();
+};
+
+NS_IMPL_ISUPPORTS0(FullscreenTransitionWindow)
+
+FullscreenTransitionWindow::FullscreenTransitionWindow(GtkWidget* aWidget) {
+  mWindow = gtk_window_new(GTK_WINDOW_POPUP);
+  GtkWindow* gtkWin = GTK_WINDOW(mWindow);
+
+  gtk_window_set_type_hint(gtkWin, GDK_WINDOW_TYPE_HINT_SPLASHSCREEN);
+  gtk_window_set_transient_for(gtkWin, GTK_WINDOW(aWidget));
+  gtk_window_set_decorated(gtkWin, false);
+
+  GdkWindow* gdkWin = gtk_widget_get_window(aWidget);
+  GdkScreen* screen = gtk_widget_get_screen(aWidget);
+  gint monitorNum = gdk_screen_get_monitor_at_window(screen, gdkWin);
+  GdkRectangle monitorRect;
+  gdk_screen_get_monitor_geometry(screen, monitorNum, &monitorRect);
+  gtk_window_set_screen(gtkWin, screen);
+  gtk_window_move(gtkWin, monitorRect.x, monitorRect.y);
+  MOZ_ASSERT(monitorRect.width > 0 && monitorRect.height > 0,
+             "Can't resize window smaller than 1x1.");
+  gtk_window_resize(gtkWin, monitorRect.width, monitorRect.height);
+
+  GdkRGBA bgColor;
+  bgColor.red = bgColor.green = bgColor.blue = 0.0;
+  bgColor.alpha = 1.0;
+  gtk_widget_override_background_color(mWindow, GTK_STATE_FLAG_NORMAL,
+                                       &bgColor);
+
+  gtk_widget_set_opacity(mWindow, 0.0);
+  gtk_widget_show(mWindow);
+}
+
+FullscreenTransitionWindow::~FullscreenTransitionWindow() {
+  gtk_widget_destroy(mWindow);
+}
+
+class FullscreenTransitionData {
+ public:
+  FullscreenTransitionData(nsIWidget::FullscreenTransitionStage aStage,
+                           uint16_t aDuration, nsIRunnable* aCallback,
+                           FullscreenTransitionWindow* aWindow)
+      : mStage(aStage),
+        mStartTime(TimeStamp::Now()),
+        mDuration(TimeDuration::FromMilliseconds(aDuration)),
+        mCallback(aCallback),
+        mWindow(aWindow) {}
+
+  static const guint sInterval = 1000 / 30;  // 30fps
+  static gboolean TimeoutCallback(gpointer aData);
+
+ private:
+  nsIWidget::FullscreenTransitionStage mStage;
+  TimeStamp mStartTime;
+  TimeDuration mDuration;
+  nsCOMPtr<nsIRunnable> mCallback;
+  RefPtr<FullscreenTransitionWindow> mWindow;
+};
+
+/* static */
+gboolean FullscreenTransitionData::TimeoutCallback(gpointer aData) {
+  bool finishing = false;
+  auto* data = static_cast<FullscreenTransitionData*>(aData);
+  gdouble opacity = (TimeStamp::Now() - data->mStartTime) / data->mDuration;
+  if (opacity >= 1.0) {
+    opacity = 1.0;
+    finishing = true;
+  }
+  if (data->mStage == nsIWidget::eAfterFullscreenToggle) {
+    opacity = 1.0 - opacity;
+  }
+  gtk_widget_set_opacity(data->mWindow->mWindow, opacity);
+
+  if (!finishing) {
+    return TRUE;
+  }
+  NS_DispatchToMainThread(data->mCallback.forget());
+  delete data;
+  return FALSE;
+}
+
+/* virtual */
+bool nsWindow::PrepareForFullscreenTransition(nsISupports** aData) {
+  if (!mCompositedScreen) {
+    return false;
+  }
+  *aData = do_AddRef(new FullscreenTransitionWindow(mShell)).take();
+  return true;
+}
+
+/* virtual */
+void nsWindow::PerformFullscreenTransition(FullscreenTransitionStage aStage,
+                                           uint16_t aDuration,
+                                           nsISupports* aData,
+                                           nsIRunnable* aCallback) {
+  auto* data = static_cast<FullscreenTransitionWindow*>(aData);
+  // This will be released at the end of the last timeout callback for it.
+  auto* transitionData =
+      new FullscreenTransitionData(aStage, aDuration, aCallback, data);
+  g_timeout_add_full(G_PRIORITY_HIGH, FullscreenTransitionData::sInterval,
+                     FullscreenTransitionData::TimeoutCallback, transitionData,
+                     nullptr);
+}
+
+already_AddRefed<nsIScreen> nsWindow::GetWidgetScreen() {
+  // Wayland can read screen directly
+  if (GdkIsWaylandDisplay()) {
+    RefPtr<nsIScreen> screen = ScreenHelperGTK::GetScreenForWindow(this);
+    if (screen) {
+      return screen.forget();
+    }
+  }
+
+  nsCOMPtr<nsIScreenManager> screenManager;
+  screenManager = do_GetService("@mozilla.org/gfx/screenmanager;1");
+  if (!screenManager) {
+    return nullptr;
+  }
+
+  // GetScreenBounds() is slow for the GTK port so we override and use
+  // mBounds directly.
+  LayoutDeviceIntRect bounds = mBounds;
+  DesktopIntRect deskBounds = RoundedToInt(bounds / GetDesktopToDeviceScale());
+  nsCOMPtr<nsIScreen> screen;
+  screenManager->ScreenForRect(deskBounds.x, deskBounds.y, deskBounds.width,
+                               deskBounds.height, getter_AddRefs(screen));
+  return screen.forget();
+}
+
+RefPtr<VsyncSource> nsWindow::GetVsyncSource() {
+#ifdef MOZ_WAYLAND
+  if (mWaylandVsyncSource) {
+    return mWaylandVsyncSource;
+  }
+#endif
+  return nullptr;
+}
+
+bool nsWindow::SynchronouslyRepaintOnResize() {
+  if (GdkIsWaylandDisplay()) {
+    // See Bug 1734368
+    // Don't request synchronous repaint on HW accelerated backend - mesa can be
+    // deadlocked when it's missing back buffer and main event loop is blocked.
+    return false;
+  }
+
+  // default is synced repaint.
+  return true;
+}
+
+static bool IsFullscreenSupported(GtkWidget* aShell) {
+#ifdef MOZ_X11
+  GdkScreen* screen = gtk_widget_get_screen(aShell);
+  GdkAtom atom = gdk_atom_intern("_NET_WM_STATE_FULLSCREEN", FALSE);
+  return gdk_x11_screen_supports_net_wm_hint(screen, atom);
+#else
+  return true;
+#endif
+}
+
+nsresult nsWindow::MakeFullScreen(bool aFullScreen) {
+  LOG("nsWindow::MakeFullScreen aFullScreen %d\n", aFullScreen);
+
+  if (GdkIsX11Display() && !IsFullscreenSupported(mShell)) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  bool wasFullscreen = mSizeState == nsSizeMode_Fullscreen;
+  if (aFullScreen != wasFullscreen && mWidgetListener) {
+    mWidgetListener->FullscreenWillChange(aFullScreen);
+  }
+
+  if (aFullScreen) {
+    if (mSizeMode != nsSizeMode_Fullscreen) mLastSizeMode = mSizeMode;
+
+    mSizeMode = nsSizeMode_Fullscreen;
+
+    if (mIsPIPWindow) {
+      gtk_window_set_type_hint(GTK_WINDOW(mShell), GDK_WINDOW_TYPE_HINT_NORMAL);
+      if (gUseAspectRatio) {
+        mAspectRatioSaved = mAspectRatio;
+        mAspectRatio = 0.0f;
+        ApplySizeConstraints();
+      }
+    }
+
+    gtk_window_fullscreen(GTK_WINDOW(mShell));
+  } else {
+    mSizeMode = mLastSizeMode;
+    gtk_window_unfullscreen(GTK_WINDOW(mShell));
+
+    if (mIsPIPWindow) {
+      gtk_window_set_type_hint(GTK_WINDOW(mShell),
+                               GDK_WINDOW_TYPE_HINT_UTILITY);
+      if (gUseAspectRatio) {
+        mAspectRatio = mAspectRatioSaved;
+        // ApplySizeConstraints();
+      }
+    }
+  }
+
+  NS_ASSERTION(mLastSizeMode != nsSizeMode_Fullscreen,
+               "mLastSizeMode should never be fullscreen");
+  return NS_OK;
+}
+
+void nsWindow::SetWindowDecoration(nsBorderStyle aStyle) {
+  LOG("nsWindow::SetWindowDecoration() Border style %x\n", aStyle);
+
+  // We can't use mGdkWindow directly here as it can be
+  // derived from mContainer which is not a top-level GdkWindow.
+  GdkWindow* window = gtk_widget_get_window(mShell);
+
+  // Sawfish, metacity, and presumably other window managers get
+  // confused if we change the window decorations while the window
+  // is visible.
+  bool wasVisible = false;
+  if (gdk_window_is_visible(window)) {
+    gdk_window_hide(window);
+    wasVisible = true;
+  }
+
+  gint wmd = ConvertBorderStyles(aStyle);
+  if (wmd != -1) gdk_window_set_decorations(window, (GdkWMDecoration)wmd);
+
+  if (wasVisible) gdk_window_show(window);
+
+    // For some window managers, adding or removing window decorations
+    // requires unmapping and remapping our toplevel window.  Go ahead
+    // and flush the queue here so that we don't end up with a BadWindow
+    // error later when this happens (when the persistence timer fires
+    // and GetWindowPos is called)
+#ifdef MOZ_X11
+  if (GdkIsX11Display()) {
+    XSync(GDK_DISPLAY_XDISPLAY(gdk_display_get_default()), X11False);
+  } else
+#endif /* MOZ_X11 */
+  {
+    gdk_flush();
+  }
+}
+
+void nsWindow::HideWindowChrome(bool aShouldHide) {
+  SetWindowDecoration(aShouldHide ? eBorderStyle_none : mBorderStyle);
+}
+
+bool nsWindow::CheckForRollup(gdouble aMouseX, gdouble aMouseY, bool aIsWheel,
+                              bool aAlwaysRollup) {
+  nsIRollupListener* rollupListener = GetActiveRollupListener();
+  nsCOMPtr<nsIWidget> rollupWidget;
+  if (rollupListener) {
+    rollupWidget = rollupListener->GetRollupWidget();
+  }
+  if (!rollupWidget) {
+    nsBaseWidget::gRollupListener = nullptr;
+    return false;
+  }
+
+  bool retVal = false;
+  auto* currentPopup =
+      (GdkWindow*)rollupWidget->GetNativeData(NS_NATIVE_WINDOW);
+  if (aAlwaysRollup || !is_mouse_in_window(currentPopup, aMouseX, aMouseY)) {
+    bool rollup = true;
+    if (aIsWheel) {
+      rollup = rollupListener->ShouldRollupOnMouseWheelEvent();
+      retVal = rollupListener->ShouldConsumeOnMouseWheelEvent();
+    }
+    // if we're dealing with menus, we probably have submenus and
+    // we don't want to rollup if the click is in a parent menu of
+    // the current submenu
+    uint32_t popupsToRollup = UINT32_MAX;
+    if (!aAlwaysRollup) {
+      AutoTArray<nsIWidget*, 5> widgetChain;
+      uint32_t sameTypeCount =
+          rollupListener->GetSubmenuWidgetChain(&widgetChain);
+      for (unsigned long i = 0; i < widgetChain.Length(); ++i) {
+        nsIWidget* widget = widgetChain[i];
+        auto* currWindow = (GdkWindow*)widget->GetNativeData(NS_NATIVE_WINDOW);
+        if (is_mouse_in_window(currWindow, aMouseX, aMouseY)) {
+          // don't roll up if the mouse event occurred within a
+          // menu of the same type. If the mouse event occurred
+          // in a menu higher than that, roll up, but pass the
+          // number of popups to Rollup so that only those of the
+          // same type close up.
+          if (i < sameTypeCount) {
+            rollup = false;
+          } else {
+            popupsToRollup = sameTypeCount;
+          }
+          break;
+        }
+      }  // foreach parent menu widget
+    }    // if rollup listener knows about menus
+
+    // if we've determined that we should still rollup, do it.
+    bool usePoint = !aIsWheel && !aAlwaysRollup;
+    LayoutDeviceIntPoint point;
+    if (usePoint) {
+      point = GdkEventCoordsToDevicePixels(aMouseX, aMouseY);
+    }
+    if (rollup &&
+        rollupListener->Rollup(popupsToRollup, true,
+                               usePoint ? &point : nullptr, nullptr)) {
+      retVal = true;
+    }
+  }
+  return retVal;
+}
+
+/* static */
+bool nsWindow::DragInProgress(void) {
+  nsCOMPtr<nsIDragService> dragService =
+      do_GetService("@mozilla.org/widget/dragservice;1");
+  if (!dragService) {
+    return false;
+  }
+
+  nsCOMPtr<nsIDragSession> currentDragSession;
+  dragService->GetCurrentSession(getter_AddRefs(currentDragSession));
+
+  return currentDragSession != nullptr;
+}
+
+// This is an ugly workaround for
+// https://bugzilla.mozilla.org/show_bug.cgi?id=1622107
+// We try to detect when Wayland compositor / gtk fails to deliver
+// info about finished D&D operations and cancel it on our own.
+MOZ_CAN_RUN_SCRIPT static void WaylandDragWorkaround(GdkEventButton* aEvent) {
+  static int buttonPressCountWithDrag = 0;
+
+  // We track only left button state as Firefox performs D&D on left
+  // button only.
+  if (aEvent->button != 1 || aEvent->type != GDK_BUTTON_PRESS) {
+    return;
+  }
+
+  nsCOMPtr<nsIDragService> dragService =
+      do_GetService("@mozilla.org/widget/dragservice;1");
+  if (!dragService) {
+    return;
+  }
+  nsCOMPtr<nsIDragSession> currentDragSession;
+  dragService->GetCurrentSession(getter_AddRefs(currentDragSession));
+
+  if (!currentDragSession) {
+    buttonPressCountWithDrag = 0;
+    return;
+  }
+
+  buttonPressCountWithDrag++;
+  if (buttonPressCountWithDrag > 1) {
+    NS_WARNING(
+        "Quit unfinished Wayland Drag and Drop operation. Buggy Wayland "
+        "compositor?");
+    buttonPressCountWithDrag = 0;
+    dragService->EndDragSession(false, 0);
+  }
+}
+
+static bool is_mouse_in_window(GdkWindow* aWindow, gdouble aMouseX,
+                               gdouble aMouseY) {
+  GdkWindow* window = aWindow;
+  if (!window) {
+    return false;
+  }
+
+  gint x = 0;
+  gint y = 0;
+  gint w, h;
+
+  gint offsetX = 0;
+  gint offsetY = 0;
+
+  while (window) {
+    gint tmpX = 0;
+    gint tmpY = 0;
+
+    gdk_window_get_position(window, &tmpX, &tmpY);
+    GtkWidget* widget = get_gtk_widget_for_gdk_window(window);
+
+    // if this is a window, compute x and y given its origin and our
+    // offset
+    if (GTK_IS_WINDOW(widget)) {
+      x = tmpX + offsetX;
+      y = tmpY + offsetY;
+      break;
+    }
+
+    offsetX += tmpX;
+    offsetY += tmpY;
+    window = gdk_window_get_parent(window);
+  }
+
+  w = gdk_window_get_width(aWindow);
+  h = gdk_window_get_height(aWindow);
+
+  return (aMouseX > x && aMouseX < x + w && aMouseY > y && aMouseY < y + h);
+}
+
+static nsWindow* get_window_for_gtk_widget(GtkWidget* widget) {
+  gpointer user_data = g_object_get_data(G_OBJECT(widget), "nsWindow");
+
+  return static_cast<nsWindow*>(user_data);
+}
+
+static nsWindow* get_window_for_gdk_window(GdkWindow* window) {
+  gpointer user_data = g_object_get_data(G_OBJECT(window), "nsWindow");
+
+  return static_cast<nsWindow*>(user_data);
+}
+
+static GtkWidget* get_gtk_widget_for_gdk_window(GdkWindow* window) {
+  gpointer user_data = nullptr;
+  gdk_window_get_user_data(window, &user_data);
+
+  return GTK_WIDGET(user_data);
+}
+
+static GdkCursor* get_gtk_cursor(nsCursor aCursor) {
+  GdkCursor* gdkcursor = nullptr;
+  uint8_t newType = 0xff;
+
+  if ((gdkcursor = gCursorCache[aCursor])) {
+    return gdkcursor;
+  }
+
+  GdkDisplay* defaultDisplay = gdk_display_get_default();
+
+  // The strategy here is to use standard GDK cursors, and, if not available,
+  // load by standard name with gdk_cursor_new_from_name.
+  // Spec is here: http://www.freedesktop.org/wiki/Specifications/cursor-spec/
+  switch (aCursor) {
+    case eCursor_standard:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_LEFT_PTR);
+      break;
+    case eCursor_wait:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_WATCH);
+      break;
+    case eCursor_select:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_XTERM);
+      break;
+    case eCursor_hyperlink:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_HAND2);
+      break;
+    case eCursor_n_resize:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_TOP_SIDE);
+      break;
+    case eCursor_s_resize:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_BOTTOM_SIDE);
+      break;
+    case eCursor_w_resize:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_LEFT_SIDE);
+      break;
+    case eCursor_e_resize:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_RIGHT_SIDE);
+      break;
+    case eCursor_nw_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_TOP_LEFT_CORNER);
+      break;
+    case eCursor_se_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_BOTTOM_RIGHT_CORNER);
+      break;
+    case eCursor_ne_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_TOP_RIGHT_CORNER);
+      break;
+    case eCursor_sw_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_BOTTOM_LEFT_CORNER);
+      break;
+    case eCursor_crosshair:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_CROSSHAIR);
+      break;
+    case eCursor_move:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_FLEUR);
+      break;
+    case eCursor_help:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_QUESTION_ARROW);
+      break;
+    case eCursor_copy:  // CSS3
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "copy");
+      if (!gdkcursor) newType = MOZ_CURSOR_COPY;
+      break;
+    case eCursor_alias:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "alias");
+      if (!gdkcursor) newType = MOZ_CURSOR_ALIAS;
+      break;
+    case eCursor_context_menu:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "context-menu");
+      if (!gdkcursor) newType = MOZ_CURSOR_CONTEXT_MENU;
+      break;
+    case eCursor_cell:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_PLUS);
+      break;
+    // Those two arent standardized. Trying both KDEs and GNOMEs names
+    case eCursor_grab:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "openhand");
+      if (!gdkcursor) newType = MOZ_CURSOR_HAND_GRAB;
+      break;
+    case eCursor_grabbing:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "closedhand");
+      if (!gdkcursor) {
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "grabbing");
+      }
+      if (!gdkcursor) newType = MOZ_CURSOR_HAND_GRABBING;
+      break;
+    case eCursor_spinning:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "progress");
+      if (!gdkcursor) newType = MOZ_CURSOR_SPINNING;
+      break;
+    case eCursor_zoom_in:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "zoom-in");
+      if (!gdkcursor) newType = MOZ_CURSOR_ZOOM_IN;
+      break;
+    case eCursor_zoom_out:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "zoom-out");
+      if (!gdkcursor) newType = MOZ_CURSOR_ZOOM_OUT;
+      break;
+    case eCursor_not_allowed:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "not-allowed");
+      if (!gdkcursor) {  // nonstandard, yet common
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "crossed_circle");
+      }
+      if (!gdkcursor) newType = MOZ_CURSOR_NOT_ALLOWED;
+      break;
+    case eCursor_no_drop:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "no-drop");
+      if (!gdkcursor) {  // this nonstandard sequence makes it work on KDE and
+                         // GNOME
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "forbidden");
+      }
+      if (!gdkcursor) {
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "circle");
+      }
+      if (!gdkcursor) newType = MOZ_CURSOR_NOT_ALLOWED;
+      break;
+    case eCursor_vertical_text:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "vertical-text");
+      if (!gdkcursor) {
+        newType = MOZ_CURSOR_VERTICAL_TEXT;
+      }
+      break;
+    case eCursor_all_scroll:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_FLEUR);
+      break;
+    case eCursor_nesw_resize:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "size_bdiag");
+      if (!gdkcursor) newType = MOZ_CURSOR_NESW_RESIZE;
+      break;
+    case eCursor_nwse_resize:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "size_fdiag");
+      if (!gdkcursor) newType = MOZ_CURSOR_NWSE_RESIZE;
+      break;
+    case eCursor_ns_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_SB_V_DOUBLE_ARROW);
+      break;
+    case eCursor_ew_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_SB_H_DOUBLE_ARROW);
+      break;
+    // Here, two better fitting cursors exist in some cursor themes. Try those
+    // first
+    case eCursor_row_resize:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "split_v");
+      if (!gdkcursor) {
+        gdkcursor =
+            gdk_cursor_new_for_display(defaultDisplay, GDK_SB_V_DOUBLE_ARROW);
+      }
+      break;
+    case eCursor_col_resize:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "split_h");
+      if (!gdkcursor) {
+        gdkcursor =
+            gdk_cursor_new_for_display(defaultDisplay, GDK_SB_H_DOUBLE_ARROW);
+      }
+      break;
+    case eCursor_none:
+      newType = MOZ_CURSOR_NONE;
+      break;
+    default:
+      NS_ASSERTION(aCursor, "Invalid cursor type");
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_LEFT_PTR);
+      break;
+  }
+
+  // If by now we don't have a xcursor, this means we have to make a custom
+  // one. First, we try creating a named cursor based on the hash of our
+  // custom bitmap, as libXcursor has some magic to convert bitmapped cursors
+  // to themed cursors
+  if (newType != 0xFF && GtkCursors[newType].hash) {
+    gdkcursor =
+        gdk_cursor_new_from_name(defaultDisplay, GtkCursors[newType].hash);
+  }
+
+  // If we still don't have a xcursor, we now really create a bitmap cursor
+  if (newType != 0xff && !gdkcursor) {
+    GdkPixbuf* cursor_pixbuf =
+        gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8, 32, 32);
+    if (!cursor_pixbuf) return nullptr;
+
+    guchar* data = gdk_pixbuf_get_pixels(cursor_pixbuf);
+
+    // Read data from GtkCursors and compose RGBA surface from 1bit bitmap and
+    // mask GtkCursors bits and mask are 32x32 monochrome bitmaps (1 bit for
+    // each pixel) so it's 128 byte array (4 bytes for are one bitmap row and
+    // there are 32 rows here).
+    const unsigned char* bits = GtkCursors[newType].bits;
+    const unsigned char* mask_bits = GtkCursors[newType].mask_bits;
+
+    for (int i = 0; i < 128; i++) {
+      char bit = (char)*bits++;
+      char mask = (char)*mask_bits++;
+      for (int j = 0; j < 8; j++) {
+        unsigned char pix = ~(((bit >> j) & 0x01) * 0xff);
+        *data++ = pix;
+        *data++ = pix;
+        *data++ = pix;
+        *data++ = (((mask >> j) & 0x01) * 0xff);
+      }
+    }
+
+    gdkcursor = gdk_cursor_new_from_pixbuf(
+        gdk_display_get_default(), cursor_pixbuf, GtkCursors[newType].hot_x,
+        GtkCursors[newType].hot_y);
+
+    g_object_unref(cursor_pixbuf);
+  }
+
+  gCursorCache[aCursor] = gdkcursor;
+
+  return gdkcursor;
+}
+
+// gtk callbacks
+
+void draw_window_of_widget(GtkWidget* widget, GdkWindow* aWindow, cairo_t* cr) {
+  if (gtk_cairo_should_draw_window(cr, aWindow)) {
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+    if (!window) {
+      NS_WARNING("Cannot get nsWindow from GtkWidget");
+    } else {
+      cairo_save(cr);
+      gtk_cairo_transform_to_window(cr, widget, aWindow);
+      // TODO - window->OnExposeEvent() can destroy this or other windows,
+      // do we need to handle it somehow?
+      window->OnExposeEvent(cr);
+      cairo_restore(cr);
+    }
+  }
+}
+
+/* static */
+gboolean expose_event_cb(GtkWidget* widget, cairo_t* cr) {
+  draw_window_of_widget(widget, gtk_widget_get_window(widget), cr);
+
+  // A strong reference is already held during "draw" signal emission,
+  // but GTK+ 3.4 wants the object to live a little longer than that
+  // (bug 1225970).
+  g_object_ref(widget);
+  g_idle_add(
+      [](gpointer data) -> gboolean {
+        g_object_unref(data);
+        return G_SOURCE_REMOVE;
+      },
+      widget);
+
+  return FALSE;
+}
+
+static gboolean configure_event_cb(GtkWidget* widget,
+                                   GdkEventConfigure* event) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return FALSE;
+  }
+
+  return window->OnConfigureEvent(widget, event);
+}
+
+// Some Gtk widget code may call gtk_widget_unrealize() which destroys
+// mGdkWindow. We need to listen on this signal and re-create
+// mGdkWindow when we're already mapped.
+static void widget_map_cb(GtkWidget* widget) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return;
+  }
+  window->OnMap();
+}
+
+static void widget_unrealize_cb(GtkWidget* widget) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return;
+  }
+  window->OnUnrealize();
+}
+
+static void size_allocate_cb(GtkWidget* widget, GtkAllocation* allocation) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return;
+  }
+
+  window->OnSizeAllocate(allocation);
+}
+
+static void toplevel_window_size_allocate_cb(GtkWidget* widget,
+                                             GtkAllocation* allocation) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return;
+  }
+
+  window->UpdateTopLevelOpaqueRegion();
+}
+
+static gboolean delete_event_cb(GtkWidget* widget, GdkEventAny* event) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return FALSE;
+  }
+
+  window->OnDeleteEvent();
+
+  return TRUE;
+}
+
+static gboolean enter_notify_event_cb(GtkWidget* widget,
+                                      GdkEventCrossing* event) {
+  RefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
+  if (!window) {
+    return TRUE;
+  }
+
+  window->OnEnterNotifyEvent(event);
+
+  return TRUE;
+}
+
+static gboolean leave_notify_event_cb(GtkWidget* widget,
+                                      GdkEventCrossing* event) {
+  if (is_parent_grab_leave(event)) {
+    return TRUE;
+  }
+
+  // bug 369599: Suppress LeaveNotify events caused by pointer grabs to
+  // avoid generating spurious mouse exit events.
+  auto x = gint(event->x_root);
+  auto y = gint(event->y_root);
+  GdkDevice* pointer = GdkGetPointer();
+  GdkWindow* winAtPt = gdk_device_get_window_at_position(pointer, &x, &y);
+  if (winAtPt == event->window) {
+    return TRUE;
+  }
+
+  RefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
+  if (!window) return TRUE;
+
+  window->OnLeaveNotifyEvent(event);
+
+  return TRUE;
+}
+
+static nsWindow* GetFirstNSWindowForGDKWindow(GdkWindow* aGdkWindow) {
+  nsWindow* window;
+  while (!(window = get_window_for_gdk_window(aGdkWindow))) {
+    // The event has bubbled to the moz_container widget as passed into each
+    // caller's *widget parameter, but its corresponding nsWindow is an ancestor
+    // of the window that we need.  Instead, look at event->window and find the
+    // first ancestor nsWindow of it because event->window may be in a plugin.
+    aGdkWindow = gdk_window_get_parent(aGdkWindow);
+    if (!aGdkWindow) {
+      window = nullptr;
+      break;
+    }
+  }
+  return window;
+}
+
+static gboolean motion_notify_event_cb(GtkWidget* widget,
+                                       GdkEventMotion* event) {
+  UpdateLastInputEventTime(event);
+
+  nsWindow* window = GetFirstNSWindowForGDKWindow(event->window);
+  if (!window) return FALSE;
+
+  window->OnMotionNotifyEvent(event);
+
+  return TRUE;
+}
+
+static gboolean button_press_event_cb(GtkWidget* widget,
+                                      GdkEventButton* event) {
+  UpdateLastInputEventTime(event);
+
+  nsWindow* window = GetFirstNSWindowForGDKWindow(event->window);
+  if (!window) return FALSE;
+
+  window->OnButtonPressEvent(event);
+
+  if (GdkIsWaylandDisplay()) {
+    WaylandDragWorkaround(event);
+  }
+
+  return TRUE;
+}
+
+static gboolean button_release_event_cb(GtkWidget* widget,
+                                        GdkEventButton* event) {
+  UpdateLastInputEventTime(event);
+
+  nsWindow* window = GetFirstNSWindowForGDKWindow(event->window);
+  if (!window) return FALSE;
+
+  window->OnButtonReleaseEvent(event);
+
+  return TRUE;
+}
+
+static gboolean focus_in_event_cb(GtkWidget* widget, GdkEventFocus* event) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) return FALSE;
+
+  window->OnContainerFocusInEvent(event);
+
+  return FALSE;
+}
+
+static gboolean focus_out_event_cb(GtkWidget* widget, GdkEventFocus* event) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) return FALSE;
+
+  window->OnContainerFocusOutEvent(event);
+
+  return FALSE;
+}
+
+#ifdef MOZ_X11
+// For long-lived popup windows that don't really take focus themselves but
+// may have elements that accept keyboard input when the parent window is
+// active, focus is handled specially.  These windows include noautohide
+// panels.  (This special handling is not necessary for temporary popups where
+// the keyboard is grabbed.)
+//
+// Mousing over or clicking on these windows should not cause them to steal
+// focus from their parent windows, so, the input field of WM_HINTS is set to
+// False to request that the window manager not set the input focus to this
+// window.  http://tronche.com/gui/x/icccm/sec-4.html#s-4.1.7
+//
+// However, these windows can still receive WM_TAKE_FOCUS messages from the
+// window manager, so they can still detect when the user has indicated that
+// they wish to direct keyboard input at these windows.  When the window
+// manager offers focus to these windows (after a mouse over or click, for
+// example), a request to make the parent window active is issued.  When the
+// parent window becomes active, keyboard events will be received.
+
+static GdkFilterReturn popup_take_focus_filter(GdkXEvent* gdk_xevent,
+                                               GdkEvent* event, gpointer data) {
+  auto* xevent = static_cast<XEvent*>(gdk_xevent);
+  if (xevent->type != ClientMessage) return GDK_FILTER_CONTINUE;
+
+  XClientMessageEvent& xclient = xevent->xclient;
+  if (xclient.message_type != gdk_x11_get_xatom_by_name("WM_PROTOCOLS")) {
+    return GDK_FILTER_CONTINUE;
+  }
+
+  Atom atom = xclient.data.l[0];
+  if (atom != gdk_x11_get_xatom_by_name("WM_TAKE_FOCUS")) {
+    return GDK_FILTER_CONTINUE;
+  }
+
+  guint32 timestamp = xclient.data.l[1];
+
+  GtkWidget* widget = get_gtk_widget_for_gdk_window(event->any.window);
+  if (!widget) return GDK_FILTER_CONTINUE;
+
+  GtkWindow* parent = gtk_window_get_transient_for(GTK_WINDOW(widget));
+  if (!parent) return GDK_FILTER_CONTINUE;
+
+  if (gtk_window_is_active(parent)) {
+    return GDK_FILTER_REMOVE;  // leave input focus on the parent
+  }
+
+  GdkWindow* parent_window = gtk_widget_get_window(GTK_WIDGET(parent));
+  if (!parent_window) return GDK_FILTER_CONTINUE;
+
+  // In case the parent has not been deconified.
+  gdk_window_show_unraised(parent_window);
+
+  // Request focus on the parent window.
+  // Use gdk_window_focus rather than gtk_window_present to avoid
+  // raising the parent window.
+  gdk_window_focus(parent_window, timestamp);
+  return GDK_FILTER_REMOVE;
+}
+#endif /* MOZ_X11 */
+
+static gboolean key_press_event_cb(GtkWidget* widget, GdkEventKey* event) {
+  LOGW("key_press_event_cb\n");
+
+  UpdateLastInputEventTime(event);
+
+  // find the window with focus and dispatch this event to that widget
+  nsWindow* window = get_window_for_gtk_widget(widget);
+  if (!window) return FALSE;
+
+  RefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
+
+#ifdef MOZ_X11
+  // Keyboard repeat can cause key press events to queue up when there are
+  // slow event handlers (bug 301029).  Throttle these events by removing
+  // consecutive pending duplicate KeyPress events to the same window.
+  // We use the event time of the last one.
+  // Note: GDK calls XkbSetDetectableAutorepeat so that KeyRelease events
+  // are generated only when the key is physically released.
+#  define NS_GDKEVENT_MATCH_MASK 0x1FFF  // GDK_SHIFT_MASK .. GDK_BUTTON5_MASK
+  // Our headers undefine X11 KeyPress - let's redefine it here.
+#  ifndef KeyPress
+#    define KeyPress 2
+#  endif
+  GdkDisplay* gdkDisplay = gtk_widget_get_display(widget);
+  if (GdkIsX11Display(gdkDisplay)) {
+    Display* dpy = GDK_DISPLAY_XDISPLAY(gdkDisplay);
+    while (XPending(dpy)) {
+      XEvent next_event;
+      XPeekEvent(dpy, &next_event);
+      GdkWindow* nextGdkWindow =
+          gdk_x11_window_lookup_for_display(gdkDisplay, next_event.xany.window);
+      if (nextGdkWindow != event->window || next_event.type != KeyPress ||
+          next_event.xkey.keycode != event->hardware_keycode ||
+          next_event.xkey.state != (event->state & NS_GDKEVENT_MATCH_MASK)) {
+        break;
+      }
+      XNextEvent(dpy, &next_event);
+      event->time = next_event.xkey.time;
+    }
+  }
+#endif
+
+  return focusWindow->OnKeyPressEvent(event);
+}
+
+static gboolean key_release_event_cb(GtkWidget* widget, GdkEventKey* event) {
+  LOGW("key_release_event_cb\n");
+
+  UpdateLastInputEventTime(event);
+
+  // find the window with focus and dispatch this event to that widget
+  nsWindow* window = get_window_for_gtk_widget(widget);
+  if (!window) return FALSE;
+
+  RefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
+
+  return focusWindow->OnKeyReleaseEvent(event);
+}
+
+static gboolean property_notify_event_cb(GtkWidget* aWidget,
+                                         GdkEventProperty* aEvent) {
+  RefPtr<nsWindow> window = get_window_for_gdk_window(aEvent->window);
+  if (!window) return FALSE;
+
+  return window->OnPropertyNotifyEvent(aWidget, aEvent);
+}
+
+static gboolean scroll_event_cb(GtkWidget* widget, GdkEventScroll* event) {
+  nsWindow* window = GetFirstNSWindowForGDKWindow(event->window);
+  if (!window) return FALSE;
+
+  window->OnScrollEvent(event);
+
+  return TRUE;
+}
+
+static void hierarchy_changed_cb(GtkWidget* widget,
+                                 GtkWidget* previous_toplevel) {
+  GtkWidget* toplevel = gtk_widget_get_toplevel(widget);
+  GdkWindowState old_window_state = GDK_WINDOW_STATE_WITHDRAWN;
+  GdkEventWindowState event;
+
+  event.new_window_state = GDK_WINDOW_STATE_WITHDRAWN;
+
+  if (GTK_IS_WINDOW(previous_toplevel)) {
+    g_signal_handlers_disconnect_by_func(
+        previous_toplevel, FuncToGpointer(window_state_event_cb), widget);
+    GdkWindow* win = gtk_widget_get_window(previous_toplevel);
+    if (win) {
+      old_window_state = gdk_window_get_state(win);
+    }
+  }
+
+  if (GTK_IS_WINDOW(toplevel)) {
+    g_signal_connect_swapped(toplevel, "window-state-event",
+                             G_CALLBACK(window_state_event_cb), widget);
+    GdkWindow* win = gtk_widget_get_window(toplevel);
+    if (win) {
+      event.new_window_state = gdk_window_get_state(win);
+    }
+  }
+
+  event.changed_mask =
+      static_cast<GdkWindowState>(old_window_state ^ event.new_window_state);
+
+  if (event.changed_mask) {
+    event.type = GDK_WINDOW_STATE;
+    event.window = nullptr;
+    event.send_event = TRUE;
+    window_state_event_cb(widget, &event);
+  }
+}
+
+static gboolean window_state_event_cb(GtkWidget* widget,
+                                      GdkEventWindowState* event) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) return FALSE;
+
+  window->OnWindowStateEvent(widget, event);
+
+  return FALSE;
+}
+
+static void settings_xft_dpi_changed_cb(GtkSettings* gtk_settings,
+                                        GParamSpec* pspec, nsWindow* data) {
+  RefPtr<nsWindow> window = data;
+  window->OnDPIChanged();
+  // Even though the window size in screen pixels has not changed,
+  // nsViewManager stores the dimensions in app units.
+  // DispatchResized() updates those.
+  window->DispatchResized();
+}
+
+static void check_resize_cb(GtkContainer* container, gpointer user_data) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(GTK_WIDGET(container));
+  if (!window) {
+    return;
+  }
+  window->OnCheckResize();
+}
+
+static void screen_composited_changed_cb(GdkScreen* screen,
+                                         gpointer user_data) {
+  // This callback can run before gfxPlatform::Init() in rare
+  // cases involving the profile manager. When this happens,
+  // we have no reason to reset any compositors as graphics
+  // hasn't been initialized yet.
+  if (GPUProcessManager::Get()) {
+    GPUProcessManager::Get()->ResetCompositors();
+  }
+}
+
+static void widget_composited_changed_cb(GtkWidget* widget,
+                                         gpointer user_data) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return;
+  }
+  window->OnCompositedChanged();
+}
+
+static void scale_changed_cb(GtkWidget* widget, GParamSpec* aPSpec,
+                             gpointer aPointer) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return;
+  }
+
+  window->OnScaleChanged();
+}
+
+static gboolean touch_event_cb(GtkWidget* aWidget, GdkEventTouch* aEvent) {
+  UpdateLastInputEventTime(aEvent);
+
+  nsWindow* window = GetFirstNSWindowForGDKWindow(aEvent->window);
+  if (!window) {
+    return FALSE;
+  }
+
+  return window->OnTouchEvent(aEvent);
+}
+
+// This function called generic because there is no signal specific to touchpad
+// pinch events.
+static gboolean generic_event_cb(GtkWidget* widget, GdkEvent* aEvent) {
+  if (aEvent->type != GDK_TOUCHPAD_PINCH) {
+    return FALSE;
+  }
+  // Using reinterpret_cast because the touchpad_pinch field of GdkEvent is not
+  // available in GTK+ versions lower than v3.18
+  GdkEventTouchpadPinch* event =
+      reinterpret_cast<GdkEventTouchpadPinch*>(aEvent);
+
+  nsWindow* window = GetFirstNSWindowForGDKWindow(event->window);
+
+  if (!window) {
+    return FALSE;
+  }
+  return window->OnTouchpadPinchEvent(event);
+}
+
+//////////////////////////////////////////////////////////////////////
+// These are all of our drag and drop operations
+
+void nsWindow::InitDragEvent(WidgetDragEvent& aEvent) {
+  // set the keyboard modifiers
+  guint modifierState = KeymapWrapper::GetCurrentModifierState();
+  KeymapWrapper::InitInputEvent(aEvent, modifierState);
+}
+
+gboolean WindowDragMotionHandler(GtkWidget* aWidget,
+                                 GdkDragContext* aDragContext, gint aX, gint aY,
+                                 guint aTime) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+  if (!window) {
+    return FALSE;
+  }
+
+  // figure out which internal widget this drag motion actually happened on
+  nscoord retx = 0;
+  nscoord rety = 0;
+
+  GdkWindow* innerWindow = get_inner_gdk_window(gtk_widget_get_window(aWidget),
+                                                aX, aY, &retx, &rety);
+  RefPtr<nsWindow> innerMostWindow = get_window_for_gdk_window(innerWindow);
+
+  if (!innerMostWindow) {
+    innerMostWindow = window;
+  }
+
+  int tx = 0, ty = 0;
+  // Workaround for Bug 1710344
+  // Caused by Gtk issue https://gitlab.gnome.org/GNOME/gtk/-/issues/4437
+  if (innerMostWindow->IsWaylandPopup()) {
+    gdk_window_get_position(innerWindow, &tx, &ty);
+  }
+
+  LayoutDeviceIntPoint point =
+      innerMostWindow->GdkPointToDevicePixels({retx + tx, rety + ty});
+  LOGDRAG("WindowDragMotionHandler nsWindow %p coords [%d, %d]\n",
+          innerMostWindow.get(), retx, rety);
+
+  RefPtr<nsDragService> dragService = nsDragService::GetInstance();
+  if (!dragService->ScheduleMotionEvent(innerMostWindow, aDragContext, point,
+                                        aTime)) {
+    return FALSE;
+  }
+  // We need to reply to drag_motion event on Wayland immediately,
+  // see Bug 1730203.
+  if (GdkIsWaylandDisplay()) {
+    dragService->ReplyToDragMotion();
+  }
+  return TRUE;
+}
+
+static gboolean drag_motion_event_cb(GtkWidget* aWidget,
+                                     GdkDragContext* aDragContext, gint aX,
+                                     gint aY, guint aTime, gpointer aData) {
+  return WindowDragMotionHandler(aWidget, aDragContext, aX, aY, aTime);
+}
+
+void WindowDragLeaveHandler(GtkWidget* aWidget) {
+  LOGDRAG("WindowDragLeaveHandler()\n");
+
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+  if (!window) {
+    LOGDRAG("    Failed - can't find nsWindow!\n");
+    return;
+  }
+
+  RefPtr<nsDragService> dragService = nsDragService::GetInstance();
+  nsWindow* mostRecentDragWindow = dragService->GetMostRecentDestWindow();
+  if (!mostRecentDragWindow) {
+    // This can happen when the target will not accept a drop.  A GTK drag
+    // source sends the leave message to the destination before the
+    // drag-failed signal on the source widget, but the leave message goes
+    // via the X server, and so doesn't get processed at least until the
+    // event loop runs again.
+    LOGDRAG("    Failed - GetMostRecentDestWindow()!\n");
+    return;
+  }
+
+  if (aWidget != window->GetGtkWidget()) {
+    // When the drag moves between widgets, GTK can send leave signal for
+    // the old widget after the motion or drop signal for the new widget.
+    // We'll send the leave event when the motion or drop event is run.
+    LOGDRAG("    Failed - GtkWidget mismatch!\n");
+    return;
+  }
+
+  LOGDRAG("WindowDragLeaveHandler nsWindow %p\n", (void*)mostRecentDragWindow);
+  dragService->ScheduleLeaveEvent();
+}
+
+static void drag_leave_event_cb(GtkWidget* aWidget,
+                                GdkDragContext* aDragContext, guint aTime,
+                                gpointer aData) {
+  WindowDragLeaveHandler(aWidget);
+}
+
+gboolean WindowDragDropHandler(GtkWidget* aWidget, GdkDragContext* aDragContext,
+                               gint aX, gint aY, guint aTime) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+  if (!window) return FALSE;
+
+  // figure out which internal widget this drag motion actually happened on
+  nscoord retx = 0;
+  nscoord rety = 0;
+
+  GdkWindow* innerWindow = get_inner_gdk_window(gtk_widget_get_window(aWidget),
+                                                aX, aY, &retx, &rety);
+  RefPtr<nsWindow> innerMostWindow = get_window_for_gdk_window(innerWindow);
+
+  if (!innerMostWindow) {
+    innerMostWindow = window;
+  }
+
+  int tx = 0, ty = 0;
+  // Workaround for Bug 1710344
+  // Caused by Gtk issue https://gitlab.gnome.org/GNOME/gtk/-/issues/4437
+  if (innerMostWindow->IsWaylandPopup()) {
+    gdk_window_get_position(innerWindow, &tx, &ty);
+  }
+
+  LayoutDeviceIntPoint point =
+      window->GdkPointToDevicePixels({retx + tx, rety + ty});
+  LOGDRAG("WindowDragDropHandler nsWindow %p coords [%d,%d]\n",
+          innerMostWindow.get(), retx, rety);
+
+  RefPtr<nsDragService> dragService = nsDragService::GetInstance();
+  return dragService->ScheduleDropEvent(innerMostWindow, aDragContext, point,
+                                        aTime);
+}
+
+static gboolean drag_drop_event_cb(GtkWidget* aWidget,
+                                   GdkDragContext* aDragContext, gint aX,
+                                   gint aY, guint aTime, gpointer aData) {
+  return WindowDragDropHandler(aWidget, aDragContext, aX, aY, aTime);
+}
+
+static void drag_data_received_event_cb(GtkWidget* aWidget,
+                                        GdkDragContext* aDragContext, gint aX,
+                                        gint aY,
+                                        GtkSelectionData* aSelectionData,
+                                        guint aInfo, guint aTime,
+                                        gpointer aData) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+  if (!window) return;
+
+  window->OnDragDataReceivedEvent(aWidget, aDragContext, aX, aY, aSelectionData,
+                                  aInfo, aTime, aData);
+}
+
+static nsresult initialize_prefs(void) {
+  if (Preferences::HasUserValue("widget.use-aspect-ratio")) {
+    gUseAspectRatio = Preferences::GetBool("widget.use-aspect-ratio", true);
+  } else {
+    static const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
+    gUseAspectRatio =
+        currentDesktop ? (strstr(currentDesktop, "GNOME") != nullptr) : false;
+  }
+
+  return NS_OK;
+}
+
+// TODO: Can we simplify it for mShell/mContainer only scenario?
+static GdkWindow* get_inner_gdk_window(GdkWindow* aWindow, gint x, gint y,
+                                       gint* retx, gint* rety) {
+  gint cx, cy, cw, ch;
+  GList* children = gdk_window_peek_children(aWindow);
+  for (GList* child = g_list_last(children); child;
+       child = g_list_previous(child)) {
+    auto* childWindow = (GdkWindow*)child->data;
+    if (get_window_for_gdk_window(childWindow)) {
+      gdk_window_get_geometry(childWindow, &cx, &cy, &cw, &ch);
+      if ((cx < x) && (x < (cx + cw)) && (cy < y) && (y < (cy + ch)) &&
+          gdk_window_is_visible(childWindow)) {
+        return get_inner_gdk_window(childWindow, x - cx, y - cy, retx, rety);
+      }
+    }
+  }
+  *retx = x;
+  *rety = y;
+  return aWindow;
+}
+
+static int is_parent_ungrab_enter(GdkEventCrossing* aEvent) {
+  return (GDK_CROSSING_UNGRAB == aEvent->mode) &&
+         ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
+          (GDK_NOTIFY_VIRTUAL == aEvent->detail));
+}
+
+static int is_parent_grab_leave(GdkEventCrossing* aEvent) {
+  return (GDK_CROSSING_GRAB == aEvent->mode) &&
+         ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
+          (GDK_NOTIFY_VIRTUAL == aEvent->detail));
+}
+
+#ifdef ACCESSIBILITY
+void nsWindow::CreateRootAccessible() {
+  if (!mRootAccessible) {
+    LOG("nsWindow:: Create Toplevel Accessibility\n");
+    mRootAccessible = GetRootAccessible();
+  }
+}
+
+void nsWindow::DispatchEventToRootAccessible(uint32_t aEventType) {
+  if (!a11y::ShouldA11yBeEnabled()) {
+    return;
+  }
+
+  nsAccessibilityService* accService = GetOrCreateAccService();
+  if (!accService) {
+    return;
+  }
+
+  // Get the root document accessible and fire event to it.
+  a11y::LocalAccessible* acc = GetRootAccessible();
+  if (acc) {
+    accService->FireAccessibleEvent(aEventType, acc);
+  }
+}
+
+void nsWindow::DispatchActivateEventAccessible(void) {
+  DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_ACTIVATE);
+}
+
+void nsWindow::DispatchDeactivateEventAccessible(void) {
+  DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_DEACTIVATE);
+}
+
+void nsWindow::DispatchMaximizeEventAccessible(void) {
+  DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_MAXIMIZE);
+}
+
+void nsWindow::DispatchMinimizeEventAccessible(void) {
+  DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_MINIMIZE);
+}
+
+void nsWindow::DispatchRestoreEventAccessible(void) {
+  DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_RESTORE);
+}
+
+#endif /* #ifdef ACCESSIBILITY */
+
+void nsWindow::SetInputContext(const InputContext& aContext,
+                               const InputContextAction& aAction) {
+  if (!mIMContext) {
+    return;
+  }
+  mIMContext->SetInputContext(this, &aContext, &aAction);
+}
+
+InputContext nsWindow::GetInputContext() {
+  InputContext context;
+  if (!mIMContext) {
+    context.mIMEState.mEnabled = IMEEnabled::Disabled;
+    context.mIMEState.mOpen = IMEState::OPEN_STATE_NOT_SUPPORTED;
+  } else {
+    context = mIMContext->GetInputContext();
+  }
+  return context;
+}
+
+TextEventDispatcherListener* nsWindow::GetNativeTextEventDispatcherListener() {
+  if (NS_WARN_IF(!mIMContext)) {
+    return nullptr;
+  }
+  return mIMContext;
+}
+
+bool nsWindow::GetEditCommands(NativeKeyBindingsType aType,
+                               const WidgetKeyboardEvent& aEvent,
+                               nsTArray<CommandInt>& aCommands) {
+  // Validate the arguments.
+  if (NS_WARN_IF(!nsIWidget::GetEditCommands(aType, aEvent, aCommands))) {
+    return false;
+  }
+
+  Maybe<WritingMode> writingMode;
+  if (aEvent.NeedsToRemapNavigationKey()) {
+    if (RefPtr<TextEventDispatcher> dispatcher = GetTextEventDispatcher()) {
+      writingMode = dispatcher->MaybeQueryWritingModeAtSelection();
+    }
+  }
+
+  NativeKeyBindings* keyBindings = NativeKeyBindings::GetInstance(aType);
+  keyBindings->GetEditCommands(aEvent, writingMode, aCommands);
+  return true;
+}
+
+already_AddRefed<DrawTarget> nsWindow::StartRemoteDrawingInRegion(
+    const LayoutDeviceIntRegion& aInvalidRegion, BufferMode* aBufferMode) {
+  return mSurfaceProvider.StartRemoteDrawingInRegion(aInvalidRegion,
+                                                     aBufferMode);
+}
+
+void nsWindow::EndRemoteDrawingInRegion(
+    DrawTarget* aDrawTarget, const LayoutDeviceIntRegion& aInvalidRegion) {
+  mSurfaceProvider.EndRemoteDrawingInRegion(aDrawTarget, aInvalidRegion);
+}
+
+// Code shared begin BeginMoveDrag and BeginResizeDrag
+bool nsWindow::GetDragInfo(WidgetMouseEvent* aMouseEvent, GdkWindow** aWindow,
+                           gint* aButton, gint* aRootX, gint* aRootY) {
+  if (aMouseEvent->mButton != MouseButton::ePrimary) {
+    // we can only begin a move drag with the left mouse button
+    return false;
+  }
+  *aButton = 1;
+
+  // get the gdk window for this widget
+  GdkWindow* gdk_window = mGdkWindow;
+  if (!gdk_window) {
+    return false;
+  }
+#ifdef DEBUG
+  // GDK_IS_WINDOW(...) expands to a statement-expression, and
+  // statement-expressions are not allowed in template-argument lists. So we
+  // have to make the MOZ_ASSERT condition indirect.
+  if (!GDK_IS_WINDOW(gdk_window)) {
+    MOZ_ASSERT(false, "must really be window");
+  }
+#endif
+
+  // find the top-level window
+  gdk_window = gdk_window_get_toplevel(gdk_window);
+  MOZ_ASSERT(gdk_window, "gdk_window_get_toplevel should not return null");
+  *aWindow = gdk_window;
+
+  if (!aMouseEvent->mWidget) {
+    return false;
+  }
+
+#ifdef MOZ_X11
+  if (GdkIsX11Display()) {
+    // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
+    // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
+    // See _should_perform_ewmh_drag() at gdkwindow-x11.c
+    GdkScreen* screen = gdk_window_get_screen(gdk_window);
+    GdkAtom atom = gdk_atom_intern("_NET_WM_MOVERESIZE", FALSE);
+    if (!gdk_x11_screen_supports_net_wm_hint(screen, atom)) {
+      static unsigned int lastTimeStamp = 0;
+      if (lastTimeStamp != aMouseEvent->mTime) {
+        lastTimeStamp = aMouseEvent->mTime;
+      } else {
+        return false;
+      }
+    }
+  }
+#endif
+
+  // FIXME: It would be nice to have the widget position at the time
+  // of the event, but it's relatively unlikely that the widget has
+  // moved since the mousedown.  (On the other hand, it's quite likely
+  // that the mouse has moved, which is why we use the mouse position
+  // from the event.)
+  LayoutDeviceIntPoint offset = aMouseEvent->mWidget->WidgetToScreenOffset();
+  *aRootX = aMouseEvent->mRefPoint.x + offset.x;
+  *aRootY = aMouseEvent->mRefPoint.y + offset.y;
+
+  return true;
+}
+
+nsresult nsWindow::BeginResizeDrag(WidgetGUIEvent* aEvent, int32_t aHorizontal,
+                                   int32_t aVertical) {
+  NS_ENSURE_ARG_POINTER(aEvent);
+
+  if (aEvent->mClass != eMouseEventClass) {
+    // you can only begin a resize drag with a mouse event
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  GdkWindow* gdk_window;
+  gint button, screenX, screenY;
+  if (!GetDragInfo(aEvent->AsMouseEvent(), &gdk_window, &button, &screenX,
+                   &screenY)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  // work out what GdkWindowEdge we're talking about
+  GdkWindowEdge window_edge;
+  if (aVertical < 0) {
+    if (aHorizontal < 0) {
+      window_edge = GDK_WINDOW_EDGE_NORTH_WEST;
+    } else if (aHorizontal == 0) {
+      window_edge = GDK_WINDOW_EDGE_NORTH;
+    } else {
+      window_edge = GDK_WINDOW_EDGE_NORTH_EAST;
+    }
+  } else if (aVertical == 0) {
+    if (aHorizontal < 0) {
+      window_edge = GDK_WINDOW_EDGE_WEST;
+    } else if (aHorizontal == 0) {
+      return NS_ERROR_INVALID_ARG;
+    } else {
+      window_edge = GDK_WINDOW_EDGE_EAST;
+    }
+  } else {
+    if (aHorizontal < 0) {
+      window_edge = GDK_WINDOW_EDGE_SOUTH_WEST;
+    } else if (aHorizontal == 0) {
+      window_edge = GDK_WINDOW_EDGE_SOUTH;
+    } else {
+      window_edge = GDK_WINDOW_EDGE_SOUTH_EAST;
+    }
+  }
+
+  // tell the window manager to start the resize
+  gdk_window_begin_resize_drag(gdk_window, window_edge, button, screenX,
+                               screenY, aEvent->mTime);
+
+  return NS_OK;
+}
+
+nsIWidget::WindowRenderer* nsWindow::GetWindowRenderer() {
+  if (mIsDestroyed) {
+    // Prevent external code from triggering the re-creation of the
+    // LayerManager/Compositor during shutdown. Just return what we currently
+    // have, which is most likely null.
+    return mWindowRenderer;
+  }
+
+  return nsBaseWidget::GetWindowRenderer();
+}
+
+void nsWindow::DidGetNonBlankPaint() {
+  if (mGotNonBlankPaint) {
+    return;
+  }
+  mGotNonBlankPaint = true;
+  if (!mConfiguredClearColor) {
+    // Nothing to do, we hadn't overridden the clear color.
+    mConfiguredClearColor = true;
+    return;
+  }
+  // Reset the clear color set in the expose event to transparent.
+  GetWindowRenderer()->AsWebRender()->WrBridge()->SendSetDefaultClearColor(
+      NS_TRANSPARENT);
+}
+
+/* nsWindow::SetCompositorWidgetDelegate() sets remote GtkCompositorWidget
+ * to render into with compositor.
+ *
+ * If we're already visible we need to recreate compositor/vsync state.
+ */
+void nsWindow::SetCompositorWidgetDelegate(CompositorWidgetDelegate* delegate) {
+  LOG("nsWindow::SetCompositorWidgetDelegate %p\n", delegate);
+
+  // There's a change of remote widget - stop compositor and VSync as
+  // we're going re-init it.
+  if (mCompositorWidgetDelegate && mIsMapped) {
+    DisableRenderingToWindow();
+  }
+
+  if (delegate) {
+    mCompositorWidgetDelegate = delegate->AsPlatformSpecificDelegate();
+    MOZ_ASSERT(mCompositorWidgetDelegate,
+               "nsWindow::SetCompositorWidgetDelegate called with a "
+               "non-PlatformCompositorWidgetDelegate");
+    // This is called from nsBaseWidget::CreateCompositor() in which case
+    // we need to create a new EGL surface in RenderCompositorEGL on X11
+    if (mIsMapped) {
+      EnableRenderingToWindow();
+    }
+  } else {
+    mCompositorWidgetDelegate = nullptr;
+  }
+}
+
+/* nsWindow::UpdateClientOffsetFromCSDWindow() is designed to be called from
+ * nsWindow::OnConfigureEvent() when mContainer window is already positioned.
+ *
+ * It works only for CSD decorated GtkWindow.
+ */
+void nsWindow::UpdateClientOffsetFromCSDWindow() {
+  int x = 0, y = 0;
+
+  if (mGdkWindow) {
+    gdk_window_get_position(mGdkWindow, &x, &y);
+  }
+
+  x = GdkCoordToDevicePixels(x);
+  y = GdkCoordToDevicePixels(y);
+
+  if (mClientOffset.x != x || mClientOffset.y != y) {
+    mClientOffset = nsIntPoint(x, y);
+
+    LOG("nsWindow::UpdateClientOffsetFromCSDWindow %d, %d\n", mClientOffset.x,
+        mClientOffset.y);
+
+    // Send a WindowMoved notification. This ensures that BrowserParent
+    // picks up the new client offset and sends it to the child process
+    // if appropriate.
+    NotifyWindowMoved(mBounds.x, mBounds.y);
+  }
+}
+
+nsresult nsWindow::SetNonClientMargins(LayoutDeviceIntMargin& aMargins) {
+  SetDrawsInTitlebar(aMargins.top == 0);
+  return NS_OK;
+}
+
+void nsWindow::SetDrawsInTitlebar(bool aState) {
+  LOG("nsWindow::SetDrawsInTitlebar() State %d mGtkWindowDecoration %d\n",
+      aState, (int)mGtkWindowDecoration);
+
+  if (mGtkWindowDecoration == GTK_DECORATION_NONE ||
+      aState == mDrawInTitlebar) {
+    LOG("  already set, quit");
+    return;
+  }
+
+  if (mIsPIPWindow) {
+    gtk_window_set_decorated(GTK_WINDOW(mShell), !aState);
+    LOG("  set decoration for PIP %d", aState);
+    return;
+  }
+
+  if (mGtkWindowDecoration == GTK_DECORATION_SYSTEM) {
+    SetWindowDecoration(aState ? eBorderStyle_border : mBorderStyle);
+  } else if (mGtkWindowDecoration == GTK_DECORATION_CLIENT) {
+    LOG("    Using CSD mode\n");
+
+    /* Window manager does not support GDK_DECOR_BORDER,
+     * emulate it by CSD.
+     *
+     * gtk_window_set_titlebar() works on unrealized widgets only,
+     * we need to handle mShell carefully here.
+     * When CSD is enabled mGdkWindow is owned by mContainer which is good
+     * as we can't delete our mGdkWindow. To make mShell unrealized while
+     * mContainer is preserved we temporary reparent mContainer to an
+     * invisible GtkWindow.
+     */
+    bool visible = !mNeedsShow && mIsShown;
+    if (visible) {
+      NativeShow(false);
+    }
+
+    // Using GTK_WINDOW_POPUP rather than
+    // GTK_WINDOW_TOPLEVEL in the hope that POPUP results in less
+    // initialization and window manager interaction.
+    GtkWidget* tmpWindow = gtk_window_new(GTK_WINDOW_POPUP);
+    gtk_widget_realize(tmpWindow);
+
+    gtk_widget_reparent(GTK_WIDGET(mContainer), tmpWindow);
+    gtk_widget_unrealize(GTK_WIDGET(mShell));
+
+    if (aState) {
+      // Add a hidden titlebar widget to trigger CSD, but disable the default
+      // titlebar.  GtkFixed is a somewhat random choice for a simple unused
+      // widget. gtk_window_set_titlebar() takes ownership of the titlebar
+      // widget.
+      gtk_window_set_titlebar(GTK_WINDOW(mShell), gtk_fixed_new());
+    } else {
+      gtk_window_set_titlebar(GTK_WINDOW(mShell), nullptr);
+    }
+
+    /* A workaround for https://bugzilla.gnome.org/show_bug.cgi?id=791081
+     * gtk_widget_realize() throws:
+     * "In pixman_region32_init_rect: Invalid rectangle passed"
+     * when mShell has default 1x1 size.
+     */
+    GtkAllocation allocation = {0, 0, 0, 0};
+    gtk_widget_get_preferred_width(GTK_WIDGET(mShell), nullptr,
+                                   &allocation.width);
+    gtk_widget_get_preferred_height(GTK_WIDGET(mShell), nullptr,
+                                    &allocation.height);
+    gtk_widget_size_allocate(GTK_WIDGET(mShell), &allocation);
+
+    gtk_widget_realize(GTK_WIDGET(mShell));
+    gtk_widget_reparent(GTK_WIDGET(mContainer), GTK_WIDGET(mShell));
+
+    // Label mShell toplevel window so property_notify_event_cb callback
+    // can find its way home.
+    g_object_set_data(G_OBJECT(gtk_widget_get_window(mShell)), "nsWindow",
+                      this);
+
+    if (AreBoundsSane()) {
+      GdkRectangle size = DevicePixelsToGdkSizeRoundUp(mBounds.Size());
+      LOG("    resize to %d x %d\n", size.width, size.height);
+      gtk_window_resize(GTK_WINDOW(mShell), size.width, size.height);
+    }
+
+    if (visible) {
+      mNeedsShow = true;
+      NativeShow(true);
+    }
+
+    gtk_widget_destroy(tmpWindow);
+  }
+
+  mDrawInTitlebar = aState;
+
+  if (mTransparencyBitmapForTitlebar) {
+    if (mDrawInTitlebar && mSizeState == nsSizeMode_Normal && !mIsTiled) {
+      UpdateTitlebarTransparencyBitmap();
+    } else {
+      ClearTransparencyBitmap();
+    }
+  }
+}
+
+GtkWindow* nsWindow::GetCurrentTopmostWindow() {
+  GtkWindow* parentWindow = GTK_WINDOW(GetGtkWidget());
+  GtkWindow* topmostParentWindow = nullptr;
+  while (parentWindow) {
+    topmostParentWindow = parentWindow;
+    parentWindow = gtk_window_get_transient_for(parentWindow);
+  }
+  return topmostParentWindow;
+}
+
+gint nsWindow::GdkCeiledScaleFactor() {
+  // We depend on notify::scale-factor callback which is reliable for toplevel
+  // windows only, so don't use scale cache for popup windows.
+  if (mWindowType == eWindowType_toplevel && !mWindowScaleFactorChanged) {
+    return mWindowScaleFactor;
+  }
+
+  GdkWindow* scaledGdkWindow = nullptr;
+  if (GdkIsWaylandDisplay()) {
+    // For popup windows/dialogs with parent window we need to get scale factor
+    // of the topmost window. Otherwise the scale factor of the popup is
+    // not updated during it's hidden.
+    if (mWindowType == eWindowType_popup || mWindowType == eWindowType_dialog) {
+      // Get toplevel window for scale factor:
+      GtkWindow* topmostParentWindow = GetCurrentTopmostWindow();
+      if (topmostParentWindow) {
+        scaledGdkWindow =
+            gtk_widget_get_window(GTK_WIDGET(topmostParentWindow));
+      } else {
+        NS_WARNING("Popup/Dialog has no parent.");
+      }
+    }
+  }
+  // Fallback for windows which parent has been unrealized.
+  if (!scaledGdkWindow) {
+    scaledGdkWindow = mGdkWindow;
+  }
+  if (scaledGdkWindow) {
+    mWindowScaleFactor = gdk_window_get_scale_factor(scaledGdkWindow);
+    mWindowScaleFactorChanged = false;
+  } else {
+    mWindowScaleFactor = ScreenHelperGTK::GetGTKMonitorScaleFactor();
+  }
+  return mWindowScaleFactor;
+}
+
+bool nsWindow::UseFractionalScale() {
+#ifdef MOZ_WAYLAND
+  return (GdkIsWaylandDisplay() &&
+          StaticPrefs::widget_wayland_fractional_buffer_scale_AtStartup() > 0 &&
+          WaylandDisplayGet()->GetViewporter());
+#else
+  return false;
+#endif
+}
+
+double nsWindow::FractionalScaleFactor() {
+#ifdef MOZ_WAYLAND
+  if (UseFractionalScale()) {
+    double scale =
+        StaticPrefs::widget_wayland_fractional_buffer_scale_AtStartup();
+    scale = std::max(scale, 0.5);
+    scale = std::min(scale, 8.0);
+    return scale;
+  }
+#endif
+  return GdkCeiledScaleFactor();
+}
+
+gint nsWindow::DevicePixelsToGdkCoordRoundUp(int pixels) {
+  double scale = FractionalScaleFactor();
+  return ceil(pixels / scale);
+}
+
+gint nsWindow::DevicePixelsToGdkCoordRoundDown(int pixels) {
+  double scale = FractionalScaleFactor();
+  return floor(pixels / scale);
+}
+
+GdkPoint nsWindow::DevicePixelsToGdkPointRoundDown(LayoutDeviceIntPoint point) {
+  double scale = FractionalScaleFactor();
+  return {int(point.x / scale), int(point.y / scale)};
+}
+
+GdkRectangle nsWindow::DevicePixelsToGdkRectRoundOut(LayoutDeviceIntRect rect) {
+  double scale = FractionalScaleFactor();
+  int x = floor(rect.x / scale);
+  int y = floor(rect.y / scale);
+  int right = ceil((rect.x + rect.width) / scale);
+  int bottom = ceil((rect.y + rect.height) / scale);
+  return {x, y, right - x, bottom - y};
+}
+
+GdkRectangle nsWindow::DevicePixelsToGdkSizeRoundUp(
+    LayoutDeviceIntSize pixelSize) {
+  double scale = FractionalScaleFactor();
+  gint width = ceil(pixelSize.width / scale);
+  gint height = ceil(pixelSize.height / scale);
+  return {0, 0, width, height};
+}
+
+int nsWindow::GdkCoordToDevicePixels(gint coord) {
+  return (int)(coord * FractionalScaleFactor());
+}
+
+LayoutDeviceIntPoint nsWindow::GdkEventCoordsToDevicePixels(gdouble x,
+                                                            gdouble y) {
+  double scale = FractionalScaleFactor();
+  return LayoutDeviceIntPoint::Floor((float)(x * scale), (float)(y * scale));
+}
+
+LayoutDeviceIntPoint nsWindow::GdkPointToDevicePixels(GdkPoint point) {
+  double scale = FractionalScaleFactor();
+  return LayoutDeviceIntPoint::Floor((float)(point.x * scale),
+                                     (float)(point.y * scale));
+}
+
+LayoutDeviceIntRect nsWindow::GdkRectToDevicePixels(GdkRectangle rect) {
+  double scale = FractionalScaleFactor();
+  return LayoutDeviceIntRect::RoundIn(
+      (float)(rect.x * scale), (float)(rect.y * scale),
+      (float)(rect.width * scale), (float)(rect.height * scale));
+}
+
+nsresult nsWindow::SynthesizeNativeMouseEvent(
+    LayoutDeviceIntPoint aPoint, NativeMouseMessage aNativeMessage,
+    MouseButton aButton, nsIWidget::Modifiers aModifierFlags,
+    nsIObserver* aObserver) {
+  AutoObserverNotifier notifier(aObserver, "mouseevent");
+
+  if (!mGdkWindow) {
+    return NS_OK;
+  }
+
+  // When a button-press/release event is requested, create it here and put it
+  // in the event queue. This will not emit a motion event - this needs to be
+  // done explicitly *before* requesting a button-press/release. You will also
+  // need to wait for the motion event to be dispatched before requesting a
+  // button-press/release event to maintain the desired event order.
+  switch (aNativeMessage) {
+    case NativeMouseMessage::ButtonDown:
+    case NativeMouseMessage::ButtonUp: {
+      GdkEvent event;
+      memset(&event, 0, sizeof(GdkEvent));
+      event.type = aNativeMessage == NativeMouseMessage::ButtonDown
+                       ? GDK_BUTTON_PRESS
+                       : GDK_BUTTON_RELEASE;
+      switch (aButton) {
+        case MouseButton::ePrimary:
+        case MouseButton::eMiddle:
+        case MouseButton::eSecondary:
+        case MouseButton::eX1:
+        case MouseButton::eX2:
+          event.button.button = aButton + 1;
+          break;
+        default:
+          return NS_ERROR_INVALID_ARG;
+      }
+      event.button.state =
+          KeymapWrapper::ConvertWidgetModifierToGdkState(aModifierFlags);
+      event.button.window = mGdkWindow;
+      event.button.time = GDK_CURRENT_TIME;
+
+      // Get device for event source
+      event.button.device = GdkGetPointer();
+
+      event.button.x_root = DevicePixelsToGdkCoordRoundDown(aPoint.x);
+      event.button.y_root = DevicePixelsToGdkCoordRoundDown(aPoint.y);
+
+      LayoutDeviceIntPoint pointInWindow = aPoint - WidgetToScreenOffset();
+      event.button.x = DevicePixelsToGdkCoordRoundDown(pointInWindow.x);
+      event.button.y = DevicePixelsToGdkCoordRoundDown(pointInWindow.y);
+
+      gdk_event_put(&event);
+      return NS_OK;
+    }
+    case NativeMouseMessage::Move: {
+      // We don't support specific events other than button-press/release. In
+      // all other cases we'll synthesize a motion event that will be emitted by
+      // gdk_display_warp_pointer().
+      // XXX How to activate native modifier for the other events?
+#ifdef MOZ_WAYLAND
+      // Impossible to warp the pointer on Wayland.
+      // For pointer lock, pointer-constraints and relative-pointer are used.
+      if (GdkIsWaylandDisplay()) {
+        return NS_OK;
+      }
+#endif
+      GdkScreen* screen = gdk_window_get_screen(mGdkWindow);
+      GdkPoint point = DevicePixelsToGdkPointRoundDown(aPoint);
+      gdk_device_warp(GdkGetPointer(), screen, point.x, point.y);
+      return NS_OK;
+    }
+    case NativeMouseMessage::EnterWindow:
+    case NativeMouseMessage::LeaveWindow:
+      MOZ_ASSERT_UNREACHABLE("Non supported mouse event on Linux");
+      return NS_ERROR_INVALID_ARG;
+  }
+  return NS_ERROR_UNEXPECTED;
+}
+
+nsresult nsWindow::SynthesizeNativeMouseScrollEvent(
+    mozilla::LayoutDeviceIntPoint aPoint, uint32_t aNativeMessage,
+    double aDeltaX, double aDeltaY, double aDeltaZ, uint32_t aModifierFlags,
+    uint32_t aAdditionalFlags, nsIObserver* aObserver) {
+  AutoObserverNotifier notifier(aObserver, "mousescrollevent");
+
+  if (!mGdkWindow) {
+    return NS_OK;
+  }
+
+  GdkEvent event;
+  memset(&event, 0, sizeof(GdkEvent));
+  event.type = GDK_SCROLL;
+  event.scroll.window = mGdkWindow;
+  event.scroll.time = GDK_CURRENT_TIME;
+  // Get device for event source
+  GdkDisplay* display = gdk_window_get_display(mGdkWindow);
+  GdkDeviceManager* device_manager = gdk_display_get_device_manager(display);
+  event.scroll.device = gdk_device_manager_get_client_pointer(device_manager);
+  event.scroll.x_root = DevicePixelsToGdkCoordRoundDown(aPoint.x);
+  event.scroll.y_root = DevicePixelsToGdkCoordRoundDown(aPoint.y);
+
+  LayoutDeviceIntPoint pointInWindow = aPoint - WidgetToScreenOffset();
+  event.scroll.x = DevicePixelsToGdkCoordRoundDown(pointInWindow.x);
+  event.scroll.y = DevicePixelsToGdkCoordRoundDown(pointInWindow.y);
+
+  // The delta values are backwards on Linux compared to Windows and Cocoa,
+  // hence the negation.
+  event.scroll.direction = GDK_SCROLL_SMOOTH;
+  event.scroll.delta_x = -aDeltaX;
+  event.scroll.delta_y = -aDeltaY;
+
+  gdk_event_put(&event);
+
+  return NS_OK;
+}
+
+nsresult nsWindow::SynthesizeNativeTouchPoint(uint32_t aPointerId,
+                                              TouchPointerState aPointerState,
+                                              LayoutDeviceIntPoint aPoint,
+                                              double aPointerPressure,
+                                              uint32_t aPointerOrientation,
+                                              nsIObserver* aObserver) {
+  AutoObserverNotifier notifier(aObserver, "touchpoint");
+
+  if (!mGdkWindow) {
+    return NS_OK;
+  }
+
+  GdkEvent event;
+  memset(&event, 0, sizeof(GdkEvent));
+
+  static std::map<uint32_t, GdkEventSequence*> sKnownPointers;
+
+  auto result = sKnownPointers.find(aPointerId);
+  switch (aPointerState) {
+    case TOUCH_CONTACT:
+      if (result == sKnownPointers.end()) {
+        // GdkEventSequence isn't a thing we can instantiate, and never gets
+        // dereferenced in the gtk code. It's an opaque pointer, the only
+        // requirement is that it be distinct from other instances of
+        // GdkEventSequence*.
+        event.touch.sequence = (GdkEventSequence*)((uintptr_t)aPointerId);
+        sKnownPointers[aPointerId] = event.touch.sequence;
+        event.type = GDK_TOUCH_BEGIN;
+      } else {
+        event.touch.sequence = result->second;
+        event.type = GDK_TOUCH_UPDATE;
+      }
+      break;
+    case TOUCH_REMOVE:
+      event.type = GDK_TOUCH_END;
+      if (result == sKnownPointers.end()) {
+        NS_WARNING("Tried to synthesize touch-end for unknown pointer!");
+        return NS_ERROR_UNEXPECTED;
+      }
+      event.touch.sequence = result->second;
+      sKnownPointers.erase(result);
+      break;
+    case TOUCH_CANCEL:
+      event.type = GDK_TOUCH_CANCEL;
+      if (result == sKnownPointers.end()) {
+        NS_WARNING("Tried to synthesize touch-cancel for unknown pointer!");
+        return NS_ERROR_UNEXPECTED;
+      }
+      event.touch.sequence = result->second;
+      sKnownPointers.erase(result);
+      break;
+    case TOUCH_HOVER:
+    default:
+      return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  event.touch.window = mGdkWindow;
+  event.touch.time = GDK_CURRENT_TIME;
+
+  GdkDisplay* display = gdk_window_get_display(mGdkWindow);
+  GdkDeviceManager* device_manager = gdk_display_get_device_manager(display);
+  event.touch.device = gdk_device_manager_get_client_pointer(device_manager);
+
+  event.touch.x_root = DevicePixelsToGdkCoordRoundDown(aPoint.x);
+  event.touch.y_root = DevicePixelsToGdkCoordRoundDown(aPoint.y);
+
+  LayoutDeviceIntPoint pointInWindow = aPoint - WidgetToScreenOffset();
+  event.touch.x = DevicePixelsToGdkCoordRoundDown(pointInWindow.x);
+  event.touch.y = DevicePixelsToGdkCoordRoundDown(pointInWindow.y);
+
+  gdk_event_put(&event);
+
+  return NS_OK;
+}
+
+nsresult nsWindow::SynthesizeNativeTouchPadPinch(
+    TouchpadGesturePhase aEventPhase, float aScale, LayoutDeviceIntPoint aPoint,
+    int32_t aModifierFlags) {
+  if (!mGdkWindow) {
+    return NS_OK;
+  }
+  GdkEvent event;
+  memset(&event, 0, sizeof(GdkEvent));
+
+  GdkEventTouchpadPinch* touchpad_event =
+      reinterpret_cast<GdkEventTouchpadPinch*>(&event);
+  touchpad_event->type = GDK_TOUCHPAD_PINCH;
+
+  switch (aEventPhase) {
+    case PHASE_BEGIN:
+      touchpad_event->phase = GDK_TOUCHPAD_GESTURE_PHASE_BEGIN;
+      break;
+    case PHASE_UPDATE:
+      touchpad_event->phase = GDK_TOUCHPAD_GESTURE_PHASE_UPDATE;
+      break;
+    case PHASE_END:
+      touchpad_event->phase = GDK_TOUCHPAD_GESTURE_PHASE_END;
+      break;
+
+    default:
+      return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  touchpad_event->window = mGdkWindow;
+  // We only set the fields of GdkEventTouchpadPinch which are
+  // actually used in OnTouchpadPinchEvent().
+  // GdkEventTouchpadPinch has additional fields (for example, `dx` and `dy`).
+  // If OnTouchpadPinchEvent() is changed to use other fields, this function
+  // will need to change to set them as well.
+  touchpad_event->time = GDK_CURRENT_TIME;
+  touchpad_event->scale = aScale;
+  touchpad_event->x_root = DevicePixelsToGdkCoordRoundDown(aPoint.x);
+  touchpad_event->y_root = DevicePixelsToGdkCoordRoundDown(aPoint.y);
+
+  LayoutDeviceIntPoint pointInWindow = aPoint - WidgetToScreenOffset();
+  touchpad_event->x = DevicePixelsToGdkCoordRoundDown(pointInWindow.x);
+  touchpad_event->y = DevicePixelsToGdkCoordRoundDown(pointInWindow.y);
+  touchpad_event->state = aModifierFlags;
+
+  gdk_event_put(&event);
+
+  return NS_OK;
+}
+
+nsWindow::GtkWindowDecoration nsWindow::GetSystemGtkWindowDecoration() {
+  static GtkWindowDecoration sGtkWindowDecoration = [] {
+    // Allow MOZ_GTK_TITLEBAR_DECORATION to override our heuristics
+    if (const char* decorationOverride =
+            getenv("MOZ_GTK_TITLEBAR_DECORATION")) {
+      if (strcmp(decorationOverride, "none") == 0) {
+        return GTK_DECORATION_NONE;
+      }
+      if (strcmp(decorationOverride, "client") == 0) {
+        return GTK_DECORATION_CLIENT;
+      }
+      if (strcmp(decorationOverride, "system") == 0) {
+        return GTK_DECORATION_SYSTEM;
+      }
+    }
+
+    // nsWindow::GetSystemGtkWindowDecoration can be called from various
+    // threads so we can't use gfxPlatformGtk here.
+    if (GdkIsWaylandDisplay()) {
+      return GTK_DECORATION_CLIENT;
+    }
+
+    // GTK_CSD forces CSD mode - use also CSD because window manager
+    // decorations does not work with CSD.
+    // We check GTK_CSD as well as gtk_window_should_use_csd() does.
+    const char* csdOverride = getenv("GTK_CSD");
+    if (csdOverride && *csdOverride == '1') {
+      return GTK_DECORATION_CLIENT;
+    }
+
+    const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
+    if (!currentDesktop) {
+      return GTK_DECORATION_NONE;
+    }
+    if (strstr(currentDesktop, "i3")) {
+      return GTK_DECORATION_NONE;
+    }
+
+    // Tested desktops: pop:GNOME, KDE, Enlightenment, LXDE, openbox, MATE,
+    // X-Cinnamon, Pantheon, Deepin, GNOME, LXQt, Unity.
+    return GTK_DECORATION_CLIENT;
+  }();
+  return sGtkWindowDecoration;
+}
+
+bool nsWindow::TitlebarUseShapeMask() {
+  static int useShapeMask = []() {
+    // Don't use titlebar shape mask on Wayland
+    if (!GdkIsX11Display()) {
+      return false;
+    }
+
+    // We can't use shape masks on Mutter/X.org as we can't resize Firefox
+    // window there (Bug 1530252).
+    const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
+    if (currentDesktop) {
+      if (strstr(currentDesktop, "GNOME") != nullptr) {
+        const char* sessionType = getenv("XDG_SESSION_TYPE");
+        if (sessionType && strstr(sessionType, "x11") != nullptr) {
+          return false;
+        }
+      }
+    }
+
+    return Preferences::GetBool("widget.titlebar-x11-use-shape-mask", false);
+  }();
+  return useShapeMask;
+}
+
+int32_t nsWindow::RoundsWidgetCoordinatesTo() { return GdkCeiledScaleFactor(); }
+
+void nsWindow::GetCompositorWidgetInitData(
+    mozilla::widget::CompositorWidgetInitData* aInitData) {
+  nsCString displayName;
+
+  LOG("nsWindow::GetCompositorWidgetInitData");
+  EnsureGdkWindow();
+
+  *aInitData = mozilla::widget::GtkCompositorWidgetInitData(
+      GetX11Window(), displayName, GetShapedState(), GdkIsX11Display(),
+      GetClientSize());
+
+#ifdef MOZ_X11
+  if (GdkIsX11Display()) {
+    // Make sure the window XID is propagated to X server, we can fail otherwise
+    // in GPU process (Bug 1401634).
+    Display* display = DefaultXDisplay();
+    XFlush(display);
+    displayName = nsCString(XDisplayString(display));
+  }
+#endif
+}
+
+#ifdef MOZ_X11
+/* XApp progress support currently works by setting a property
+ * on a window with this Atom name.  A supporting window manager
+ * will notice this and pass it along to whatever handling has
+ * been implemented on that end (e.g. passing it on to a taskbar
+ * widget.)  There is no issue if WM support is lacking, this is
+ * simply ignored in that case.
+ *
+ * See https://github.com/linuxmint/xapps/blob/master/libxapp/xapp-gtk-window.c
+ * for further details.
+ */
+
+#  define PROGRESS_HINT "_NET_WM_XAPP_PROGRESS"
+
+static void set_window_hint_cardinal(Window xid, const gchar* atom_name,
+                                     gulong cardinal) {
+  GdkDisplay* display;
+
+  display = gdk_display_get_default();
+
+  if (cardinal > 0) {
+    XChangeProperty(GDK_DISPLAY_XDISPLAY(display), xid,
+                    gdk_x11_get_xatom_by_name_for_display(display, atom_name),
+                    XA_CARDINAL, 32, PropModeReplace, (guchar*)&cardinal, 1);
+  } else {
+    XDeleteProperty(GDK_DISPLAY_XDISPLAY(display), xid,
+                    gdk_x11_get_xatom_by_name_for_display(display, atom_name));
+  }
+}
+#endif  // MOZ_X11
+
+void nsWindow::SetProgress(unsigned long progressPercent) {
+#ifdef MOZ_X11
+
+  if (!GdkIsX11Display()) {
+    return;
+  }
+
+  if (!mShell) {
+    return;
+  }
+
+  progressPercent = MIN(progressPercent, 100);
+
+  set_window_hint_cardinal(GDK_WINDOW_XID(gtk_widget_get_window(mShell)),
+                           PROGRESS_HINT, progressPercent);
+#endif  // MOZ_X11
+}
+
+#ifdef MOZ_X11
+void nsWindow::SetCompositorHint(WindowComposeRequest aState) {
+  if (!GdkIsX11Display()) {
+    return;
+  }
+
+  gulong value = aState;
+  GdkAtom cardinal_atom = gdk_x11_xatom_to_atom(XA_CARDINAL);
+  gdk_property_change(gtk_widget_get_window(mShell),
+                      gdk_atom_intern("_NET_WM_BYPASS_COMPOSITOR", FALSE),
+                      cardinal_atom,
+                      32,  // format
+                      GDK_PROP_MODE_REPLACE, (guchar*)&value, 1);
+}
+#endif
+
+nsresult nsWindow::SetSystemFont(const nsCString& aFontName) {
+  GtkSettings* settings = gtk_settings_get_default();
+  g_object_set(settings, "gtk-font-name", aFontName.get(), nullptr);
+  return NS_OK;
+}
+
+nsresult nsWindow::GetSystemFont(nsCString& aFontName) {
+  GtkSettings* settings = gtk_settings_get_default();
+  gchar* fontName = nullptr;
+  g_object_get(settings, "gtk-font-name", &fontName, nullptr);
+  if (fontName) {
+    aFontName.Assign(fontName);
+    g_free(fontName);
+  }
+  return NS_OK;
+}
+
+already_AddRefed<nsIWidget> nsIWidget::CreateTopLevelWindow() {
+  nsCOMPtr<nsIWidget> window = new nsWindow();
+  return window.forget();
+}
+
+already_AddRefed<nsIWidget> nsIWidget::CreateChildWindow() {
+  nsCOMPtr<nsIWidget> window = new nsWindow();
+  return window.forget();
+}
+
+#ifdef MOZ_WAYLAND
+static void relative_pointer_handle_relative_motion(
+    void* data, struct zwp_relative_pointer_v1* pointer, uint32_t time_hi,
+    uint32_t time_lo, wl_fixed_t dx_w, wl_fixed_t dy_w, wl_fixed_t dx_unaccel_w,
+    wl_fixed_t dy_unaccel_w) {
+  RefPtr<nsWindow> window(reinterpret_cast<nsWindow*>(data));
+
+  WidgetMouseEvent event(true, eMouseMove, window, WidgetMouseEvent::eReal);
+
+  event.mRefPoint = window->GetNativePointerLockCenter();
+  event.mRefPoint.x += wl_fixed_to_int(dx_w);
+  event.mRefPoint.y += wl_fixed_to_int(dy_w);
+
+  event.AssignEventTime(window->GetWidgetEventTime(time_lo));
+  window->DispatchInputEvent(&event);
+}
+
+static const struct zwp_relative_pointer_v1_listener relative_pointer_listener =
+    {
+        relative_pointer_handle_relative_motion,
+};
+
+void nsWindow::SetNativePointerLockCenter(
+    const LayoutDeviceIntPoint& aLockCenter) {
+  mNativePointerLockCenter = aLockCenter;
+}
+
+void nsWindow::LockNativePointer() {
+  if (!GdkIsWaylandDisplay()) {
+    return;
+  }
+
+  auto waylandDisplay = WaylandDisplayGet();
+
+  auto* pointerConstraints = waylandDisplay->GetPointerConstraints();
+  if (!pointerConstraints) {
+    return;
+  }
+
+  auto* relativePointerMgr = waylandDisplay->GetRelativePointerManager();
+  if (!relativePointerMgr) {
+    return;
+  }
+
+  GdkDisplay* display = gdk_display_get_default();
+
+  GdkDeviceManager* manager = gdk_display_get_device_manager(display);
+  MOZ_ASSERT(manager);
+
+  GdkDevice* device = gdk_device_manager_get_client_pointer(manager);
+  if (!device) {
+    NS_WARNING("Could not find Wayland pointer to lock");
+    return;
+  }
+  wl_pointer* pointer = gdk_wayland_device_get_wl_pointer(device);
+  MOZ_ASSERT(pointer);
+
+  wl_surface* surface =
+      gdk_wayland_window_get_wl_surface(gtk_widget_get_window(GetGtkWidget()));
+  if (!surface) {
+    /* Can be null when the window is hidden.
+     * Though it's unlikely that a lock request comes in that case, be
+     * defensive. */
+    return;
+  }
+
+  mLockedPointer = zwp_pointer_constraints_v1_lock_pointer(
+      pointerConstraints, surface, pointer, nullptr,
+      ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+  if (!mLockedPointer) {
+    NS_WARNING("Could not lock Wayland pointer");
+    return;
+  }
+
+  mRelativePointer = zwp_relative_pointer_manager_v1_get_relative_pointer(
+      relativePointerMgr, pointer);
+  if (!mRelativePointer) {
+    NS_WARNING("Could not create relative Wayland pointer");
+    zwp_locked_pointer_v1_destroy(mLockedPointer);
+    mLockedPointer = nullptr;
+    return;
+  }
+
+  zwp_relative_pointer_v1_add_listener(mRelativePointer,
+                                       &relative_pointer_listener, this);
+}
+
+void nsWindow::UnlockNativePointer() {
+  if (!GdkIsWaylandDisplay()) {
+    return;
+  }
+  if (mRelativePointer) {
+    zwp_relative_pointer_v1_destroy(mRelativePointer);
+    mRelativePointer = nullptr;
+  }
+  if (mLockedPointer) {
+    zwp_locked_pointer_v1_destroy(mLockedPointer);
+    mLockedPointer = nullptr;
+  }
+}
+#endif
+
+bool nsWindow::GetTopLevelWindowActiveState(nsIFrame* aFrame) {
+  // Used by window frame and button box rendering. We can end up in here in
+  // the content process when rendering one of these moz styles freely in a
+  // page. Fail in this case, there is no applicable window focus state.
+  if (!XRE_IsParentProcess()) {
+    return false;
+  }
+  // All headless windows are considered active so they are painted.
+  if (gfxPlatform::IsHeadless()) {
+    return true;
+  }
+  // Get the widget. nsIFrame's GetNearestWidget walks up the view chain
+  // until it finds a real window.
+  nsWindow* window = static_cast<nsWindow*>(aFrame->GetNearestWidget());
+  if (!window) {
+    return false;
+  }
+  return !window->mTitlebarBackdropState;
+}
+
+static nsIFrame* FindTitlebarFrame(nsIFrame* aFrame) {
+  for (nsIFrame* childFrame : aFrame->PrincipalChildList()) {
+    StyleAppearance appearance =
+        childFrame->StyleDisplay()->EffectiveAppearance();
+    if (appearance == StyleAppearance::MozWindowTitlebar ||
+        appearance == StyleAppearance::MozWindowTitlebarMaximized) {
+      return childFrame;
+    }
+
+    if (nsIFrame* foundFrame = FindTitlebarFrame(childFrame)) {
+      return foundFrame;
+    }
+  }
+  return nullptr;
+}
+
+nsIFrame* nsWindow::GetFrame() const {
+  nsView* view = nsView::GetViewFor(this);
+  if (!view) {
+    return nullptr;
+  }
+  return view->GetFrame();
+}
+
+void nsWindow::UpdateMozWindowActive() {
+  // Update activation state for the :-moz-window-inactive pseudoclass.
+  // Normally, this follows focus; we override it here to follow
+  // GDK_WINDOW_STATE_FOCUSED.
+  if (mozilla::dom::Document* document = GetDocument()) {
+    if (nsPIDOMWindowOuter* window = document->GetWindow()) {
+      if (RefPtr<mozilla::dom::BrowsingContext> bc =
+              window->GetBrowsingContext()) {
+        bc->SetIsActiveBrowserWindow(!mTitlebarBackdropState);
+      }
+    }
+  }
+}
+
+void nsWindow::ForceTitlebarRedraw(void) {
+  MOZ_ASSERT(mDrawInTitlebar, "We should not redraw invisible titlebar.");
+
+  if (!mWidgetListener || !mWidgetListener->GetPresShell()) {
+    return;
+  }
+
+  nsIFrame* frame = GetFrame();
+  if (!frame) {
+    return;
+  }
+
+  frame = FindTitlebarFrame(frame);
+  if (frame) {
+    nsIContent* content = frame->GetContent();
+    if (content) {
+      nsLayoutUtils::PostRestyleEvent(content->AsElement(), RestyleHint{0},
+                                      nsChangeHint_RepaintFrame);
+    }
+  }
+}
+
+void nsWindow::LockAspectRatio(bool aShouldLock) {
+  if (!gUseAspectRatio) {
+    return;
+  }
+
+  if (aShouldLock) {
+    int decWidth = 0, decHeight = 0;
+    AddCSDDecorationSize(&decWidth, &decHeight);
+
+    float width =
+        (float)DevicePixelsToGdkCoordRoundDown(mBounds.width) + (float)decWidth;
+    float height = (float)DevicePixelsToGdkCoordRoundDown(mBounds.height) +
+                   (float)decHeight;
+
+    mAspectRatio = width / height;
+    LOG("nsWindow::LockAspectRatio() width %f height %f aspect %f", width,
+        height, mAspectRatio);
+  } else {
+    mAspectRatio = 0.0;
+    LOG("nsWindow::LockAspectRatio() removed aspect ratio");
+  }
+
+  ApplySizeConstraints();
+}
+
+nsWindow* nsWindow::GetFocusedWindow() { return gFocusWindow; }
+
+#ifdef MOZ_WAYLAND
+void nsWindow::SetEGLNativeWindowSize(
+    const LayoutDeviceIntSize& aEGLWindowSize) {
+  if (!mContainer || !GdkIsWaylandDisplay()) {
+    return;
+  }
+  moz_container_wayland_egl_window_set_size(mContainer, aEGLWindowSize.width,
+                                            aEGLWindowSize.height);
+  moz_container_wayland_set_scale_factor(mContainer);
+}
+#endif
+
+LayoutDeviceIntSize nsWindow::GetMozContainerSize() {
+  LayoutDeviceIntSize size(0, 0);
+  if (mContainer) {
+    GtkAllocation allocation;
+    gtk_widget_get_allocation(GTK_WIDGET(mContainer), &allocation);
+    double scale = FractionalScaleFactor();
+    size.width = round(allocation.width * scale);
+    size.height = round(allocation.height * scale);
+  }
+  return size;
+}
diff --git a/widget/gtk/nsWindow.h b/widget/gtk/nsWindow.h
index af2b633f7f..7b96166609 100644
--- a/widget/gtk/nsWindow.h
+++ b/widget/gtk/nsWindow.h
@@ -26,6 +26,8 @@
 #include "nsRefPtrHashtable.h"
 #include "IMContextWrapper.h"
 
+#include "nsMenuBar.h"
+
 #ifdef ACCESSIBILITY
 #  include "mozilla/a11y/LocalAccessible.h"
 #endif
@@ -191,6 +193,8 @@ class nsWindow final : public nsBaseWidget {
   nsresult MakeFullScreen(bool aFullScreen) override;
   void HideWindowChrome(bool aShouldHide) override;
 
+  void SetMenuBar(mozilla::UniquePtr<nsMenuBar> aMenuBar);
+
   /**
    * GetLastUserInputTime returns a timestamp for the most recent user input
    * event.  This is intended for pointer grab requests (including drags).
@@ -857,6 +861,8 @@ class nsWindow final : public nsBaseWidget {
 
   static bool sTransparentMainWindow;
 
+  mozilla::UniquePtr<nsMenuBar> mMenuBar;
+
 #ifdef ACCESSIBILITY
   RefPtr<mozilla::a11y::LocalAccessible> mRootAccessible;
 
diff --git a/widget/gtk/nsWindow.h.orig b/widget/gtk/nsWindow.h.orig
new file mode 100644
index 0000000000..af2b633f7f
--- /dev/null
+++ b/widget/gtk/nsWindow.h.orig
@@ -0,0 +1,923 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsWindow_h__
+#define __nsWindow_h__
+
+#include <gdk/gdk.h>
+#include <gtk/gtk.h>
+
+#include "CompositorWidget.h"
+#include "MozContainer.h"
+#include "mozilla/EventForwards.h"
+#include "mozilla/Maybe.h"
+#include "mozilla/RefPtr.h"
+#include "mozilla/TouchEvents.h"
+#include "mozilla/UniquePtr.h"
+#include "mozilla/widget/WindowSurface.h"
+#include "mozilla/widget/WindowSurfaceProvider.h"
+#include "nsBaseWidget.h"
+#include "nsGkAtoms.h"
+#include "nsIDragService.h"
+#include "nsRefPtrHashtable.h"
+#include "IMContextWrapper.h"
+
+#ifdef ACCESSIBILITY
+#  include "mozilla/a11y/LocalAccessible.h"
+#endif
+
+#ifdef MOZ_X11
+#  include <gdk/gdkx.h>
+#  include "X11UndefineNone.h"
+#endif
+#ifdef MOZ_WAYLAND
+#  include <gdk/gdkwayland.h>
+#  include "base/thread.h"
+#  include "WaylandVsyncSource.h"
+#  include "nsClipboardWayland.h"
+#endif
+
+#ifdef MOZ_LOGGING
+
+#  include "mozilla/Logging.h"
+#  include "nsTArray.h"
+#  include "Units.h"
+
+extern mozilla::LazyLogModule gWidgetLog;
+extern mozilla::LazyLogModule gWidgetDragLog;
+extern mozilla::LazyLogModule gWidgetPopupLog;
+extern mozilla::LazyLogModule gWidgetVsync;
+
+#  define LOG(str, ...)                               \
+    MOZ_LOG(IsPopup() ? gWidgetPopupLog : gWidgetLog, \
+            mozilla::LogLevel::Debug,                 \
+            ("%s: " str, GetDebugTag().get(), ##__VA_ARGS__))
+#  define LOGW(...) MOZ_LOG(gWidgetLog, mozilla::LogLevel::Debug, (__VA_ARGS__))
+#  define LOGDRAG(...) \
+    MOZ_LOG(gWidgetDragLog, mozilla::LogLevel::Debug, (__VA_ARGS__))
+#  define LOG_POPUP(...) \
+    MOZ_LOG(gWidgetPopupLog, mozilla::LogLevel::Debug, (__VA_ARGS__))
+#  define LOG_VSYNC(...) \
+    MOZ_LOG(gWidgetVsync, mozilla::LogLevel::Debug, (__VA_ARGS__))
+#  define LOG_ENABLED()                                         \
+    (MOZ_LOG_TEST(gWidgetPopupLog, mozilla::LogLevel::Debug) || \
+     MOZ_LOG_TEST(gWidgetLog, mozilla::LogLevel::Debug))
+
+#else
+
+#  define LOG(...)
+#  define LOGW(...)
+#  define LOGDRAG(...)
+#  define LOG_POPUP(...)
+#  define LOG_ENABLED() false
+
+#endif /* MOZ_LOGGING */
+
+#if defined(MOZ_WAYLAND) && !defined(MOZ_X11)
+typedef uintptr_t Window;
+#endif
+
+class gfxPattern;
+class nsIFrame;
+#if !GTK_CHECK_VERSION(3, 18, 0)
+struct _GdkEventTouchpadPinch;
+typedef struct _GdkEventTouchpadPinch GdkEventTouchpadPinch;
+#endif
+
+#if !GTK_CHECK_VERSION(3, 22, 0)
+typedef enum {
+  GDK_ANCHOR_FLIP_X = 1 << 0,
+  GDK_ANCHOR_FLIP_Y = 1 << 1,
+  GDK_ANCHOR_SLIDE_X = 1 << 2,
+  GDK_ANCHOR_SLIDE_Y = 1 << 3,
+  GDK_ANCHOR_RESIZE_X = 1 << 4,
+  GDK_ANCHOR_RESIZE_Y = 1 << 5,
+  GDK_ANCHOR_FLIP = GDK_ANCHOR_FLIP_X | GDK_ANCHOR_FLIP_Y,
+  GDK_ANCHOR_SLIDE = GDK_ANCHOR_SLIDE_X | GDK_ANCHOR_SLIDE_Y,
+  GDK_ANCHOR_RESIZE = GDK_ANCHOR_RESIZE_X | GDK_ANCHOR_RESIZE_Y
+} GdkAnchorHints;
+#endif
+
+namespace mozilla {
+enum class NativeKeyBindingsType : uint8_t;
+
+class TimeStamp;
+#ifdef MOZ_X11
+class CurrentX11TimeGetter;
+#endif
+}  // namespace mozilla
+
+class nsWindow final : public nsBaseWidget {
+ public:
+  typedef mozilla::gfx::DrawTarget DrawTarget;
+  typedef mozilla::WidgetEventTime WidgetEventTime;
+  typedef mozilla::WidgetKeyboardEvent WidgetKeyboardEvent;
+  typedef mozilla::widget::PlatformCompositorWidgetDelegate
+      PlatformCompositorWidgetDelegate;
+
+  nsWindow();
+
+  static void ReleaseGlobals();
+
+  NS_INLINE_DECL_REFCOUNTING_INHERITED(nsWindow, nsBaseWidget)
+
+  nsresult DispatchEvent(mozilla::WidgetGUIEvent* aEvent,
+                         nsEventStatus& aStatus) override;
+
+  // called when we are destroyed
+  void OnDestroy() override;
+
+  // called to check and see if a widget's dimensions are sane
+  bool AreBoundsSane(void);
+
+  // nsIWidget
+  using nsBaseWidget::Create;  // for Create signature not overridden here
+  [[nodiscard]] nsresult Create(nsIWidget* aParent,
+                                nsNativeWidget aNativeParent,
+                                const LayoutDeviceIntRect& aRect,
+                                nsWidgetInitData* aInitData) override;
+  void Destroy() override;
+  nsIWidget* GetParent() override;
+  float GetDPI() override;
+  double GetDefaultScaleInternal() override;
+  mozilla::DesktopToLayoutDeviceScale GetDesktopToDeviceScale() override;
+  mozilla::DesktopToLayoutDeviceScale GetDesktopToDeviceScaleByScreen()
+      override;
+  void SetParent(nsIWidget* aNewParent) override;
+  void SetModal(bool aModal) override;
+  bool IsVisible() const override;
+  void ConstrainPosition(bool aAllowSlop, int32_t* aX, int32_t* aY) override;
+  void SetSizeConstraints(const SizeConstraints& aConstraints) override;
+  void LockAspectRatio(bool aShouldLock) override;
+  void Move(double aX, double aY) override;
+  void Show(bool aState) override;
+  void Resize(double aWidth, double aHeight, bool aRepaint) override;
+  void Resize(double aX, double aY, double aWidth, double aHeight,
+              bool aRepaint) override;
+  bool IsEnabled() const override;
+
+  void SetZIndex(int32_t aZIndex) override;
+  void SetSizeMode(nsSizeMode aMode) override;
+  void GetWorkspaceID(nsAString& workspaceID) override;
+  void MoveToWorkspace(const nsAString& workspaceID) override;
+  void Enable(bool aState) override;
+  void SetFocus(Raise, mozilla::dom::CallerType aCallerType) override;
+  LayoutDeviceIntRect GetScreenBounds() override;
+  LayoutDeviceIntRect GetClientBounds() override;
+  LayoutDeviceIntSize GetClientSize() override;
+  LayoutDeviceIntPoint GetClientOffset() override;
+  void SetCursor(const Cursor&) override;
+  void Invalidate(const LayoutDeviceIntRect& aRect) override;
+  void* GetNativeData(uint32_t aDataType) override;
+  nsresult SetTitle(const nsAString& aTitle) override;
+  void SetIcon(const nsAString& aIconSpec) override;
+  void SetWindowClass(const nsAString& xulWinType) override;
+  LayoutDeviceIntPoint WidgetToScreenOffset() override;
+  void CaptureMouse(bool aCapture) override;
+  void CaptureRollupEvents(nsIRollupListener* aListener,
+                           bool aDoCapture) override;
+  [[nodiscard]] nsresult GetAttention(int32_t aCycleCount) override;
+  bool HasPendingInputEvent() override;
+
+  bool PrepareForFullscreenTransition(nsISupports** aData) override;
+  void PerformFullscreenTransition(FullscreenTransitionStage aStage,
+                                   uint16_t aDuration, nsISupports* aData,
+                                   nsIRunnable* aCallback) override;
+  already_AddRefed<nsIScreen> GetWidgetScreen() override;
+  nsresult MakeFullScreen(bool aFullScreen) override;
+  void HideWindowChrome(bool aShouldHide) override;
+
+  /**
+   * GetLastUserInputTime returns a timestamp for the most recent user input
+   * event.  This is intended for pointer grab requests (including drags).
+   */
+  static guint32 GetLastUserInputTime();
+
+  // utility method, -1 if no change should be made, otherwise returns a
+  // value that can be passed to gdk_window_set_decorations
+  gint ConvertBorderStyles(nsBorderStyle aStyle);
+
+  GdkRectangle DevicePixelsToGdkRectRoundOut(LayoutDeviceIntRect aRect);
+
+  mozilla::widget::IMContextWrapper* GetIMContext() const { return mIMContext; }
+
+  bool DispatchCommandEvent(nsAtom* aCommand);
+  bool DispatchContentCommandEvent(mozilla::EventMessage aMsg);
+
+  // event callbacks
+  gboolean OnExposeEvent(cairo_t* cr);
+  gboolean OnConfigureEvent(GtkWidget* aWidget, GdkEventConfigure* aEvent);
+  void OnMap();
+  void OnUnrealize();
+  void OnSizeAllocate(GtkAllocation* aAllocation);
+  void OnDeleteEvent();
+  void OnEnterNotifyEvent(GdkEventCrossing* aEvent);
+  void OnLeaveNotifyEvent(GdkEventCrossing* aEvent);
+  void OnMotionNotifyEvent(GdkEventMotion* aEvent);
+  void OnButtonPressEvent(GdkEventButton* aEvent);
+  void OnButtonReleaseEvent(GdkEventButton* aEvent);
+  void OnContainerFocusInEvent(GdkEventFocus* aEvent);
+  void OnContainerFocusOutEvent(GdkEventFocus* aEvent);
+  gboolean OnKeyPressEvent(GdkEventKey* aEvent);
+  gboolean OnKeyReleaseEvent(GdkEventKey* aEvent);
+
+  void OnScrollEvent(GdkEventScroll* aEvent);
+
+  void OnWindowStateEvent(GtkWidget* aWidget, GdkEventWindowState* aEvent);
+  void OnDragDataReceivedEvent(GtkWidget* aWidget, GdkDragContext* aDragContext,
+                               gint aX, gint aY,
+                               GtkSelectionData* aSelectionData, guint aInfo,
+                               guint aTime, gpointer aData);
+  gboolean OnPropertyNotifyEvent(GtkWidget* aWidget, GdkEventProperty* aEvent);
+  gboolean OnTouchEvent(GdkEventTouch* aEvent);
+  gboolean OnTouchpadPinchEvent(GdkEventTouchpadPinch* aEvent);
+
+  void UpdateTopLevelOpaqueRegion();
+
+  already_AddRefed<mozilla::gfx::DrawTarget> StartRemoteDrawingInRegion(
+      const LayoutDeviceIntRegion& aInvalidRegion,
+      mozilla::layers::BufferMode* aBufferMode) override;
+  void EndRemoteDrawingInRegion(
+      mozilla::gfx::DrawTarget* aDrawTarget,
+      const LayoutDeviceIntRegion& aInvalidRegion) override;
+
+  void SetProgress(unsigned long progressPercent);
+
+  RefPtr<mozilla::gfx::VsyncSource> GetVsyncSource() override;
+  bool SynchronouslyRepaintOnResize() override;
+
+  void OnDPIChanged(void);
+  void OnCheckResize(void);
+  void OnCompositedChanged(void);
+  void OnScaleChanged();
+  void DispatchResized();
+
+  static guint32 sLastButtonPressTime;
+
+  [[nodiscard]] nsresult BeginResizeDrag(mozilla::WidgetGUIEvent* aEvent,
+                                         int32_t aHorizontal,
+                                         int32_t aVertical) override;
+
+  MozContainer* GetMozContainer() { return mContainer; }
+  LayoutDeviceIntSize GetMozContainerSize();
+  // GetMozContainerWidget returns the MozContainer even for undestroyed
+  // descendant windows
+  GtkWidget* GetMozContainerWidget();
+  GdkWindow* GetGdkWindow() { return mGdkWindow; };
+  GdkWindow* GetToplevelGdkWindow();
+  GtkWidget* GetGtkWidget() { return mShell; }
+  nsIFrame* GetFrame() const;
+  bool IsDestroyed() const { return mIsDestroyed; }
+  bool IsPopup() const;
+  bool IsWaylandPopup() const;
+  bool IsPIPWindow() const { return mIsPIPWindow; };
+  bool IsDragPopup() { return mIsDragPopup; };
+
+  nsAutoCString GetDebugTag() const;
+
+  void DispatchDragEvent(mozilla::EventMessage aMsg,
+                         const LayoutDeviceIntPoint& aRefPoint, guint aTime);
+  static void UpdateDragStatus(GdkDragContext* aDragContext,
+                               nsIDragService* aDragService);
+
+  WidgetEventTime GetWidgetEventTime(guint32 aEventTime);
+  mozilla::TimeStamp GetEventTimeStamp(guint32 aEventTime);
+#ifdef MOZ_X11
+  mozilla::CurrentX11TimeGetter* GetCurrentTimeGetter();
+#endif
+
+  void SetInputContext(const InputContext& aContext,
+                       const InputContextAction& aAction) override;
+  InputContext GetInputContext() override;
+  TextEventDispatcherListener* GetNativeTextEventDispatcherListener() override;
+  MOZ_CAN_RUN_SCRIPT bool GetEditCommands(
+      mozilla::NativeKeyBindingsType aType,
+      const mozilla::WidgetKeyboardEvent& aEvent,
+      nsTArray<mozilla::CommandInt>& aCommands) override;
+
+  // These methods are for toplevel windows only.
+  void ResizeTransparencyBitmap();
+  void ApplyTransparencyBitmap();
+  void ClearTransparencyBitmap();
+
+  void SetTransparencyMode(nsTransparencyMode aMode) override;
+  nsTransparencyMode GetTransparencyMode() override;
+  void SetWindowMouseTransparent(bool aIsTransparent) override;
+  nsresult UpdateTranslucentWindowAlphaInternal(const nsIntRect& aRect,
+                                                uint8_t* aAlphas,
+                                                int32_t aStride);
+  void ReparentNativeWidget(nsIWidget* aNewParent) override;
+
+  void UpdateTitlebarTransparencyBitmap();
+
+  nsresult SynthesizeNativeMouseEvent(LayoutDeviceIntPoint aPoint,
+                                      NativeMouseMessage aNativeMessage,
+                                      mozilla::MouseButton aButton,
+                                      nsIWidget::Modifiers aModifierFlags,
+                                      nsIObserver* aObserver) override;
+
+  nsresult SynthesizeNativeMouseMove(LayoutDeviceIntPoint aPoint,
+                                     nsIObserver* aObserver) override {
+    return SynthesizeNativeMouseEvent(
+        aPoint, NativeMouseMessage::Move, mozilla::MouseButton::eNotPressed,
+        nsIWidget::Modifiers::NO_MODIFIERS, aObserver);
+  }
+
+  nsresult SynthesizeNativeMouseScrollEvent(
+      LayoutDeviceIntPoint aPoint, uint32_t aNativeMessage, double aDeltaX,
+      double aDeltaY, double aDeltaZ, uint32_t aModifierFlags,
+      uint32_t aAdditionalFlags, nsIObserver* aObserver) override;
+
+  nsresult SynthesizeNativeTouchPoint(uint32_t aPointerId,
+                                      TouchPointerState aPointerState,
+                                      LayoutDeviceIntPoint aPoint,
+                                      double aPointerPressure,
+                                      uint32_t aPointerOrientation,
+                                      nsIObserver* aObserver) override;
+
+  nsresult SynthesizeNativeTouchPadPinch(TouchpadGesturePhase aEventPhase,
+                                         float aScale,
+                                         LayoutDeviceIntPoint aPoint,
+                                         int32_t aModifierFlags) override;
+
+  void GetCompositorWidgetInitData(
+      mozilla::widget::CompositorWidgetInitData* aInitData) override;
+
+  nsresult SetNonClientMargins(LayoutDeviceIntMargin& aMargins) override;
+  void SetDrawsInTitlebar(bool aState) override;
+  mozilla::LayoutDeviceIntCoord GetTitlebarRadius();
+  LayoutDeviceIntRect GetTitlebarRect();
+  void UpdateWindowDraggingRegion(
+      const LayoutDeviceIntRegion& aRegion) override;
+
+  // HiDPI scale conversion
+  gint GdkCeiledScaleFactor();
+  bool UseFractionalScale();
+  double FractionalScaleFactor();
+
+  // To GDK
+  gint DevicePixelsToGdkCoordRoundUp(int pixels);
+  gint DevicePixelsToGdkCoordRoundDown(int pixels);
+  GdkPoint DevicePixelsToGdkPointRoundDown(LayoutDeviceIntPoint point);
+  GdkRectangle DevicePixelsToGdkSizeRoundUp(LayoutDeviceIntSize pixelSize);
+
+  // From GDK
+  int GdkCoordToDevicePixels(gint coord);
+  LayoutDeviceIntPoint GdkPointToDevicePixels(GdkPoint point);
+  LayoutDeviceIntPoint GdkEventCoordsToDevicePixels(gdouble x, gdouble y);
+  LayoutDeviceIntRect GdkRectToDevicePixels(GdkRectangle rect);
+
+  bool WidgetTypeSupportsAcceleration() override;
+
+  nsresult SetSystemFont(const nsCString& aFontName) override;
+  nsresult GetSystemFont(nsCString& aFontName) override;
+
+  typedef enum {
+    GTK_DECORATION_SYSTEM,  // CSD including shadows
+    GTK_DECORATION_CLIENT,  // CSD without shadows
+    GTK_DECORATION_NONE,    // WM does not support CSD at all
+  } GtkWindowDecoration;
+  /**
+   * Get the support of Client Side Decoration by checking
+   * the XDG_CURRENT_DESKTOP environment variable.
+   */
+  static GtkWindowDecoration GetSystemGtkWindowDecoration();
+
+  static bool GetTopLevelWindowActiveState(nsIFrame* aFrame);
+  static bool TitlebarUseShapeMask();
+  bool IsRemoteContent() { return HasRemoteContent(); }
+  void NativeMoveResizeWaylandPopupCallback(const GdkRectangle* aFinalSize,
+                                            bool aFlippedX, bool aFlippedY);
+  static bool IsToplevelWindowTransparent();
+
+  static nsWindow* GetFocusedWindow();
+
+#ifdef MOZ_WAYLAND
+  // Use xdg-activation protocol to transfer focus from gFocusWindow to aWindow.
+  static void RequestFocusWaylandWindow(RefPtr<nsWindow> aWindow);
+  void FocusWaylandWindow(const char* aTokenID);
+
+  bool GetCSDDecorationOffset(int* aDx, int* aDy);
+  void SetEGLNativeWindowSize(const LayoutDeviceIntSize& aEGLWindowSize);
+  void WaylandDragWorkaround(GdkEventButton* aEvent);
+
+  wl_display* GetWaylandDisplay();
+  void CreateCompositorVsyncDispatcher() override;
+  LayoutDeviceIntPoint GetNativePointerLockCenter() {
+    return mNativePointerLockCenter;
+  }
+  void SetNativePointerLockCenter(
+      const LayoutDeviceIntPoint& aLockCenter) override;
+  void LockNativePointer() override;
+  void UnlockNativePointer() override;
+  LayoutDeviceIntSize GetMoveToRectPopupSize() const override {
+    return mMoveToRectPopupSize;
+  };
+#endif
+
+  typedef enum {
+    // WebRender compositor is enabled
+    COMPOSITOR_ENABLED,
+    // WebRender compositor is paused after window creation.
+    COMPOSITOR_PAUSED_INITIALLY,
+    // WebRender compositor is paused because GtkWindow is hidden,
+    // we can't draw into GL context.
+    COMPOSITOR_PAUSED_MISSING_WINDOW,
+    // WebRender compositor is paused as we're repainting whole window and
+    // we're waiting for content process to update page content.
+    COMPOSITOR_PAUSED_FLICKERING
+  } WindowCompositorState;
+
+  // Pause compositor to avoid rendering artifacts from content process.
+  void ResumeCompositor();
+  void ResumeCompositorFromCompositorThread();
+  void PauseCompositor();
+  bool IsWaitingForCompositorResume();
+
+ protected:
+  virtual ~nsWindow();
+
+  // event handling code
+  void DispatchActivateEvent(void);
+  void DispatchDeactivateEvent(void);
+  void MaybeDispatchResized();
+
+  void RegisterTouchWindow() override;
+  bool CompositorInitiallyPaused() override {
+    return mCompositorState == COMPOSITOR_PAUSED_INITIALLY;
+  }
+  nsCOMPtr<nsIWidget> mParent;
+  nsPopupType mPopupHint{};
+  int mWindowScaleFactor = 1;
+
+  void UpdateAlpha(mozilla::gfx::SourceSurface* aSourceSurface,
+                   nsIntRect aBoundsRect);
+
+  void NativeMoveResize(bool aMoved, bool aResized);
+
+  void NativeShow(bool aAction);
+  void SetHasMappedToplevel(bool aState);
+  LayoutDeviceIntSize GetSafeWindowSize(LayoutDeviceIntSize aSize);
+
+  void EnsureGrabs(void);
+  void GrabPointer(guint32 aTime);
+  void ReleaseGrabs(void);
+
+  void UpdateClientOffsetFromFrameExtents();
+  void UpdateClientOffsetFromCSDWindow();
+
+  void DispatchContextMenuEventFromMouseEvent(uint16_t domButton,
+                                              GdkEventButton* aEvent);
+
+  void EnableRenderingToWindow();
+  void DisableRenderingToWindow();
+  void ResumeCompositorHiddenWindow();
+  void PauseCompositorHiddenWindow();
+  void WaylandStartVsync();
+  void WaylandStopVsync();
+  void DestroyChildWindows();
+  GtkWidget* GetToplevelWidget();
+  nsWindow* GetContainerWindow();
+  Window GetX11Window();
+  bool GetShapedState();
+  void EnsureGdkWindow();
+  void SetUrgencyHint(GtkWidget* top_window, bool state);
+  void SetDefaultIcon(void);
+  void SetWindowDecoration(nsBorderStyle aStyle);
+  void InitButtonEvent(mozilla::WidgetMouseEvent& aEvent,
+                       GdkEventButton* aGdkEvent);
+  bool CheckForRollup(gdouble aMouseX, gdouble aMouseY, bool aIsWheel,
+                      bool aAlwaysRollup);
+  void CheckForRollupDuringGrab() { CheckForRollup(0, 0, false, true); }
+
+  bool GetDragInfo(mozilla::WidgetMouseEvent* aMouseEvent, GdkWindow** aWindow,
+                   gint* aButton, gint* aRootX, gint* aRootY);
+  nsIWidgetListener* GetListener();
+
+  nsWindow* GetTransientForWindowIfPopup();
+  bool IsHandlingTouchSequence(GdkEventSequence* aSequence);
+
+  void ResizeInt(int aX, int aY, int aWidth, int aHeight, bool aMove);
+  void NativeMoveResizeWaylandPopup(bool aMove, bool aResize);
+
+  // Returns true if the given point (in device pixels) is within a resizer
+  // region of the window. Only used when drawing decorations client side.
+  bool CheckResizerEdge(LayoutDeviceIntPoint aPoint, GdkWindowEdge& aOutEdge);
+
+  GtkTextDirection GetTextDirection();
+
+  void AddCSDDecorationSize(int* aWidth, int* aHeight);
+
+  nsCString mGtkWindowAppName;
+  nsCString mGtkWindowRoleName;
+  void RefreshWindowClass();
+
+  GtkWidget* mShell = nullptr;
+  MozContainer* mContainer = nullptr;
+  GdkWindow* mGdkWindow = nullptr;
+  PlatformCompositorWidgetDelegate* mCompositorWidgetDelegate = nullptr;
+  mozilla::Atomic<WindowCompositorState, mozilla::Relaxed> mCompositorState{
+      COMPOSITOR_ENABLED};
+  // This is used in COMPOSITOR_PAUSED_FLICKERING mode only to resume compositor
+  // in some reasonable time when page content is not updated.
+  int mCompositorPauseTimeoutID = 0;
+
+  nsSizeMode mSizeState = nsSizeMode_Normal;
+  float mAspectRatio = 0.0f;
+  float mAspectRatioSaved = 0.0f;
+  nsIntPoint mClientOffset;
+
+  // This field omits duplicate scroll events caused by GNOME bug 726878.
+  guint32 mLastScrollEventTime = GDK_CURRENT_TIME;
+  mozilla::ScreenCoord mLastPinchEventSpan;
+
+  // for touch event handling
+  nsRefPtrHashtable<nsPtrHashKey<GdkEventSequence>, mozilla::dom::Touch>
+      mTouches;
+
+  // Upper bound on pending ConfigureNotify events to be dispatched to the
+  // window. See bug 1225044.
+  unsigned int mPendingConfigures = 0;
+
+  // Window titlebar rendering mode, GTK_DECORATION_NONE if it's disabled
+  // for this window.
+  GtkWindowDecoration mGtkWindowDecoration = GTK_DECORATION_NONE;
+
+  // Draggable titlebar region maintained by UpdateWindowDraggingRegion
+  LayoutDeviceIntRegion mDraggableRegion;
+
+  // The cursor cache
+  static GdkCursor* gsGtkCursorCache[eCursorCount];
+
+  // If true, draw our own window titlebar.
+  //
+  // Needs to be atomic because GetTitlebarRect() gets called from non-main
+  // threads.
+  //
+  // FIXME(emilio): GetTitlebarRect() reads other things that TSAN doesn't
+  // catch because mDrawInTitlebar is false on automation ~always. We should
+  // probably make GetTitlebarRect() simpler / properly thread-safe.
+  mozilla::Atomic<bool, mozilla::Relaxed> mDrawInTitlebar{false};
+
+  // Has this widget been destroyed yet?
+  bool mIsDestroyed : 1;
+  // Does WindowResized need to be called on listeners?
+  bool mNeedsDispatchResized : 1;
+  // mIsShown tracks requested visible status from browser perspective, i.e.
+  // if the window should be visible or now.
+  bool mIsShown : 1;
+  // mNeedsShow is set when browser requested to show this window but we failed
+  // to do so for some reason (wrong window size for instance).
+  // In such case we set mIsShown = true and mNeedsShow = true to indicate
+  // that the window is not actually visible but we report to browser that
+  // it is visible (mIsShown == true).
+  bool mNeedsShow : 1;
+  // This track real window visibility from OS perspective.
+  // It's set by OnMap/OnUnrealize which is based on Gtk events.
+  bool mIsMapped : 1;
+  // is this widget enabled?
+  bool mEnabled : 1;
+  // has the native window for this been created yet?
+  bool mCreated : 1;
+  // whether we handle touch event
+  bool mHandleTouchEvent : 1;
+  // true if this is a drag and drop feedback popup
+  bool mIsDragPopup : 1;
+  bool mWindowScaleFactorChanged : 1;
+  bool mCompositedScreen : 1;
+  bool mIsAccelerated : 1;
+  bool mWindowShouldStartDragging : 1;
+  bool mHasMappedToplevel : 1;
+  bool mRetryPointerGrab : 1;
+  bool mPanInProgress : 1;
+  // Use dedicated GdkWindow for mContainer
+  bool mDrawToContainer : 1;
+  // Draw titlebar with :backdrop css state (inactive/unfocused).
+  bool mTitlebarBackdropState : 1;
+  // It's PictureInPicture window.
+  bool mIsPIPWindow : 1;
+  // It's undecorated popup utility window, without resizers/titlebar,
+  // movable by mouse. Used on Wayland for popups without
+  // parent (for instance WebRTC sharing indicator, notifications).
+  bool mIsWaylandPanelWindow : 1;
+  // It's child window, i.e. window which is nested in parent window.
+  // This is obsoleted and should not be used.
+  // We use GdkWindow hierarchy for such windows.
+  bool mIsChildWindow : 1;
+  bool mAlwaysOnTop : 1;
+  bool mNoAutoHide : 1;
+  bool mMouseTransparent : 1;
+  bool mIsTransparent : 1;
+  // We can't detect size state changes correctly so set this flag
+  // to force update mBounds after a size state change from a configure
+  // event.
+  bool mBoundsAreValid : 1;
+
+  /*  Gkt creates popup in two incarnations - wl_subsurface and xdg_popup.
+   *  Kind of popup is choosen before GdkWindow is mapped so we can change
+   *  it only when GdkWindow is hidden.
+   *
+   *  Relevant Gtk code is at gdkwindow-wayland.c
+   *  in should_map_as_popup() and should_map_as_subsurface()
+   *
+   *  wl_subsurface:
+   *    - can't be positioned by move-to-rect
+   *    - can stand outside popup widget hierarchy (has toplevel as parent)
+   *    - don't have child popup widgets
+   *
+   *  xdg_popup:
+   *    - can be positioned by move-to-rect
+   *    - aligned in popup widget hierarchy, first one is attached to toplevel
+   *    - has child (popup) widgets
+   *
+   *  Thus we need to map Firefox popup type to desired Gtk one:
+   *
+   *  wl_subsurface:
+   *    - pernament panels
+   *
+   *  xdg_popup:
+   *    - menus
+   *    - autohide popups (hamburger menu)
+   *    - extension popups
+   *    - tooltips
+   *
+   *  We set mPopupTrackInHierarchy = false for pernament panels which
+   *  are always mapped to toplevel and painted as wl_surfaces.
+   */
+  bool mPopupTrackInHierarchy : 1;
+  bool mPopupTrackInHierarchyConfigured : 1;
+
+  /* On X11 Gtk tends to ignore window position requests when gtk_window
+   * is hidden. Save the position requests at mPopupPosition and apply
+   * when the widget is shown.
+   */
+  bool mHiddenPopupPositioned : 1;
+
+  // The transparency bitmap is used instead of ARGB visual for toplevel
+  // window to draw titlebar.
+  bool mTransparencyBitmapForTitlebar : 1;
+
+  // True when we're on compositing window manager and this
+  // window is using visual with alpha channel.
+  bool mHasAlphaVisual : 1;
+
+  // When popup is anchored, mPopupPosition is relative to its parent popup.
+  bool mPopupAnchored : 1;
+
+  // When popup is context menu.
+  bool mPopupContextMenu : 1;
+
+  // Indicates that this popup matches layout setup so we can use parent popup
+  // coordinates reliably.
+  bool mPopupMatchesLayout : 1;
+
+  /*  Indicates that popup setup was changed and
+   *  we need to recalculate popup coordinates.
+   */
+  bool mPopupChanged : 1;
+
+  // Popup is hidden only as a part of hierarchy tree update.
+  bool mPopupTemporaryHidden : 1;
+
+  // Popup is going to be closed and removed.
+  bool mPopupClosed : 1;
+
+  // Popup is positioned by gdk_window_move_to_rect()
+  bool mPopupUseMoveToRect : 1;
+
+  /* mWaitingForMoveToRectCallback is set when move-to-rect is called
+   * and we're waiting for move-to-rect callback.
+   *
+   * If another position/resize request comes between move-to-rect call and
+   * move-to-rect callback we set mNewBoundsAfterMoveToRect.
+   */
+  bool mWaitingForMoveToRectCallback : 1;
+
+  // Params used for popup placemend by GdkWindowMoveToRect.
+  // When popup is only resized and not positioned,
+  // we need to reuse last GdkWindowMoveToRect params to avoid
+  // popup movement.
+  struct WaylandPopupMoveToRectParams {
+    LayoutDeviceIntRect mAnchorRect;
+    GdkGravity mAnchorRectType;
+    GdkGravity mPopupAnchorType;
+    GdkAnchorHints mHints;
+    GdkPoint mOffset;
+  };
+
+  WaylandPopupMoveToRectParams mPopupMoveToRectParams;
+
+  // Whether we've configured default clear color already.
+  bool mConfiguredClearColor : 1;
+  // Whether we've received a non-blank paint in which case we can reset the
+  // clear color to transparent.
+  bool mGotNonBlankPaint : 1;
+
+  // This bitmap tracks which pixels are transparent. We don't support
+  // full translucency at this time; each pixel is either fully opaque
+  // or fully transparent.
+  gchar* mTransparencyBitmap = nullptr;
+  int32_t mTransparencyBitmapWidth = 0;
+  int32_t mTransparencyBitmapHeight = 0;
+
+  // all of our DND stuff
+  void InitDragEvent(mozilla::WidgetDragEvent& aEvent);
+
+  float mLastMotionPressure = 0.0f;
+
+  // Remember the last sizemode so that we can restore it when
+  // leaving fullscreen
+  nsSizeMode mLastSizeMode = nsSizeMode_Normal;
+
+  static bool DragInProgress(void);
+
+  void DispatchMissedButtonReleases(GdkEventCrossing* aGdkEvent);
+
+  // When window widget gets mapped/unmapped we need to configure
+  // underlying GdkWindow properly. Otherwise we'll end up with
+  // rendering to released window.
+  void ConfigureGdkWindow();
+  void ReleaseGdkWindow();
+
+  // nsBaseWidget
+  WindowRenderer* GetWindowRenderer() override;
+  void DidGetNonBlankPaint() override;
+
+  void SetCompositorWidgetDelegate(CompositorWidgetDelegate* delegate) override;
+
+  void CleanLayerManagerRecursive();
+
+  int32_t RoundsWidgetCoordinatesTo() override;
+
+  void UpdateMozWindowActive();
+
+  void ForceTitlebarRedraw();
+  bool DoDrawTilebarCorners();
+  bool IsChromeWindowTitlebar();
+
+  void SetPopupWindowDecoration(bool aShowOnTaskbar);
+
+  void ApplySizeConstraints(void);
+
+  // Wayland Popup section
+  GdkPoint WaylandGetParentPosition();
+  bool WaylandPopupConfigure();
+  bool WaylandPopupIsAnchored();
+  bool WaylandPopupIsMenu();
+  bool WaylandPopupIsContextMenu();
+  bool WaylandPopupIsPermanent();
+  bool IsWidgetOverflowWindow();
+  void RemovePopupFromHierarchyList();
+  void ShowWaylandWindow();
+  void HideWaylandWindow();
+  void HideWaylandPopupWindow(bool aTemporaryHidden, bool aRemoveFromPopupList);
+  void HideWaylandToplevelWindow();
+  void WaylandPopupHideTooltips();
+  void AppendPopupToHierarchyList(nsWindow* aToplevelWindow);
+  void WaylandPopupHierarchyHideTemporary();
+  void WaylandPopupHierarchyShowTemporaryHidden();
+  void WaylandPopupHierarchyCalculatePositions();
+  bool IsInPopupHierarchy();
+  void AddWindowToPopupHierarchy();
+  void UpdateWaylandPopupHierarchy();
+  void WaylandPopupHierarchyHideByLayout(
+      nsTArray<nsIWidget*>* aLayoutWidgetHierarchy);
+  void WaylandPopupHierarchyValidateByLayout(
+      nsTArray<nsIWidget*>* aLayoutWidgetHierarchy);
+  void CloseAllPopupsBeforeRemotePopup();
+  void WaylandPopupHideClosedPopups();
+  void WaylandPopupMove();
+  bool WaylandPopupRemoveNegativePosition(int* aX = nullptr, int* aY = nullptr);
+  nsWindow* WaylandPopupGetTopmostWindow();
+  bool IsPopupInLayoutPopupChain(nsTArray<nsIWidget*>* aLayoutWidgetHierarchy,
+                                 bool aMustMatchParent);
+  void WaylandPopupMarkAsClosed();
+  void WaylandPopupRemoveClosedPopups();
+  void WaylandPopupSetDirectPosition();
+  bool WaylandPopupFitsToplevelWindow();
+  const WaylandPopupMoveToRectParams WaylandPopupGetPositionFromLayout();
+  void WaylandPopupPropagateChangesToLayout(bool aMove, bool aResize);
+  nsWindow* WaylandPopupFindLast(nsWindow* aPopup);
+  GtkWindow* GetCurrentTopmostWindow();
+  nsAutoCString GetFrameTag() const;
+  nsCString GetPopupTypeName();
+  bool IsPopupDirectionRTL();
+
+#ifdef MOZ_LOGGING
+  void LogPopupHierarchy();
+#endif
+
+  // mPopupPosition is the original popup position/size from layout, set by
+  // nsWindow::Move() or nsWindow::Resize().
+  // Popup position is relative to main (toplevel) window.
+  GdkPoint mPopupPosition{};
+
+  // mRelativePopupPosition is popup position calculated against
+  // recent popup parent window.
+  GdkPoint mRelativePopupPosition{};
+
+  // Toplevel window (first element) of linked list of Wayland popups. It's null
+  // if we're the toplevel.
+  RefPtr<nsWindow> mWaylandToplevel;
+
+  // Next/Previous popups in Wayland popup hierarchy.
+  RefPtr<nsWindow> mWaylandPopupNext;
+  RefPtr<nsWindow> mWaylandPopupPrev;
+
+  // When popup is resized by Gtk by move-to-rect callback,
+  // we store final popup size here. Then we use mMoveToRectPopupSize size
+  // in following popup operations unless mLayoutPopupSizeCleared is set.
+  LayoutDeviceIntSize mMoveToRectPopupSize;
+
+  LayoutDeviceIntRect mNewBoundsAfterMoveToRect;
+
+  /**
+   * |mIMContext| takes all IME related stuff.
+   *
+   * This is owned by the top-level nsWindow or the topmost child
+   * nsWindow embedded in a non-Gecko widget.
+   *
+   * The instance is created when the top level widget is created.  And when
+   * the widget is destroyed, it's released.  All child windows refer its
+   * ancestor widget's instance.  So, one set of IM contexts is created for
+   * all windows in a hierarchy.  If the children are released after the top
+   * level window is released, the children still have a valid pointer,
+   * however, IME doesn't work at that time.
+   */
+  RefPtr<mozilla::widget::IMContextWrapper> mIMContext;
+
+#ifdef MOZ_X11
+  mozilla::UniquePtr<mozilla::CurrentX11TimeGetter> mCurrentTimeGetter;
+#endif
+  static GtkWindowDecoration sGtkWindowDecoration;
+
+  static bool sTransparentMainWindow;
+
+#ifdef ACCESSIBILITY
+  RefPtr<mozilla::a11y::LocalAccessible> mRootAccessible;
+
+  /**
+   * Request to create the accessible for this window if it is top level.
+   */
+  void CreateRootAccessible();
+
+  /**
+   * Dispatch accessible event for the top level window accessible.
+   *
+   * @param  aEventType  [in] the accessible event type to dispatch
+   */
+  void DispatchEventToRootAccessible(uint32_t aEventType);
+
+  /**
+   * Dispatch accessible window activate event for the top level window
+   * accessible.
+   */
+  void DispatchActivateEventAccessible();
+
+  /**
+   * Dispatch accessible window deactivate event for the top level window
+   * accessible.
+   */
+  void DispatchDeactivateEventAccessible();
+
+  /**
+   * Dispatch accessible window maximize event for the top level window
+   * accessible.
+   */
+  void DispatchMaximizeEventAccessible();
+
+  /**
+   * Dispatch accessible window minize event for the top level window
+   * accessible.
+   */
+  void DispatchMinimizeEventAccessible();
+
+  /**
+   * Dispatch accessible window restore event for the top level window
+   * accessible.
+   */
+  void DispatchRestoreEventAccessible();
+#endif
+
+#ifdef MOZ_X11
+  typedef enum {GTK_WIDGET_COMPOSIDED_DEFAULT = 0,
+                GTK_WIDGET_COMPOSIDED_DISABLED = 1,
+                GTK_WIDGET_COMPOSIDED_ENABLED = 2} WindowComposeRequest;
+  void SetCompositorHint(WindowComposeRequest aState);
+  bool ConfigureX11GLVisual();
+#endif
+#ifdef MOZ_WAYLAND
+  RefPtr<mozilla::WaylandVsyncSource> mWaylandVsyncSource;
+  LayoutDeviceIntPoint mNativePointerLockCenter;
+  zwp_locked_pointer_v1* mLockedPointer = nullptr;
+  zwp_relative_pointer_v1* mRelativePointer = nullptr;
+  xdg_activation_token_v1* mXdgToken = nullptr;
+#endif
+  mozilla::widget::WindowSurfaceProvider mSurfaceProvider;
+};
+
+#endif /* __nsWindow_h__ */
diff --git a/widget/moz.build b/widget/moz.build
index 4bad4c00df..9c1e4b0642 100644
--- a/widget/moz.build
+++ b/widget/moz.build
@@ -157,6 +157,11 @@ EXPORTS += [
     "PuppetWidget.h",
 ]
 
+if toolkit == "gtk":
+    EXPORTS += [
+        "nsINativeMenuService.h",
+    ]
+
 EXPORTS.mozilla += [
     "BasicEvents.h",
     "ColorScheme.h",
diff --git a/widget/nsINativeMenuService.h b/widget/nsINativeMenuService.h
new file mode 100644
index 0000000000..e92d7a74a3
--- /dev/null
+++ b/widget/nsINativeMenuService.h
@@ -0,0 +1,39 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsINativeMenuService_h_
+#define nsINativeMenuService_h_
+
+#include "nsISupports.h"
+
+class nsIWidget;
+class nsIContent;
+namespace mozilla {
+namespace dom {
+class Element;
+}
+}  // namespace mozilla
+
+// {90DF88F9-F084-4EF3-829A-49496E636DED}
+#define NS_INATIVEMENUSERVICE_IID                    \
+  {                                                  \
+    0x90DF88F9, 0xF084, 0x4EF3, {                    \
+      0x82, 0x9A, 0x49, 0x49, 0x6E, 0x63, 0x6D, 0xED \
+    }                                                \
+  }
+
+class nsINativeMenuService : public nsISupports {
+ public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_INATIVEMENUSERVICE_IID)
+  // Given a top-level window widget and a menu bar DOM node, sets up native
+  // menus. Once created, native menus are controlled via the DOM, including
+  // destruction.
+  NS_IMETHOD CreateNativeMenuBar(nsIWidget* aParent,
+                                 mozilla::dom::Element* aMenuBarNode) = 0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsINativeMenuService, NS_INATIVEMENUSERVICE_IID)
+
+#endif  // nsINativeMenuService_h_
diff --git a/widget/nsWidgetsCID.h b/widget/nsWidgetsCID.h
index 5a632e2612..ad7f165ed9 100644
--- a/widget/nsWidgetsCID.h
+++ b/widget/nsWidgetsCID.h
@@ -66,6 +66,14 @@
 // Menus
 //-----------------------------------------------------------
 
+// {0B3FE5AA-BC72-4303-85AE-76365DF1251D}
+#define NS_NATIVEMENUSERVICE_CID                     \
+  {                                                  \
+    0x0B3FE5AA, 0xBC72, 0x4303, {                    \
+      0x85, 0xAE, 0x76, 0x36, 0x5D, 0xF1, 0x25, 0x1D \
+    }                                                \
+  }
+
 // {F6CD4F21-53AF-11d2-8DC4-00609703C14E}
 #define NS_POPUPMENU_CID                           \
   {                                                \
diff --git a/xpcom/components/ManifestParser.cpp b/xpcom/components/ManifestParser.cpp
index f3d0055f2c..d13543ab52 100644
--- a/xpcom/components/ManifestParser.cpp
+++ b/xpcom/components/ManifestParser.cpp
@@ -43,6 +43,7 @@
 #include "nsIScriptError.h"
 #include "nsIXULAppInfo.h"
 #include "nsIXULRuntime.h"
+#include "nsKDEUtils.h"
 
 using namespace mozilla;
 
@@ -402,6 +403,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
   constexpr auto kOs = u"os"_ns;
   constexpr auto kOsVersion = u"osversion"_ns;
   constexpr auto kABI = u"abi"_ns;
+  constexpr auto kDesktop = u"desktop"_ns;
   constexpr auto kProcess = u"process"_ns;
 #if defined(MOZ_WIDGET_ANDROID)
   constexpr auto kTablet = u"tablet"_ns;
@@ -461,6 +463,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
   }
 
   nsAutoString osVersion;
+  nsAutoString desktop;
 #if defined(XP_WIN)
 #  pragma warning(push)
 #  pragma warning(disable : 4996)  // VC12+ deprecates GetVersionEx
@@ -469,14 +472,17 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
     nsTextFormatter::ssprintf(osVersion, u"%ld.%ld", info.dwMajorVersion,
                               info.dwMinorVersion);
   }
+  desktop = u"win"_ns;
 #  pragma warning(pop)
 #elif defined(MOZ_WIDGET_COCOA)
   SInt32 majorVersion = nsCocoaFeatures::macOSVersionMajor();
   SInt32 minorVersion = nsCocoaFeatures::macOSVersionMinor();
   nsTextFormatter::ssprintf(osVersion, u"%ld.%ld", majorVersion, minorVersion);
+  desktop = u"macosx"_ns);
 #elif defined(MOZ_WIDGET_GTK)
   nsTextFormatter::ssprintf(osVersion, u"%ld.%ld", gtk_major_version,
                             gtk_minor_version);
+  desktop = nsKDEUtils::kdeSession() ? u"kde"_ns : u"gnome"_ns;
 #elif defined(MOZ_WIDGET_ANDROID)
   bool isTablet = false;
   if (mozilla::AndroidBridge::Bridge()) {
@@ -484,6 +490,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
         "android/os/Build$VERSION", "RELEASE", osVersion);
     isTablet = java::GeckoAppShell::IsTablet();
   }
+  desktop = u"android"_ns;
 #endif
 
   if (XRE_IsContentProcess()) {
@@ -588,6 +595,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
                                     : eUnspecified;
 #endif
     int flags = 0;
+    TriState stDesktop = eUnspecified;
 
     while ((token = nsCRT::strtok(whitespace, kWhitespace, &whitespace)) &&
            ok) {
@@ -597,6 +605,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
       if (CheckStringFlag(kApplication, wtoken, appID, stApp) ||
           CheckOsFlag(kOs, wtoken, osTarget, stOs) ||
           CheckStringFlag(kABI, wtoken, abi, stABI) ||
+          CheckStringFlag(kDesktop, wtoken, desktop, stDesktop) ||
           CheckStringFlag(kProcess, wtoken, process, stProcess) ||
           CheckVersionFlag(kOsVersion, wtoken, osVersion, stOsVersion) ||
           CheckVersionFlag(kAppVersion, wtoken, appVersion, stAppVersion) ||
@@ -655,7 +664,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
     }
 
     if (!ok || stApp == eBad || stAppVersion == eBad ||
-        stGeckoVersion == eBad || stOs == eBad || stOsVersion == eBad ||
+        stGeckoVersion == eBad || stOs == eBad || stOsVersion == eBad || stDesktop == eBad ||
 #ifdef MOZ_WIDGET_ANDROID
         stTablet == eBad ||
 #endif
diff --git a/xpcom/components/moz.build b/xpcom/components/moz.build
index 6cf78aa9be..dfcf9c7697 100644
--- a/xpcom/components/moz.build
+++ b/xpcom/components/moz.build
@@ -71,6 +71,7 @@ LOCAL_INCLUDES += [
     "/js/xpconnect/loader",
     "/layout/build",
     "/modules/libjar",
+    "/toolkit/xre",
 ]
 
 if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
diff --git a/xpcom/ds/NativeMenuAtoms.py b/xpcom/ds/NativeMenuAtoms.py
new file mode 100644
index 0000000000..488c8f49c0
--- /dev/null
+++ b/xpcom/ds/NativeMenuAtoms.py
@@ -0,0 +1,9 @@
+from Atom import Atom
+
+NATIVE_MENU_ATOMS = [
+    Atom("menuitem_with_favicon", "menuitem-with-favicon"),
+    Atom("_moz_menubarkeeplocal", "_moz-menubarkeeplocal"),
+    Atom("_moz_nativemenupopupstate", "_moz-nativemenupopupstate"),
+    Atom("openedwithkey", "openedwithkey"),
+    Atom("shellshowingmenubar", "shellshowingmenubar"),
+]
diff --git a/xpcom/ds/StaticAtoms.py b/xpcom/ds/StaticAtoms.py
index 2f4500b8bc..d70250b5f3 100644
--- a/xpcom/ds/StaticAtoms.py
+++ b/xpcom/ds/StaticAtoms.py
@@ -7,6 +7,7 @@
 from Atom import Atom, InheritingAnonBoxAtom, NonInheritingAnonBoxAtom
 from Atom import PseudoElementAtom
 from HTMLAtoms import HTML_PARSER_ATOMS
+from NativeMenuAtoms import NATIVE_MENU_ATOMS
 import sys
 
 # Static atom definitions, used to generate nsGkAtomList.h.
@@ -2534,7 +2535,7 @@ STATIC_ATOMS = [
     InheritingAnonBoxAtom("AnonBox_mozSVGForeignContent", ":-moz-svg-foreign-content"),
     InheritingAnonBoxAtom("AnonBox_mozSVGText", ":-moz-svg-text"),
     # END ATOMS
-] + HTML_PARSER_ATOMS
+] + HTML_PARSER_ATOMS + NATIVE_MENU_ATOMS
 # fmt: on
 
 
diff --git a/xpcom/ds/StaticAtoms.py.orig b/xpcom/ds/StaticAtoms.py.orig
new file mode 100644
index 0000000000..2f4500b8bc
--- /dev/null
+++ b/xpcom/ds/StaticAtoms.py.orig
@@ -0,0 +1,2615 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+# flake8: noqa
+
+from Atom import Atom, InheritingAnonBoxAtom, NonInheritingAnonBoxAtom
+from Atom import PseudoElementAtom
+from HTMLAtoms import HTML_PARSER_ATOMS
+import sys
+
+# Static atom definitions, used to generate nsGkAtomList.h.
+#
+# Each atom is defined by a call to Atom, PseudoElementAtom,
+# NonInheritingAnonBoxAtom or InheritingAnonBoxAtom.
+#
+# The first argument is the atom's identifier.
+# The second argument is the atom's string value.
+#
+# Please keep the Atom() definitions on one line as this is parsed by the
+#   htmlparser: parser/html/java/htmlparser
+# Please keep "START ATOMS" and "END ATOMS" comments as the parser uses them.
+#
+# It is not possible to conditionally define static atoms with #ifdef etc.
+# fmt: off
+STATIC_ATOMS = [
+    # START ATOMS
+    # --------------------------------------------------------------------------
+    # Generic atoms
+    # --------------------------------------------------------------------------
+    Atom("SystemPrincipal", "[System Principal]"),
+    Atom("_empty", ""),
+    Atom("_0", "0"),
+    Atom("_1", "1"),
+    Atom("mozframetype", "mozframetype"),
+    Atom("_moz_abspos", "_moz_abspos"),
+    Atom("_moz_activated", "_moz_activated"),
+    Atom("_moz_anonclass", "_moz_anonclass"),
+    Atom("_moz_resizing", "_moz_resizing"),
+    Atom("moztype", "_moz-type"),
+    Atom("mozdirty", "_moz_dirty"),
+    Atom("mozdisallowselectionprint", "mozdisallowselectionprint"),
+    Atom("mozdonotsend", "moz-do-not-send"),
+    Atom("mozfwcontainer", "moz-forward-container"),  # Used by MailNews.
+    Atom("mozgeneratedcontentbefore", "_moz_generated_content_before"),
+    Atom("mozgeneratedcontentafter", "_moz_generated_content_after"),
+    Atom("mozgeneratedcontentmarker", "_moz_generated_content_marker"),
+    Atom("mozgeneratedcontentimage", "_moz_generated_content_image"),
+    Atom("mozquote", "_moz_quote"),
+    Atom("mozsignature", "moz-signature"),  # Used by MailNews.
+    Atom("_moz_bullet_font", "-moz-bullet-font"),
+    Atom("_moz_is_glyph", "-moz-is-glyph"),
+    Atom("_moz_original_size", "_moz_original_size"),
+    Atom("_moz_print_preview", "-moz-print-preview"),
+    Atom("_moz_non_native_content_theme", "-moz-non-native-content-theme"),
+    Atom("menuactive", "_moz-menuactive"),
+    Atom("_poundDefault", "#default"),
+    Atom("_asterisk", "*"),
+    Atom("a", "a"),
+    Atom("abbr", "abbr"),
+    Atom("abort", "abort"),
+    Atom("above", "above"),
+    Atom("acceltext", "acceltext"),
+    Atom("accept", "accept"),
+    Atom("acceptcharset", "accept-charset"),
+    Atom("accessiblenode", "accessible-node"),
+    Atom("accesskey", "accesskey"),
+    Atom("acronym", "acronym"),
+    Atom("action", "action"),
+    Atom("active", "active"),
+    Atom("activateontab", "activateontab"),
+    Atom("actuate", "actuate"),
+    Atom("address", "address"),
+    Atom("adoptedsheetclones", "adoptedsheetclones"),
+    Atom("after", "after"),
+    Atom("align", "align"),
+    Atom("alink", "alink"),
+    Atom("all", "all"),
+    Atom("allow", "allow"),
+    Atom("allowdownloads", "allow-downloads"),
+    Atom("allowevents", "allowevents"),
+    Atom("allowforms", "allow-forms"),
+    Atom("allowfullscreen", "allowfullscreen"),
+    Atom("allowmodals", "allow-modals"),
+    Atom("alloworientationlock", "allow-orientation-lock"),
+    Atom("allowpointerlock", "allow-pointer-lock"),
+    Atom("allowpopupstoescapesandbox", "allow-popups-to-escape-sandbox"),
+    Atom("allowpopups", "allow-popups"),
+    Atom("allowpresentation", "allow-presentation"),
+    Atom("allowstorageaccessbyuseractivatetion", "allow-storage-access-by-user-activation"),
+    Atom("allowsameorigin", "allow-same-origin"),
+    Atom("allowscripts", "allow-scripts"),
+    Atom("allowscriptstoclose", "allowscriptstoclose"),
+    Atom("allowtopnavigation", "allow-top-navigation"),
+    Atom("allowtopnavigationbyuseractivation", "allow-top-navigation-by-user-activation"),
+    Atom("allowtopnavigationcustomprotocols", "allow-top-navigation-to-custom-protocols"),
+    Atom("allowuntrusted", "allowuntrusted"),
+    Atom("alt", "alt"),
+    Atom("alternate", "alternate"),
+    Atom("always", "always"),
+    Atom("ancestor", "ancestor"),
+    Atom("ancestorOrSelf", "ancestor-or-self"),
+    Atom("anchor", "anchor"),
+    Atom("_and", "and"),
+    Atom("animations", "animations"),
+    Atom("anonid", "anonid"),
+    Atom("anonlocation", "anonlocation"),
+    Atom("any", "any"),
+    Atom("any_hover", "any-hover"),
+    Atom("any_pointer", "any-pointer"),
+    Atom("applet", "applet"),
+    Atom("applyImports", "apply-imports"),
+    Atom("applyTemplates", "apply-templates"),
+    Atom("archive", "archive"),
+    Atom("area", "area"),
+    Atom("aria_activedescendant", "aria-activedescendant"),
+    Atom("aria_atomic", "aria-atomic"),
+    Atom("aria_autocomplete", "aria-autocomplete"),
+    Atom("aria_busy", "aria-busy"),
+    Atom("aria_checked", "aria-checked"),
+    Atom("aria_controls", "aria-controls"),
+    Atom("aria_current", "aria-current"),
+    Atom("aria_describedby", "aria-describedby"),
+    Atom("aria_description", "aria-description"),
+    Atom("aria_disabled", "aria-disabled"),
+    Atom("aria_dropeffect", "aria-dropeffect"),
+    Atom("aria_expanded", "aria-expanded"),
+    Atom("aria_flowto", "aria-flowto"),
+    Atom("aria_haspopup", "aria-haspopup"),
+    Atom("aria_hidden", "aria-hidden"),
+    Atom("aria_invalid", "aria-invalid"),
+    Atom("aria_labelledby", "aria-labelledby"),
+    Atom("aria_level", "aria-level"),
+    Atom("aria_live", "aria-live"),
+    Atom("aria_multiline", "aria-multiline"),
+    Atom("aria_multiselectable", "aria-multiselectable"),
+    Atom("aria_owns", "aria-owns"),
+    Atom("aria_posinset", "aria-posinset"),
+    Atom("aria_pressed", "aria-pressed"),
+    Atom("aria_readonly", "aria-readonly"),
+    Atom("aria_relevant", "aria-relevant"),
+    Atom("aria_required", "aria-required"),
+    Atom("aria_selected", "aria-selected"),
+    Atom("aria_setsize", "aria-setsize"),
+    Atom("aria_sort", "aria-sort"),
+    Atom("aria_valuemax", "aria-valuemax"),
+    Atom("aria_valuemin", "aria-valuemin"),
+    Atom("aria_valuenow", "aria-valuenow"),
+    Atom("arrow", "arrow"),
+    Atom("article", "article"),
+    Atom("as", "as"),
+    Atom("ascending", "ascending"),
+    Atom("aside", "aside"),
+    Atom("aspectRatio", "aspect-ratio"),
+    Atom("async", "async"),
+    Atom("attribute", "attribute"),
+    Atom("attributes", "attributes"),
+    Atom("attributeSet", "attribute-set"),
+    Atom("_auto", "auto"),
+    Atom("autocapitalize", "autocapitalize"),
+    Atom("autocheck", "autocheck"),
+    Atom("autocomplete", "autocomplete"),
+    Atom("autocomplete_richlistbox", "autocomplete-richlistbox"),
+    Atom("autofocus", "autofocus"),
+    Atom("autoplay", "autoplay"),
+    Atom("axis", "axis"),
+    Atom("b", "b"),
+    Atom("background", "background"),
+    Atom("bar", "bar"),
+    Atom("base", "base"),
+    Atom("basefont", "basefont"),
+    Atom("baseline", "baseline"),
+    Atom("bdi", "bdi"),
+    Atom("bdo", "bdo"),
+    Atom("before", "before"),
+    Atom("behavior", "behavior"),
+    Atom("below", "below"),
+    Atom("bgcolor", "bgcolor"),
+    Atom("bgsound", "bgsound"),
+    Atom("big", "big"),
+    Atom("binding", "binding"),
+    Atom("bindings", "bindings"),
+    Atom("bindToUntrustedContent", "bindToUntrustedContent"),
+    Atom("black", "black"),
+    Atom("block", "block"),
+    Atom("block_size", "block-size"),
+    Atom("blockquote", "blockquote"),
+    Atom("blur", "blur"),
+    Atom("body", "body"),
+    Atom("boolean", "boolean"),
+    Atom("border", "border"),
+    Atom("bordercolor", "bordercolor"),
+    Atom("both", "both"),
+    Atom("bottom", "bottom"),
+    Atom("bottomend", "bottomend"),
+    Atom("bottomstart", "bottomstart"),
+    Atom("bottomleft", "bottomleft"),
+    Atom("bottommargin", "bottommargin"),
+    Atom("bottomright", "bottomright"),
+    Atom("box", "box"),
+    Atom("br", "br"),
+    Atom("browser", "browser"),
+    Atom("mozbrowser", "mozbrowser"),
+    Atom("button", "button"),
+    Atom("callTemplate", "call-template"),
+    Atom("canvas", "canvas"),
+    Atom("caption", "caption"),
+    Atom("captionBox", "caption-box"),
+    Atom("capture", "capture"),
+    Atom("caseOrder", "case-order"),
+    Atom("cdataSectionElements", "cdata-section-elements"),
+    Atom("ceiling", "ceiling"),
+    Atom("cell", "cell"),
+    Atom("cellpadding", "cellpadding"),
+    Atom("cellspacing", "cellspacing"),
+    Atom("center", "center"),
+    Atom("change", "change"),
+    Atom("_char", "char"),
+    Atom("characterData", "characterData"),
+    Atom("charcode", "charcode"),
+    Atom("charoff", "charoff"),
+    Atom("charset", "charset"),
+    Atom("checkbox", "checkbox"),
+    Atom("checkboxLabel", "checkbox-label"),
+    Atom("checked", "checked"),
+    Atom("child", "child"),
+    Atom("children", "children"),
+    Atom("childList", "childList"),
+    Atom("child_item_count", "child-item-count"),
+    Atom("choose", "choose"),
+    Atom("chromemargin", "chromemargin"),
+    Atom("exposeToUntrustedContent", "exposeToUntrustedContent"),
+    Atom("circ", "circ"),
+    Atom("circle", "circle"),
+    Atom("cite", "cite"),
+    Atom("_class", "class"),
+    Atom("classid", "classid"),
+    Atom("clear", "clear"),
+    Atom("click", "click"),
+    Atom("clickcount", "clickcount"),
+    Atom("clickthrough", "clickthrough"),
+    Atom("movetoclick", "movetoclick"),
+    Atom("clip", "clip"),
+    Atom("close", "close"),
+    Atom("closed", "closed"),
+    Atom("closemenu", "closemenu"),
+    Atom("code", "code"),
+    Atom("codebase", "codebase"),
+    Atom("codetype", "codetype"),
+    Atom("col", "col"),
+    Atom("colgroup", "colgroup"),
+    Atom("collapse", "collapse"),
+    Atom("collapsed", "collapsed"),
+    Atom("color", "color"),
+    Atom("color_index", "color-index"),
+    Atom("color_scheme", "color-scheme"),
+    Atom("cols", "cols"),
+    Atom("colspan", "colspan"),
+    Atom("combobox", "combobox"),
+    Atom("command", "command"),
+    Atom("commandupdater", "commandupdater"),
+    Atom("comment", "comment"),
+    Atom("compact", "compact"),
+    Atom("concat", "concat"),
+    Atom("constructor", "constructor"),
+    Atom("consumeoutsideclicks", "consumeoutsideclicks"),
+    Atom("container", "container"),
+    Atom("contains", "contains"),
+    Atom("content", "content"),
+    Atom("contenteditable", "contenteditable"),
+    Atom("headerContentDisposition", "content-disposition"),
+    Atom("headerContentLanguage", "content-language"),
+    Atom("contentLocation", "content-location"),
+    Atom("headerContentScriptType", "content-script-type"),
+    Atom("headerContentStyleType", "content-style-type"),
+    Atom("headerContentType", "content-type"),
+    Atom("consumeanchor", "consumeanchor"),
+    Atom("context", "context"),
+    Atom("contextmenu", "contextmenu"),
+    Atom("control", "control"),
+    Atom("controls", "controls"),
+    Atom("coords", "coords"),
+    Atom("copy", "copy"),
+    Atom("copyOf", "copy-of"),
+    Atom("count", "count"),
+    Atom("crop", "crop"),
+    Atom("crossorigin", "crossorigin"),
+    Atom("curpos", "curpos"),
+    Atom("current", "current"),
+    Atom("cutoutregion", "cutoutregion"),
+    Atom("cycler", "cycler"),
+    Atom("dashed", "dashed"),
+    Atom("data", "data"),
+    Atom("dataAtShortcutkeys", "data-at-shortcutkeys"),
+    Atom("datalist", "datalist"),
+    Atom("datal10nid", "data-l10n-id"),
+    Atom("datal10nargs", "data-l10n-args"),
+    Atom("datal10nattrs", "data-l10n-attrs"),
+    Atom("datal10nname", "data-l10n-name"),
+    Atom("datal10nsync", "data-l10n-sync"),
+    Atom("dataType", "data-type"),
+    Atom("dateTime", "date-time"),
+    Atom("date", "date"),
+    Atom("datetime", "datetime"),
+    Atom("datetime_local", "datetime-local"),
+    Atom("datetimeInputBoxWrapper", "datetime-input-box-wrapper"),
+    Atom("datetimeResetButton", "datetime-reset-button"),
+    Atom("dd", "dd"),
+    Atom("decimal", "decimal"),
+    Atom("decimalFormat", "decimal-format"),
+    Atom("decimalSeparator", "decimal-separator"),
+    Atom("declare", "declare"),
+    Atom("decoderDoctor", "decoder-doctor"),
+    Atom("decoding", "decoding"),
+    Atom("decrement", "decrement"),
+    Atom("_default", "default"),
+    Atom("headerDefaultStyle", "default-style"),
+    Atom("defer", "defer"),
+    Atom("del", "del"),
+    Atom("deletion", "deletion"),
+    Atom("deprecation", "deprecation"),
+    Atom("descendant", "descendant"),
+    Atom("descendantOrSelf", "descendant-or-self"),
+    Atom("descending", "descending"),
+    Atom("description", "description"),
+    Atom("destructor", "destructor"),
+    Atom("details", "details"),
+    Atom("deviceAspectRatio", "device-aspect-ratio"),
+    Atom("deviceHeight", "device-height"),
+    Atom("devicePixelRatio", "device-pixel-ratio"),
+    Atom("deviceWidth", "device-width"),
+    Atom("dfn", "dfn"),
+    Atom("dialog", "dialog"),
+    Atom("difference", "difference"),
+    Atom("digit", "digit"),
+    Atom("dir", "dir"),
+    Atom("dirAutoSetBy", "dirAutoSetBy"),
+    Atom("directory", "directory"),
+    Atom("disableOutputEscaping", "disable-output-escaping"),
+    Atom("disabled", "disabled"),
+    Atom("disableglobalhistory", "disableglobalhistory"),
+    Atom("disablehistory", "disablehistory"),
+    Atom("disablefullscreen", "disablefullscreen"),
+    Atom("disclosure_closed", "disclosure-closed"),
+    Atom("disclosure_open", "disclosure-open"),
+    Atom("display", "display"),
+    Atom("displayMode", "display-mode"),
+    Atom("distinct", "distinct"),
+    Atom("div", "div"),
+    Atom("dl", "dl"),
+    Atom("docAbstract", "doc-abstract"),
+    Atom("docAcknowledgments", "doc-acknowledgments"),
+    Atom("docAfterword", "doc-afterword"),
+    Atom("docAppendix", "doc-appendix"),
+    Atom("docBacklink", "doc-backlink"),
+    Atom("docBiblioentry", "doc-biblioentry"),
+    Atom("docBibliography", "doc-bibliography"),
+    Atom("docBiblioref", "doc-biblioref"),
+    Atom("docChapter", "doc-chapter"),
+    Atom("docColophon", "doc-colophon"),
+    Atom("docConclusion", "doc-conclusion"),
+    Atom("docCover", "doc-cover"),
+    Atom("docCredit", "doc-credit"),
+    Atom("docCredits", "doc-credits"),
+    Atom("docDedication", "doc-dedication"),
+    Atom("docEndnote", "doc-endnote"),
+    Atom("docEndnotes", "doc-endnotes"),
+    Atom("docEpigraph", "doc-epigraph"),
+    Atom("docEpilogue", "doc-epilogue"),
+    Atom("docErrata", "doc-errata"),
+    Atom("docExample", "doc-example"),
+    Atom("docFootnote", "doc-footnote"),
+    Atom("docForeword", "doc-foreword"),
+    Atom("docGlossary", "doc-glossary"),
+    Atom("docGlossref", "doc-glossref"),
+    Atom("docIndex", "doc-index"),
+    Atom("docIntroduction", "doc-introduction"),
+    Atom("docNoteref", "doc-noteref"),
+    Atom("docNotice", "doc-notice"),
+    Atom("docPagebreak", "doc-pagebreak"),
+    Atom("docPagelist", "doc-pagelist"),
+    Atom("docPart", "doc-part"),
+    Atom("docPreface", "doc-preface"),
+    Atom("docPrologue", "doc-prologue"),
+    Atom("docPullquote", "doc-pullquote"),
+    Atom("docQna", "doc-qna"),
+    Atom("docSubtitle", "doc-subtitle"),
+    Atom("docTip", "doc-tip"),
+    Atom("docToc", "doc-toc"),
+    Atom("doctypePublic", "doctype-public"),
+    Atom("doctypeSystem", "doctype-system"),
+    Atom("document", "document"),
+    Atom("down", "down"),
+    Atom("download", "download"),
+    Atom("drag", "drag"),
+    Atom("draggable", "draggable"),
+    Atom("dragging", "dragging"),
+    Atom("dragSession", "dragSession"),
+    Atom("drawintitlebar", "drawintitlebar"),
+    Atom("drawtitle", "drawtitle"),
+    Atom("dropAfter", "dropAfter"),
+    Atom("dropBefore", "dropBefore"),
+    Atom("dropOn", "dropOn"),
+    Atom("dropMarker", "dropmarker"),
+    Atom("dt", "dt"),
+    Atom("e", "e"),
+    Atom("editable", "editable"),
+    Atom("editing", "editing"),
+    Atom("editor", "editor"),
+    Atom("element", "element"),
+    Atom("elementAvailable", "element-available"),
+    Atom("elements", "elements"),
+    Atom("em", "em"),
+    Atom("embed", "embed"),
+    Atom("empty", "empty"),
+    Atom("encoding", "encoding"),
+    Atom("enctype", "enctype"),
+    Atom("end", "end"),
+    Atom("endEvent", "endEvent"),
+    Atom("enterkeyhint", "enterkeyhint"),
+    Atom("equalsize", "equalsize"),
+    Atom("error", "error"),
+    Atom("ethiopic_numeric", "ethiopic-numeric"),
+    Atom("even", "even"),
+    Atom("event", "event"),
+    Atom("events", "events"),
+    Atom("excludeResultPrefixes", "exclude-result-prefixes"),
+    Atom("exportparts", "exportparts"),
+    Atom("explicit_name", "explicit-name"),
+    Atom("extends", "extends"),
+    Atom("extensionElementPrefixes", "extension-element-prefixes"),
+    Atom("face", "face"),
+    Atom("fallback", "fallback"),
+    Atom("_false", "false"),
+    Atom("farthest", "farthest"),
+    Atom("featurePolicyViolation", "feature-policy-violation"),
+    Atom("field", "field"),
+    Atom("fieldset", "fieldset"),
+    Atom("file", "file"),
+    Atom("figcaption", "figcaption"),
+    Atom("figure", "figure"),
+    Atom("findbar", "findbar"),
+    Atom("firstInput", "first-input"),
+    Atom("fixed", "fixed"),
+    Atom("flags", "flags"),
+    Atom("flex", "flex"),
+    Atom("flip", "flip"),
+    Atom("floating", "floating"),
+    Atom("floor", "floor"),
+    Atom("flowlength", "flowlength"),
+    Atom("focus", "focus"),
+    Atom("focused", "focused"),
+    Atom("followanchor", "followanchor"),
+    Atom("following", "following"),
+    Atom("followingSibling", "following-sibling"),
+    Atom("font", "font"),
+    Atom("fontWeight", "font-weight"),
+    Atom("footer", "footer"),
+    Atom("_for", "for"),
+    Atom("forEach", "for-each"),
+    Atom("forcedColors", "forced-colors"),
+    Atom("forceOwnRefreshDriver", "forceOwnRefreshDriver"),
+    Atom("form", "form"),
+    Atom("formaction", "formaction"),
+    Atom("format", "format"),
+    Atom("formatNumber", "format-number"),
+    Atom("formenctype", "formenctype"),
+    Atom("formmethod", "formmethod"),
+    Atom("formnovalidate", "formnovalidate"),
+    Atom("formtarget", "formtarget"),
+    Atom("frame", "frame"),
+    Atom("frameborder", "frameborder"),
+    Atom("frameset", "frameset"),
+    Atom("from", "from"),
+    Atom("fullscreenchange", "fullscreenchange"),
+    Atom("fullscreenerror", "fullscreenerror"),
+    Atom("functionAvailable", "function-available"),
+    Atom("generateId", "generate-id"),
+    Atom("getter", "getter"),
+    Atom("graphicsDocument", "graphics-document"),
+    Atom("graphicsObject", "graphics-object"),
+    Atom("graphicsSymbol", "graphics-symbol"),
+    Atom("grid", "grid"),
+    Atom("group", "group"),
+    Atom("groups", "groups"),
+    Atom("groupbox", "groupbox"),
+    Atom("groupingSeparator", "grouping-separator"),
+    Atom("groupingSize", "grouping-size"),
+    Atom("grow", "grow"),
+    Atom("h1", "h1"),
+    Atom("h2", "h2"),
+    Atom("h3", "h3"),
+    Atom("h4", "h4"),
+    Atom("h5", "h5"),
+    Atom("h6", "h6"),
+    Atom("handheldFriendly", "HandheldFriendly"),
+    Atom("handler", "handler"),
+    Atom("handlers", "handlers"),
+    Atom("HARD", "HARD"),
+    Atom("hasSameNode", "has-same-node"),
+    Atom("hbox", "hbox"),
+    Atom("head", "head"),
+    Atom("header", "header"),
+    Atom("headers", "headers"),
+    Atom("hebrew", "hebrew"),
+    Atom("height", "height"),
+    Atom("hgroup", "hgroup"),
+    Atom("hidden", "hidden"),
+    Atom("hidechrome", "hidechrome"),
+    Atom("hidecolumnpicker", "hidecolumnpicker"),
+    Atom("high", "high"),
+    Atom("highest", "highest"),
+    Atom("horizontal", "horizontal"),
+    Atom("hover", "hover"),
+    Atom("hr", "hr"),
+    Atom("href", "href"),
+    Atom("hreflang", "hreflang"),
+    Atom("hsides", "hsides"),
+    Atom("hspace", "hspace"),
+    Atom("html", "html"),
+    Atom("httpEquiv", "http-equiv"),
+    Atom("i", "i"),
+    Atom("icon", "icon"),
+    Atom("id", "id"),
+    Atom("_if", "if"),
+    Atom("iframe", "iframe"),
+    Atom("ignorekeys", "ignorekeys"),
+    Atom("ignoreuserfocus", "ignoreuserfocus"),
+    Atom("image", "image"),
+    Atom("imageClickedPoint", "image-clicked-point"),
+    Atom("imagesizes", "imagesizes"),
+    Atom("imagesrcset", "imagesrcset"),
+    Atom("img", "img"),
+    Atom("implementation", "implementation"),
+    Atom("implements", "implements"),
+    Atom("import", "import"),
+    Atom("include", "include"),
+    Atom("includes", "includes"),
+    Atom("incontentshell", "incontentshell"),
+    Atom("increment", "increment"),
+    Atom("indent", "indent"),
+    Atom("indeterminate", "indeterminate"),
+    Atom("index", "index"),
+    Atom("inert", "inert"),
+    Atom("infinity", "infinity"),
+    Atom("inherits", "inherits"),
+    Atom("inheritOverflow", "inherit-overflow"),
+    Atom("inheritstyle", "inheritstyle"),
+    Atom("initial_scale", "initial-scale"),
+    Atom("input", "input"),
+    Atom("inputmode", "inputmode"),
+    Atom("ins", "ins"),
+    Atom("insertafter", "insertafter"),
+    Atom("insertbefore", "insertbefore"),
+    Atom("insertion", "insertion"),
+    Atom("integer", "integer"),
+    Atom("integrity", "integrity"),
+    Atom("internal", "internal"),
+    Atom("internals", "internals"),
+    Atom("intersection", "intersection"),
+    Atom("intersectionobserverlist", "intersectionobserverlist"),
+    Atom("is", "is"),
+    Atom("ismap", "ismap"),
+    Atom("itemid", "itemid"),
+    Atom("itemprop", "itemprop"),
+    Atom("itemref", "itemref"),
+    Atom("itemscope", "itemscope"),
+    Atom("itemtype", "itemtype"),
+    Atom("japanese_formal", "japanese-formal"),
+    Atom("japanese_informal", "japanese-informal"),
+    Atom("kbd", "kbd"),
+    Atom("keepcurrentinview", "keepcurrentinview"),
+    Atom("keepobjectsalive", "keepobjectsalive"),
+    Atom("key", "key"),
+    Atom("keycode", "keycode"),
+    Atom("keydown", "keydown"),
+    Atom("keygen", "keygen"),
+    Atom("keypress", "keypress"),
+    Atom("keyset", "keyset"),
+    Atom("keysystem", "keysystem"),
+    Atom("keyup", "keyup"),
+    Atom("kind", "kind"),
+    Atom("korean_hangul_formal", "korean-hangul-formal"),
+    Atom("korean_hanja_formal", "korean-hanja-formal"),
+    Atom("korean_hanja_informal", "korean-hanja-informal"),
+    Atom("label", "label"),
+    Atom("lang", "lang"),
+    Atom("language", "language"),
+    Atom("last", "last"),
+    Atom("layer", "layer"),
+    Atom("LayerActivity", "LayerActivity"),
+    Atom("layout_guess", "layout-guess"),
+    Atom("leading", "leading"),
+    Atom("leaf", "leaf"),
+    Atom("left", "left"),
+    Atom("leftmargin", "leftmargin"),
+    Atom("legend", "legend"),
+    Atom("length", "length"),
+    Atom("letterValue", "letter-value"),
+    Atom("level", "level"),
+    Atom("lhs", "lhs"),
+    Atom("li", "li"),
+    Atom("line", "line"),
+    Atom("link", "link"),
+    Atom("linkset", "linkset"),
+    # Atom("list", "list"),  # "list" is present below
+    Atom("listbox", "listbox"),
+    Atom("listener", "listener"),
+    Atom("listheader", "listheader"),
+    Atom("listing", "listing"),
+    Atom("listitem", "listitem"),
+    Atom("load", "load"),
+    Atom("loading", "loading"),
+    Atom("triggeringprincipal", "triggeringprincipal"),
+    Atom("localedir", "localedir"),
+    Atom("localName", "local-name"),
+    Atom("localization", "localization"),
+    Atom("longdesc", "longdesc"),
+    Atom("loop", "loop"),
+    Atom("low", "low"),
+    Atom("lowerFirst", "lower-first"),
+    Atom("lowest", "lowest"),
+    Atom("lowsrc", "lowsrc"),
+    Atom("ltr", "ltr"),
+    Atom("lwtheme", "lwtheme"),
+    Atom("main", "main"),
+    Atom("map", "map"),
+    Atom("manifest", "manifest"),
+    Atom("marginBottom", "margin-bottom"),
+    Atom("marginLeft", "margin-left"),
+    Atom("marginRight", "margin-right"),
+    Atom("marginTop", "margin-top"),
+    Atom("marginheight", "marginheight"),
+    Atom("marginwidth", "marginwidth"),
+    Atom("mark", "mark"),
+    Atom("marquee", "marquee"),
+    Atom("match", "match"),
+    Atom("max", "max"),
+    Atom("maxheight", "maxheight"),
+    Atom("maximum_scale", "maximum-scale"),
+    Atom("maxlength", "maxlength"),
+    Atom("maxpos", "maxpos"),
+    Atom("maxwidth", "maxwidth"),
+    Atom("measure", "measure"),
+    Atom("media", "media"),
+    Atom("mediaType", "media-type"),
+    Atom("menu", "menu"),
+    Atom("menubar", "menubar"),
+    Atom("menucaption", "menucaption"),
+    Atom("menugroup", "menugroup"),
+    Atom("menuitem", "menuitem"),
+    Atom("menulist", "menulist"),
+    Atom("menupopup", "menupopup"),
+    Atom("menuseparator", "menuseparator"),
+    Atom("mesh", "mesh"),
+    Atom("message", "message"),
+    Atom("meta", "meta"),
+    Atom("referrer", "referrer"),
+    Atom("referrerpolicy", "referrerpolicy"),
+    Atom("renderroot", "renderroot"),
+    Atom("headerReferrerPolicy", "referrer-policy"),
+    Atom("meter", "meter"),
+    Atom("method", "method"),
+    Atom("middle", "middle"),
+    Atom("min", "min"),
+    Atom("minheight", "minheight"),
+    Atom("minimum_scale", "minimum-scale"),
+    Atom("minlength", "minlength"),
+    Atom("minpos", "minpos"),
+    Atom("minusSign", "minus-sign"),
+    Atom("minwidth", "minwidth"),
+    Atom("mixed", "mixed"),
+    Atom("messagemanagergroup", "messagemanagergroup"),
+    Atom("mod", "mod"),
+    Atom("mode", "mode"),
+    Atom("modifiers", "modifiers"),
+    Atom("monochrome", "monochrome"),
+    Atom("mouseover", "mouseover"),
+    Atom("mozAccessiblecaret", "moz-accessiblecaret"),
+    Atom("mozCustomContentContainer", "moz-custom-content-container"),
+    Atom("mozGrabber", "mozGrabber"),
+    Atom("mozNativeAnonymous", "-moz-native-anonymous"),
+    Atom("mozprivatebrowsing", "mozprivatebrowsing"),
+    Atom("mozResizer", "mozResizer"),
+    Atom("mozResizingInfo", "mozResizingInfo"),
+    Atom("mozResizingShadow", "mozResizingShadow"),
+    Atom("mozTableAddColumnAfter", "mozTableAddColumnAfter"),
+    Atom("mozTableAddColumnBefore", "mozTableAddColumnBefore"),
+    Atom("mozTableAddRowAfter", "mozTableAddRowAfter"),
+    Atom("mozTableAddRowBefore", "mozTableAddRowBefore"),
+    Atom("mozTableRemoveRow", "mozTableRemoveRow"),
+    Atom("mozTableRemoveColumn", "mozTableRemoveColumn"),
+    Atom("moz_opaque", "moz-opaque"),
+    Atom("moz_action_hint", "mozactionhint"),
+    Atom("multicol", "multicol"),
+    Atom("multiple", "multiple"),
+    Atom("muted", "muted"),
+    Atom("name", "name"),
+    Atom("_namespace", "namespace"),
+    Atom("namespaceAlias", "namespace-alias"),
+    Atom("namespaceUri", "namespace-uri"),
+    Atom("NaN", "NaN"),
+    Atom("n", "n"),
+    Atom("nativeAnonymousChildList", "nativeAnonymousChildList"),
+    Atom("nav", "nav"),
+    Atom("ne", "ne"),
+    Atom("never", "never"),
+    Atom("_new", "new"),
+    Atom("newline", "newline"),
+    Atom("nextRemoteTabId", "nextRemoteTabId"),
+    Atom("no", "no"),
+    Atom("noautofocus", "noautofocus"),
+    Atom("noautohide", "noautohide"),
+    Atom("norolluponanchor", "norolluponanchor"),
+    Atom("noBar", "no-bar"),
+    Atom("nobr", "nobr"),
+    Atom("nodefaultsrc", "nodefaultsrc"),
+    Atom("nodeSet", "node-set"),
+    Atom("noembed", "noembed"),
+    Atom("noframes", "noframes"),
+    Atom("nohref", "nohref"),
+    Atom("nomodule", "nomodule"),
+    Atom("nonce", "nonce"),
+    Atom("none", "none"),
+    Atom("noresize", "noresize"),
+    Atom("normal", "normal"),
+    Atom("normalizeSpace", "normalize-space"),
+    Atom("noscript", "noscript"),
+    Atom("noshade", "noshade"),
+    Atom("notification", "notification"),
+    Atom("novalidate", "novalidate"),
+    Atom("_not", "not"),
+    Atom("nowrap", "nowrap"),
+    Atom("number", "number"),
+    Atom("nw", "nw"),
+    Atom("object", "object"),
+    Atom("objectType", "object-type"),
+    Atom("observes", "observes"),
+    Atom("odd", "odd"),
+    Atom("OFF", "OFF"),
+    Atom("ol", "ol"),
+    Atom("omitXmlDeclaration", "omit-xml-declaration"),
+    Atom("onabort", "onabort"),
+    Atom("onmozaccesskeynotfound", "onmozaccesskeynotfound"),
+    Atom("onactivate", "onactivate"),
+    Atom("onafterprint", "onafterprint"),
+    Atom("onafterscriptexecute", "onafterscriptexecute"),
+    Atom("onanimationcancel", "onanimationcancel"),
+    Atom("onanimationend", "onanimationend"),
+    Atom("onanimationiteration", "onanimationiteration"),
+    Atom("onanimationstart", "onanimationstart"),
+    Atom("onAppCommand", "onAppCommand"),
+    Atom("onaudioprocess", "onaudioprocess"),
+    Atom("onauxclick", "onauxclick"),
+    Atom("onbeforecopy", "onbeforecopy"),
+    Atom("onbeforecut", "onbeforecut"),
+    Atom("onbeforeinput", "onbeforeinput"),
+    Atom("onbeforepaste", "onbeforepaste"),
+    Atom("onbeforeprint", "onbeforeprint"),
+    Atom("onbeforescriptexecute", "onbeforescriptexecute"),
+    Atom("onbeforeunload", "onbeforeunload"),
+    Atom("onblocked", "onblocked"),
+    Atom("onblur", "onblur"),
+    Atom("onbounce", "onbounce"),
+    Atom("onboundschange", "onboundschange"),
+    Atom("onbroadcast", "onbroadcast"),
+    Atom("onbufferedamountlow", "onbufferedamountlow"),
+    Atom("oncached", "oncached"),
+    Atom("oncancel", "oncancel"),
+    Atom("onchange", "onchange"),
+    Atom("onchargingchange", "onchargingchange"),
+    Atom("onchargingtimechange", "onchargingtimechange"),
+    Atom("onchecking", "onchecking"),
+    Atom("onCheckboxStateChange", "onCheckboxStateChange"),
+    Atom("onCheckKeyPressEventModel", "onCheckKeyPressEventModel"),
+    Atom("onclick", "onclick"),
+    Atom("onclose", "onclose"),
+    Atom("oncommand", "oncommand"),
+    Atom("oncommandupdate", "oncommandupdate"),
+    Atom("oncomplete", "oncomplete"),
+    Atom("oncompositionend", "oncompositionend"),
+    Atom("oncompositionstart", "oncompositionstart"),
+    Atom("oncompositionupdate", "oncompositionupdate"),
+    Atom("onconnect", "onconnect"),
+    Atom("onconnectionavailable", "onconnectionavailable"),
+    Atom("oncontextmenu", "oncontextmenu"),
+    Atom("oncontextlost", "oncontextlost"),
+    Atom("oncontextrestored", "oncontextrestored"),
+    Atom("oncopy", "oncopy"),
+    Atom("oncut", "oncut"),
+    Atom("ondblclick", "ondblclick"),
+    Atom("ondischargingtimechange", "ondischargingtimechange"),
+    Atom("ondownloading", "ondownloading"),
+    Atom("onDOMActivate", "onDOMActivate"),
+    Atom("onDOMAttrModified", "onDOMAttrModified"),
+    Atom("onDOMCharacterDataModified", "onDOMCharacterDataModified"),
+    Atom("onDOMFocusIn", "onDOMFocusIn"),
+    Atom("onDOMFocusOut", "onDOMFocusOut"),
+    Atom("onDOMMouseScroll", "onDOMMouseScroll"),
+    Atom("onDOMNodeInserted", "onDOMNodeInserted"),
+    Atom("onDOMNodeInsertedIntoDocument", "onDOMNodeInsertedIntoDocument"),
+    Atom("onDOMNodeRemoved", "onDOMNodeRemoved"),
+    Atom("onDOMNodeRemovedFromDocument", "onDOMNodeRemovedFromDocument"),
+    Atom("onDOMSubtreeModified", "onDOMSubtreeModified"),
+    Atom("ondata", "ondata"),
+    Atom("ondrag", "ondrag"),
+    Atom("ondragdrop", "ondragdrop"),
+    Atom("ondragend", "ondragend"),
+    Atom("ondragenter", "ondragenter"),
+    Atom("ondragexit", "ondragexit"),
+    Atom("ondragleave", "ondragleave"),
+    Atom("ondragover", "ondragover"),
+    Atom("ondragstart", "ondragstart"),
+    Atom("ondrain", "ondrain"),
+    Atom("ondrop", "ondrop"),
+    Atom("onerror", "onerror"),
+    Atom("onfinish", "onfinish"),
+    Atom("onfocus", "onfocus"),
+    Atom("onfocusin", "onfocusin"),
+    Atom("onfocusout", "onfocusout"),
+    Atom("onfullscreenchange", "onfullscreenchange"),
+    Atom("onfullscreenerror", "onfullscreenerror"),
+    Atom("onget", "onget"),
+    Atom("onhashchange", "onhashchange"),
+    Atom("oninput", "oninput"),
+    Atom("oninputsourceschange", "oninputsourceschange"),
+    Atom("oninstall", "oninstall"),
+    Atom("oninvalid", "oninvalid"),
+    Atom("onkeydown", "onkeydown"),
+    Atom("onkeypress", "onkeypress"),
+    Atom("onkeyup", "onkeyup"),
+    Atom("onlanguagechange", "onlanguagechange"),
+    Atom("onlevelchange", "onlevelchange"),
+    Atom("onload", "onload"),
+    Atom("onloading", "onloading"),
+    Atom("onloadingdone", "onloadingdone"),
+    Atom("onloadingerror", "onloadingerror"),
+    Atom("onpopstate", "onpopstate"),
+    Atom("only", "only"),  # this one is not an event
+    Atom("onmerchantvalidation", "onmerchantvalidation"),
+    Atom("onmessage", "onmessage"),
+    Atom("onmessageerror", "onmessageerror"),
+    Atom("onmidimessage", "onmidimessage"),
+    Atom("onmousedown", "onmousedown"),
+    Atom("onmouseenter", "onmouseenter"),
+    Atom("onmouseleave", "onmouseleave"),
+    Atom("onmouselongtap", "onmouselongtap"),
+    Atom("onmousemove", "onmousemove"),
+    Atom("onmouseout", "onmouseout"),
+    Atom("onmouseover", "onmouseover"),
+    Atom("onMozMouseHittest", "onMozMouseHittest"),
+    Atom("onMozMouseExploreByTouch", "onMozMouseExploreByTouch"),
+    Atom("onmouseup", "onmouseup"),
+    Atom("onMozAfterPaint", "onMozAfterPaint"),
+    Atom("onmozfullscreenchange", "onmozfullscreenchange"),
+    Atom("onmozfullscreenerror", "onmozfullscreenerror"),
+    Atom("onmozpointerlockchange", "onmozpointerlockchange"),
+    Atom("onmozpointerlockerror", "onmozpointerlockerror"),
+    Atom("onMozMousePixelScroll", "onMozMousePixelScroll"),
+    Atom("onMozScrolledAreaChanged", "onMozScrolledAreaChanged"),
+    Atom("onmute", "onmute"),
+    Atom("onnotificationclick", "onnotificationclick"),
+    Atom("onnotificationclose", "onnotificationclose"),
+    Atom("onnoupdate", "onnoupdate"),
+    Atom("onobsolete", "onobsolete"),
+    Atom("ononline", "ononline"),
+    Atom("onoffline", "onoffline"),
+    Atom("onopen", "onopen"),
+    Atom("onorientationchange", "onorientationchange"),
+    Atom("onoverflow", "onoverflow"),
+    Atom("onpagehide", "onpagehide"),
+    Atom("onpageshow", "onpageshow"),
+    Atom("onpaste", "onpaste"),
+    Atom("onpayerdetailchange", "onpayerdetailchange"),
+    Atom("onpaymentmethodchange", "onpaymentmethodchange"),
+    Atom("onpointerlockchange", "onpointerlockchange"),
+    Atom("onpointerlockerror", "onpointerlockerror"),
+    Atom("onpopuphidden", "onpopuphidden"),
+    Atom("onpopuphiding", "onpopuphiding"),
+    Atom("onpopuppositioned", "onpopuppositioned"),
+    Atom("onpopupshowing", "onpopupshowing"),
+    Atom("onpopupshown", "onpopupshown"),
+    Atom("onprocessorerror", "onprocessorerror"),
+    Atom("onprioritychange", "onprioritychange"),
+    Atom("onpush", "onpush"),
+    Atom("onpushsubscriptionchange", "onpushsubscriptionchange"),
+    Atom("onRadioStateChange", "onRadioStateChange"),
+    Atom("onreadystatechange", "onreadystatechange"),
+    Atom("onrejectionhandled", "onrejectionhandled"),
+    Atom("onremove", "onremove"),
+    Atom("onrequestprogress", "onrequestprogress"),
+    Atom("onresourcetimingbufferfull", "onresourcetimingbufferfull"),
+    Atom("onresponseprogress", "onresponseprogress"),
+    Atom("onRequest", "onRequest"),
+    Atom("onreset", "onreset"),
+    Atom("onresize", "onresize"),
+    Atom("onscroll", "onscroll"),
+    Atom("onsecuritypolicyviolation", "onsecuritypolicyviolation"),
+    Atom("onselect", "onselect"),
+    Atom("onselectionchange", "onselectionchange"),
+    Atom("onselectend", "onselectend"),
+    Atom("onselectstart", "onselectstart"),
+    Atom("onset", "onset"),
+    Atom("onshippingaddresschange", "onshippingaddresschange"),
+    Atom("onshippingoptionchange", "onshippingoptionchange"),
+    Atom("onshow", "onshow"),
+    Atom("onslotchange", "onslotchange"),
+    Atom("onsqueeze", "onsqueeze"),
+    Atom("onsqueezeend", "onsqueezeend"),
+    Atom("onsqueezestart", "onsqueezestart"),
+    Atom("onstatechange", "onstatechange"),
+    Atom("onstorage", "onstorage"),
+    Atom("onsubmit", "onsubmit"),
+    Atom("onsuccess", "onsuccess"),
+    Atom("onsystemstatusbarclick", "onsystemstatusbarclick"),
+    Atom("ontypechange", "ontypechange"),
+    Atom("onterminate", "onterminate"),
+    Atom("ontext", "ontext"),
+    Atom("ontoggle", "ontoggle"),
+    Atom("ontonechange", "ontonechange"),
+    Atom("ontouchstart", "ontouchstart"),
+    Atom("ontouchend", "ontouchend"),
+    Atom("ontouchmove", "ontouchmove"),
+    Atom("ontouchcancel", "ontouchcancel"),
+    Atom("ontransitioncancel", "ontransitioncancel"),
+    Atom("ontransitionend", "ontransitionend"),
+    Atom("ontransitionrun", "ontransitionrun"),
+    Atom("ontransitionstart", "ontransitionstart"),
+    Atom("onuncapturederror", "onuncapturederror"),
+    Atom("onunderflow", "onunderflow"),
+    Atom("onunhandledrejection", "onunhandledrejection"),
+    Atom("onunload", "onunload"),
+    Atom("onunmute", "onunmute"),
+    Atom("onupdatefound", "onupdatefound"),
+    Atom("onupdateready", "onupdateready"),
+    Atom("onupgradeneeded", "onupgradeneeded"),
+    Atom("onversionchange", "onversionchange"),
+    Atom("onvisibilitychange", "onvisibilitychange"),
+    Atom("onvoiceschanged", "onvoiceschanged"),
+    Atom("onvrdisplayactivate", "onvrdisplayactivate"),
+    Atom("onvrdisplayconnect", "onvrdisplayconnect"),
+    Atom("onvrdisplaydeactivate", "onvrdisplaydeactivate"),
+    Atom("onvrdisplaydisconnect", "onvrdisplaydisconnect"),
+    Atom("onvrdisplaypresentchange", "onvrdisplaypresentchange"),
+    Atom("onwebkitAnimationEnd", "onwebkitAnimationEnd"),
+    Atom("onwebkitAnimationIteration", "onwebkitAnimationIteration"),
+    Atom("onwebkitAnimationStart", "onwebkitAnimationStart"),
+    Atom("onwebkitTransitionEnd", "onwebkitTransitionEnd"),
+    Atom("onwebkitanimationend", "onwebkitanimationend"),
+    Atom("onwebkitanimationiteration", "onwebkitanimationiteration"),
+    Atom("onwebkitanimationstart", "onwebkitanimationstart"),
+    Atom("onwebkittransitionend", "onwebkittransitionend"),
+    Atom("onwheel", "onwheel"),
+    Atom("open", "open"),
+    Atom("optgroup", "optgroup"),
+    Atom("optimum", "optimum"),
+    Atom("option", "option"),
+    Atom("_or", "or"),
+    Atom("order", "order"),
+    Atom("orient", "orient"),
+    Atom("orientation", "orientation"),
+    Atom("origin_trial", "origin-trial"),
+    Atom("otherwise", "otherwise"),
+    Atom("output", "output"),
+    Atom("overflow", "overflow"),
+    Atom("overflowBlock", "overflow-block"),
+    Atom("overflowInline", "overflow-inline"),
+    Atom("overlay", "overlay"),
+    Atom("p", "p"),
+    Atom("pack", "pack"),
+    Atom("page", "page"),
+    Atom("pageincrement", "pageincrement"),
+    Atom("paint", "paint"),
+    Atom("paint_order", "paint-order"),
+    Atom("panel", "panel"),
+    Atom("paragraph", "paragraph"),
+    Atom("param", "param"),
+    Atom("parameter", "parameter"),
+    Atom("parent", "parent"),
+    Atom("parentfocused", "parentfocused"),
+    Atom("parsererror", "parsererror"),
+    Atom("part", "part"),
+    Atom("password", "password"),
+    Atom("pattern", "pattern"),
+    Atom("patternSeparator", "pattern-separator"),
+    Atom("perMille", "per-mille"),
+    Atom("percent", "percent"),
+    Atom("persist", "persist"),
+    Atom("phase", "phase"),
+    Atom("picture", "picture"),
+    Atom("ping", "ping"),
+    Atom("pinned", "pinned"),
+    Atom("placeholder", "placeholder"),
+    Atom("plaintext", "plaintext"),
+    Atom("playbackrate", "playbackrate"),
+    Atom("pointSize", "point-size"),
+    Atom("poly", "poly"),
+    Atom("polygon", "polygon"),
+    Atom("popup", "popup"),
+    Atom("popupalign", "popupalign"),
+    Atom("popupanchor", "popupanchor"),
+    Atom("popupgroup", "popupgroup"),
+    Atom("popupset", "popupset"),
+    Atom("popupsinherittooltip", "popupsinherittooltip"),
+    Atom("position", "position"),
+    Atom("poster", "poster"),
+    Atom("pre", "pre"),
+    Atom("preceding", "preceding"),
+    Atom("precedingSibling", "preceding-sibling"),
+    Atom("prefersReducedMotion", "prefers-reduced-motion"),
+    Atom("prefersColorScheme", "prefers-color-scheme"),
+    Atom("prefersContrast", "prefers-contrast"),
+    Atom("dynamicRange", "dynamic-range"),
+    Atom("videoDynamicRange", "video-dynamic-range"),
+    Atom("prefix", "prefix"),
+    Atom("preload", "preload"),
+    Atom("preserve", "preserve"),
+    Atom("preserveSpace", "preserve-space"),
+    Atom("preventdefault", "preventdefault"),
+    Atom("previewDiv", "preview-div"),
+    Atom("primary", "primary"),
+    Atom("print", "print"),
+    Atom("printselectionranges", "printselectionranges"),
+    Atom("priority", "priority"),
+    Atom("processingInstruction", "processing-instruction"),
+    Atom("profile", "profile"),
+    Atom("progress", "progress"),
+    Atom("prompt", "prompt"),
+    Atom("properties", "properties"),
+    Atom("property", "property"),
+    Atom("pubdate", "pubdate"),
+    Atom("q", "q"),
+    Atom("radio", "radio"),
+    Atom("radioLabel", "radio-label"),
+    Atom("radiogroup", "radiogroup"),
+    Atom("range", "range"),
+    Atom("readonly", "readonly"),
+    Atom("rect", "rect"),
+    Atom("rectangle", "rectangle"),
+    Atom("refresh", "refresh"),
+    Atom("rel", "rel"),
+    Atom("relativeBounds", "relative-bounds"),
+    Atom("rem", "rem"),
+    Atom("remote", "remote"),
+    Atom("removeelement", "removeelement"),
+    Atom("renderingobserverset", "renderingobserverset"),
+    Atom("repeat", "repeat"),
+    Atom("replace", "replace"),
+    Atom("requestcontextid", "requestcontextid"),
+    Atom("required", "required"),
+    Atom("reserved", "reserved"),
+    Atom("reset", "reset"),
+    Atom("resizeafter", "resizeafter"),
+    Atom("resizebefore", "resizebefore"),
+    Atom("resizer", "resizer"),
+    Atom("resolution", "resolution"),
+    Atom("resources", "resources"),
+    Atom("result", "result"),
+    Atom("resultPrefix", "result-prefix"),
+    Atom("retargetdocumentfocus", "retargetdocumentfocus"),
+    Atom("rev", "rev"),
+    Atom("reverse", "reverse"),
+    Atom("reversed", "reversed"),
+    Atom("rhs", "rhs"),
+    Atom("richlistbox", "richlistbox"),
+    Atom("richlistitem", "richlistitem"),
+    Atom("right", "right"),
+    Atom("rightmargin", "rightmargin"),
+    Atom("role", "role"),
+    Atom("rolluponmousewheel", "rolluponmousewheel"),
+    Atom("round", "round"),
+    Atom("row", "row"),
+    Atom("rows", "rows"),
+    Atom("rowspan", "rowspan"),
+    Atom("rb", "rb"),
+    Atom("rp", "rp"),
+    Atom("rt", "rt"),
+    Atom("rtc", "rtc"),
+    Atom("rtl", "rtl"),
+    Atom("ruby", "ruby"),
+    Atom("rubyBase", "ruby-base"),
+    Atom("rubyBaseContainer", "ruby-base-container"),
+    Atom("rubyText", "ruby-text"),
+    Atom("rubyTextContainer", "ruby-text-container"),
+    Atom("rules", "rules"),
+    Atom("s", "s"),
+    Atom("safe_area_inset_top", "safe-area-inset-top"),
+    Atom("safe_area_inset_bottom", "safe-area-inset-bottom"),
+    Atom("safe_area_inset_left", "safe-area-inset-left"),
+    Atom("safe_area_inset_right", "safe-area-inset-right"),
+    Atom("samp", "samp"),
+    Atom("sandbox", "sandbox"),
+    Atom("sbattr", "sbattr"),
+    Atom("scale", "scale"),
+    Atom("scan", "scan"),
+    Atom("scheme", "scheme"),
+    Atom("scope", "scope"),
+    Atom("scoped", "scoped"),
+    Atom("screen", "screen"),
+    Atom("screenX", "screenX"),
+    Atom("screenY", "screenY"),
+    Atom("script", "script"),
+    Atom("scrollbar", "scrollbar"),
+    Atom("scrollbarThumb", "scrollbar-thumb"),
+    Atom("scrollamount", "scrollamount"),
+    Atom("scrollbarbutton", "scrollbarbutton"),
+    Atom("scrollbarDownBottom", "scrollbar-down-bottom"),
+    Atom("scrollbarDownTop", "scrollbar-down-top"),
+    Atom("scrollbarUpBottom", "scrollbar-up-bottom"),
+    Atom("scrollbarUpTop", "scrollbar-up-top"),
+    Atom("scrollbox", "scrollbox"),
+    Atom("scrollcorner", "scrollcorner"),
+    Atom("scrolldelay", "scrolldelay"),
+    Atom("scrolling", "scrolling"),
+    Atom("scrollPosition", "scroll-position"),
+    Atom("se", "se"),
+    Atom("section", "section"),
+    Atom("select", "select"),
+    Atom("selected", "selected"),
+    Atom("selectedIndex", "selectedIndex"),
+    Atom("selectedindex", "selectedindex"),
+    Atom("self", "self"),
+    Atom("seltype", "seltype"),
+    Atom("setcookie", "set-cookie"),
+    Atom("setter", "setter"),
+    Atom("shadow", "shadow"),
+    Atom("shape", "shape"),
+    Atom("show", "show"),
+    Atom("showcaret", "showcaret"),
+    Atom("simple", "simple"),
+    Atom("simp_chinese_formal", "simp-chinese-formal"),
+    Atom("simp_chinese_informal", "simp-chinese-informal"),
+    Atom("single", "single"),
+    Atom("size", "size"),
+    Atom("sizes", "sizes"),
+    Atom("sizemode", "sizemode"),
+    Atom("sizetopopup", "sizetopopup"),
+    Atom("slider", "slider"),
+    Atom("small", "small"),
+    Atom("smooth", "smooth"),
+    Atom("snap", "snap"),
+    Atom("solid", "solid"),
+    Atom("sort", "sort"),
+    Atom("sortActive", "sortActive"),
+    Atom("sortDirection", "sortDirection"),
+    Atom("sorted", "sorted"),
+    Atom("sorthints", "sorthints"),
+    Atom("source", "source"),
+    Atom("sourcetext", "sourcetext"),
+    Atom("space", "space"),
+    Atom("spacer", "spacer"),
+    Atom("span", "span"),
+    Atom("spellcheck", "spellcheck"),
+    Atom("split", "split"),
+    Atom("splitter", "splitter"),
+    Atom("square", "square"),
+    Atom("src", "src"),
+    Atom("srcdoc", "srcdoc"),
+    Atom("srclang", "srclang"),
+    Atom("srcset", "srcset"),
+    Atom("standalone", "standalone"),
+    Atom("standby", "standby"),
+    Atom("start", "start"),
+    Atom("startsWith", "starts-with"),
+    Atom("state", "state"),
+    Atom("statusbar", "statusbar"),
+    Atom("step", "step"),
+    Atom("stop", "stop"),
+    Atom("stretch", "stretch"),
+    Atom("strike", "strike"),
+    Atom("string", "string"),
+    Atom("stringLength", "string-length"),
+    Atom("stripSpace", "strip-space"),
+    Atom("strong", "strong"),
+    Atom("style", "style"),
+    Atom("stylesheet", "stylesheet"),
+    Atom("stylesheetPrefix", "stylesheet-prefix"),
+    Atom("submit", "submit"),
+    Atom("substate", "substate"),
+    Atom("substring", "substring"),
+    Atom("substringAfter", "substring-after"),
+    Atom("substringBefore", "substring-before"),
+    Atom("sub", "sub"),
+    Atom("suggestion", "suggestion"),
+    Atom("sum", "sum"),
+    Atom("sup", "sup"),
+    Atom("summary", "summary"),
+    Atom("sw", "sw"),
+    # Atom("_switch", "switch"),  # "switch" is present below
+    Atom("systemProperty", "system-property"),
+    Atom("tab", "tab"),
+    Atom("tabindex", "tabindex"),
+    Atom("table", "table"),
+    Atom("tabpanel", "tabpanel"),
+    Atom("tabpanels", "tabpanels"),
+    Atom("tag", "tag"),
+    Atom("target", "target"),
+    Atom("targets", "targets"),
+    Atom("tbody", "tbody"),
+    Atom("td", "td"),
+    Atom("_template", "template"),
+    Atom("text_decoration", "text-decoration"),
+    Atom("terminate", "terminate"),
+    Atom("term", "term"),
+    Atom("test", "test"),
+    Atom("text", "text"),
+    Atom("textAlign", "text-align"),
+    Atom("textarea", "textarea"),
+    Atom("textbox", "textbox"),
+    Atom("textLink", "text-link"),
+    Atom("textNodeDirectionalityMap", "textNodeDirectionalityMap"),
+    Atom("textOverlay", "text-overlay"),
+    Atom("tfoot", "tfoot"),
+    Atom("th", "th"),
+    Atom("thead", "thead"),
+    Atom("thumb", "thumb"),
+    Atom("time", "time"),
+    Atom("title", "title"),
+    Atom("titlebar", "titlebar"),
+    Atom("titlebar_button","titlebar-btn"),
+    Atom("titletip", "titletip"),
+    Atom("token", "token"),
+    Atom("tokenize", "tokenize"),
+    Atom("toolbar", "toolbar"),
+    Atom("toolbarbutton", "toolbarbutton"),
+    Atom("toolbaritem", "toolbaritem"),
+    Atom("toolbarpaletteitem", "toolbarpaletteitem"),
+    Atom("toolbox", "toolbox"),
+    Atom("tooltip", "tooltip"),
+    Atom("tooltiptext", "tooltiptext"),
+    Atom("top", "top"),
+    Atom("topleft", "topleft"),
+    Atom("topmargin", "topmargin"),
+    Atom("topright", "topright"),
+    Atom("tr", "tr"),
+    Atom("track", "track"),
+    Atom("trad_chinese_formal", "trad-chinese-formal"),
+    Atom("trad_chinese_informal", "trad-chinese-informal"),
+    Atom("trailing", "trailing"),
+    Atom("transform", "transform"),
+    Atom("transform_3d", "transform-3d"),
+    Atom("transformiix", "transformiix"),
+    Atom("translate", "translate"),
+    Atom("transparent", "transparent"),
+    Atom("tree", "tree"),
+    Atom("treecell", "treecell"),
+    Atom("treechildren", "treechildren"),
+    Atom("treecol", "treecol"),
+    Atom("treecolpicker", "treecolpicker"),
+    Atom("treecols", "treecols"),
+    Atom("treeitem", "treeitem"),
+    Atom("treerow", "treerow"),
+    Atom("treeseparator", "treeseparator"),
+    Atom("_true", "true"),
+    Atom("truespeed", "truespeed"),
+    Atom("tt", "tt"),
+    Atom("type", "type"),
+    Atom("u", "u"),
+    Atom("ul", "ul"),
+    Atom("unparsedEntityUri", "unparsed-entity-uri"),
+    Atom("up", "up"),
+    Atom("upperFirst", "upper-first"),
+    Atom("use", "use"),
+    Atom("useAttributeSets", "use-attribute-sets"),
+    Atom("usemap", "usemap"),
+    Atom("user_scalable", "user-scalable"),
+    Atom("validate", "validate"),
+    Atom("valign", "valign"),
+    Atom("value", "value"),
+    Atom("values", "values"),
+    Atom("valueOf", "value-of"),
+    Atom("valuetype", "valuetype"),
+    Atom("var", "var"),
+    Atom("variable", "variable"),
+    Atom("vendor", "vendor"),
+    Atom("vendorUrl", "vendor-url"),
+    Atom("version", "version"),
+    Atom("vertical", "vertical"),
+    Atom("audio", "audio"),
+    Atom("video", "video"),
+    Atom("viewport", "viewport"),
+    Atom("viewport_fit", "viewport-fit"),
+    Atom("viewport_height", "viewport-height"),
+    Atom("viewport_initial_scale", "viewport-initial-scale"),
+    Atom("viewport_maximum_scale", "viewport-maximum-scale"),
+    Atom("viewport_minimum_scale", "viewport-minimum-scale"),
+    Atom("viewport_user_scalable", "viewport-user-scalable"),
+    Atom("viewport_width", "viewport-width"),
+    Atom("visibility", "visibility"),
+    Atom("visuallyselected", "visuallyselected"),
+    Atom("vlink", "vlink"),
+    Atom("_void", "void"),
+    Atom("vsides", "vsides"),
+    Atom("vspace", "vspace"),
+    Atom("w", "w"),
+    Atom("wbr", "wbr"),
+    Atom("webkitdirectory", "webkitdirectory"),
+    Atom("when", "when"),
+    Atom("white", "white"),
+    Atom("width", "width"),
+    Atom("willChange", "will-change"),
+    Atom("window", "window"),
+    Atom("headerWindowTarget", "window-target"),
+    Atom("windowtype", "windowtype"),
+    Atom("withParam", "with-param"),
+    Atom("wrap", "wrap"),
+    Atom("headerDNSPrefetchControl", "x-dns-prefetch-control"),
+    Atom("headerCSP", "content-security-policy"),
+    Atom("headerCSPReportOnly", "content-security-policy-report-only"),
+    Atom("headerXFO", "x-frame-options"),
+    Atom("x_western", "x-western"),
+    Atom("xml", "xml"),
+    Atom("xml_stylesheet", "xml-stylesheet"),
+    Atom("xmlns", "xmlns"),
+    Atom("xmp", "xmp"),
+    Atom("xul", "xul"),
+    Atom("yes", "yes"),
+    Atom("z_index", "z-index"),
+    Atom("zeroDigit", "zero-digit"),
+    Atom("zlevel", "zlevel"),
+    Atom("percentage", "%"),
+    Atom("A", "A"),
+    Atom("alignment_baseline", "alignment-baseline"),
+    Atom("amplitude", "amplitude"),
+    Atom("animate", "animate"),
+    Atom("animateColor", "animateColor"),
+    Atom("animateMotion", "animateMotion"),
+    Atom("animateTransform", "animateTransform"),
+    Atom("arithmetic", "arithmetic"),
+    Atom("atop", "atop"),
+    Atom("azimuth", "azimuth"),
+    Atom("B", "B"),
+    Atom("backgroundColor", "background-color"),
+    Atom("background_image", "background-image"),
+    Atom("baseFrequency", "baseFrequency"),
+    Atom("baseline_shift", "baseline-shift"),
+    Atom("bias", "bias"),
+    Atom("caption_side", "caption-side"),
+    Atom("clip_path", "clip-path"),
+    Atom("clip_rule", "clip-rule"),
+    Atom("clipPath", "clipPath"),
+    Atom("clipPathUnits", "clipPathUnits"),
+    Atom("cm", "cm"),
+    Atom("colorBurn", "color-burn"),
+    Atom("colorDodge", "color-dodge"),
+    Atom("colorInterpolation", "color-interpolation"),
+    Atom("colorInterpolationFilters", "color-interpolation-filters"),
+    Atom("colorProfile", "color-profile"),
+    Atom("cursor", "cursor"),
+    Atom("cx", "cx"),
+    Atom("cy", "cy"),
+    Atom("d", "d"),
+    Atom("darken", "darken"),
+    Atom("defs", "defs"),
+    Atom("deg", "deg"),
+    Atom("desc", "desc"),
+    Atom("diffuseConstant", "diffuseConstant"),
+    Atom("dilate", "dilate"),
+    Atom("direction", "direction"),
+    Atom("disable", "disable"),
+    Atom("disc", "disc"),
+    Atom("discrete", "discrete"),
+    Atom("divisor", "divisor"),
+    Atom("dominant_baseline", "dominant-baseline"),
+    Atom("duplicate", "duplicate"),
+    Atom("dx", "dx"),
+    Atom("dy", "dy"),
+    Atom("edgeMode", "edgeMode"),
+    Atom("ellipse", "ellipse"),
+    Atom("elevation", "elevation"),
+    Atom("erode", "erode"),
+    Atom("ex", "ex"),
+    Atom("exact", "exact"),
+    Atom("exclusion", "exclusion"),
+    Atom("exponent", "exponent"),
+    Atom("feBlend", "feBlend"),
+    Atom("feColorMatrix", "feColorMatrix"),
+    Atom("feComponentTransfer", "feComponentTransfer"),
+    Atom("feComposite", "feComposite"),
+    Atom("feConvolveMatrix", "feConvolveMatrix"),
+    Atom("feDiffuseLighting", "feDiffuseLighting"),
+    Atom("feDisplacementMap", "feDisplacementMap"),
+    Atom("feDistantLight", "feDistantLight"),
+    Atom("feDropShadow", "feDropShadow"),
+    Atom("feFlood", "feFlood"),
+    Atom("feFuncA", "feFuncA"),
+    Atom("feFuncB", "feFuncB"),
+    Atom("feFuncG", "feFuncG"),
+    Atom("feFuncR", "feFuncR"),
+    Atom("feGaussianBlur", "feGaussianBlur"),
+    Atom("feImage", "feImage"),
+    Atom("feMerge", "feMerge"),
+    Atom("feMergeNode", "feMergeNode"),
+    Atom("feMorphology", "feMorphology"),
+    Atom("feOffset", "feOffset"),
+    Atom("fePointLight", "fePointLight"),
+    Atom("feSpecularLighting", "feSpecularLighting"),
+    Atom("feSpotLight", "feSpotLight"),
+    Atom("feTile", "feTile"),
+    Atom("feTurbulence", "feTurbulence"),
+    Atom("fill", "fill"),
+    Atom("fill_opacity", "fill-opacity"),
+    Atom("fill_rule", "fill-rule"),
+    Atom("filter", "filter"),
+    Atom("filterUnits", "filterUnits"),
+    Atom("_float", "float"),
+    Atom("flood_color", "flood-color"),
+    Atom("flood_opacity", "flood-opacity"),
+    Atom("font_face", "font-face"),
+    Atom("font_face_format", "font-face-format"),
+    Atom("font_face_name", "font-face-name"),
+    Atom("font_face_src", "font-face-src"),
+    Atom("font_face_uri", "font-face-uri"),
+    Atom("font_family", "font-family"),
+    Atom("font_size", "font-size"),
+    Atom("font_size_adjust", "font-size-adjust"),
+    Atom("font_stretch", "font-stretch"),
+    Atom("font_style", "font-style"),
+    Atom("font_variant", "font-variant"),
+    Atom("formatting", "formatting"),
+    Atom("foreignObject", "foreignObject"),
+    Atom("fractalNoise", "fractalNoise"),
+    Atom("fr", "fr"),
+    Atom("fx", "fx"),
+    Atom("fy", "fy"),
+    Atom("G", "G"),
+    Atom("g", "g"),
+    Atom("gamma", "gamma"),
+    Atom("glyphRef", "glyphRef"),
+    Atom("grad", "grad"),
+    Atom("gradientTransform", "gradientTransform"),
+    Atom("gradientUnits", "gradientUnits"),
+    Atom("hardLight", "hard-light"),
+    Atom("hue", "hue"),
+    Atom("hueRotate", "hueRotate"),
+    Atom("identity", "identity"),
+    Atom("image_rendering", "image-rendering"),
+    Atom("in", "in"),
+    Atom("in2", "in2"),
+    Atom("intercept", "intercept"),
+    Atom("k1", "k1"),
+    Atom("k2", "k2"),
+    Atom("k3", "k3"),
+    Atom("k4", "k4"),
+    Atom("kernelMatrix", "kernelMatrix"),
+    Atom("kernelUnitLength", "kernelUnitLength"),
+    Atom("lengthAdjust", "lengthAdjust"),
+    Atom("letter_spacing", "letter-spacing"),
+    Atom("lighten", "lighten"),
+    Atom("lighter", "lighter"),
+    Atom("lighting_color", "lighting-color"),
+    Atom("limitingConeAngle", "limitingConeAngle"),
+    Atom("linear", "linear"),
+    Atom("linearGradient", "linearGradient"),
+    Atom("list_item", "list-item"),
+    Atom("list_style_type", "list-style-type"),
+    Atom("luminanceToAlpha", "luminanceToAlpha"),
+    Atom("luminosity", "luminosity"),
+    Atom("magnify", "magnify"),
+    Atom("marker", "marker"),
+    Atom("marker_end", "marker-end"),
+    Atom("marker_mid", "marker-mid"),
+    Atom("marker_start", "marker-start"),
+    Atom("markerHeight", "markerHeight"),
+    Atom("markerUnits", "markerUnits"),
+    Atom("markerWidth", "markerWidth"),
+    Atom("mask", "mask"),
+    Atom("maskContentUnits", "maskContentUnits"),
+    Atom("mask_type", "mask-type"),
+    Atom("maskUnits", "maskUnits"),
+    Atom("matrix", "matrix"),
+    Atom("metadata", "metadata"),
+    Atom("missingGlyph", "missing-glyph"),
+    Atom("mm", "mm"),
+    Atom("mpath", "mpath"),
+    Atom("noStitch", "noStitch"),
+    Atom("numOctaves", "numOctaves"),
+    Atom("multiply", "multiply"),
+    Atom("objectBoundingBox", "objectBoundingBox"),
+    Atom("offset", "offset"),
+    Atom("onSVGLoad", "onSVGLoad"),
+    Atom("onSVGScroll", "onSVGScroll"),
+    Atom("onzoom", "onzoom"),
+    Atom("opacity", "opacity"),
+    Atom("_operator", "operator"),
+    Atom("out", "out"),
+    Atom("over", "over"),
+    Atom("overridePreserveAspectRatio", "overridePreserveAspectRatio"),
+    Atom("pad", "pad"),
+    Atom("path", "path"),
+    Atom("pathLength", "pathLength"),
+    Atom("patternContentUnits", "patternContentUnits"),
+    Atom("patternTransform", "patternTransform"),
+    Atom("patternUnits", "patternUnits"),
+    Atom("pc", "pc"),
+    Atom("pointer", "pointer"),
+    Atom("pointer_events", "pointer-events"),
+    Atom("points", "points"),
+    Atom("pointsAtX", "pointsAtX"),
+    Atom("pointsAtY", "pointsAtY"),
+    Atom("pointsAtZ", "pointsAtZ"),
+    Atom("polyline", "polyline"),
+    Atom("preserveAlpha", "preserveAlpha"),
+    Atom("preserveAspectRatio", "preserveAspectRatio"),
+    Atom("primitiveUnits", "primitiveUnits"),
+    Atom("pt", "pt"),
+    Atom("px", "px"),
+    Atom("R", "R"),
+    Atom("r", "r"),
+    Atom("rad", "rad"),
+    Atom("radialGradient", "radialGradient"),
+    Atom("radius", "radius"),
+    Atom("reflect", "reflect"),
+    Atom("refX", "refX"),
+    Atom("refY", "refY"),
+    Atom("requiredExtensions", "requiredExtensions"),
+    Atom("requiredFeatures", "requiredFeatures"),
+    Atom("rotate", "rotate"),
+    Atom("rx", "rx"),
+    Atom("ry", "ry"),
+    Atom("saturate", "saturate"),
+    Atom("saturation", "saturation"),
+    Atom("set", "set"),
+    Atom("seed", "seed"),
+    Atom("shape_rendering", "shape-rendering"),
+    Atom("simpleScopeChain", "simpleScopeChain"),
+    Atom("skewX", "skewX"),
+    Atom("skewY", "skewY"),
+    Atom("slope", "slope"),
+    Atom("slot", "slot"),
+    Atom("softLight", "soft-light"),
+    Atom("spacing", "spacing"),
+    Atom("spacingAndGlyphs", "spacingAndGlyphs"),
+    Atom("specularConstant", "specularConstant"),
+    Atom("specularExponent", "specularExponent"),
+    Atom("spreadMethod", "spreadMethod"),
+    Atom("startOffset", "startOffset"),
+    Atom("stdDeviation", "stdDeviation"),
+    Atom("stitch", "stitch"),
+    Atom("stitchTiles", "stitchTiles"),
+    Atom("stop_color", "stop-color"),
+    Atom("stop_opacity", "stop-opacity"),
+    Atom("stroke", "stroke"),
+    Atom("stroke_dasharray", "stroke-dasharray"),
+    Atom("stroke_dashoffset", "stroke-dashoffset"),
+    Atom("stroke_linecap", "stroke-linecap"),
+    Atom("stroke_linejoin", "stroke-linejoin"),
+    Atom("stroke_miterlimit", "stroke-miterlimit"),
+    Atom("stroke_opacity", "stroke-opacity"),
+    Atom("stroke_width", "stroke-width"),
+    Atom("strokeWidth", "strokeWidth"),
+    Atom("surfaceScale", "surfaceScale"),
+    Atom("svg", "svg"),
+    Atom("svgSwitch", "switch"),
+    Atom("symbol", "symbol"),
+    Atom("systemLanguage", "systemLanguage"),
+    Atom("tableValues", "tableValues"),
+    Atom("targetX", "targetX"),
+    Atom("targetY", "targetY"),
+    Atom("text_anchor", "text-anchor"),
+    Atom("text_rendering", "text-rendering"),
+    Atom("textLength", "textLength"),
+    Atom("textPath", "textPath"),
+    Atom("transform_origin", "transform-origin"),
+    Atom("tref", "tref"),
+    Atom("tspan", "tspan"),
+    Atom("turbulence", "turbulence"),
+    Atom("unicode_bidi", "unicode-bidi"),
+    Atom("userSpaceOnUse", "userSpaceOnUse"),
+    Atom("view", "view"),
+    Atom("viewBox", "viewBox"),
+    Atom("viewTarget", "viewTarget"),
+    Atom("white_space", "white-space"),
+    Atom("word_spacing", "word-spacing"),
+    Atom("writing_mode", "writing-mode"),
+    Atom("x", "x"),
+    Atom("x1", "x1"),
+    Atom("x2", "x2"),
+    Atom("xChannelSelector", "xChannelSelector"),
+    Atom("xor_", "xor"),
+    Atom("y", "y"),
+    Atom("y1", "y1"),
+    Atom("y2", "y2"),
+    Atom("yChannelSelector", "yChannelSelector"),
+    Atom("z", "z"),
+    Atom("zoomAndPan", "zoomAndPan"),
+    Atom("vector_effect", "vector-effect"),
+    Atom("vertical_align", "vertical-align"),
+    Atom("accumulate", "accumulate"),
+    Atom("additive", "additive"),
+    Atom("attributeName", "attributeName"),
+    Atom("attributeType", "attributeType"),
+    Atom("auto_reverse", "auto-reverse"),
+    Atom("begin", "begin"),
+    Atom("beginEvent", "beginEvent"),
+    Atom("by", "by"),
+    Atom("calcMode", "calcMode"),
+    Atom("dur", "dur"),
+    Atom("keyPoints", "keyPoints"),
+    Atom("keySplines", "keySplines"),
+    Atom("keyTimes", "keyTimes"),
+    Atom("mozAnimateMotionDummyAttr", "_mozAnimateMotionDummyAttr"),
+    Atom("onbegin", "onbegin"),
+    Atom("onbeginEvent", "onbeginEvent"),
+    Atom("onend", "onend"),
+    Atom("onendEvent", "onendEvent"),
+    Atom("onrepeat", "onrepeat"),
+    Atom("onrepeatEvent", "onrepeatEvent"),
+    Atom("repeatCount", "repeatCount"),
+    Atom("repeatDur", "repeatDur"),
+    Atom("repeatEvent", "repeatEvent"),
+    Atom("restart", "restart"),
+    Atom("to", "to"),
+    Atom("abs_", "abs"),
+    Atom("accent_", "accent"),
+    Atom("accentunder_", "accentunder"),
+    Atom("actiontype_", "actiontype"),
+    Atom("alignmentscope_", "alignmentscope"),
+    Atom("altimg_", "altimg"),
+    Atom("altimg_height_", "altimg-height"),
+    Atom("altimg_valign_", "altimg-valign"),
+    Atom("altimg_width_", "altimg-width"),
+    Atom("annotation_", "annotation"),
+    Atom("annotation_xml_", "annotation-xml"),
+    Atom("apply_", "apply"),
+    Atom("approx_", "approx"),
+    Atom("arccos_", "arccos"),
+    Atom("arccosh_", "arccosh"),
+    Atom("arccot_", "arccot"),
+    Atom("arccoth_", "arccoth"),
+    Atom("arccsc_", "arccsc"),
+    Atom("arccsch_", "arccsch"),
+    Atom("arcsec_", "arcsec"),
+    Atom("arcsech_", "arcsech"),
+    Atom("arcsin_", "arcsin"),
+    Atom("arcsinh_", "arcsinh"),
+    Atom("arctan_", "arctan"),
+    Atom("arctanh_", "arctanh"),
+    Atom("arg_", "arg"),
+    Atom("bevelled_", "bevelled"),
+    Atom("bind_", "bind"),
+    Atom("bvar_", "bvar"),
+    Atom("card_", "card"),
+    Atom("cartesianproduct_", "cartesianproduct"),
+    Atom("cbytes_", "cbytes"),
+    Atom("cd_", "cd"),
+    Atom("cdgroup_", "cdgroup"),
+    Atom("cerror_", "cerror"),
+    Atom("charalign_", "charalign"),
+    Atom("ci_", "ci"),
+    Atom("closure_", "closure"),
+    Atom("cn_", "cn"),
+    Atom("codomain_", "codomain"),
+    Atom("columnalign_", "columnalign"),
+    Atom("columnalignment_", "columnalignment"),
+    Atom("columnlines_", "columnlines"),
+    Atom("columnspacing_", "columnspacing"),
+    Atom("columnspan_", "columnspan"),
+    Atom("columnwidth_", "columnwidth"),
+    Atom("complexes_", "complexes"),
+    Atom("compose_", "compose"),
+    Atom("condition_", "condition"),
+    Atom("conjugate_", "conjugate"),
+    Atom("cos_", "cos"),
+    Atom("cosh_", "cosh"),
+    Atom("cot_", "cot"),
+    Atom("coth_", "coth"),
+    Atom("crossout_", "crossout"),
+    Atom("csc_", "csc"),
+    Atom("csch_", "csch"),
+    Atom("cs_", "cs"),
+    Atom("csymbol_", "csymbol"),
+    Atom("csp", "csp"),
+    Atom("curl_", "curl"),
+    Atom("decimalpoint_", "decimalpoint"),
+    Atom("definitionURL_", "definitionURL"),
+    Atom("degree_", "degree"),
+    Atom("denomalign_", "denomalign"),
+    Atom("depth_", "depth"),
+    Atom("determinant_", "determinant"),
+    Atom("diff_", "diff"),
+    Atom("displaystyle_", "displaystyle"),
+    Atom("divergence_", "divergence"),
+    Atom("divide_", "divide"),
+    Atom("domain_", "domain"),
+    Atom("domainofapplication_", "domainofapplication"),
+    Atom("edge_", "edge"),
+    Atom("el", "el"),
+    Atom("emptyset_", "emptyset"),
+    Atom("eq_", "eq"),
+    Atom("equalcolumns_", "equalcolumns"),
+    Atom("equalrows_", "equalrows"),
+    Atom("equivalent_", "equivalent"),
+    Atom("eulergamma_", "eulergamma"),
+    Atom("exists_", "exists"),
+    Atom("exp_", "exp"),
+    Atom("exponentiale_", "exponentiale"),
+    Atom("factorial_", "factorial"),
+    Atom("factorof_", "factorof"),
+    Atom("fence_", "fence"),
+    Atom("fn_", "fn"),
+    Atom("fontfamily_", "fontfamily"),
+    Atom("fontsize_", "fontsize"),
+    Atom("fontstyle_", "fontstyle"),
+    Atom("fontweight_", "fontweight"),
+    Atom("forall_", "forall"),
+    Atom("framespacing_", "framespacing"),
+    Atom("gcd_", "gcd"),
+    Atom("geq_", "geq"),
+    Atom("groupalign_", "groupalign"),
+    Atom("gt_", "gt"),
+    Atom("ident_", "ident"),
+    Atom("imaginaryi_", "imaginaryi"),
+    Atom("imaginary_", "imaginary"),
+    Atom("implies_", "implies"),
+    Atom("indentalignfirst_", "indentalignfirst"),
+    Atom("indentalign_", "indentalign"),
+    Atom("indentalignlast_", "indentalignlast"),
+    Atom("indentshiftfirst_", "indentshiftfirst"),
+    Atom("indentshift_", "indentshift"),
+    Atom("indenttarget_", "indenttarget"),
+    Atom("integers_", "integers"),
+    Atom("intersect_", "intersect"),
+    Atom("interval_", "interval"),
+    Atom("int_", "int"),
+    Atom("inverse_", "inverse"),
+    Atom("lambda_", "lambda"),
+    Atom("laplacian_", "laplacian"),
+    Atom("largeop_", "largeop"),
+    Atom("lcm_", "lcm"),
+    Atom("leq_", "leq"),
+    Atom("limit_", "limit"),
+    Atom("linebreak_", "linebreak"),
+    Atom("linebreakmultchar_", "linebreakmultchar"),
+    Atom("linebreakstyle_", "linebreakstyle"),
+    Atom("linethickness_", "linethickness"),
+    Atom("list_", "list"),
+    Atom("ln_", "ln"),
+    Atom("location_", "location"),
+    Atom("logbase_", "logbase"),
+    Atom("log_", "log"),
+    Atom("longdivstyle_", "longdivstyle"),
+    Atom("lowlimit_", "lowlimit"),
+    Atom("lquote_", "lquote"),
+    Atom("lspace_", "lspace"),
+    Atom("lt_", "lt"),
+    Atom("maction_", "maction"),
+    Atom("maligngroup_", "maligngroup"),
+    Atom("malignmark_", "malignmark"),
+    Atom("mathbackground_", "mathbackground"),
+    Atom("mathcolor_", "mathcolor"),
+    Atom("mathsize_", "mathsize"),
+    Atom("mathvariant_", "mathvariant"),
+    Atom("matrixrow_", "matrixrow"),
+    Atom("maxsize_", "maxsize"),
+    Atom("mean_", "mean"),
+    Atom("median_", "median"),
+    Atom("menclose_", "menclose"),
+    Atom("merror_", "merror"),
+    Atom("mfenced_", "mfenced"),
+    Atom("mfrac_", "mfrac"),
+    Atom("mglyph_", "mglyph"),
+    Atom("mi_", "mi"),
+    Atom("minlabelspacing_", "minlabelspacing"),
+    Atom("minsize_", "minsize"),
+    Atom("minus_", "minus"),
+    Atom("mlabeledtr_", "mlabeledtr"),
+    Atom("mlongdiv_", "mlongdiv"),
+    Atom("mmultiscripts_", "mmultiscripts"),
+    Atom("mn_", "mn"),
+    Atom("momentabout_", "momentabout"),
+    Atom("moment_", "moment"),
+    Atom("mo_", "mo"),
+    Atom("movablelimits_", "movablelimits"),
+    Atom("mover_", "mover"),
+    Atom("mpadded_", "mpadded"),
+    Atom("mphantom_", "mphantom"),
+    Atom("mprescripts_", "mprescripts"),
+    Atom("mroot_", "mroot"),
+    Atom("mrow_", "mrow"),
+    Atom("mscarries_", "mscarries"),
+    Atom("mscarry_", "mscarry"),
+    Atom("msgroup_", "msgroup"),
+    Atom("msline_", "msline"),
+    Atom("ms_", "ms"),
+    Atom("mspace_", "mspace"),
+    Atom("msqrt_", "msqrt"),
+    Atom("msrow_", "msrow"),
+    Atom("mstack_", "mstack"),
+    Atom("mstyle_", "mstyle"),
+    Atom("msub_", "msub"),
+    Atom("msubsup_", "msubsup"),
+    Atom("msup_", "msup"),
+    Atom("mtable_", "mtable"),
+    Atom("mtd_", "mtd"),
+    Atom("mtext_", "mtext"),
+    Atom("mtr_", "mtr"),
+    Atom("munder_", "munder"),
+    Atom("munderover_", "munderover"),
+    Atom("naturalnumbers_", "naturalnumbers"),
+    Atom("neq_", "neq"),
+    Atom("notanumber_", "notanumber"),
+    Atom("notation_", "notation"),
+    Atom("note_", "note"),
+    Atom("notin_", "notin"),
+    Atom("notprsubset_", "notprsubset"),
+    Atom("notsubset_", "notsubset"),
+    Atom("numalign_", "numalign"),
+    Atom("other", "other"),
+    Atom("outerproduct_", "outerproduct"),
+    Atom("partialdiff_", "partialdiff"),
+    Atom("piece_", "piece"),
+    Atom("piecewise_", "piecewise"),
+    Atom("pi_", "pi"),
+    Atom("plus_", "plus"),
+    Atom("power_", "power"),
+    Atom("primes_", "primes"),
+    Atom("product_", "product"),
+    Atom("prsubset_", "prsubset"),
+    Atom("quotient_", "quotient"),
+    Atom("rationals_", "rationals"),
+    Atom("real_", "real"),
+    Atom("reals_", "reals"),
+    Atom("reln_", "reln"),
+    Atom("root_", "root"),
+    Atom("rowalign_", "rowalign"),
+    Atom("rowlines_", "rowlines"),
+    Atom("rowspacing_", "rowspacing"),
+    Atom("rquote_", "rquote"),
+    Atom("rspace_", "rspace"),
+    Atom("scalarproduct_", "scalarproduct"),
+    Atom("schemaLocation_", "schemaLocation"),
+    Atom("scriptlevel_", "scriptlevel"),
+    Atom("scriptminsize_", "scriptminsize"),
+    Atom("scriptsizemultiplier_", "scriptsizemultiplier"),
+    Atom("scriptsize_", "scriptsize"),
+    Atom("sdev_", "sdev"),
+    Atom("sech_", "sech"),
+    Atom("sec_", "sec"),
+    Atom("selection_", "selection"),
+    Atom("selector_", "selector"),
+    Atom("semantics_", "semantics"),
+    Atom("separator_", "separator"),
+    Atom("separators_", "separators"),
+    Atom("sep_", "sep"),
+    Atom("setdiff_", "setdiff"),
+    # Atom("set_", "set"),  # "set" is present above
+    Atom("share_", "share"),
+    Atom("shift_", "shift"),
+    Atom("side_", "side"),
+    Atom("sinh_", "sinh"),
+    Atom("sin_", "sin"),
+    Atom("stackalign_", "stackalign"),
+    Atom("stretchy_", "stretchy"),
+    Atom("subscriptshift_", "subscriptshift"),
+    Atom("subset_", "subset"),
+    Atom("superscriptshift_", "superscriptshift"),
+    Atom("symmetric_", "symmetric"),
+    Atom("tanh_", "tanh"),
+    Atom("tan_", "tan"),
+    Atom("tendsto_", "tendsto"),
+    Atom("times_", "times"),
+    Atom("transpose_", "transpose"),
+    Atom("union_", "union"),
+    Atom("uplimit_", "uplimit"),
+    Atom("variance_", "variance"),
+    Atom("vectorproduct_", "vectorproduct"),
+    Atom("vector_", "vector"),
+    Atom("voffset_", "voffset"),
+    Atom("xref_", "xref"),
+    Atom("math", "math"),  # the only one without an underscore
+    Atom("booleanFromString", "boolean-from-string"),
+    Atom("countNonEmpty", "count-non-empty"),
+    Atom("daysFromDate", "days-from-date"),
+    Atom("secondsFromDateTime", "seconds-from-dateTime"),
+    Atom("tabbrowser_arrowscrollbox", "tabbrowser-arrowscrollbox"),
+    # Simple gestures support
+    Atom("onMozSwipeGestureMayStart", "onMozSwipeGestureMayStart"),
+    Atom("onMozSwipeGestureStart", "onMozSwipeGestureStart"),
+    Atom("onMozSwipeGestureUpdate", "onMozSwipeGestureUpdate"),
+    Atom("onMozSwipeGestureEnd", "onMozSwipeGestureEnd"),
+    Atom("onMozSwipeGesture", "onMozSwipeGesture"),
+    Atom("onMozMagnifyGestureStart", "onMozMagnifyGestureStart"),
+    Atom("onMozMagnifyGestureUpdate", "onMozMagnifyGestureUpdate"),
+    Atom("onMozMagnifyGesture", "onMozMagnifyGesture"),
+    Atom("onMozRotateGestureStart", "onMozRotateGestureStart"),
+    Atom("onMozRotateGestureUpdate", "onMozRotateGestureUpdate"),
+    Atom("onMozRotateGesture", "onMozRotateGesture"),
+    Atom("onMozTapGesture", "onMozTapGesture"),
+    Atom("onMozPressTapGesture", "onMozPressTapGesture"),
+    Atom("onMozEdgeUIStarted", "onMozEdgeUIStarted"),
+    Atom("onMozEdgeUICanceled", "onMozEdgeUICanceled"),
+    Atom("onMozEdgeUICompleted", "onMozEdgeUICompleted"),
+    # Pointer events
+    Atom("onpointerdown", "onpointerdown"),
+    Atom("onpointermove", "onpointermove"),
+    Atom("onpointerup", "onpointerup"),
+    Atom("onpointercancel", "onpointercancel"),
+    Atom("onpointerover", "onpointerover"),
+    Atom("onpointerout", "onpointerout"),
+    Atom("onpointerenter", "onpointerenter"),
+    Atom("onpointerleave", "onpointerleave"),
+    Atom("ongotpointercapture", "ongotpointercapture"),
+    Atom("onlostpointercapture", "onlostpointercapture"),
+    # orientation support
+    Atom("ondevicemotion", "ondevicemotion"),
+    Atom("ondeviceorientation", "ondeviceorientation"),
+    Atom("onabsolutedeviceorientation", "onabsolutedeviceorientation"),
+    Atom("onmozorientationchange", "onmozorientationchange"),
+    Atom("onuserproximity", "onuserproximity"),
+    # light sensor support
+    Atom("ondevicelight", "ondevicelight"),
+    # MediaDevices device change event
+    Atom("ondevicechange", "ondevicechange"),
+    # Internal Visual Viewport events
+    Atom("onmozvisualresize", "onmozvisualresize"),
+    Atom("onmozvisualscroll", "onmozvisualscroll"),
+    # Miscellaneous events included for memory usage optimization (see bug 1542885)
+    Atom("onDOMAutoComplete", "onDOMAutoComplete"),
+    Atom("onDOMContentLoaded", "onDOMContentLoaded"),
+    Atom("onDOMDocElementInserted", "onDOMDocElementInserted"),
+    Atom("onDOMFormBeforeSubmit", "onDOMFormBeforeSubmit"),
+    Atom("onDOMFormHasPassword", "onDOMFormHasPassword"),
+    Atom("onDOMFrameContentLoaded", "onDOMFrameContentLoaded"),
+    Atom("onDOMHeadElementParsed", "onDOMHeadElementParsed"),
+    Atom("onDOMInputPasswordAdded", "onDOMInputPasswordAdded"),
+    Atom("onDOMLinkAdded", "onDOMLinkAdded"),
+    Atom("onDOMLinkChanged", "onDOMLinkChanged"),
+    Atom("onDOMMetaAdded", "onDOMMetaAdded"),
+    Atom("onDOMMetaChanged", "onDOMMetaChanged"),
+    Atom("onDOMMetaRemoved", "onDOMMetaRemoved"),
+    Atom("onDOMPopupBlocked", "onDOMPopupBlocked"),
+    Atom("onDOMTitleChanged", "onDOMTitleChanged"),
+    Atom("onDOMWindowClose", "onDOMWindowClose"),
+    Atom("onDOMWindowCreated", "onDOMWindowCreated"),
+    Atom("onDOMWindowFocus", "onDOMWindowFocus"),
+    Atom("onFullZoomChange", "onFullZoomChange"),
+    Atom("onGloballyAutoplayBlocked", "onGloballyAutoplayBlocked"),
+    Atom("onMozApplicationManifest", "onMozApplicationManifest"),
+    Atom("onMozDOMFullscreen_Entered", "onMozDOMFullscreen:Entered"),
+    Atom("onMozDOMFullscreen_Exit", "onMozDOMFullscreen:Exit"),
+    Atom("onMozDOMFullscreen_Exited", "onMozDOMFullscreen:Exited"),
+    Atom("onMozDOMFullscreen_NewOrigin", "onMozDOMFullscreen:NewOrigin"),
+    Atom("onMozDOMFullscreen_Request", "onMozDOMFullscreen:Request"),
+    Atom("onMozDOMPointerLock_Entered", "onMozDOMPointerLock:Entered"),
+    Atom("onMozDOMPointerLock_Exited", "onMozDOMPointerLock:Exited"),
+    Atom("onMozInvalidForm", "onMozInvalidForm"),
+    Atom("onMozLocalStorageChanged", "onMozLocalStorageChanged"),
+    Atom("onMozOpenDateTimePicker", "onMozOpenDateTimePicker"),
+    Atom("onMozSessionStorageChanged", "onMozSessionStorageChanged"),
+    Atom("onMozTogglePictureInPicture", "onMozTogglePictureInPicture"),
+    Atom("onPluginCrashed", "onPluginCrashed"),
+    Atom("onPrintingError", "onPrintingError"),
+    Atom("onTextZoomChange", "onTextZoomChange"),
+    Atom("onUAWidgetSetupOrChange", "onUAWidgetSetupOrChange"),
+    Atom("onUAWidgetTeardown", "onUAWidgetTeardown"),
+    Atom("onUnselectedTabHover_Disable", "onUnselectedTabHover:Disable"),
+    Atom("onUnselectedTabHover_Enable", "onUnselectedTabHover:Enable"),
+    Atom("onmozshowdropdown", "onmozshowdropdown"),
+    Atom("onmozshowdropdown_sourcetouch", "onmozshowdropdown-sourcetouch"),
+    Atom("onprintPreviewUpdate", "onprintPreviewUpdate"),
+    Atom("onscrollend", "onscrollend"),
+    # WebExtensions
+    Atom("moz_extension", "moz-extension"),
+    Atom("all_urlsPermission", "<all_urls>"),
+    Atom("clipboardRead", "clipboardRead"),
+    Atom("clipboardWrite", "clipboardWrite"),
+    Atom("debugger", "debugger"),
+    Atom("mozillaAddons", "mozillaAddons"),
+    Atom("tabs", "tabs"),
+    Atom("webRequestBlocking", "webRequestBlocking"),
+    Atom("webRequestFilterResponse_serviceWorkerScript", "webRequestFilterResponse.serviceWorkerScript"),
+    Atom("http", "http"),
+    Atom("https", "https"),
+    Atom("proxy", "proxy"),
+    Atom("privateBrowsingAllowedPermission", "internal:privateBrowsingAllowed"),
+    Atom("svgContextPropertiesAllowedPermission", "internal:svgContextPropertiesAllowed"),
+    # CSS Counter Styles
+    Atom("decimal_leading_zero", "decimal-leading-zero"),
+    Atom("arabic_indic", "arabic-indic"),
+    Atom("armenian", "armenian"),
+    Atom("upper_armenian", "upper-armenian"),
+    Atom("lower_armenian", "lower-armenian"),
+    Atom("bengali", "bengali"),
+    Atom("cambodian", "cambodian"),
+    Atom("khmer", "khmer"),
+    Atom("cjk_decimal", "cjk-decimal"),
+    Atom("devanagari", "devanagari"),
+    Atom("georgian", "georgian"),
+    Atom("gujarati", "gujarati"),
+    Atom("gurmukhi", "gurmukhi"),
+    Atom("kannada", "kannada"),
+    Atom("lao", "lao"),
+    Atom("malayalam", "malayalam"),
+    Atom("mongolian", "mongolian"),
+    Atom("myanmar", "myanmar"),
+    Atom("oriya", "oriya"),
+    Atom("persian", "persian"),
+    Atom("lower_roman", "lower-roman"),
+    Atom("upper_roman", "upper-roman"),
+    Atom("tamil", "tamil"),
+    Atom("telugu", "telugu"),
+    Atom("thai", "thai"),
+    Atom("tibetan", "tibetan"),
+    Atom("lower_alpha", "lower-alpha"),
+    Atom("lower_latin", "lower-latin"),
+    Atom("upper_alpha", "upper-alpha"),
+    Atom("upper_latin", "upper-latin"),
+    Atom("cjk_heavenly_stem", "cjk-heavenly-stem"),
+    Atom("cjk_earthly_branch", "cjk-earthly-branch"),
+    Atom("lower_greek", "lower-greek"),
+    Atom("hiragana", "hiragana"),
+    Atom("hiragana_iroha", "hiragana-iroha"),
+    Atom("katakana", "katakana"),
+    Atom("katakana_iroha", "katakana-iroha"),
+    Atom("cjk_ideographic", "cjk-ideographic"),
+    Atom("_moz_arabic_indic", "-moz-arabic-indic"),
+    Atom("_moz_persian", "-moz-persian"),
+    Atom("_moz_urdu", "-moz-urdu"),
+    Atom("_moz_devanagari", "-moz-devanagari"),
+    Atom("_moz_bengali", "-moz-bengali"),
+    Atom("_moz_gurmukhi", "-moz-gurmukhi"),
+    Atom("_moz_gujarati", "-moz-gujarati"),
+    Atom("_moz_oriya", "-moz-oriya"),
+    Atom("_moz_tamil", "-moz-tamil"),
+    Atom("_moz_telugu", "-moz-telugu"),
+    Atom("_moz_kannada", "-moz-kannada"),
+    Atom("_moz_malayalam", "-moz-malayalam"),
+    Atom("_moz_thai", "-moz-thai"),
+    Atom("_moz_lao", "-moz-lao"),
+    Atom("_moz_myanmar", "-moz-myanmar"),
+    Atom("_moz_khmer", "-moz-khmer"),
+    Atom("_moz_cjk_heavenly_stem", "-moz-cjk-heavenly-stem"),
+    Atom("_moz_cjk_earthly_branch", "-moz-cjk-earthly-branch"),
+    Atom("_moz_hangul", "-moz-hangul"),
+    Atom("_moz_hangul_consonant", "-moz-hangul-consonant"),
+    Atom("_moz_ethiopic_halehame", "-moz-ethiopic-halehame"),
+    Atom("_moz_ethiopic_halehame_am", "-moz-ethiopic-halehame-am"),
+    Atom("_moz_ethiopic_halehame_ti_er", "-moz-ethiopic-halehame-ti-er"),
+    Atom("_moz_ethiopic_halehame_ti_et", "-moz-ethiopic-halehame-ti-et"),
+    Atom("_moz_trad_chinese_informal", "-moz-trad-chinese-informal"),
+    Atom("_moz_trad_chinese_formal", "-moz-trad-chinese-formal"),
+    Atom("_moz_simp_chinese_informal", "-moz-simp-chinese-informal"),
+    Atom("_moz_simp_chinese_formal", "-moz-simp-chinese-formal"),
+    Atom("_moz_japanese_informal", "-moz-japanese-informal"),
+    Atom("_moz_japanese_formal", "-moz-japanese-formal"),
+    Atom("_moz_ethiopic_numeric", "-moz-ethiopic-numeric"),
+    # --------------------------------------------------------------------------
+    # Special atoms
+    # --------------------------------------------------------------------------
+    # Node types
+    Atom("cdataTagName", "#cdata-section"),
+    Atom("commentTagName", "#comment"),
+    Atom("documentNodeName", "#document"),
+    Atom("documentFragmentNodeName", "#document-fragment"),
+    Atom("documentTypeNodeName", "#document-type"),
+    Atom("processingInstructionTagName", "#processing-instruction"),
+    Atom("textTagName", "#text"),
+    # Frame types
+    #
+    # TODO(emilio): Rename this? This is only used now to mark the style context of
+    # the placeholder with a dummy pseudo.
+    Atom("placeholderFrame", "PlaceholderFrame"),
+    Atom("onloadend", "onloadend"),
+    Atom("onloadstart", "onloadstart"),
+    Atom("onprogress", "onprogress"),
+    Atom("onsuspend", "onsuspend"),
+    Atom("onemptied", "onemptied"),
+    Atom("onstalled", "onstalled"),
+    Atom("onplay", "onplay"),
+    Atom("onpause", "onpause"),
+    Atom("onloadedmetadata", "onloadedmetadata"),
+    Atom("onloadeddata", "onloadeddata"),
+    Atom("onwaiting", "onwaiting"),
+    Atom("onplaying", "onplaying"),
+    Atom("oncanplay", "oncanplay"),
+    Atom("oncanplaythrough", "oncanplaythrough"),
+    Atom("onseeking", "onseeking"),
+    Atom("onseeked", "onseeked"),
+    Atom("ontimeout", "ontimeout"),
+    Atom("ontimeupdate", "ontimeupdate"),
+    Atom("onended", "onended"),
+    Atom("onformdata", "onformdata"),
+    Atom("onratechange", "onratechange"),
+    Atom("ondurationchange", "ondurationchange"),
+    Atom("onvolumechange", "onvolumechange"),
+    Atom("onaddtrack", "onaddtrack"),
+    Atom("oncontrollerchange", "oncontrollerchange"),
+    Atom("oncuechange", "oncuechange"),
+    Atom("onenter", "onenter"),
+    Atom("onexit", "onexit"),
+    Atom("onencrypted", "onencrypted"),
+    Atom("onwaitingforkey", "onwaitingforkey"),
+    Atom("onkeystatuseschange", "onkeystatuseschange"),
+    Atom("onremovetrack", "onremovetrack"),
+    Atom("loadstart", "loadstart"),
+    Atom("suspend", "suspend"),
+    Atom("emptied", "emptied"),
+    Atom("play", "play"),
+    Atom("pause", "pause"),
+    Atom("loadedmetadata", "loadedmetadata"),
+    Atom("loadeddata", "loadeddata"),
+    Atom("waiting", "waiting"),
+    Atom("playing", "playing"),
+    Atom("timeupdate", "timeupdate"),
+    Atom("canplay", "canplay"),
+    Atom("canplaythrough", "canplaythrough"),
+    Atom("ondataavailable", "ondataavailable"),
+    Atom("onwarning", "onwarning"),
+    Atom("onstart", "onstart"),
+    Atom("onstop", "onstop"),
+    Atom("onphoto", "onphoto"),
+    Atom("ongamepadbuttondown", "ongamepadbuttondown"),
+    Atom("ongamepadbuttonup", "ongamepadbuttonup"),
+    Atom("ongamepadaxismove", "ongamepadaxismove"),
+    Atom("ongamepadconnected", "ongamepadconnected"),
+    Atom("ongamepaddisconnected", "ongamepaddisconnected"),
+    Atom("onfetch", "onfetch"),
+    # Content property names
+    Atom("afterPseudoProperty", "afterPseudoProperty"),  # nsXMLElement*
+    Atom("animationsProperty", "AnimationsProperty"),  # FrameAnimations*
+    Atom("animationsOfBeforeProperty", "AnimationsOfBeforeProperty"),  # FrameAnimations*
+    Atom("animationsOfAfterProperty", "AnimationsOfAfterProperty"),  # FrameAnimations*
+    Atom("animationsOfMarkerProperty", "AnimationsOfMarkerProperty"),  # FrameAnimations*
+    Atom("animationEffectsProperty", "AnimationEffectsProperty"),  # EffectSet*
+    Atom("animationEffectsForBeforeProperty", "AnimationsEffectsForBeforeProperty"),  # EffectSet*
+    Atom("animationEffectsForAfterProperty", "AnimationsEffectsForAfterProperty"),  # EffectSet*
+    Atom("animationEffectsForMarkerProperty", "AnimationsEffectsForMarkerProperty"),  # EffectSet*
+    Atom("beforePseudoProperty", "beforePseudoProperty"),  # nsXMLElement*
+    Atom("cssPseudoElementBeforeProperty", "CSSPseudoElementBeforeProperty"),  # CSSPseudoElement*
+    Atom("cssPseudoElementAfterProperty", "CSSPseudoElementAfterProperty"),  # CSSPseudoElement*
+    Atom("cssPseudoElementMarkerProperty", "CSSPseudoElementMarkerProperty"),  # CSSPseudoElement*
+    Atom("transitionsProperty", "TransitionsProperty"),  # FrameTransitions*
+    Atom("transitionsOfBeforeProperty", "TransitionsOfBeforeProperty"),  # FrameTransitions*
+    Atom("transitionsOfAfterProperty", "TransitionsOfAfterProperty"),  # FrameTransitions*
+    Atom("transitionsOfMarkerProperty", "TransitionsOfMarkerProperty"),  # FrameTransitions*
+    Atom("genConInitializerProperty", "QuoteNodeProperty"),
+    Atom("labelMouseDownPtProperty", "LabelMouseDownPtProperty"),
+    Atom("lockedStyleStates", "lockedStyleStates"),
+    Atom("apzCallbackTransform", "apzCallbackTransform"),
+    Atom("apzDisabled", "ApzDisabled"),  # bool
+    Atom("restylableAnonymousNode", "restylableAnonymousNode"),  # bool
+    Atom("docLevelNativeAnonymousContent", "docLevelNativeAnonymousContent"),  # bool
+    Atom("paintRequestTime", "PaintRequestTime"),
+    Atom("pseudoProperty", "PseudoProperty"),  # PseudoStyleType
+    Atom("scrollTimelinesProperty", "SrollTimelinesProperty"),  # ScrollTimelineSet*
+    Atom("manualNACProperty", "ManualNACProperty"),  # ManualNAC*
+    Atom("markerPseudoProperty", "markerPseudoProperty"),  # nsXMLElement*
+    # Languages for lang-specific transforms
+    Atom("Japanese", "ja"),
+    Atom("Chinese", "zh-CN"),
+    Atom("Taiwanese", "zh-TW"),
+    Atom("HongKongChinese", "zh-HK"),
+    Atom("Unicode", "x-unicode"),
+    # language codes specifically referenced in the gfx code
+    Atom("ko", "ko"),
+    Atom("zh_cn", "zh-cn"),
+    Atom("zh_tw", "zh-tw"),
+    # additional codes used in nsUnicodeRange.cpp
+    Atom("x_cyrillic", "x-cyrillic"),
+    Atom("he", "he"),
+    Atom("ar", "ar"),
+    Atom("x_devanagari", "x-devanagari"),
+    Atom("x_tamil", "x-tamil"),
+    Atom("x_armn", "x-armn"),
+    Atom("x_beng", "x-beng"),
+    Atom("x_cans", "x-cans"),
+    Atom("x_ethi", "x-ethi"),
+    Atom("x_geor", "x-geor"),
+    Atom("x_gujr", "x-gujr"),
+    Atom("x_guru", "x-guru"),
+    Atom("x_khmr", "x-khmr"),
+    Atom("x_knda", "x-knda"),
+    Atom("x_mlym", "x-mlym"),
+    Atom("x_orya", "x-orya"),
+    Atom("x_sinh", "x-sinh"),
+    Atom("x_telu", "x-telu"),
+    Atom("x_tibt", "x-tibt"),
+    # additional languages that have special case transformations
+    Atom("az", "az"),
+    Atom("ba", "ba"),
+    Atom("crh", "crh"),
+    # Atom("el", "el"),  # "el" is present above
+    Atom("ga", "ga"),
+    # Atom("lt", "lt"),  # "lt" is present above (atom name "lt_")
+    Atom("nl", "nl"),
+    # mathematical language, used for MathML
+    Atom("x_math", "x-math"),
+    # other languages mentioned in :lang() rules in UA style sheets
+    Atom("zh", "zh"),
+    # Names for editor transactions
+    Atom("TypingTxnName", "Typing"),
+    Atom("IMETxnName", "IME"),
+    Atom("DeleteTxnName", "Deleting"),
+    # Font families
+    Atom("serif", "serif"),
+    Atom("sans_serif", "sans-serif"),
+    Atom("cursive", "cursive"),
+    Atom("fantasy", "fantasy"),
+    Atom("monospace", "monospace"),
+    Atom("mozfixed", "-moz-fixed"),
+    # IPC stuff
+    # Atom("Remote", "remote"),  # "remote" is present above
+    Atom("RemoteId", "_remote_id"),
+    Atom("RemoteType", "remoteType"),
+    Atom("DisplayPort", "_displayport"),
+    Atom("DisplayPortMargins", "_displayportmargins"),
+    Atom("DisplayPortBase", "_displayportbase"),
+    Atom("MinimalDisplayPort", "_minimaldisplayport"),
+    Atom("forceMousewheelAutodir", "_force_mousewheel_autodir"),
+    Atom("forceMousewheelAutodirHonourRoot", "_force_mousewheel_autodir_honourroot"),
+    Atom("forcemessagemanager", "forcemessagemanager"),
+    Atom("initialBrowsingContextGroupId", "initialBrowsingContextGroupId"),
+    Atom("initiallyactive", "initiallyactive"),
+    # windows media query names
+    Atom("windows_win7", "windows-win7"),
+    Atom("windows_win8", "windows-win8"),
+    Atom("windows_win10", "windows-win10"),
+    # Names for system metrics.
+    Atom("_moz_scrollbar_start_backward", "-moz-scrollbar-start-backward"),
+    Atom("_moz_scrollbar_start_forward", "-moz-scrollbar-start-forward"),
+    Atom("_moz_scrollbar_end_backward", "-moz-scrollbar-end-backward"),
+    Atom("_moz_scrollbar_end_forward", "-moz-scrollbar-end-forward"),
+    Atom("_moz_scrollbar_thumb_proportional", "-moz-scrollbar-thumb-proportional"),
+    Atom("_moz_overlay_scrollbars", "-moz-overlay-scrollbars"),
+    Atom("_moz_windows_accent_color_in_titlebar", "-moz-windows-accent-color-in-titlebar"),
+    Atom("_moz_windows_default_theme", "-moz-windows-default-theme"),
+    Atom("_moz_mac_graphite_theme", "-moz-mac-graphite-theme"),
+    Atom("_moz_mac_big_sur_theme", "-moz-mac-big-sur-theme"),
+    Atom("_moz_mac_rtl", "-moz-mac-rtl"),
+    Atom("_moz_platform", "-moz-platform"),
+    Atom("_moz_windows_compositor", "-moz-windows-compositor"),
+    Atom("_moz_windows_classic", "-moz-windows-classic"),
+    Atom("_moz_windows_glass", "-moz-windows-glass"),
+    Atom("_moz_windows_non_native_menus", "-moz-windows-non-native-menus"),
+    Atom("_moz_menubar_drag", "-moz-menubar-drag"),
+    Atom("_moz_device_pixel_ratio", "-moz-device-pixel-ratio"),
+    Atom("_moz_device_orientation", "-moz-device-orientation"),
+    Atom("_moz_is_resource_document", "-moz-is-resource-document"),
+    Atom("_moz_swipe_animation_enabled", "-moz-swipe-animation-enabled"),
+    Atom("_moz_gtk_csd_available", "-moz-gtk-csd-available"),
+    Atom("_moz_gtk_csd_titlebar_radius", "-moz-gtk-csd-titlebar-radius"),
+    Atom("_moz_gtk_csd_minimize_button", "-moz-gtk-csd-minimize-button"),
+    Atom("_moz_gtk_csd_minimize_button_position", "-moz-gtk-csd-minimize-button-position"),
+    Atom("_moz_gtk_csd_maximize_button", "-moz-gtk-csd-maximize-button"),
+    Atom("_moz_gtk_csd_maximize_button_position", "-moz-gtk-csd-maximize-button-position"),
+    Atom("_moz_gtk_csd_close_button", "-moz-gtk-csd-close-button"),
+    Atom("_moz_gtk_csd_close_button_position", "-moz-gtk-csd-close-button-position"),
+    Atom("_moz_gtk_csd_reversed_placement", "-moz-gtk-csd-reversed-placement"),
+    Atom("_moz_gtk_csd_menu_radius", "-moz-gtk-csd-menu-radius"),
+    Atom("_moz_content_prefers_color_scheme", "-moz-content-prefers-color-scheme"),
+    Atom("_moz_content_preferred_color_scheme", "-moz-content-preferred-color-scheme"),
+    Atom("_moz_proton_places_tooltip", "-moz-proton-places-tooltip"),
+    Atom("_moz_system_dark_theme", "-moz-system-dark-theme"),
+    # application commands
+    Atom("Back", "Back"),
+    Atom("Forward", "Forward"),
+    Atom("Reload", "Reload"),
+    Atom("Stop", "Stop"),
+    Atom("Search", "Search"),
+    Atom("Bookmarks", "Bookmarks"),
+    Atom("Home", "Home"),
+    Atom("NextTrack", "NextTrack"),
+    Atom("PreviousTrack", "PreviousTrack"),
+    Atom("MediaStop", "MediaStop"),
+    Atom("PlayPause", "PlayPause"),
+    Atom("New", "New"),
+    Atom("Open", "Open"),
+    Atom("Close", "Close"),
+    Atom("Save", "Save"),
+    Atom("Find", "Find"),
+    Atom("Help", "Help"),
+    Atom("Print", "Print"),
+    Atom("SendMail", "SendMail"),
+    Atom("ForwardMail", "ForwardMail"),
+    Atom("ReplyToMail", "ReplyToMail"),
+    Atom("alert", "alert"),
+    Atom("alertdialog", "alertdialog"),
+    Atom("application", "application"),
+    Atom("aria_colcount", "aria-colcount"),
+    Atom("aria_colindex", "aria-colindex"),
+    Atom("aria_colindextext", "aria-colindextext"),
+    Atom("aria_colspan", "aria-colspan"),
+    Atom("aria_details", "aria-details"),
+    Atom("aria_errormessage", "aria-errormessage"),
+    Atom("aria_grabbed", "aria-grabbed"),
+    Atom("aria_keyshortcuts", "aria-keyshortcuts"),
+    Atom("aria_label", "aria-label"),
+    Atom("aria_modal", "aria-modal"),
+    Atom("aria_orientation", "aria-orientation"),
+    Atom("aria_placeholder", "aria-placeholder"),
+    Atom("aria_roledescription", "aria-roledescription"),
+    Atom("aria_rowcount", "aria-rowcount"),
+    Atom("aria_rowindex", "aria-rowindex"),
+    Atom("aria_rowindextext", "aria-rowindextext"),
+    Atom("aria_rowspan", "aria-rowspan"),
+    Atom("aria_valuetext", "aria-valuetext"),
+    Atom("assertive", "assertive"),
+    Atom("auto_generated", "auto-generated"),
+    Atom("banner", "banner"),
+    Atom("checkable", "checkable"),
+    Atom("columnheader", "columnheader"),
+    Atom("complementary", "complementary"),
+    Atom("containerAtomic", "container-atomic"),
+    Atom("containerBusy", "container-busy"),
+    Atom("containerLive", "container-live"),
+    Atom("containerLiveRole", "container-live-role"),
+    Atom("containerRelevant", "container-relevant"),
+    Atom("contentinfo", "contentinfo"),
+    Atom("cycles", "cycles"),
+    Atom("datatable", "datatable"),
+    Atom("eventFromInput", "event-from-input"),
+    Atom("feed", "feed"),
+    Atom("grammar", "grammar"),
+    Atom("gridcell", "gridcell"),
+    Atom("heading", "heading"),
+    Atom("hitregion", "hitregion"),
+    Atom("inlinevalue", "inline"),
+    Atom("inline_size", "inline-size"),
+    Atom("invalid", "invalid"),
+    Atom("lineNumber", "line-number"),
+    Atom("menuitemcheckbox", "menuitemcheckbox"),
+    Atom("menuitemradio", "menuitemradio"),
+    # Atom("mixed", "mixed"),  # "mixed" is present above
+    Atom("navigation", "navigation"),
+    Atom("polite", "polite"),
+    Atom("posinset", "posinset"),
+    Atom("presentation", "presentation"),
+    Atom("progressbar", "progressbar"),
+    Atom("region", "region"),
+    Atom("rowgroup", "rowgroup"),
+    Atom("rowheader", "rowheader"),
+    Atom("search", "search"),
+    Atom("searchbox", "searchbox"),
+    Atom("setsize", "setsize"),
+    Atom("spelling", "spelling"),
+    Atom("spinbutton", "spinbutton"),
+    Atom("status", "status"),
+    Atom("tableCellIndex", "table-cell-index"),
+    Atom("tablist", "tablist"),
+    Atom("textIndent", "text-indent"),
+    Atom("textInputType", "text-input-type"),
+    Atom("textLineThroughColor", "text-line-through-color"),
+    Atom("textLineThroughStyle", "text-line-through-style"),
+    Atom("textPosition", "text-position"),
+    Atom("textUnderlineColor", "text-underline-color"),
+    Atom("textUnderlineStyle", "text-underline-style"),
+    Atom("timer", "timer"),
+    Atom("toolbarname", "toolbarname"),
+    Atom("toolbarseparator", "toolbarseparator"),
+    Atom("toolbarspacer", "toolbarspacer"),
+    Atom("toolbarspring", "toolbarspring"),
+    Atom("treegrid", "treegrid"),
+    Atom("_undefined", "undefined"),
+    Atom("xmlroles", "xml-roles"),
+    # MathML xml roles
+    Atom("close_fence", "close-fence"),
+    Atom("denominator", "denominator"),
+    Atom("numerator", "numerator"),
+    Atom("open_fence", "open-fence"),
+    Atom("overscript", "overscript"),
+    Atom("presubscript", "presubscript"),
+    Atom("presuperscript", "presuperscript"),
+    Atom("root_index", "root-index"),
+    Atom("subscript", "subscript"),
+    Atom("superscript", "superscript"),
+    Atom("underscript", "underscript"),
+    Atom("onaudiostart", "onaudiostart"),
+    Atom("onaudioend", "onaudioend"),
+    Atom("onsoundstart", "onsoundstart"),
+    Atom("onsoundend", "onsoundend"),
+    Atom("onspeechstart", "onspeechstart"),
+    Atom("onspeechend", "onspeechend"),
+    Atom("onresult", "onresult"),
+    Atom("onnomatch", "onnomatch"),
+    Atom("onresume", "onresume"),
+    Atom("onmark", "onmark"),
+    Atom("onboundary", "onboundary"),
+    # Media Controller
+    Atom("onactivated", "onactivated"),
+    Atom("ondeactivated", "ondeactivated"),
+    Atom("onmetadatachange", "onmetadatachange"),
+    Atom("onplaybackstatechange", "onplaybackstatechange"),
+    Atom("onpositionstatechange", "onpositionstatechange"),
+    Atom("onsupportedkeyschange", "onsupportedkeyschange"),
+    # Contextual Identity / Containers
+    Atom("usercontextid", "usercontextid"),
+    Atom("geckoViewSessionContextId", "geckoViewSessionContextId"),
+    # Namespaces
+    Atom("nsuri_xmlns", "http://www.w3.org/2000/xmlns/"),
+    Atom("nsuri_xml", "http://www.w3.org/XML/1998/namespace"),
+    Atom("nsuri_xhtml", "http://www.w3.org/1999/xhtml"),
+    Atom("nsuri_xlink", "http://www.w3.org/1999/xlink"),
+    Atom("nsuri_xslt", "http://www.w3.org/1999/XSL/Transform"),
+    Atom("nsuri_mathml", "http://www.w3.org/1998/Math/MathML"),
+    Atom("nsuri_rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#"),
+    Atom("nsuri_xul", "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"),
+    Atom("nsuri_svg", "http://www.w3.org/2000/svg"),
+    Atom("nsuri_parsererror", "http://www.mozilla.org/newlayout/xml/parsererror.xml"),
+    # MSE
+    Atom("onsourceopen", "onsourceopen"),
+    Atom("onsourceended", "onsourceended"),
+    Atom("onsourceclose", "onsourceclose"),
+    Atom("onupdatestart", "onupdatestart"),
+    Atom("onupdate", "onupdate"),
+    Atom("onupdateend", "onupdateend"),
+    Atom("onaddsourcebuffer", "onaddsourcebuffer"),
+    Atom("onremovesourcebuffer", "onremovesourcebuffer"),
+    # RDF (not used by mozilla-central, but still used by comm-central)
+    Atom("about", "about"),
+    Atom("ID", "ID"),
+    Atom("nodeID", "nodeID"),
+    Atom("aboutEach", "aboutEach"),
+    Atom("resource", "resource"),
+    Atom("RDF", "RDF"),
+    Atom("Description", "Description"),
+    Atom("Bag", "Bag"),
+    Atom("Seq", "Seq"),
+    Atom("Alt", "Alt"),
+    # Atom("kLiAtom", "li"),  # "li" is present above
+    # Atom("kXMLNSAtom", "xmlns"),  # "xmlns" is present above
+    Atom("parseType", "parseType"),
+    # Directory service
+    Atom("DirectoryService_CurrentProcess", "XCurProcD"),
+    Atom("DirectoryService_GRE_Directory", "GreD"),
+    Atom("DirectoryService_GRE_BinDirectory", "GreBinD"),
+    Atom("DirectoryService_OS_TemporaryDirectory", "TmpD"),
+    Atom("DirectoryService_OS_CurrentProcessDirectory", "CurProcD"),
+    Atom("DirectoryService_OS_CurrentWorkingDirectory", "CurWorkD"),
+    # Atom("DirectoryService_OS_HomeDirectory", "Home"),  # "Home" is present above
+    Atom("DirectoryService_OS_DesktopDirectory", "Desk"),
+    Atom("DirectoryService_InitCurrentProcess_dummy", "MozBinD"),
+    Atom("DirectoryService_SystemDirectory", "SysD"),
+    Atom("DirectoryService_UserLibDirectory", "ULibDir"),
+    Atom("DirectoryService_DefaultDownloadDirectory", "DfltDwnld"),
+    Atom("DirectoryService_LocalApplicationsDirectory", "LocApp"),
+    Atom("DirectoryService_UserPreferencesDirectory", "UsrPrfs"),
+    Atom("DirectoryService_PictureDocumentsDirectory", "Pct"),
+    Atom("DirectoryService_WindowsDirectory", "WinD"),
+    Atom("DirectoryService_WindowsProgramFiles", "ProgF"),
+    Atom("DirectoryService_Programs", "Progs"),
+    Atom("DirectoryService_Favorites", "Favs"),
+    Atom("DirectoryService_Appdata", "AppData"),
+    Atom("DirectoryService_LocalAppdata", "LocalAppData"),
+    Atom("DirectoryService_LocalAppdataLow", "LocalAppDataLow"),
+    Atom("DirectoryService_LowIntegrityTempBase", "LowTmpDBase"),
+    Atom("DirectoryService_WinCookiesDirectory", "CookD"),
+    # CSS pseudo-elements -- these must appear in the same order as
+    # in nsCSSPseudoElementList.h
+    PseudoElementAtom("PseudoElement_after", ":after"),
+    PseudoElementAtom("PseudoElement_before", ":before"),
+    PseudoElementAtom("PseudoElement_marker", ":marker"),
+    PseudoElementAtom("PseudoElement_backdrop", ":backdrop"),
+    PseudoElementAtom("PseudoElement_cue", ":cue"),
+    PseudoElementAtom("PseudoElement_firstLetter", ":first-letter"),
+    PseudoElementAtom("PseudoElement_firstLine", ":first-line"),
+    PseudoElementAtom("PseudoElement_selection", ":selection"),
+    PseudoElementAtom("PseudoElement_mozFocusInner", ":-moz-focus-inner"),
+    PseudoElementAtom("PseudoElement_mozNumberSpinBox", ":-moz-number-spin-box"),
+    PseudoElementAtom("PseudoElement_mozNumberSpinUp", ":-moz-number-spin-up"),
+    PseudoElementAtom("PseudoElement_mozNumberSpinDown", ":-moz-number-spin-down"),
+    PseudoElementAtom("PseudoElement_mozSearchClearButton", ":-moz-search-clear-button"),
+    PseudoElementAtom("PseudoElement_mozProgressBar", ":-moz-progress-bar"),
+    PseudoElementAtom("PseudoElement_mozRangeTrack", ":-moz-range-track"),
+    PseudoElementAtom("PseudoElement_mozRangeProgress", ":-moz-range-progress"),
+    PseudoElementAtom("PseudoElement_mozRangeThumb", ":-moz-range-thumb"),
+    PseudoElementAtom("PseudoElement_mozMeterBar", ":-moz-meter-bar"),
+    PseudoElementAtom("PseudoElement_placeholder", ":placeholder"),
+    PseudoElementAtom("PseudoElement_mozColorSwatch", ":-moz-color-swatch"),
+    PseudoElementAtom("PseudoElement_mozTextControlEditingRoot", ":-moz-text-control-editing-root"),
+    PseudoElementAtom("PseudoElement_mozTextControlPreview", ":-moz-text-control-preview"),
+    PseudoElementAtom("PseudoElement_mozReveal", ":-moz-reveal"),
+    PseudoElementAtom("PseudoElement_fileSelectorButton", ":file-selector-button"),
+    # CSS anonymous boxes -- these must appear in the same order as
+    # in nsCSSAnonBoxList.h
+    NonInheritingAnonBoxAtom("AnonBox_oofPlaceholder", ":-moz-oof-placeholder"),
+    NonInheritingAnonBoxAtom("AnonBox_horizontalFramesetBorder", ":-moz-hframeset-border"),
+    NonInheritingAnonBoxAtom("AnonBox_verticalFramesetBorder", ":-moz-vframeset-border"),
+    NonInheritingAnonBoxAtom("AnonBox_framesetBlank", ":-moz-frameset-blank"),
+    NonInheritingAnonBoxAtom("AnonBox_tableColGroup", ":-moz-table-column-group"),
+    NonInheritingAnonBoxAtom("AnonBox_tableCol", ":-moz-table-column"),
+    NonInheritingAnonBoxAtom("AnonBox_page", ":-moz-page"),
+    NonInheritingAnonBoxAtom("AnonBox_pageBreak", ":-moz-page-break"),
+    NonInheritingAnonBoxAtom("AnonBox_pageContent", ":-moz-page-content"),
+    NonInheritingAnonBoxAtom("AnonBox_printedSheet", ":-moz-printed-sheet"),
+    NonInheritingAnonBoxAtom("AnonBox_columnSpanWrapper", ":-moz-column-span-wrapper"),
+    InheritingAnonBoxAtom("AnonBox_mozText", ":-moz-text"),
+    InheritingAnonBoxAtom("AnonBox_firstLetterContinuation", ":-moz-first-letter-continuation"),
+    InheritingAnonBoxAtom("AnonBox_mozBlockInsideInlineWrapper", ":-moz-block-inside-inline-wrapper"),
+    InheritingAnonBoxAtom("AnonBox_mozMathMLAnonymousBlock", ":-moz-mathml-anonymous-block"),
+    InheritingAnonBoxAtom("AnonBox_mozXULAnonymousBlock", ":-moz-xul-anonymous-block"),
+    InheritingAnonBoxAtom("AnonBox_mozLineFrame", ":-moz-line-frame"),
+    InheritingAnonBoxAtom("AnonBox_buttonContent", ":-moz-button-content"),
+    InheritingAnonBoxAtom("AnonBox_cellContent", ":-moz-cell-content"),
+    InheritingAnonBoxAtom("AnonBox_dropDownList", ":-moz-dropdown-list"),
+    InheritingAnonBoxAtom("AnonBox_fieldsetContent", ":-moz-fieldset-content"),
+    InheritingAnonBoxAtom("AnonBox_mozDisplayComboboxControlFrame", ":-moz-display-comboboxcontrol-frame"),
+    InheritingAnonBoxAtom("AnonBox_htmlCanvasContent", ":-moz-html-canvas-content"),
+    InheritingAnonBoxAtom("AnonBox_inlineTable", ":-moz-inline-table"),
+    InheritingAnonBoxAtom("AnonBox_table", ":-moz-table"),
+    InheritingAnonBoxAtom("AnonBox_tableCell", ":-moz-table-cell"),
+    InheritingAnonBoxAtom("AnonBox_tableWrapper", ":-moz-table-wrapper"),
+    InheritingAnonBoxAtom("AnonBox_tableRowGroup", ":-moz-table-row-group"),
+    InheritingAnonBoxAtom("AnonBox_tableRow", ":-moz-table-row"),
+    InheritingAnonBoxAtom("AnonBox_canvas", ":-moz-canvas"),
+    InheritingAnonBoxAtom("AnonBox_pageSequence", ":-moz-page-sequence"),
+    InheritingAnonBoxAtom("AnonBox_scrolledContent", ":-moz-scrolled-content"),
+    InheritingAnonBoxAtom("AnonBox_scrolledCanvas", ":-moz-scrolled-canvas"),
+    InheritingAnonBoxAtom("AnonBox_columnSet", ":-moz-column-set"),
+    InheritingAnonBoxAtom("AnonBox_columnContent", ":-moz-column-content"),
+    InheritingAnonBoxAtom("AnonBox_viewport", ":-moz-viewport"),
+    InheritingAnonBoxAtom("AnonBox_viewportScroll", ":-moz-viewport-scroll"),
+    InheritingAnonBoxAtom("AnonBox_anonymousFlexItem", ":-moz-anonymous-flex-item"),
+    InheritingAnonBoxAtom("AnonBox_anonymousGridItem", ":-moz-anonymous-grid-item"),
+    InheritingAnonBoxAtom("AnonBox_blockRubyContent", ":-moz-block-ruby-content"),
+    InheritingAnonBoxAtom("AnonBox_ruby", ":-moz-ruby"),
+    InheritingAnonBoxAtom("AnonBox_rubyBase", ":-moz-ruby-base"),
+    InheritingAnonBoxAtom("AnonBox_rubyBaseContainer", ":-moz-ruby-base-container"),
+    InheritingAnonBoxAtom("AnonBox_rubyText", ":-moz-ruby-text"),
+    InheritingAnonBoxAtom("AnonBox_rubyTextContainer", ":-moz-ruby-text-container"),
+    InheritingAnonBoxAtom("AnonBox_mozTreeColumn", ":-moz-tree-column"),
+    InheritingAnonBoxAtom("AnonBox_mozTreeRow", ":-moz-tree-row"),
+    InheritingAnonBoxAtom("AnonBox_mozTreeSeparator", ":-moz-tree-separator"),
+    InheritingAnonBoxAtom("AnonBox_mozTreeCell", ":-moz-tree-cell"),
+    InheritingAnonBoxAtom("AnonBox_mozTreeIndentation", ":-moz-tree-indentation"),
+    InheritingAnonBoxAtom("AnonBox_mozTreeLine", ":-moz-tree-line"),
+    InheritingAnonBoxAtom("AnonBox_mozTreeTwisty", ":-moz-tree-twisty"),
+    InheritingAnonBoxAtom("AnonBox_mozTreeImage", ":-moz-tree-image"),
+    InheritingAnonBoxAtom("AnonBox_mozTreeCellText", ":-moz-tree-cell-text"),
+    InheritingAnonBoxAtom("AnonBox_mozTreeCheckbox", ":-moz-tree-checkbox"),
+    InheritingAnonBoxAtom("AnonBox_mozTreeDropFeedback", ":-moz-tree-drop-feedback"),
+    InheritingAnonBoxAtom("AnonBox_mozSVGMarkerAnonChild", ":-moz-svg-marker-anon-child"),
+    InheritingAnonBoxAtom("AnonBox_mozSVGOuterSVGAnonChild", ":-moz-svg-outer-svg-anon-child"),
+    InheritingAnonBoxAtom("AnonBox_mozSVGForeignContent", ":-moz-svg-foreign-content"),
+    InheritingAnonBoxAtom("AnonBox_mozSVGText", ":-moz-svg-text"),
+    # END ATOMS
+] + HTML_PARSER_ATOMS
+# fmt: on
+
+
+def verify():
+    idents = set()
+    strings = set()
+    failed = False
+    for atom in STATIC_ATOMS:
+        if atom.ident in idents:
+            print("StaticAtoms.py: duplicate static atom ident: %s" % atom.ident)
+            failed = True
+        if atom.string in strings:
+            print('StaticAtoms.py: duplicate static atom string: "%s"' % atom.string)
+            failed = True
+        idents.add(atom.ident)
+        strings.add(atom.string)
+    if failed:
+        sys.exit(1)
+
+
+def generate_nsgkatomlist_h(output, *ignore):
+    verify()
+    output.write(
+        "/* THIS FILE IS AUTOGENERATED BY StaticAtoms.py.  DO NOT EDIT */\n\n"
+        "#ifdef small\n"
+        "#undef small\n"
+        "#endif\n\n"
+        "// GK_ATOM(identifier, string, hash, is_ascii_lower, gecko_type, atom_type)\n"
+        + "".join(
+            [
+                'GK_ATOM(%s, "%s", 0x%08x, %s, %s, %s)\n'
+                % (
+                    a.ident,
+                    a.string,
+                    a.hash,
+                    str(a.is_ascii_lowercase).lower(),
+                    a.ty,
+                    a.atom_type,
+                )
+                for a in STATIC_ATOMS
+            ]
+        )
+    )
+
+
+def generate_nsgkatomconsts_h(output, *ignore):
+    pseudo_index = None
+    anon_box_index = None
+    pseudo_count = 0
+    anon_box_count = 0
+    for i, atom in enumerate(STATIC_ATOMS):
+        if atom.atom_type == "PseudoElementAtom":
+            if pseudo_index is None:
+                pseudo_index = i
+            pseudo_count += 1
+        elif (
+            atom.atom_type == "NonInheritingAnonBoxAtom"
+            or atom.atom_type == "InheritingAnonBoxAtom"
+        ):
+            if anon_box_index is None:
+                anon_box_index = i
+            anon_box_count += 1
+    output.write(
+        "/* THIS IS AN AUTOGENERATED FILE.  DO NOT EDIT */\n\n"
+        "#ifndef nsGkAtomConsts_h\n"
+        "#define nsGkAtomConsts_h\n\n"
+        "namespace mozilla {\n"
+        "  constexpr uint32_t kAtomIndex_PseudoElements = %d;\n"
+        "  constexpr uint32_t kAtomCount_PseudoElements = %d;\n"
+        "  constexpr uint32_t kAtomIndex_AnonBoxes = %d;\n"
+        "  constexpr uint32_t kAtomCount_AnonBoxes = %d;\n"
+        "}\n\n"
+        "#endif\n" % (pseudo_index, pseudo_count, anon_box_index, anon_box_count)
+    )
+
+
+if __name__ == "__main__":
+    generate_nsgkatomlist_h(sys.stdout)
diff --git a/xpcom/io/nsLocalFileUnix.cpp b/xpcom/io/nsLocalFileUnix.cpp
index f3f98008ed..e2edd26b76 100644
--- a/xpcom/io/nsLocalFileUnix.cpp
+++ b/xpcom/io/nsLocalFileUnix.cpp
@@ -59,6 +59,7 @@
 
 #ifdef MOZ_WIDGET_GTK
 #  include "nsIGIOService.h"
+#  include "nsKDEUtils.h"
 #endif
 
 #ifdef MOZ_WIDGET_COCOA
@@ -2076,10 +2077,19 @@ nsLocalFile::Reveal() {
   }
 
 #ifdef MOZ_WIDGET_GTK
+  nsAutoCString url;
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
-  if (!giovfs) {
-    return NS_ERROR_FAILURE;
+  url = mPath;
+  if(nsKDEUtils::kdeSupport()) {
+    nsTArray<nsCString> command;
+    command.AppendElement( "REVEAL"_ns );
+    command.AppendElement( mPath );
+    return nsKDEUtils::command( command ) ? NS_OK : NS_ERROR_FAILURE;
   }
+
+  if (!giovfs)
+    return NS_ERROR_FAILURE;
+
   return giovfs->RevealFile(this);
 #elif defined(MOZ_WIDGET_COCOA)
   CFURLRef url;
@@ -2101,6 +2111,13 @@ nsLocalFile::Launch() {
   }
 
 #ifdef MOZ_WIDGET_GTK
+  if( nsKDEUtils::kdeSupport()) {
+    nsTArray<nsCString> command;
+    command.AppendElement( "OPEN"_ns );
+    command.AppendElement( mPath );
+    return nsKDEUtils::command( command ) ? NS_OK : NS_ERROR_FAILURE;
+  }
+
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
   if (!giovfs) {
     return NS_ERROR_FAILURE;
diff --git a/xpfe/appshell/AppWindow.cpp b/xpfe/appshell/AppWindow.cpp
index df2801539f..4952fc942e 100644
--- a/xpfe/appshell/AppWindow.cpp
+++ b/xpfe/appshell/AppWindow.cpp
@@ -80,7 +80,7 @@
 
 #include "mozilla/dom/DocumentL10n.h"
 
-#ifdef XP_MACOSX
+#if defined(XP_MACOSX) || defined(MOZ_WIDGET_GTK)
 #  include "mozilla/widget/NativeMenuSupport.h"
 #  define USE_NATIVE_MENUS
 #endif
-- 
2.36.1

