From f8f7db409bd3a325b13829938a60775d22349ae3 Mon Sep 17 00:00:00 2001
From: Peter Jung <admin@ptr1337.dev>
Date: Wed, 29 Jun 2022 00:15:49 +0200
Subject: [PATCH] kde-after-unity

Signed-off-by: Peter Jung <admin@ptr1337.dev>
---
 modules/libpref/Preferences.cpp               |   14 +-
 modules/libpref/moz.build                     |    4 +
 python/mozbuild/mozpack/chrome/flags.py       |    1 +
 python/mozbuild/mozpack/chrome/manifest.py    |    1 +
 toolkit/components/downloads/moz.build        |    4 +
 toolkit/mozapps/downloads/HelperAppDlg.jsm    |   70 +-
 .../mozapps/downloads/HelperAppDlg.jsm.orig   | 1364 ++++++++
 .../unixproxy/nsUnixSystemProxySettings.cpp   |   32 +
 .../nsUnixSystemProxySettings.cpp.orig        |  394 +++
 toolkit/xre/moz.build                         |    2 +
 toolkit/xre/nsKDEUtils.cpp                    |  321 ++
 toolkit/xre/nsKDEUtils.h                      |   48 +
 uriloader/exthandler/HandlerServiceParent.cpp |    6 +-
 .../exthandler/HandlerServiceParent.cpp.orig  |  374 +++
 uriloader/exthandler/moz.build                |    3 +
 .../exthandler/unix/nsCommonRegistry.cpp      |   53 +
 uriloader/exthandler/unix/nsCommonRegistry.h  |   28 +
 uriloader/exthandler/unix/nsKDERegistry.cpp   |   89 +
 uriloader/exthandler/unix/nsKDERegistry.h     |   34 +
 uriloader/exthandler/unix/nsMIMEInfoUnix.cpp  |   30 +-
 .../exthandler/unix/nsOSHelperAppService.cpp  |   10 +-
 widget/gtk/moz.build                          |    1 +
 widget/gtk/nsFilePicker.cpp                   |  258 +-
 widget/gtk/nsFilePicker.h                     |    6 +
 xpcom/components/ManifestParser.cpp           |   11 +-
 xpcom/components/moz.build                    |    1 +
 xpcom/io/nsLocalFileUnix.cpp                  |   21 +-
 xpcom/io/nsLocalFileUnix.cpp.orig             | 2824 +++++++++++++++++
 28 files changed, 5966 insertions(+), 38 deletions(-)
 create mode 100644 toolkit/mozapps/downloads/HelperAppDlg.jsm.orig
 create mode 100644 toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp.orig
 create mode 100644 toolkit/xre/nsKDEUtils.cpp
 create mode 100644 toolkit/xre/nsKDEUtils.h
 create mode 100644 uriloader/exthandler/HandlerServiceParent.cpp.orig
 create mode 100644 uriloader/exthandler/unix/nsCommonRegistry.cpp
 create mode 100644 uriloader/exthandler/unix/nsCommonRegistry.h
 create mode 100644 uriloader/exthandler/unix/nsKDERegistry.cpp
 create mode 100644 uriloader/exthandler/unix/nsKDERegistry.h
 create mode 100644 xpcom/io/nsLocalFileUnix.cpp.orig

diff --git a/modules/libpref/Preferences.cpp b/modules/libpref/Preferences.cpp
index 6d0bebd2ee..c138e63b23 100644
--- a/modules/libpref/Preferences.cpp
+++ b/modules/libpref/Preferences.cpp
@@ -93,6 +93,7 @@
 #ifdef MOZ_BACKGROUNDTASKS
 #  include "mozilla/BackgroundTasks.h"
 #endif
+#include "nsKDEUtils.h"
 
 #ifdef DEBUG
 #  include <map>
@@ -4772,6 +4773,17 @@ nsresult Preferences::InitInitialObjects(bool aIsStartup) {
 #endif
   };
 
+  if(nsKDEUtils::kdeSession()) { // TODO what if some setup actually requires the helper?
+    for(int i = 0;
+        i < MOZ_ARRAY_LENGTH(specialFiles);
+        ++i ) {
+      if( *specialFiles[ i ] == '\0' ) {
+        specialFiles[ i ] = "kde.js";
+        break;
+      }
+    }
+  }
+
   rv = pref_LoadPrefsInDir(defaultPrefDir, specialFiles,
                            ArrayLength(specialFiles));
   if (NS_FAILED(rv)) {
@@ -4846,7 +4858,7 @@ nsresult Preferences::InitInitialObjects(bool aIsStartup) {
       }
 
       // Do we care if a file provided by this process fails to load?
-      pref_LoadPrefsInDir(path, nullptr, 0);
+      pref_LoadPrefsInDir(path, specialFiles, ArrayLength(specialFiles));
     }
   }
 
diff --git a/modules/libpref/moz.build b/modules/libpref/moz.build
index 1f021d409c..171d034cc0 100644
--- a/modules/libpref/moz.build
+++ b/modules/libpref/moz.build
@@ -125,6 +125,10 @@ UNIFIED_SOURCES += [
     "SharedPrefMap.cpp",
 ]
 
+LOCAL_INCLUDES += [
+    '/toolkit/xre'
+]
+
 gen_all_tuple = tuple(gen_h + gen_cpp + gen_rs)
 
 GeneratedFile(
diff --git a/python/mozbuild/mozpack/chrome/flags.py b/python/mozbuild/mozpack/chrome/flags.py
index 0fe6ee99bd..f7acdafe97 100644
--- a/python/mozbuild/mozpack/chrome/flags.py
+++ b/python/mozbuild/mozpack/chrome/flags.py
@@ -234,6 +234,7 @@ class Flags(OrderedDict):
         "tablet": Flag,
         "process": StringFlag,
         "backgroundtask": StringFlag,
+        "desktop": StringFlag,
     }
     RE = re.compile(r"([!<>=]+)")
 
diff --git a/python/mozbuild/mozpack/chrome/manifest.py b/python/mozbuild/mozpack/chrome/manifest.py
index a733685f95..f64b17fb7b 100644
--- a/python/mozbuild/mozpack/chrome/manifest.py
+++ b/python/mozbuild/mozpack/chrome/manifest.py
@@ -44,6 +44,7 @@ class ManifestEntry(object):
         "process",
         "contentaccessible",
         "backgroundtask",
+        "desktop",
     ]
 
     def __init__(self, base, *flags):
diff --git a/toolkit/components/downloads/moz.build b/toolkit/components/downloads/moz.build
index d4172e2d73..8bd0577bc5 100644
--- a/toolkit/components/downloads/moz.build
+++ b/toolkit/components/downloads/moz.build
@@ -51,5 +51,9 @@ if CONFIG["MOZ_PLACES"]:
 
 FINAL_LIBRARY = "xul"
 
+LOCAL_INCLUDES += [
+    '/toolkit/xre'
+]
+
 with Files("**"):
     BUG_COMPONENT = ("Toolkit", "Downloads API")
diff --git a/toolkit/mozapps/downloads/HelperAppDlg.jsm b/toolkit/mozapps/downloads/HelperAppDlg.jsm
index 325de51c0c..8e5219f0e2 100644
--- a/toolkit/mozapps/downloads/HelperAppDlg.jsm
+++ b/toolkit/mozapps/downloads/HelperAppDlg.jsm
@@ -1259,26 +1259,56 @@ nsUnknownContentTypeDialog.prototype = {
         this.chosenApp = params.handlerApp;
       }
     } else if ("@mozilla.org/applicationchooser;1" in Cc) {
-      var nsIApplicationChooser = Ci.nsIApplicationChooser;
-      var appChooser = Cc["@mozilla.org/applicationchooser;1"].createInstance(
-        nsIApplicationChooser
-      );
-      appChooser.init(
-        this.mDialog,
-        this.dialogElement("strings").getString("chooseAppFilePickerTitle")
-      );
-      var contentTypeDialogObj = this;
-      let appChooserCallback = function appChooserCallback_done(aResult) {
-        if (aResult) {
-          contentTypeDialogObj.chosenApp = aResult.QueryInterface(
-            Ci.nsILocalHandlerApp
-          );
-        }
-        contentTypeDialogObj.finishChooseApp();
-      };
-      appChooser.open(this.mLauncher.MIMEInfo.MIMEType, appChooserCallback);
-      // The finishChooseApp is called from appChooserCallback
-      return;
+      // handle the KDE case which is implemented in the filepicker
+      // therefore falling back to Gtk2 like behaviour if KDE is running
+      // FIXME this should be better handled in the nsIApplicationChooser
+      // interface
+      var env = Components.classes["@mozilla.org/process/environment;1"]
+                          .getService(Components.interfaces.nsIEnvironment);
+      if (env.get('KDE_FULL_SESSION') == "true")
+      {
+        var nsIFilePicker = Ci.nsIFilePicker;
+        var fp = Cc["@mozilla.org/filepicker;1"]
+                    .createInstance(nsIFilePicker);
+        fp.init(this.mDialog,
+                this.dialogElement("strings").getString("chooseAppFilePickerTitle"),
+                nsIFilePicker.modeOpen);
+
+        fp.appendFilters(nsIFilePicker.filterApps);
+
+        fp.open(aResult => {
+          if (aResult == nsIFilePicker.returnOK && fp.file) {
+            // Remember the file they chose to run.
+            var localHandlerApp =
+              Cc["@mozilla.org/uriloader/local-handler-app;1"].
+                         createInstance(Ci.nsILocalHandlerApp);
+            localHandlerApp.executable = fp.file;
+            this.chosenApp = localHandlerApp;
+          }
+          this.finishChooseApp();
+        });
+      } else {
+        var nsIApplicationChooser = Ci.nsIApplicationChooser;
+        var appChooser = Cc["@mozilla.org/applicationchooser;1"].createInstance(
+          nsIApplicationChooser
+        );
+        appChooser.init(
+          this.mDialog,
+          this.dialogElement("strings").getString("chooseAppFilePickerTitle")
+        );
+        var contentTypeDialogObj = this;
+        let appChooserCallback = function appChooserCallback_done(aResult) {
+          if (aResult) {
+            contentTypeDialogObj.chosenApp = aResult.QueryInterface(
+              Ci.nsILocalHandlerApp
+            );
+          }
+          contentTypeDialogObj.finishChooseApp();
+        };
+        appChooser.open(this.mLauncher.MIMEInfo.MIMEType, appChooserCallback);
+        // The finishChooseApp is called from appChooserCallback
+        return;
+      }
     } else {
       var nsIFilePicker = Ci.nsIFilePicker;
       var fp = Cc["@mozilla.org/filepicker;1"].createInstance(nsIFilePicker);
diff --git a/toolkit/mozapps/downloads/HelperAppDlg.jsm.orig b/toolkit/mozapps/downloads/HelperAppDlg.jsm.orig
new file mode 100644
index 0000000000..325de51c0c
--- /dev/null
+++ b/toolkit/mozapps/downloads/HelperAppDlg.jsm.orig
@@ -0,0 +1,1364 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
+const { AppConstants } = ChromeUtils.import(
+  "resource://gre/modules/AppConstants.jsm"
+);
+const { XPCOMUtils } = ChromeUtils.import(
+  "resource://gre/modules/XPCOMUtils.jsm"
+);
+ChromeUtils.defineModuleGetter(
+  this,
+  "EnableDelayHelper",
+  "resource://gre/modules/SharedPromptUtils.jsm"
+);
+
+XPCOMUtils.defineLazyServiceGetter(
+  this,
+  "gReputationService",
+  "@mozilla.org/reputationservice/application-reputation-service;1",
+  Ci.nsIApplicationReputationService
+);
+
+const { Integration } = ChromeUtils.import(
+  "resource://gre/modules/Integration.jsm"
+);
+/* global DownloadIntegration */
+Integration.downloads.defineModuleGetter(
+  this,
+  "DownloadIntegration",
+  "resource://gre/modules/DownloadIntegration.jsm"
+);
+
+// /////////////////////////////////////////////////////////////////////////////
+// // Helper Functions
+
+/**
+ * Determines if a given directory is able to be used to download to.
+ *
+ * @param aDirectory
+ *        The directory to check.
+ * @return true if we can use the directory, false otherwise.
+ */
+function isUsableDirectory(aDirectory) {
+  return (
+    aDirectory.exists() && aDirectory.isDirectory() && aDirectory.isWritable()
+  );
+}
+
+// Web progress listener so we can detect errors while mLauncher is
+// streaming the data to a temporary file.
+function nsUnknownContentTypeDialogProgressListener(aHelperAppDialog) {
+  this.helperAppDlg = aHelperAppDialog;
+}
+
+nsUnknownContentTypeDialogProgressListener.prototype = {
+  // nsIWebProgressListener methods.
+  // Look for error notifications and display alert to user.
+  onStatusChange(aWebProgress, aRequest, aStatus, aMessage) {
+    if (aStatus != Cr.NS_OK) {
+      // Display error alert (using text supplied by back-end).
+      // FIXME this.dialog is undefined?
+      Services.prompt.alert(this.dialog, this.helperAppDlg.mTitle, aMessage);
+      // Close the dialog.
+      this.helperAppDlg.onCancel();
+      if (this.helperAppDlg.mDialog) {
+        this.helperAppDlg.mDialog.close();
+      }
+    }
+  },
+
+  // Ignore onProgressChange, onProgressChange64, onStateChange, onLocationChange, onSecurityChange, onContentBlockingEvent and onRefreshAttempted notifications.
+  onProgressChange(
+    aWebProgress,
+    aRequest,
+    aCurSelfProgress,
+    aMaxSelfProgress,
+    aCurTotalProgress,
+    aMaxTotalProgress
+  ) {},
+
+  onProgressChange64(
+    aWebProgress,
+    aRequest,
+    aCurSelfProgress,
+    aMaxSelfProgress,
+    aCurTotalProgress,
+    aMaxTotalProgress
+  ) {},
+
+  onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {},
+
+  onLocationChange(aWebProgress, aRequest, aLocation, aFlags) {},
+
+  onSecurityChange(aWebProgress, aRequest, aState) {},
+
+  onContentBlockingEvent(aWebProgress, aRequest, aEvent) {},
+
+  onRefreshAttempted(aWebProgress, aURI, aDelay, aSameURI) {
+    return true;
+  },
+};
+
+// /////////////////////////////////////////////////////////////////////////////
+// // nsUnknownContentTypeDialog
+
+/* This file implements the nsIHelperAppLauncherDialog interface.
+ *
+ * The implementation consists of a JavaScript "class" named nsUnknownContentTypeDialog,
+ * comprised of:
+ *   - a JS constructor function
+ *   - a prototype providing all the interface methods and implementation stuff
+ *
+ * In addition, this file implements an nsIModule object that registers the
+ * nsUnknownContentTypeDialog component.
+ */
+
+const PREF_BD_USEDOWNLOADDIR = "browser.download.useDownloadDir";
+const nsITimer = Ci.nsITimer;
+
+var downloadModule = ChromeUtils.import(
+  "resource://gre/modules/DownloadLastDir.jsm"
+);
+const { DownloadPaths } = ChromeUtils.import(
+  "resource://gre/modules/DownloadPaths.jsm"
+);
+const { DownloadUtils } = ChromeUtils.import(
+  "resource://gre/modules/DownloadUtils.jsm"
+);
+const { Downloads } = ChromeUtils.import(
+  "resource://gre/modules/Downloads.jsm"
+);
+const { FileUtils } = ChromeUtils.import(
+  "resource://gre/modules/FileUtils.jsm"
+);
+
+/* ctor
+ */
+function nsUnknownContentTypeDialog() {
+  // Initialize data properties.
+  this.mLauncher = null;
+  this.mContext = null;
+  this.mReason = null;
+  this.chosenApp = null;
+  this.givenDefaultApp = false;
+  this.updateSelf = true;
+  this.mTitle = "";
+}
+
+nsUnknownContentTypeDialog.prototype = {
+  classID: Components.ID("{F68578EB-6EC2-4169-AE19-8C6243F0ABE1}"),
+
+  nsIMIMEInfo: Ci.nsIMIMEInfo,
+
+  QueryInterface: ChromeUtils.generateQI([
+    "nsIHelperAppLauncherDialog",
+    "nsITimerCallback",
+  ]),
+
+  // ---------- nsIHelperAppLauncherDialog methods ----------
+
+  // show: Open XUL dialog using window watcher.  Since the dialog is not
+  //       modal, it needs to be a top level window and the way to open
+  //       one of those is via that route).
+  show(aLauncher, aContext, aReason) {
+    this.mLauncher = aLauncher;
+    this.mContext = aContext;
+    this.mReason = aReason;
+
+    // Cache some information in case this context goes away:
+    try {
+      let parent = aContext.getInterface(Ci.nsIDOMWindow);
+      this._mDownloadDir = new downloadModule.DownloadLastDir(parent);
+    } catch (ex) {
+      Cu.reportError(
+        "Missing window information when showing nsIHelperAppLauncherDialog: " +
+          ex
+      );
+    }
+
+    const nsITimer = Ci.nsITimer;
+    this._showTimer = Cc["@mozilla.org/timer;1"].createInstance(nsITimer);
+    this._showTimer.initWithCallback(this, 0, nsITimer.TYPE_ONE_SHOT);
+  },
+
+  // When opening from new tab, if tab closes while dialog is opening,
+  // (which is a race condition on the XUL file being cached and the timer
+  // in nsExternalHelperAppService), the dialog gets a blur and doesn't
+  // activate the OK button.  So we wait a bit before doing opening it.
+  reallyShow() {
+    try {
+      let docShell = this.mContext.getInterface(Ci.nsIDocShell);
+      let rootWin = docShell.browsingContext.topChromeWindow;
+      this.mDialog = Services.ww.openWindow(
+        rootWin,
+        "chrome://mozapps/content/downloads/unknownContentType.xhtml",
+        null,
+        "chrome,centerscreen,titlebar,dialog=yes,dependent",
+        null
+      );
+    } catch (ex) {
+      // The containing window may have gone away.  Break reference
+      // cycles and stop doing the download.
+      this.mLauncher.cancel(Cr.NS_BINDING_ABORTED);
+      return;
+    }
+
+    // Hook this object to the dialog.
+    this.mDialog.dialog = this;
+
+    // Hook up utility functions.
+    this.getSpecialFolderKey = this.mDialog.getSpecialFolderKey;
+
+    // Watch for error notifications.
+    var progressListener = new nsUnknownContentTypeDialogProgressListener(this);
+    this.mLauncher.setWebProgressListener(progressListener);
+  },
+
+  //
+  // displayBadPermissionAlert()
+  //
+  // Diplay an alert panel about the bad permission of folder/directory.
+  //
+  displayBadPermissionAlert() {
+    let bundle = Services.strings.createBundle(
+      "chrome://mozapps/locale/downloads/unknownContentType.properties"
+    );
+
+    Services.prompt.alert(
+      this.dialog,
+      bundle.GetStringFromName("badPermissions.title"),
+      bundle.GetStringFromName("badPermissions")
+    );
+  },
+
+  promptForSaveToFileAsync(
+    aLauncher,
+    aContext,
+    aDefaultFileName,
+    aSuggestedFileExtension,
+    aForcePrompt
+  ) {
+    var result = null;
+
+    this.mLauncher = aLauncher;
+
+    let bundle = Services.strings.createBundle(
+      "chrome://mozapps/locale/downloads/unknownContentType.properties"
+    );
+
+    let parent;
+    let gDownloadLastDir;
+    try {
+      parent = aContext.getInterface(Ci.nsIDOMWindow);
+    } catch (ex) {}
+
+    if (parent) {
+      gDownloadLastDir = new downloadModule.DownloadLastDir(parent);
+    } else {
+      // Use the cached download info, but pick an arbitrary parent window
+      // because the original one is definitely gone (and nsIFilePicker doesn't like
+      // a null parent):
+      gDownloadLastDir = this._mDownloadDir;
+      for (let someWin of Services.wm.getEnumerator("")) {
+        // We need to make sure we don't end up with this dialog, because otherwise
+        // that's going to go away when the user clicks "Save", and that breaks the
+        // windows file picker that's supposed to show up if we let the user choose
+        // where to save files...
+        if (someWin != this.mDialog) {
+          parent = someWin;
+        }
+      }
+      if (!parent) {
+        Cu.reportError(
+          "No candidate parent windows were found for the save filepicker." +
+            "This should never happen."
+        );
+      }
+    }
+
+    (async () => {
+      if (!aForcePrompt) {
+        // Check to see if the user wishes to auto save to the default download
+        // folder without prompting. Note that preference might not be set.
+        let autodownload = Services.prefs.getBoolPref(
+          PREF_BD_USEDOWNLOADDIR,
+          false
+        );
+
+        if (autodownload) {
+          // Retrieve the user's default download directory
+          let preferredDir = await Downloads.getPreferredDownloadsDirectory();
+          let defaultFolder = new FileUtils.File(preferredDir);
+
+          try {
+            if (aDefaultFileName) {
+              result = this.validateLeafName(
+                defaultFolder,
+                aDefaultFileName,
+                aSuggestedFileExtension
+              );
+            }
+          } catch (ex) {
+            // When the default download directory is write-protected,
+            // prompt the user for a different target file.
+          }
+
+          // Check to make sure we have a valid directory, otherwise, prompt
+          if (result) {
+            // This path is taken when we have a writable default download directory.
+            aLauncher.saveDestinationAvailable(result);
+            return;
+          }
+        }
+      }
+
+      // Use file picker to show dialog.
+      var nsIFilePicker = Ci.nsIFilePicker;
+      var picker = Cc["@mozilla.org/filepicker;1"].createInstance(
+        nsIFilePicker
+      );
+      var windowTitle = bundle.GetStringFromName("saveDialogTitle");
+      picker.init(parent, windowTitle, nsIFilePicker.modeSave);
+      if (aDefaultFileName) {
+        picker.defaultString = this.getFinalLeafName(aDefaultFileName);
+      }
+
+      if (aSuggestedFileExtension) {
+        // aSuggestedFileExtension includes the period, so strip it
+        picker.defaultExtension = aSuggestedFileExtension.substring(1);
+      } else {
+        try {
+          picker.defaultExtension = this.mLauncher.MIMEInfo.primaryExtension;
+        } catch (ex) {}
+      }
+
+      var wildCardExtension = "*";
+      if (aSuggestedFileExtension) {
+        wildCardExtension += aSuggestedFileExtension;
+        picker.appendFilter(
+          this.mLauncher.MIMEInfo.description,
+          wildCardExtension
+        );
+      }
+
+      picker.appendFilters(nsIFilePicker.filterAll);
+
+      // Default to lastDir if it is valid, otherwise use the user's default
+      // downloads directory.  getPreferredDownloadsDirectory should always
+      // return a valid directory path, so we can safely default to it.
+      let preferredDir = await Downloads.getPreferredDownloadsDirectory();
+      picker.displayDirectory = new FileUtils.File(preferredDir);
+
+      gDownloadLastDir.getFileAsync(aLauncher.source, lastDir => {
+        if (lastDir && isUsableDirectory(lastDir)) {
+          picker.displayDirectory = lastDir;
+        }
+
+        picker.open(returnValue => {
+          if (returnValue == nsIFilePicker.returnCancel) {
+            // null result means user cancelled.
+            aLauncher.saveDestinationAvailable(null);
+            return;
+          }
+
+          // Be sure to save the directory the user chose through the Save As...
+          // dialog  as the new browser.download.dir since the old one
+          // didn't exist.
+          result = picker.file;
+
+          if (result) {
+            let allowOverwrite = false;
+            try {
+              // If we're overwriting, avoid renaming our file, and assume
+              // overwriting it does the right thing.
+              if (
+                result.exists() &&
+                this.getFinalLeafName(result.leafName) == result.leafName
+              ) {
+                allowOverwrite = true;
+              }
+            } catch (ex) {
+              // As it turns out, the failure to remove the file, for example due to
+              // permission error, will be handled below eventually somehow.
+            }
+
+            var newDir = result.parent.QueryInterface(Ci.nsIFile);
+
+            // Do not store the last save directory as a pref inside the private browsing mode
+            gDownloadLastDir.setFile(aLauncher.source, newDir);
+
+            try {
+              result = this.validateLeafName(
+                newDir,
+                result.leafName,
+                null,
+                allowOverwrite
+              );
+            } catch (ex) {
+              // When the chosen download directory is write-protected,
+              // display an informative error message.
+              // In all cases, download will be stopped.
+
+              if (ex.result == Cr.NS_ERROR_FILE_ACCESS_DENIED) {
+                this.displayBadPermissionAlert();
+                aLauncher.saveDestinationAvailable(null);
+                return;
+              }
+            }
+          }
+          aLauncher.saveDestinationAvailable(result);
+        });
+      });
+    })().catch(Cu.reportError);
+  },
+
+  getFinalLeafName(aLeafName, aFileExt) {
+    return (
+      DownloadPaths.sanitize(aLeafName) ||
+      "unnamed" + (aFileExt ? "." + aFileExt : "")
+    );
+  },
+
+  /**
+   * Ensures that a local folder/file combination does not already exist in
+   * the file system (or finds such a combination with a reasonably similar
+   * leaf name), creates the corresponding file, and returns it.
+   *
+   * @param   aLocalFolder
+   *          the folder where the file resides
+   * @param   aLeafName
+   *          the string name of the file (may be empty if no name is known,
+   *          in which case a name will be chosen)
+   * @param   aFileExt
+   *          the extension of the file, if one is known; this will be ignored
+   *          if aLeafName is non-empty
+   * @param   aAllowExisting
+   *          if set to true, avoid creating a unique file.
+   * @return  nsIFile
+   *          the created file
+   * @throw   an error such as permission doesn't allow creation of
+   *          file, etc.
+   */
+  validateLeafName(aLocalFolder, aLeafName, aFileExt, aAllowExisting = false) {
+    if (!(aLocalFolder && isUsableDirectory(aLocalFolder))) {
+      throw new Components.Exception(
+        "Destination directory non-existing or permission error",
+        Cr.NS_ERROR_FILE_ACCESS_DENIED
+      );
+    }
+
+    aLeafName = this.getFinalLeafName(aLeafName, aFileExt);
+    aLocalFolder.append(aLeafName);
+
+    if (!aAllowExisting) {
+      // The following assignment can throw an exception, but
+      // is now caught properly in the caller of validateLeafName.
+      var validatedFile = DownloadPaths.createNiceUniqueFile(aLocalFolder);
+    } else {
+      validatedFile = aLocalFolder;
+    }
+
+    if (AppConstants.platform == "win") {
+      let ext;
+      try {
+        // We can fail here if there's no primary extension set
+        ext = "." + this.mLauncher.MIMEInfo.primaryExtension;
+      } catch (e) {}
+
+      // Append a file extension if it's an executable that doesn't have one
+      // but make sure we actually have an extension to add
+      let leaf = validatedFile.leafName;
+      if (
+        ext &&
+        !leaf.toLowerCase().endsWith(ext.toLowerCase()) &&
+        validatedFile.isExecutable()
+      ) {
+        validatedFile.remove(false);
+        aLocalFolder.leafName = leaf + ext;
+        if (!aAllowExisting) {
+          validatedFile = DownloadPaths.createNiceUniqueFile(aLocalFolder);
+        }
+      }
+    }
+
+    return validatedFile;
+  },
+
+  // ---------- implementation methods ----------
+
+  // initDialog:  Fill various dialog fields with initial content.
+  initDialog() {
+    // Put file name in window title.
+    var suggestedFileName = this.mLauncher.suggestedFileName;
+
+    this.mDialog.document.addEventListener("dialogaccept", this);
+    this.mDialog.document.addEventListener("dialogcancel", this);
+
+    var url = this.mLauncher.source;
+    if (url instanceof Ci.nsINestedURI) {
+      url = url.innermostURI;
+    }
+    if (url.scheme == "blob") {
+      let origin = new URL(url.spec).origin;
+      // Origin can be "null" for blob URIs from a sandbox.
+      if (origin != "null") {
+        // `newURI` can throw (like for null) and throwing here breaks...
+        // a lot of stuff. So let's avoid doing that in case there are other
+        // edgecases we're missing here.
+        try {
+          url = Services.io.newURI(origin);
+        } catch (ex) {
+          Cu.reportError(ex);
+        }
+      }
+    }
+
+    var fname = "";
+    var iconPath = "goat";
+    this.mSourcePath = url.prePath;
+    // Some URIs do not implement nsIURL, so we can't just QI.
+    if (url instanceof Ci.nsIURL) {
+      // A url, use file name from it.
+      fname = iconPath = url.fileName;
+      this.mSourcePath += url.directory;
+    } else {
+      // A generic uri, use path.
+      fname = url.pathQueryRef;
+      this.mSourcePath += url.pathQueryRef;
+    }
+
+    if (suggestedFileName) {
+      fname = iconPath = suggestedFileName;
+    }
+
+    var displayName = fname.replace(/ +/g, " ");
+
+    this.mTitle = this.dialogElement("strings").getFormattedString("title", [
+      displayName,
+    ]);
+    this.mDialog.document.title = this.mTitle;
+
+    // Put content type, filename and location into intro.
+    this.initIntro(url, fname, displayName);
+
+    var iconString =
+      "moz-icon://" +
+      iconPath +
+      "?size=16&contentType=" +
+      this.mLauncher.MIMEInfo.MIMEType;
+    this.dialogElement("contentTypeImage").setAttribute("src", iconString);
+
+    let dialog = this.mDialog.document.getElementById("unknownContentType");
+
+    // if always-save and is-executable and no-handler
+    // then set up simple ui
+    var mimeType = this.mLauncher.MIMEInfo.MIMEType;
+    let isPlain = mimeType == "text/plain";
+    var shouldntRememberChoice =
+      mimeType == "application/octet-stream" ||
+      mimeType == "application/x-msdownload" ||
+      this.mLauncher.targetFileIsExecutable ||
+      // Do not offer to remember text/plain mimetype choices if the file
+      // isn't actually a 'plain' text file.
+      (isPlain && gReputationService.isBinary(suggestedFileName));
+    if (
+      (shouldntRememberChoice && !this.openWithDefaultOK()) ||
+      Services.prefs.getBoolPref("browser.download.forbid_open_with")
+    ) {
+      // hide featured choice
+      this.dialogElement("normalBox").collapsed = true;
+      // show basic choice
+      this.dialogElement("basicBox").collapsed = false;
+      // change button labels and icons; use "save" icon for the accept
+      // button since it's the only action possible
+      let acceptButton = dialog.getButton("accept");
+      acceptButton.label = this.dialogElement("strings").getString(
+        "unknownAccept.label"
+      );
+      acceptButton.setAttribute("icon", "save");
+      dialog.getButton("cancel").label = this.dialogElement(
+        "strings"
+      ).getString("unknownCancel.label");
+      // hide other handler
+      this.dialogElement("openHandler").collapsed = true;
+      // set save as the selected option
+      this.dialogElement("mode").selectedItem = this.dialogElement("save");
+    } else {
+      this.initInteractiveControls();
+
+      // Initialize "always ask me" box. This should always be disabled
+      // and set to true for the ambiguous type application/octet-stream.
+      // We don't also check for application/x-msdownload here since we
+      // want users to be able to autodownload .exe files.
+      var rememberChoice = this.dialogElement("rememberChoice");
+
+      // Just because we have a content-type of application/octet-stream
+      // here doesn't actually mean that the content is of that type. Many
+      // servers default to sending text/plain for file types they don't know
+      // about. To account for this, the uriloader does some checking to see
+      // if a file sent as text/plain contains binary characters, and if so (*)
+      // it morphs the content-type into application/octet-stream so that
+      // the file can be properly handled. Since this is not generic binary
+      // data, rather, a data format that the system probably knows about,
+      // we don't want to use the content-type provided by this dialog's
+      // opener, as that's the generic application/octet-stream that the
+      // uriloader has passed, rather we want to ask the MIME Service.
+      // This is so we don't needlessly disable the "autohandle" checkbox.
+
+      if (shouldntRememberChoice) {
+        rememberChoice.checked = false;
+        rememberChoice.hidden = true;
+      } else {
+        rememberChoice.checked =
+          !this.mLauncher.MIMEInfo.alwaysAskBeforeHandling &&
+          this.mLauncher.MIMEInfo.preferredAction !=
+            this.nsIMIMEInfo.handleInternally;
+      }
+      this.toggleRememberChoice(rememberChoice);
+    }
+
+    this.mDialog.setTimeout(function() {
+      this.dialog.postShowCallback();
+    }, 0);
+
+    this.delayHelper = new EnableDelayHelper({
+      disableDialog: () => {
+        dialog.getButton("accept").disabled = true;
+      },
+      enableDialog: () => {
+        dialog.getButton("accept").disabled = false;
+      },
+      focusTarget: this.mDialog,
+    });
+  },
+
+  notify(aTimer) {
+    if (aTimer == this._showTimer) {
+      if (!this.mDialog) {
+        this.reallyShow();
+      }
+      // The timer won't release us, so we have to release it.
+      this._showTimer = null;
+    } else if (aTimer == this._saveToDiskTimer) {
+      // Since saveToDisk may open a file picker and therefore block this routine,
+      // we should only call it once the dialog is closed.
+      this.mLauncher.promptForSaveDestination();
+      this._saveToDiskTimer = null;
+    }
+  },
+
+  postShowCallback() {
+    this.mDialog.sizeToContent();
+
+    // Set initial focus
+    this.dialogElement("mode").focus();
+  },
+
+  initIntro(url, filename, displayname) {
+    this.dialogElement("location").value = displayname;
+    this.dialogElement("location").setAttribute("realname", filename);
+    this.dialogElement("location").setAttribute("tooltiptext", displayname);
+
+    // if mSourcePath is a local file, then let's use the pretty path name
+    // instead of an ugly url...
+    var pathString;
+    if (url instanceof Ci.nsIFileURL) {
+      try {
+        // Getting .file might throw, or .parent could be null
+        pathString = url.file.parent.path;
+      } catch (ex) {}
+    }
+
+    if (!pathString) {
+      // wasn't a fileURL
+      var tmpurl = url; // don't want to change the real url
+      try {
+        tmpurl = tmpurl
+          .mutate()
+          .setUserPass("")
+          .finalize();
+      } catch (ex) {}
+      pathString = tmpurl.prePath;
+    }
+
+    // Set the location text, which is separate from the intro text so it can be cropped
+    var location = this.dialogElement("source");
+    location.value = pathString;
+    location.setAttribute("tooltiptext", this.mSourcePath);
+
+    // Show the type of file.
+    var type = this.dialogElement("type");
+    var mimeInfo = this.mLauncher.MIMEInfo;
+
+    // 1. Try to use the pretty description of the type, if one is available.
+    var typeString = mimeInfo.description;
+
+    if (typeString == "") {
+      // 2. If there is none, use the extension to identify the file, e.g. "ZIP file"
+      var primaryExtension = "";
+      try {
+        primaryExtension = mimeInfo.primaryExtension;
+      } catch (ex) {}
+      if (primaryExtension != "") {
+        typeString = this.dialogElement(
+          "strings"
+        ).getFormattedString("fileType", [primaryExtension.toUpperCase()]);
+      }
+      // 3. If we can't even do that, just give up and show the MIME type.
+      else {
+        typeString = mimeInfo.MIMEType;
+      }
+    }
+    // When the length is unknown, contentLength would be -1
+    if (this.mLauncher.contentLength >= 0) {
+      let [size, unit] = DownloadUtils.convertByteUnits(
+        this.mLauncher.contentLength
+      );
+      type.value = this.dialogElement(
+        "strings"
+      ).getFormattedString("orderedFileSizeWithType", [typeString, size, unit]);
+    } else {
+      type.value = typeString;
+    }
+  },
+
+  // Returns true if opening the default application makes sense.
+  openWithDefaultOK() {
+    // The checking is different on Windows...
+    if (AppConstants.platform == "win") {
+      // Windows presents some special cases.
+      // We need to prevent use of "system default" when the file is
+      // executable (so the user doesn't launch nasty programs downloaded
+      // from the web), and, enable use of "system default" if it isn't
+      // executable (because we will prompt the user for the default app
+      // in that case).
+
+      //  Default is Ok if the file isn't executable (and vice-versa).
+      return !this.mLauncher.targetFileIsExecutable;
+    }
+    // On other platforms, default is Ok if there is a default app.
+    // Note that nsIMIMEInfo providers need to ensure that this holds true
+    // on each platform.
+    return this.mLauncher.MIMEInfo.hasDefaultHandler;
+  },
+
+  // Set "default" application description field.
+  initDefaultApp() {
+    // Use description, if we can get one.
+    var desc = this.mLauncher.MIMEInfo.defaultDescription;
+    if (desc) {
+      var defaultApp = this.dialogElement(
+        "strings"
+      ).getFormattedString("defaultApp", [desc]);
+      this.dialogElement("defaultHandler").label = defaultApp;
+    } else {
+      this.dialogElement("modeDeck").setAttribute("selectedIndex", "1");
+      // Hide the default handler item too, in case the user picks a
+      // custom handler at a later date which triggers the menulist to show.
+      this.dialogElement("defaultHandler").hidden = true;
+    }
+  },
+
+  getPath(aFile) {
+    if (AppConstants.platform == "macosx") {
+      return aFile.leafName || aFile.path;
+    }
+    return aFile.path;
+  },
+
+  initInteractiveControls() {
+    var modeGroup = this.dialogElement("mode");
+
+    // We don't let users open .exe files or random binary data directly
+    // from the browser at the moment because of security concerns.
+    var openWithDefaultOK = this.openWithDefaultOK();
+    var mimeType = this.mLauncher.MIMEInfo.MIMEType;
+    var openHandler = this.dialogElement("openHandler");
+    if (
+      this.mLauncher.targetFileIsExecutable ||
+      ((mimeType == "application/octet-stream" ||
+        mimeType == "application/x-msdos-program" ||
+        mimeType == "application/x-msdownload") &&
+        !openWithDefaultOK)
+    ) {
+      this.dialogElement("open").disabled = true;
+      openHandler.disabled = true;
+      openHandler.selectedItem = null;
+      modeGroup.selectedItem = this.dialogElement("save");
+      return;
+    }
+
+    // Fill in helper app info, if there is any.
+    try {
+      this.chosenApp = this.mLauncher.MIMEInfo.preferredApplicationHandler.QueryInterface(
+        Ci.nsILocalHandlerApp
+      );
+    } catch (e) {
+      this.chosenApp = null;
+    }
+    // Initialize "default application" field.
+    this.initDefaultApp();
+
+    var otherHandler = this.dialogElement("otherHandler");
+
+    // Fill application name textbox.
+    if (
+      this.chosenApp &&
+      this.chosenApp.executable &&
+      this.chosenApp.executable.path
+    ) {
+      otherHandler.setAttribute(
+        "path",
+        this.getPath(this.chosenApp.executable)
+      );
+
+      otherHandler.label = this.getFileDisplayName(this.chosenApp.executable);
+      otherHandler.hidden = false;
+    }
+
+    openHandler.selectedIndex = 0;
+    var defaultOpenHandler = this.dialogElement("defaultHandler");
+
+    if (this.shouldShowInternalHandlerOption()) {
+      this.dialogElement("handleInternally").hidden = false;
+    }
+
+    if (
+      this.mLauncher.MIMEInfo.preferredAction ==
+      this.nsIMIMEInfo.useSystemDefault
+    ) {
+      // Open (using system default).
+      modeGroup.selectedItem = this.dialogElement("open");
+    } else if (
+      this.mLauncher.MIMEInfo.preferredAction == this.nsIMIMEInfo.useHelperApp
+    ) {
+      // Open with given helper app.
+      modeGroup.selectedItem = this.dialogElement("open");
+      openHandler.selectedItem =
+        otherHandler && !otherHandler.hidden
+          ? otherHandler
+          : defaultOpenHandler;
+    } else if (
+      !this.dialogElement("handleInternally").hidden &&
+      this.mLauncher.MIMEInfo.preferredAction ==
+        this.nsIMIMEInfo.handleInternally
+    ) {
+      // Handle internally
+      modeGroup.selectedItem = this.dialogElement("handleInternally");
+    } else {
+      // Save to disk.
+      modeGroup.selectedItem = this.dialogElement("save");
+    }
+
+    // If we don't have a "default app" then disable that choice.
+    if (!openWithDefaultOK) {
+      var isSelected = defaultOpenHandler.selected;
+
+      // Disable that choice.
+      defaultOpenHandler.hidden = true;
+      // If that's the default, then switch to "save to disk."
+      if (isSelected) {
+        openHandler.selectedIndex = 1;
+        if (this.dialogElement("open").selected) {
+          modeGroup.selectedItem = this.dialogElement("save");
+        }
+      }
+    }
+
+    otherHandler.nextSibling.hidden = otherHandler.nextSibling.nextSibling.hidden = false;
+    this.updateOKButton();
+  },
+
+  // Returns the user-selected application
+  helperAppChoice() {
+    return this.chosenApp;
+  },
+
+  get saveToDisk() {
+    return this.dialogElement("save").selected;
+  },
+
+  get useOtherHandler() {
+    return (
+      this.dialogElement("open").selected &&
+      this.dialogElement("openHandler").selectedIndex == 1
+    );
+  },
+
+  get useSystemDefault() {
+    return (
+      this.dialogElement("open").selected &&
+      this.dialogElement("openHandler").selectedIndex == 0
+    );
+  },
+
+  get handleInternally() {
+    return this.dialogElement("handleInternally").selected;
+  },
+
+  toggleRememberChoice(aCheckbox) {
+    this.dialogElement("settingsChange").hidden = !aCheckbox.checked;
+    this.mDialog.sizeToContent();
+  },
+
+  openHandlerCommand() {
+    var openHandler = this.dialogElement("openHandler");
+    if (openHandler.selectedItem.id == "choose") {
+      this.chooseApp();
+    } else {
+      openHandler.setAttribute(
+        "lastSelectedItemID",
+        openHandler.selectedItem.id
+      );
+    }
+  },
+
+  updateOKButton() {
+    var ok = false;
+    if (this.dialogElement("save").selected) {
+      // This is always OK.
+      ok = true;
+    } else if (this.dialogElement("open").selected) {
+      switch (this.dialogElement("openHandler").selectedIndex) {
+        case 0:
+          // No app need be specified in this case.
+          ok = true;
+          break;
+        case 1:
+          // only enable the OK button if we have a default app to use or if
+          // the user chose an app....
+          ok =
+            this.chosenApp ||
+            /\S/.test(this.dialogElement("otherHandler").getAttribute("path"));
+          break;
+      }
+    }
+
+    // Enable Ok button if ok to press.
+    let dialog = this.mDialog.document.getElementById("unknownContentType");
+    dialog.getButton("accept").disabled = !ok;
+  },
+
+  // Returns true iff the user-specified helper app has been modified.
+  appChanged() {
+    return (
+      this.helperAppChoice() !=
+      this.mLauncher.MIMEInfo.preferredApplicationHandler
+    );
+  },
+
+  updateMIMEInfo() {
+    let { MIMEInfo } = this.mLauncher;
+
+    // Don't erase the preferred choice being internal handler
+    // -- this dialog is often the result of the handler fallback
+    // (e.g. Content-Disposition was set as attachment) and we don't
+    // want to inadvertently cause that to always show the dialog if
+    // users don't want that behaviour.
+
+    // Note: this is the same condition as the one in initDialog
+    // which avoids ticking the checkbox. The user can still change
+    // the action by ticking the checkbox, or by using the prefs to
+    // manually select always ask (at which point `areAlwaysOpeningInternally`
+    // will be false, which means `discardUpdate` will be false, which means
+    // we'll store the last-selected option even if the filetype's pref is
+    // set to always ask).
+    let areAlwaysOpeningInternally =
+      MIMEInfo.preferredAction == Ci.nsIMIMEInfo.handleInternally &&
+      !MIMEInfo.alwaysAskBeforeHandling;
+    let discardUpdate =
+      areAlwaysOpeningInternally &&
+      !this.dialogElement("rememberChoice").checked;
+
+    var needUpdate = false;
+    // If current selection differs from what's in the mime info object,
+    // then we need to update.
+    if (this.saveToDisk) {
+      needUpdate =
+        this.mLauncher.MIMEInfo.preferredAction != this.nsIMIMEInfo.saveToDisk;
+      if (needUpdate) {
+        this.mLauncher.MIMEInfo.preferredAction = this.nsIMIMEInfo.saveToDisk;
+      }
+    } else if (this.useSystemDefault) {
+      needUpdate =
+        this.mLauncher.MIMEInfo.preferredAction !=
+        this.nsIMIMEInfo.useSystemDefault;
+      if (needUpdate) {
+        this.mLauncher.MIMEInfo.preferredAction = this.nsIMIMEInfo.useSystemDefault;
+      }
+    } else if (this.useOtherHandler) {
+      // For "open with", we need to check both preferred action and whether the user chose
+      // a new app.
+      needUpdate =
+        this.mLauncher.MIMEInfo.preferredAction !=
+          this.nsIMIMEInfo.useHelperApp || this.appChanged();
+      if (needUpdate) {
+        this.mLauncher.MIMEInfo.preferredAction = this.nsIMIMEInfo.useHelperApp;
+        // App may have changed - Update application
+        var app = this.helperAppChoice();
+        this.mLauncher.MIMEInfo.preferredApplicationHandler = app;
+      }
+    } else if (this.handleInternally) {
+      needUpdate =
+        this.mLauncher.MIMEInfo.preferredAction !=
+        this.nsIMIMEInfo.handleInternally;
+      if (needUpdate) {
+        this.mLauncher.MIMEInfo.preferredAction = this.nsIMIMEInfo.handleInternally;
+      }
+    }
+    // We will also need to update if the "always ask" flag has changed.
+    needUpdate =
+      needUpdate ||
+      this.mLauncher.MIMEInfo.alwaysAskBeforeHandling !=
+        !this.dialogElement("rememberChoice").checked;
+
+    // One last special case: If the input "always ask" flag was false, then we always
+    // update.  In that case we are displaying the helper app dialog for the first
+    // time for this mime type and we need to store the user's action in the handler service
+    // (whether that action has changed or not; if it didn't change, then we need
+    // to store the "always ask" flag so the helper app dialog will or won't display
+    // next time, per the user's selection).
+    needUpdate = needUpdate || !this.mLauncher.MIMEInfo.alwaysAskBeforeHandling;
+
+    // Make sure mime info has updated setting for the "always ask" flag.
+    this.mLauncher.MIMEInfo.alwaysAskBeforeHandling = !this.dialogElement(
+      "rememberChoice"
+    ).checked;
+
+    return needUpdate && !discardUpdate;
+  },
+
+  // See if the user changed things, and if so, store this mime type in the
+  // handler service.
+  updateHelperAppPref() {
+    var handlerInfo = this.mLauncher.MIMEInfo;
+    var hs = Cc["@mozilla.org/uriloader/handler-service;1"].getService(
+      Ci.nsIHandlerService
+    );
+    hs.store(handlerInfo);
+  },
+
+  onOK(aEvent) {
+    // Verify typed app path, if necessary.
+    if (this.useOtherHandler) {
+      var helperApp = this.helperAppChoice();
+      if (
+        !helperApp ||
+        !helperApp.executable ||
+        !helperApp.executable.exists()
+      ) {
+        // Show alert and try again.
+        var bundle = this.dialogElement("strings");
+        var msg = bundle.getFormattedString("badApp", [
+          this.dialogElement("otherHandler").getAttribute("path"),
+        ]);
+        Services.prompt.alert(
+          this.mDialog,
+          bundle.getString("badApp.title"),
+          msg
+        );
+
+        // Disable the OK button.
+        let dialog = this.mDialog.document.getElementById("unknownContentType");
+        dialog.getButton("accept").disabled = true;
+        this.dialogElement("mode").focus();
+
+        // Clear chosen application.
+        this.chosenApp = null;
+
+        // Leave dialog up.
+        aEvent.preventDefault();
+      }
+    }
+
+    // Remove our web progress listener (a progress dialog will be
+    // taking over).
+    this.mLauncher.setWebProgressListener(null);
+
+    // saveToDisk and setDownloadToLaunch can return errors in
+    // certain circumstances (e.g. The user clicks cancel in the
+    // "Save to Disk" dialog. In those cases, we don't want to
+    // update the helper application preferences in the RDF file.
+    try {
+      var needUpdate = this.updateMIMEInfo();
+
+      if (this.dialogElement("save").selected) {
+        // see @notify
+        // we cannot use opener's setTimeout, see bug 420405
+        this._saveToDiskTimer = Cc["@mozilla.org/timer;1"].createInstance(
+          nsITimer
+        );
+        this._saveToDiskTimer.initWithCallback(this, 0, nsITimer.TYPE_ONE_SHOT);
+      } else {
+        let uri = this.mLauncher.source;
+        // Launch local files immediately without downloading them:
+        if (uri instanceof Ci.nsIFileURL) {
+          this.mLauncher.launchLocalFile();
+        } else {
+          this.mLauncher.setDownloadToLaunch(this.handleInternally, null);
+        }
+      }
+
+      // Update user pref for this mime type (if necessary). We do not
+      // store anything in the mime type preferences for the ambiguous
+      // type application/octet-stream. We do NOT do this for
+      // application/x-msdownload since we want users to be able to
+      // autodownload these to disk.
+      if (
+        needUpdate &&
+        this.mLauncher.MIMEInfo.MIMEType != "application/octet-stream"
+      ) {
+        this.updateHelperAppPref();
+      }
+    } catch (e) {
+      Cu.reportError(e);
+    }
+
+    this.onUnload();
+  },
+
+  onCancel() {
+    // Remove our web progress listener.
+    this.mLauncher.setWebProgressListener(null);
+
+    // Cancel app launcher.
+    try {
+      this.mLauncher.cancel(Cr.NS_BINDING_ABORTED);
+    } catch (e) {
+      Cu.reportError(e);
+    }
+
+    this.onUnload();
+  },
+
+  onUnload() {
+    this.mDialog.document.removeEventListener("dialogaccept", this);
+    this.mDialog.document.removeEventListener("dialogcancel", this);
+
+    // Unhook dialog from this object.
+    this.mDialog.dialog = null;
+  },
+
+  handleEvent(aEvent) {
+    switch (aEvent.type) {
+      case "dialogaccept":
+        this.onOK(aEvent);
+        break;
+      case "dialogcancel":
+        this.onCancel();
+        break;
+    }
+  },
+
+  dialogElement(id) {
+    return this.mDialog.document.getElementById(id);
+  },
+
+  // Retrieve the pretty description from the file
+  getFileDisplayName: function getFileDisplayName(file) {
+    if (AppConstants.platform == "win") {
+      if (file instanceof Ci.nsILocalFileWin) {
+        try {
+          return file.getVersionInfoField("FileDescription");
+        } catch (e) {}
+      }
+    } else if (AppConstants.platform == "macosx") {
+      if (file instanceof Ci.nsILocalFileMac) {
+        try {
+          return file.bundleDisplayName;
+        } catch (e) {}
+      }
+    }
+    return file.leafName;
+  },
+
+  finishChooseApp() {
+    if (this.chosenApp) {
+      // Show the "handler" menulist since we have a (user-specified)
+      // application now.
+      this.dialogElement("modeDeck").setAttribute("selectedIndex", "0");
+
+      // Update dialog.
+      var otherHandler = this.dialogElement("otherHandler");
+      otherHandler.removeAttribute("hidden");
+      otherHandler.setAttribute(
+        "path",
+        this.getPath(this.chosenApp.executable)
+      );
+      if (AppConstants.platform == "win") {
+        otherHandler.label = this.getFileDisplayName(this.chosenApp.executable);
+      } else {
+        otherHandler.label = this.chosenApp.name;
+      }
+      this.dialogElement("openHandler").selectedIndex = 1;
+      this.dialogElement("openHandler").setAttribute(
+        "lastSelectedItemID",
+        "otherHandler"
+      );
+
+      this.dialogElement("mode").selectedItem = this.dialogElement("open");
+    } else {
+      var openHandler = this.dialogElement("openHandler");
+      var lastSelectedID = openHandler.getAttribute("lastSelectedItemID");
+      if (!lastSelectedID) {
+        lastSelectedID = "defaultHandler";
+      }
+      openHandler.selectedItem = this.dialogElement(lastSelectedID);
+    }
+  },
+  // chooseApp:  Open file picker and prompt user for application.
+  chooseApp() {
+    if (AppConstants.platform == "win") {
+      // Protect against the lack of an extension
+      var fileExtension = "";
+      try {
+        fileExtension = this.mLauncher.MIMEInfo.primaryExtension;
+      } catch (ex) {}
+
+      // Try to use the pretty description of the type, if one is available.
+      var typeString = this.mLauncher.MIMEInfo.description;
+
+      if (!typeString) {
+        // If there is none, use the extension to
+        // identify the file, e.g. "ZIP file"
+        if (fileExtension) {
+          typeString = this.dialogElement(
+            "strings"
+          ).getFormattedString("fileType", [fileExtension.toUpperCase()]);
+        } else {
+          // If we can't even do that, just give up and show the MIME type.
+          typeString = this.mLauncher.MIMEInfo.MIMEType;
+        }
+      }
+
+      var params = {};
+      params.title = this.dialogElement("strings").getString(
+        "chooseAppFilePickerTitle"
+      );
+      params.description = typeString;
+      params.filename = this.mLauncher.suggestedFileName;
+      params.mimeInfo = this.mLauncher.MIMEInfo;
+      params.handlerApp = null;
+
+      this.mDialog.openDialog(
+        "chrome://global/content/appPicker.xhtml",
+        null,
+        "chrome,modal,centerscreen,titlebar,dialog=yes",
+        params
+      );
+
+      if (
+        params.handlerApp &&
+        params.handlerApp.executable &&
+        params.handlerApp.executable.isFile()
+      ) {
+        // Remember the file they chose to run.
+        this.chosenApp = params.handlerApp;
+      }
+    } else if ("@mozilla.org/applicationchooser;1" in Cc) {
+      var nsIApplicationChooser = Ci.nsIApplicationChooser;
+      var appChooser = Cc["@mozilla.org/applicationchooser;1"].createInstance(
+        nsIApplicationChooser
+      );
+      appChooser.init(
+        this.mDialog,
+        this.dialogElement("strings").getString("chooseAppFilePickerTitle")
+      );
+      var contentTypeDialogObj = this;
+      let appChooserCallback = function appChooserCallback_done(aResult) {
+        if (aResult) {
+          contentTypeDialogObj.chosenApp = aResult.QueryInterface(
+            Ci.nsILocalHandlerApp
+          );
+        }
+        contentTypeDialogObj.finishChooseApp();
+      };
+      appChooser.open(this.mLauncher.MIMEInfo.MIMEType, appChooserCallback);
+      // The finishChooseApp is called from appChooserCallback
+      return;
+    } else {
+      var nsIFilePicker = Ci.nsIFilePicker;
+      var fp = Cc["@mozilla.org/filepicker;1"].createInstance(nsIFilePicker);
+      fp.init(
+        this.mDialog,
+        this.dialogElement("strings").getString("chooseAppFilePickerTitle"),
+        nsIFilePicker.modeOpen
+      );
+
+      fp.appendFilters(nsIFilePicker.filterApps);
+
+      fp.open(aResult => {
+        if (aResult == nsIFilePicker.returnOK && fp.file) {
+          // Remember the file they chose to run.
+          var localHandlerApp = Cc[
+            "@mozilla.org/uriloader/local-handler-app;1"
+          ].createInstance(Ci.nsILocalHandlerApp);
+          localHandlerApp.executable = fp.file;
+          this.chosenApp = localHandlerApp;
+        }
+        this.finishChooseApp();
+      });
+      // The finishChooseApp is called from fp.open() callback
+      return;
+    }
+
+    this.finishChooseApp();
+  },
+
+  shouldShowInternalHandlerOption() {
+    let browsingContext = this.mDialog.BrowsingContext.get(
+      this.mLauncher.browsingContextId
+    );
+    let primaryExtension = "";
+    try {
+      // The primaryExtension getter may throw if there are no
+      // known extensions for this mimetype.
+      primaryExtension = this.mLauncher.MIMEInfo.primaryExtension;
+    } catch (e) {}
+
+    // Only available for PDF files when pdf.js is enabled.
+    // Skip if the current window uses the resource scheme, to avoid
+    // showing the option when using the Download button in pdf.js.
+    if (primaryExtension == "pdf") {
+      return (
+        !(
+          this.mLauncher.source.schemeIs("blob") ||
+          this.mLauncher.source.equalsExceptRef(
+            browsingContext.currentWindowGlobal.documentURI
+          )
+        ) &&
+        !Services.prefs.getBoolPref("pdfjs.disabled", true) &&
+        Services.prefs.getBoolPref(
+          "browser.helperApps.showOpenOptionForPdfJS",
+          false
+        )
+      );
+    }
+
+    return (
+      Services.prefs.getBoolPref(
+        "browser.helperApps.showOpenOptionForViewableInternally",
+        false
+      ) &&
+      DownloadIntegration.shouldViewDownloadInternally(
+        this.mLauncher.MIMEInfo.MIMEType,
+        primaryExtension
+      )
+    );
+  },
+
+  // Turn this on to get debugging messages.
+  debug: false,
+
+  // Dump text (if debug is on).
+  dump(text) {
+    if (this.debug) {
+      dump(text);
+    }
+  },
+};
+
+var EXPORTED_SYMBOLS = ["nsUnknownContentTypeDialog"];
diff --git a/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
index ef110b1287..4983f0bd76 100644
--- a/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
+++ b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
@@ -15,6 +15,7 @@
 #include "nsNetUtil.h"
 #include "nsISupportsPrimitives.h"
 #include "nsIGSettingsService.h"
+#include "nsKDEUtils.h"
 
 using namespace mozilla;
 
@@ -38,6 +39,8 @@ class nsUnixSystemProxySettings final : public nsISystemProxySettings {
                                  nsACString& aResult);
   nsresult SetProxyResultFromGSettings(const char* aKeyBase, const char* aType,
                                        nsACString& aResult);
+  nsresult GetProxyFromKDE(const nsACString& aScheme, const nsACString& aHost,
+                           PRInt32 aPort, nsACString& aResult);
 };
 
 NS_IMPL_ISUPPORTS(nsUnixSystemProxySettings, nsISystemProxySettings)
@@ -379,6 +382,9 @@ nsresult nsUnixSystemProxySettings::GetProxyForURI(const nsACString& aSpec,
                                                    const nsACString& aHost,
                                                    const int32_t aPort,
                                                    nsACString& aResult) {
+  if (nsKDEUtils::kdeSupport())
+    return GetProxyFromKDE(aScheme, aHost, aPort, aResult);
+
   if (mProxySettings) {
     nsresult rv = GetProxyFromGSettings(aScheme, aHost, aPort, aResult);
     if (NS_SUCCEEDED(rv)) return rv;
@@ -387,6 +393,32 @@ nsresult nsUnixSystemProxySettings::GetProxyForURI(const nsACString& aSpec,
   return GetProxyFromEnvironment(aScheme, aHost, aPort, aResult);
 }
 
+nsresult
+nsUnixSystemProxySettings::GetProxyFromKDE(const nsACString& aScheme,
+                                           const nsACString& aHost,
+                                           PRInt32 aPort,
+                                           nsACString& aResult)
+{
+  nsAutoCString url;
+  url = aScheme;
+  url += "://";
+  url += aHost;
+  if( aPort >= 0 )
+  {
+    url += ":";
+    url += nsPrintfCString("%d", aPort);
+  }
+  nsTArray<nsCString> command;
+  command.AppendElement( "GETPROXY"_ns );
+  command.AppendElement( url );
+  nsTArray<nsCString> result;
+  if( !nsKDEUtils::command( command, &result ) || result.Length() != 1 )
+    return NS_ERROR_FAILURE;
+  aResult = result[0];
+  return NS_OK;
+}
+
+
 NS_IMPL_COMPONENT_FACTORY(nsUnixSystemProxySettings) {
   auto result = MakeRefPtr<nsUnixSystemProxySettings>();
   result->Init();
diff --git a/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp.orig b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp.orig
new file mode 100644
index 0000000000..ef110b1287
--- /dev/null
+++ b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp.orig
@@ -0,0 +1,394 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISystemProxySettings.h"
+#include "mozilla/Components.h"
+#include "nsIURI.h"
+#include "nsArrayUtils.h"
+#include "prnetdb.h"
+#include "prenv.h"
+#include "nsInterfaceHashtable.h"
+#include "nsHashtablesFwd.h"
+#include "nsHashKeys.h"
+#include "nsNetUtil.h"
+#include "nsISupportsPrimitives.h"
+#include "nsIGSettingsService.h"
+
+using namespace mozilla;
+
+class nsUnixSystemProxySettings final : public nsISystemProxySettings {
+ public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSISYSTEMPROXYSETTINGS
+
+  nsUnixSystemProxySettings() : mSchemeProxySettings(4) {}
+  void Init();
+
+ private:
+  ~nsUnixSystemProxySettings() = default;
+
+  nsCOMPtr<nsIGSettingsService> mGSettings;
+  nsCOMPtr<nsIGSettingsCollection> mProxySettings;
+  nsInterfaceHashtable<nsCStringHashKey, nsIGSettingsCollection>
+      mSchemeProxySettings;
+  nsresult GetProxyFromGSettings(const nsACString& aScheme,
+                                 const nsACString& aHost, int32_t aPort,
+                                 nsACString& aResult);
+  nsresult SetProxyResultFromGSettings(const char* aKeyBase, const char* aType,
+                                       nsACString& aResult);
+};
+
+NS_IMPL_ISUPPORTS(nsUnixSystemProxySettings, nsISystemProxySettings)
+
+NS_IMETHODIMP
+nsUnixSystemProxySettings::GetMainThreadOnly(bool* aMainThreadOnly) {
+  // dbus prevents us from being threadsafe, but this routine should not block
+  // anyhow
+  *aMainThreadOnly = true;
+  return NS_OK;
+}
+
+void nsUnixSystemProxySettings::Init() {
+  mGSettings = do_GetService(NS_GSETTINGSSERVICE_CONTRACTID);
+  if (mGSettings) {
+    mGSettings->GetCollectionForSchema("org.gnome.system.proxy"_ns,
+                                       getter_AddRefs(mProxySettings));
+  }
+}
+
+nsresult nsUnixSystemProxySettings::GetPACURI(nsACString& aResult) {
+  if (mProxySettings) {
+    nsCString proxyMode;
+    // Check if mode is auto
+    nsresult rv = mProxySettings->GetString("mode"_ns, proxyMode);
+    if (rv == NS_OK && proxyMode.EqualsLiteral("auto")) {
+      return mProxySettings->GetString("autoconfig-url"_ns, aResult);
+    }
+  }
+
+  // Return an empty string when auto mode is not set.
+  aResult.Truncate();
+  return NS_OK;
+}
+
+static bool IsInNoProxyList(const nsACString& aHost, int32_t aPort,
+                            const char* noProxyVal) {
+  NS_ASSERTION(aPort >= 0, "Negative port?");
+
+  nsAutoCString noProxy(noProxyVal);
+  if (noProxy.EqualsLiteral("*")) return true;
+
+  noProxy.StripWhitespace();
+
+  nsReadingIterator<char> pos;
+  nsReadingIterator<char> end;
+  noProxy.BeginReading(pos);
+  noProxy.EndReading(end);
+  while (pos != end) {
+    nsReadingIterator<char> last = pos;
+    nsReadingIterator<char> nextPos;
+    if (FindCharInReadable(',', last, end)) {
+      nextPos = last;
+      ++nextPos;
+    } else {
+      last = end;
+      nextPos = end;
+    }
+
+    nsReadingIterator<char> colon = pos;
+    int32_t port = -1;
+    if (FindCharInReadable(':', colon, last)) {
+      ++colon;
+      nsDependentCSubstring portStr(colon, last);
+      nsAutoCString portStr2(
+          portStr);  // We need this for ToInteger. String API's suck.
+      nsresult err;
+      port = portStr2.ToInteger(&err);
+      if (NS_FAILED(err)) {
+        port = -2;  // don't match any port, so we ignore this pattern
+      }
+      --colon;
+    } else {
+      colon = last;
+    }
+
+    if (port == -1 || port == aPort) {
+      nsDependentCSubstring hostStr(pos, colon);
+      // By using StringEndsWith instead of an equality comparator, we can
+      // include sub-domains
+      if (StringEndsWith(aHost, hostStr, nsCaseInsensitiveCStringComparator))
+        return true;
+    }
+
+    pos = nextPos;
+  }
+
+  return false;
+}
+
+static void SetProxyResult(const char* aType, const nsACString& aHost,
+                           int32_t aPort, nsACString& aResult) {
+  aResult.AssignASCII(aType);
+  aResult.Append(' ');
+  aResult.Append(aHost);
+  if (aPort > 0) {
+    aResult.Append(':');
+    aResult.AppendInt(aPort);
+  }
+}
+
+static void SetProxyResultDirect(nsACString& aResult) {
+  aResult.AssignLiteral("DIRECT");
+}
+
+static nsresult GetProxyFromEnvironment(const nsACString& aScheme,
+                                        const nsACString& aHost, int32_t aPort,
+                                        nsACString& aResult) {
+  nsAutoCString envVar;
+  envVar.Append(aScheme);
+  envVar.AppendLiteral("_proxy");
+  const char* proxyVal = PR_GetEnv(envVar.get());
+  if (!proxyVal) {
+    proxyVal = PR_GetEnv("all_proxy");
+    if (!proxyVal) {
+      // Return failure so that the caller can detect the failure and
+      // fall back to other proxy detection (e.g., WPAD)
+      return NS_ERROR_FAILURE;
+    }
+  }
+
+  const char* noProxyVal = PR_GetEnv("no_proxy");
+  if (noProxyVal && IsInNoProxyList(aHost, aPort, noProxyVal)) {
+    SetProxyResultDirect(aResult);
+    return NS_OK;
+  }
+
+  // Use our URI parser to crack the proxy URI
+  nsCOMPtr<nsIURI> proxyURI;
+  nsresult rv = NS_NewURI(getter_AddRefs(proxyURI), proxyVal);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Is there a way to specify "socks://" or something in these environment
+  // variables? I can't find any documentation.
+  if (!proxyURI->SchemeIs("http")) {
+    return NS_ERROR_UNKNOWN_PROTOCOL;
+  }
+
+  nsAutoCString proxyHost;
+  rv = proxyURI->GetHost(proxyHost);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  int32_t proxyPort;
+  rv = proxyURI->GetPort(&proxyPort);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  SetProxyResult("PROXY", proxyHost, proxyPort, aResult);
+  return NS_OK;
+}
+
+nsresult nsUnixSystemProxySettings::SetProxyResultFromGSettings(
+    const char* aKeyBase, const char* aType, nsACString& aResult) {
+  nsDependentCString key(aKeyBase);
+
+  nsCOMPtr<nsIGSettingsCollection> proxy_settings =
+      mSchemeProxySettings.Get(key);
+  nsresult rv;
+  if (!proxy_settings) {
+    rv =
+        mGSettings->GetCollectionForSchema(key, getter_AddRefs(proxy_settings));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    mSchemeProxySettings.InsertOrUpdate(key, proxy_settings);
+  }
+
+  nsAutoCString host;
+  rv = proxy_settings->GetString("host"_ns, host);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (host.IsEmpty()) return NS_ERROR_FAILURE;
+
+  int32_t port;
+  rv = proxy_settings->GetInt("port"_ns, &port);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  /* When port is 0, proxy is not considered as enabled even if host is set. */
+  if (port == 0) return NS_ERROR_FAILURE;
+
+  SetProxyResult(aType, host, port, aResult);
+  return NS_OK;
+}
+
+/* copied from nsProtocolProxyService.cpp --- we should share this! */
+static void proxy_MaskIPv6Addr(PRIPv6Addr& addr, uint16_t mask_len) {
+  if (mask_len == 128) return;
+
+  if (mask_len > 96) {
+    addr.pr_s6_addr32[3] =
+        PR_htonl(PR_ntohl(addr.pr_s6_addr32[3]) & (~0L << (128 - mask_len)));
+  } else if (mask_len > 64) {
+    addr.pr_s6_addr32[3] = 0;
+    addr.pr_s6_addr32[2] =
+        PR_htonl(PR_ntohl(addr.pr_s6_addr32[2]) & (~0L << (96 - mask_len)));
+  } else if (mask_len > 32) {
+    addr.pr_s6_addr32[3] = 0;
+    addr.pr_s6_addr32[2] = 0;
+    addr.pr_s6_addr32[1] =
+        PR_htonl(PR_ntohl(addr.pr_s6_addr32[1]) & (~0L << (64 - mask_len)));
+  } else {
+    addr.pr_s6_addr32[3] = 0;
+    addr.pr_s6_addr32[2] = 0;
+    addr.pr_s6_addr32[1] = 0;
+    addr.pr_s6_addr32[0] =
+        PR_htonl(PR_ntohl(addr.pr_s6_addr32[0]) & (~0L << (32 - mask_len)));
+  }
+}
+
+static bool ConvertToIPV6Addr(const nsACString& aName, PRIPv6Addr* aAddr,
+                              int32_t* aMask) {
+  PRNetAddr addr;
+  // try to convert hostname to IP
+  if (PR_StringToNetAddr(PromiseFlatCString(aName).get(), &addr) != PR_SUCCESS)
+    return false;
+
+  // convert parsed address to IPv6
+  if (addr.raw.family == PR_AF_INET) {
+    // convert to IPv4-mapped address
+    PR_ConvertIPv4AddrToIPv6(addr.inet.ip, aAddr);
+    if (aMask) {
+      if (*aMask <= 32)
+        *aMask += 96;
+      else
+        return false;
+    }
+  } else if (addr.raw.family == PR_AF_INET6) {
+    // copy the address
+    memcpy(aAddr, &addr.ipv6.ip, sizeof(PRIPv6Addr));
+  } else {
+    return false;
+  }
+
+  return true;
+}
+
+static bool HostIgnoredByProxy(const nsACString& aIgnore,
+                               const nsACString& aHost) {
+  if (aIgnore.Equals(aHost, nsCaseInsensitiveCStringComparator)) return true;
+
+  if (aIgnore.First() == '*' &&
+      StringEndsWith(aHost, nsDependentCSubstring(aIgnore, 1),
+                     nsCaseInsensitiveCStringComparator))
+    return true;
+
+  int32_t mask = 128;
+  nsReadingIterator<char> start;
+  nsReadingIterator<char> slash;
+  nsReadingIterator<char> end;
+  aIgnore.BeginReading(start);
+  aIgnore.BeginReading(slash);
+  aIgnore.EndReading(end);
+  if (FindCharInReadable('/', slash, end)) {
+    ++slash;
+    nsDependentCSubstring maskStr(slash, end);
+    nsAutoCString maskStr2(maskStr);
+    nsresult err;
+    mask = maskStr2.ToInteger(&err);
+    if (NS_FAILED(err)) {
+      mask = 128;
+    }
+    --slash;
+  } else {
+    slash = end;
+  }
+
+  nsDependentCSubstring ignoreStripped(start, slash);
+  PRIPv6Addr ignoreAddr, hostAddr;
+  if (!ConvertToIPV6Addr(ignoreStripped, &ignoreAddr, &mask) ||
+      !ConvertToIPV6Addr(aHost, &hostAddr, nullptr))
+    return false;
+
+  proxy_MaskIPv6Addr(ignoreAddr, mask);
+  proxy_MaskIPv6Addr(hostAddr, mask);
+
+  return memcmp(&ignoreAddr, &hostAddr, sizeof(PRIPv6Addr)) == 0;
+}
+
+nsresult nsUnixSystemProxySettings::GetProxyFromGSettings(
+    const nsACString& aScheme, const nsACString& aHost, int32_t aPort,
+    nsACString& aResult) {
+  nsCString proxyMode;
+  nsresult rv = mProxySettings->GetString("mode"_ns, proxyMode);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // return NS_ERROR_FAILURE when no proxy is set
+  if (!proxyMode.EqualsLiteral("manual")) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsIArray> ignoreList;
+  if (NS_SUCCEEDED(mProxySettings->GetStringList("ignore-hosts"_ns,
+                                                 getter_AddRefs(ignoreList))) &&
+      ignoreList) {
+    uint32_t len = 0;
+    ignoreList->GetLength(&len);
+    for (uint32_t i = 0; i < len; ++i) {
+      nsCOMPtr<nsISupportsCString> str = do_QueryElementAt(ignoreList, i);
+      if (str) {
+        nsCString s;
+        if (NS_SUCCEEDED(str->GetData(s)) && !s.IsEmpty()) {
+          if (HostIgnoredByProxy(s, aHost)) {
+            SetProxyResultDirect(aResult);
+            return NS_OK;
+          }
+        }
+      }
+    }
+  }
+
+  if (aScheme.LowerCaseEqualsLiteral("http")) {
+    rv = SetProxyResultFromGSettings("org.gnome.system.proxy.http", "PROXY",
+                                     aResult);
+  } else if (aScheme.LowerCaseEqualsLiteral("https")) {
+    rv = SetProxyResultFromGSettings("org.gnome.system.proxy.https", "PROXY",
+                                     aResult);
+    /* Try to use HTTP proxy when HTTPS proxy is not explicitly defined */
+    if (rv != NS_OK)
+      rv = SetProxyResultFromGSettings("org.gnome.system.proxy.http", "PROXY",
+                                       aResult);
+  } else if (aScheme.LowerCaseEqualsLiteral("ftp")) {
+    rv = SetProxyResultFromGSettings("org.gnome.system.proxy.ftp", "PROXY",
+                                     aResult);
+  } else {
+    rv = NS_ERROR_FAILURE;
+  }
+  if (rv != NS_OK) {
+    /* If proxy for scheme is not specified, use SOCKS proxy for all schemes */
+    rv = SetProxyResultFromGSettings("org.gnome.system.proxy.socks", "SOCKS",
+                                     aResult);
+  }
+
+  if (NS_FAILED(rv)) {
+    SetProxyResultDirect(aResult);
+  }
+
+  return NS_OK;
+}
+
+nsresult nsUnixSystemProxySettings::GetProxyForURI(const nsACString& aSpec,
+                                                   const nsACString& aScheme,
+                                                   const nsACString& aHost,
+                                                   const int32_t aPort,
+                                                   nsACString& aResult) {
+  if (mProxySettings) {
+    nsresult rv = GetProxyFromGSettings(aScheme, aHost, aPort, aResult);
+    if (NS_SUCCEEDED(rv)) return rv;
+  }
+
+  return GetProxyFromEnvironment(aScheme, aHost, aPort, aResult);
+}
+
+NS_IMPL_COMPONENT_FACTORY(nsUnixSystemProxySettings) {
+  auto result = MakeRefPtr<nsUnixSystemProxySettings>();
+  result->Init();
+  return result.forget().downcast<nsISupports>();
+}
diff --git a/toolkit/xre/moz.build b/toolkit/xre/moz.build
index 6475c0296a..83e0184d49 100644
--- a/toolkit/xre/moz.build
+++ b/toolkit/xre/moz.build
@@ -97,7 +97,9 @@ elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "uikit":
         "UIKitDirProvider.mm",
     ]
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
+    EXPORTS += ['nsKDEUtils.h']
     UNIFIED_SOURCES += [
+        "nsKDEUtils.cpp",
         "nsNativeAppSupportUnix.cpp",
     ]
     CXXFLAGS += CONFIG["MOZ_X11_SM_CFLAGS"]
diff --git a/toolkit/xre/nsKDEUtils.cpp b/toolkit/xre/nsKDEUtils.cpp
new file mode 100644
index 0000000000..7a6edf0770
--- /dev/null
+++ b/toolkit/xre/nsKDEUtils.cpp
@@ -0,0 +1,321 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsKDEUtils.h"
+#include "nsIWidget.h"
+#include "nsISupportsPrimitives.h"
+#include "nsIMutableArray.h"
+#include "nsComponentManagerUtils.h"
+#include "nsArrayUtils.h"
+
+#include <gtk/gtk.h>
+
+#include <limits.h>
+#include <stdio.h>
+#include <sys/wait.h>
+#include <sys/resource.h>
+#include <unistd.h>
+#include <X11/Xlib.h>
+// copied from X11/X.h as a hack since for an unknown
+// reason it's not picked up from X11/X.h
+#ifndef None
+#define None                 0L /* universal null resource or null atom */
+#endif
+
+//#define DEBUG_KDE
+#ifdef DEBUG_KDE
+#define KMOZILLAHELPER "kmozillahelper"
+#else
+// not need for lib64, it's a binary
+#define KMOZILLAHELPER "/usr/lib/mozilla/kmozillahelper"
+#endif
+
+#define KMOZILLAHELPER_VERSION 6
+#define MAKE_STR2( n ) #n
+#define MAKE_STR( n ) MAKE_STR2( n )
+
+static bool getKdeSession()
+{
+    if (PR_GetEnv("KDE_FULL_SESSION"))
+    {
+      return true;
+    }
+    return false;
+}
+
+static bool getKdeSupport()
+    {
+    nsTArray<nsCString> command;
+    command.AppendElement( "CHECK"_ns );
+    command.AppendElement( "KMOZILLAHELPER_VERSION"_ns );
+    bool kde = nsKDEUtils::command( command );
+#ifdef DEBUG_KDE
+    fprintf( stderr, "KDE RUNNING %d\n", kde );
+#endif
+    return kde;
+    }
+
+nsKDEUtils::nsKDEUtils()
+    : commandFile( NULL )
+    , replyFile( NULL )
+    {
+    }
+
+nsKDEUtils::~nsKDEUtils()
+    {
+//    closeHelper(); not actually useful, exiting will close the fd too
+    }
+
+nsKDEUtils* nsKDEUtils::self()
+    {
+    static nsKDEUtils s;
+    return &s;
+    }
+
+static bool helperRunning = false;
+static bool helperFailed = false;
+
+bool nsKDEUtils::kdeSession()
+    {
+    static bool session = getKdeSession();
+    return session;
+    }
+
+bool nsKDEUtils::kdeSupport()
+    {
+    static bool support = kdeSession() && getKdeSupport();
+    return support && helperRunning;
+    }
+
+struct nsKDECommandData
+    {
+    FILE* file;
+    nsTArray<nsCString>* output;
+    GMainLoop* loop;
+    bool success;
+    };
+
+static gboolean kdeReadFunc( GIOChannel*, GIOCondition, gpointer data )
+    {
+    nsKDECommandData* p = static_cast< nsKDECommandData* >( data );
+    char buf[ 8192 ]; // TODO big enough
+    bool command_done = false;
+    bool command_failed = false;
+    while( !command_done && !command_failed && fgets( buf, 8192, p->file ) != NULL )
+        { // TODO what if the kernel splits a line into two chunks?
+//#ifdef DEBUG_KDE
+//        fprintf( stderr, "READ: %s %d\n", buf, feof( p->file ));
+//#endif
+        if( char* eol = strchr( buf, '\n' ))
+            *eol = '\0';
+        command_done = ( strcmp( buf, "\\1" ) == 0 );
+        command_failed = ( strcmp( buf, "\\0" ) == 0 );
+        nsAutoCString line( buf );
+        line.ReplaceSubstring( "\\n", "\n" );
+        line.ReplaceSubstring( "\\" "\\", "\\" ); //  \\ -> \ , i.e. unescape
+        if( p->output && !( command_done || command_failed ))
+            p->output->AppendElement( nsCString( buf )); // TODO utf8?
+        }
+    bool quit = false;
+    if( feof( p->file ) || command_failed )
+        {
+        quit = true;
+        p->success = false;
+        }
+    if( command_done )
+        { // reading one reply finished
+        quit = true;
+        p->success = true;
+        }
+    if( quit )
+        {
+        if( p->loop )
+            g_main_loop_quit( p->loop );
+        return FALSE;
+        }
+    return TRUE;
+    }
+
+bool nsKDEUtils::command( const nsTArray<nsCString>& command, nsTArray<nsCString>* output )
+    {
+    return self()->internalCommand( command, NULL, false, output );
+    }
+
+bool nsKDEUtils::command( nsIArray* command, nsIArray** output)
+    {
+    nsTArray<nsCString> in;
+    PRUint32 length;
+    command->GetLength( &length );
+    for ( PRUint32 i = 0; i < length; i++ )
+        {
+        nsCOMPtr<nsISupportsCString> str = do_QueryElementAt( command, i );
+        if( str )
+            {
+            nsAutoCString s;
+            str->GetData( s );
+            in.AppendElement( s );
+            }
+        }
+
+    nsTArray<nsCString> out;
+    bool ret = self()->internalCommand( in, NULL, false, &out );
+
+    if ( !output ) return ret;
+
+    nsCOMPtr<nsIMutableArray> result = do_CreateInstance( NS_ARRAY_CONTRACTID );
+    if ( !result ) return false;
+
+    for ( PRUint32 i = 0; i < out.Length(); i++ )
+        {
+        nsCOMPtr<nsISupportsCString> rstr = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+        if ( !rstr ) return false;
+
+        rstr->SetData( out[i] );
+        result->AppendElement( rstr );
+        }
+
+    NS_ADDREF( *output = result);
+    return ret;
+    }
+
+
+bool nsKDEUtils::commandBlockUi( const nsTArray<nsCString>& command, GtkWindow* parent, nsTArray<nsCString>* output )
+    {
+    return self()->internalCommand( command, parent, true, output );
+    }
+
+bool nsKDEUtils::internalCommand( const nsTArray<nsCString>& command, GtkWindow* parent, bool blockUi,
+    nsTArray<nsCString>* output )
+    {
+    if( !startHelper())
+        return false;
+    feedCommand( command );
+    // do not store the data in 'this' but in extra structure, just in case there
+    // is reentrancy (can there be? the event loop is re-entered)
+    nsKDECommandData data;
+    data.file = replyFile;
+    data.output = output;
+    data.success = false;
+    if( blockUi )
+        {
+        data.loop = g_main_loop_new( NULL, FALSE );
+        GtkWidget* window = gtk_window_new( GTK_WINDOW_TOPLEVEL );
+        if( parent && gtk_window_get_group(parent) )
+            gtk_window_group_add_window( gtk_window_get_group(parent), GTK_WINDOW( window ));
+        gtk_widget_realize( window );
+        gtk_widget_set_sensitive( window, TRUE );
+        gtk_grab_add( window );
+        GIOChannel* channel = g_io_channel_unix_new( fileno( data.file ));
+        g_io_add_watch( channel, static_cast< GIOCondition >( G_IO_IN | G_IO_ERR | G_IO_HUP ), kdeReadFunc, &data );
+        g_io_channel_unref( channel );
+        g_main_loop_run( data.loop );
+        g_main_loop_unref( data.loop );
+        gtk_grab_remove( window );
+        gtk_widget_destroy( window );
+        }
+    else
+        {
+        data.loop = NULL;
+        while( kdeReadFunc( NULL, static_cast< GIOCondition >( 0 ), &data ))
+            ;
+        }
+    return data.success;
+    }
+
+bool nsKDEUtils::startHelper()
+    {
+    if( helperRunning )
+        return true;
+    if( helperFailed )
+        return false;
+    helperFailed = true;
+    int fdcommand[ 2 ];
+    int fdreply[ 2 ];
+    if( pipe( fdcommand ) < 0 )
+        return false;
+    if( pipe( fdreply ) < 0 )
+        {
+        close( fdcommand[ 0 ] );
+        close( fdcommand[ 1 ] );
+        return false;
+        }
+    char* args[ 2 ] = { const_cast< char* >( KMOZILLAHELPER ), NULL };
+    switch( fork())
+        {
+        case -1:
+            {
+            close( fdcommand[ 0 ] );
+            close( fdcommand[ 1 ] );
+            close( fdreply[ 0 ] );
+            close( fdreply[ 1 ] );
+            return false;
+            }
+        case 0: // child
+            {
+            if( dup2( fdcommand[ 0 ], STDIN_FILENO ) < 0 )
+                _exit( 1 );
+            if( dup2( fdreply[ 1 ], STDOUT_FILENO ) < 0 )
+                _exit( 1 );
+            int maxfd = 1024; // close all other fds
+            struct rlimit rl;
+            if( getrlimit( RLIMIT_NOFILE, &rl ) == 0 )
+                maxfd = rl.rlim_max;
+            for( int i = 3;
+                 i < maxfd;
+                 ++i )
+                close( i );
+#ifdef DEBUG_KDE
+            execvp( KMOZILLAHELPER, args );
+#else
+            execv( KMOZILLAHELPER, args );
+#endif
+            _exit( 1 ); // failed
+            }
+        default: // parent
+            {
+            commandFile = fdopen( fdcommand[ 1 ], "w" );
+            replyFile = fdopen( fdreply[ 0 ], "r" );
+            close( fdcommand[ 0 ] );
+            close( fdreply[ 1 ] );
+            if( commandFile == NULL || replyFile == NULL )
+                {
+                closeHelper();
+                return false;
+                }
+            // ok, helper ready, getKdeRunning() will check if it works
+            }
+        }
+    helperFailed = false;
+    helperRunning = true;
+    return true;
+    }
+
+void nsKDEUtils::closeHelper()
+    {
+    if( commandFile != NULL )
+        fclose( commandFile ); // this will also make the helper quit
+    if( replyFile != NULL )
+        fclose( replyFile );
+    helperRunning = false;
+    }
+
+void nsKDEUtils::feedCommand( const nsTArray<nsCString>& command )
+    {
+    for( int i = 0;
+         i < command.Length();
+         ++i )
+        {
+        nsCString line = command[ i ];
+        line.ReplaceSubstring( "\\", "\\" "\\" ); // \ -> \\ , i.e. escape
+        line.ReplaceSubstring( "\n", "\\n" );
+#ifdef DEBUG_KDE
+        fprintf( stderr, "COMM: %s\n", line.get());
+#endif
+        fputs( line.get(), commandFile );
+        fputs( "\n", commandFile );
+        }
+    fputs( "\\E\n", commandFile ); // done as \E, so it cannot happen in normal data
+    fflush( commandFile );
+    }
diff --git a/toolkit/xre/nsKDEUtils.h b/toolkit/xre/nsKDEUtils.h
new file mode 100644
index 0000000000..c9c1284e29
--- /dev/null
+++ b/toolkit/xre/nsKDEUtils.h
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsKDEUtils_h__
+#define nsKDEUtils_h__
+
+#include "nsString.h"
+#include "nsTArray.h"
+#include <stdio.h>
+
+typedef struct _GtkWindow GtkWindow;
+
+class nsIArray;
+
+class NS_EXPORT nsKDEUtils
+    {
+    public:
+        /* Returns true if running inside a KDE session (regardless of whether there is KDE
+           support available for Firefox). This should be used e.g. when determining
+           dialog button order but not for code that requires the KDE support. */
+        static bool kdeSession();
+        /* Returns true if running inside a KDE session and KDE support is available
+           for Firefox. This should be used everywhere where the external helper is needed. */
+        static bool kdeSupport();
+        /* Executes the given helper command, returns true if helper returned success. */
+        static bool command( const nsTArray<nsCString>& command, nsTArray<nsCString>* output = NULL );
+        static bool command( nsIArray* command, nsIArray** output = NULL );
+        /* Like command(), but additionally blocks the parent widget like if there was
+           a modal dialog shown and enters the event loop (i.e. there are still paint updates,
+           this is for commands that take long). */
+        static bool commandBlockUi( const nsTArray<nsCString>& command, GtkWindow* parent, nsTArray<nsCString>* output = NULL );
+
+    private:
+        nsKDEUtils();
+        ~nsKDEUtils();
+        static nsKDEUtils* self();
+        bool startHelper();
+        void closeHelper();
+        void feedCommand( const nsTArray<nsCString>& command );
+        bool internalCommand( const nsTArray<nsCString>& command, GtkWindow* parent, bool isParent,
+            nsTArray<nsCString>* output );
+        FILE* commandFile;
+        FILE* replyFile;
+    };
+
+#endif // nsKDEUtils
diff --git a/uriloader/exthandler/HandlerServiceParent.cpp b/uriloader/exthandler/HandlerServiceParent.cpp
index dbcc95d956..f9a3cc0d0c 100644
--- a/uriloader/exthandler/HandlerServiceParent.cpp
+++ b/uriloader/exthandler/HandlerServiceParent.cpp
@@ -12,7 +12,7 @@
 #include "ContentHandlerService.h"
 #include "nsStringEnumerator.h"
 #ifdef MOZ_WIDGET_GTK
-#  include "unix/nsGNOMERegistry.h"
+#  include "unix/nsCommonRegistry.h"
 #endif
 
 using mozilla::dom::ContentHandlerService;
@@ -304,7 +304,7 @@ mozilla::ipc::IPCResult HandlerServiceParent::RecvExistsForProtocolOS(
   }
 #ifdef MOZ_WIDGET_GTK
   // Check the GNOME registry for a protocol handler
-  *aHandlerExists = nsGNOMERegistry::HandlerExists(aProtocolScheme.get());
+  *aHandlerExists = nsCommonRegistry::HandlerExists(aProtocolScheme.get());
 #else
   *aHandlerExists = false;
 #endif
@@ -332,7 +332,7 @@ mozilla::ipc::IPCResult HandlerServiceParent::RecvExistsForProtocol(
   }
   rv = protoSvc->ExternalProtocolHandlerExists(aProtocolScheme.get(),
                                                aHandlerExists);
-
+##
   if (NS_WARN_IF(NS_FAILED(rv))) {
     *aHandlerExists = false;
   }
diff --git a/uriloader/exthandler/HandlerServiceParent.cpp.orig b/uriloader/exthandler/HandlerServiceParent.cpp.orig
new file mode 100644
index 0000000000..dbcc95d956
--- /dev/null
+++ b/uriloader/exthandler/HandlerServiceParent.cpp.orig
@@ -0,0 +1,374 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ipc/ProtocolUtils.h"
+#include "mozilla/Logging.h"
+#include "HandlerServiceParent.h"
+#include "nsIHandlerService.h"
+#include "nsIMIMEInfo.h"
+#include "ContentHandlerService.h"
+#include "nsStringEnumerator.h"
+#ifdef MOZ_WIDGET_GTK
+#  include "unix/nsGNOMERegistry.h"
+#endif
+
+using mozilla::dom::ContentHandlerService;
+using mozilla::dom::HandlerApp;
+using mozilla::dom::HandlerInfo;
+using mozilla::dom::RemoteHandlerApp;
+
+namespace {
+
+class ProxyHandlerInfo final : public nsIHandlerInfo {
+ public:
+  explicit ProxyHandlerInfo(const HandlerInfo& aHandlerInfo);
+  NS_DECL_ISUPPORTS;
+  NS_DECL_NSIHANDLERINFO;
+
+  nsTArray<nsCString>& Extensions() { return mHandlerInfo.extensions(); }
+
+ protected:
+  ~ProxyHandlerInfo() {}
+  HandlerInfo mHandlerInfo;
+  nsHandlerInfoAction mPrefAction;
+  nsCOMPtr<nsIMutableArray> mPossibleApps;
+};
+
+NS_IMPL_ISUPPORTS(ProxyHandlerInfo, nsIHandlerInfo)
+
+ProxyHandlerInfo::ProxyHandlerInfo(const HandlerInfo& aHandlerInfo)
+    : mHandlerInfo(aHandlerInfo),
+      mPrefAction(nsIHandlerInfo::alwaysAsk),
+      mPossibleApps(do_CreateInstance(NS_ARRAY_CONTRACTID)) {
+  for (auto& happ : aHandlerInfo.possibleApplicationHandlers()) {
+    mPossibleApps->AppendElement(new RemoteHandlerApp(happ));
+  }
+}
+
+/* readonly attribute ACString type; */
+NS_IMETHODIMP ProxyHandlerInfo::GetType(nsACString& aType) {
+  aType.Assign(mHandlerInfo.type());
+  return NS_OK;
+}
+
+/* attribute AString description; */
+NS_IMETHODIMP ProxyHandlerInfo::GetDescription(nsAString& aDescription) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+NS_IMETHODIMP ProxyHandlerInfo::SetDescription(const nsAString& aDescription) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* attribute nsIHandlerApp preferredApplicationHandler; */
+NS_IMETHODIMP ProxyHandlerInfo::GetPreferredApplicationHandler(
+    nsIHandlerApp** aPreferredApplicationHandler) {
+  *aPreferredApplicationHandler =
+      new RemoteHandlerApp(mHandlerInfo.preferredApplicationHandler());
+  NS_IF_ADDREF(*aPreferredApplicationHandler);
+  return NS_OK;
+}
+
+NS_IMETHODIMP ProxyHandlerInfo::SetPreferredApplicationHandler(
+    nsIHandlerApp* aApp) {
+  nsString name;
+  nsString detailedDescription;
+  if (aApp) {
+    aApp->GetName(name);
+    aApp->GetDetailedDescription(detailedDescription);
+  }
+
+  mHandlerInfo.preferredApplicationHandler() =
+      HandlerApp(name, detailedDescription);
+  return NS_OK;
+}
+
+/* readonly attribute nsIMutableArray possibleApplicationHandlers; */
+NS_IMETHODIMP ProxyHandlerInfo::GetPossibleApplicationHandlers(
+    nsIMutableArray** aPossibleApplicationHandlers) {
+  *aPossibleApplicationHandlers = mPossibleApps;
+  NS_IF_ADDREF(*aPossibleApplicationHandlers);
+  return NS_OK;
+}
+
+/* readonly attribute boolean hasDefaultHandler; */
+NS_IMETHODIMP ProxyHandlerInfo::GetHasDefaultHandler(bool* aHasDefaultHandler) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* readonly attribute AString defaultDescription; */
+NS_IMETHODIMP ProxyHandlerInfo::GetDefaultDescription(
+    nsAString& aDefaultDescription) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* void launchWithURI (in nsIURI aURI,
+                       [optional] in BrowsingContext aBrowsingContext); */
+NS_IMETHODIMP ProxyHandlerInfo::LaunchWithURI(
+    nsIURI* aURI, mozilla::dom::BrowsingContext* aBrowsingContext) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* attribute ProxyHandlerInfoAction preferredAction; */
+NS_IMETHODIMP ProxyHandlerInfo::GetPreferredAction(
+    nsHandlerInfoAction* aPreferredAction) {
+  *aPreferredAction = mPrefAction;
+  return NS_OK;
+}
+NS_IMETHODIMP ProxyHandlerInfo::SetPreferredAction(
+    nsHandlerInfoAction aPreferredAction) {
+  mHandlerInfo.preferredAction() = aPreferredAction;
+  mPrefAction = aPreferredAction;
+  return NS_OK;
+}
+
+/* attribute boolean alwaysAskBeforeHandling; */
+NS_IMETHODIMP ProxyHandlerInfo::GetAlwaysAskBeforeHandling(
+    bool* aAlwaysAskBeforeHandling) {
+  *aAlwaysAskBeforeHandling = mHandlerInfo.alwaysAskBeforeHandling();
+  return NS_OK;
+}
+NS_IMETHODIMP ProxyHandlerInfo::SetAlwaysAskBeforeHandling(
+    bool aAlwaysAskBeforeHandling) {
+  mHandlerInfo.alwaysAskBeforeHandling() = aAlwaysAskBeforeHandling;
+  return NS_OK;
+}
+
+class ProxyMIMEInfo : public nsIMIMEInfo {
+ public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIMIMEINFO
+  NS_FORWARD_NSIHANDLERINFO(mProxyHandlerInfo->);
+
+  explicit ProxyMIMEInfo(const HandlerInfo& aHandlerInfo)
+      : mProxyHandlerInfo(new ProxyHandlerInfo(aHandlerInfo)) {}
+
+ private:
+  virtual ~ProxyMIMEInfo() {}
+  RefPtr<ProxyHandlerInfo> mProxyHandlerInfo;
+
+ protected:
+  /* additional members */
+};
+
+NS_IMPL_ISUPPORTS(ProxyMIMEInfo, nsIMIMEInfo, nsIHandlerInfo)
+
+/* nsIUTF8StringEnumerator getFileExtensions (); */
+NS_IMETHODIMP ProxyMIMEInfo::GetFileExtensions(
+    nsIUTF8StringEnumerator** _retval) {
+  return NS_NewUTF8StringEnumerator(_retval, &mProxyHandlerInfo->Extensions(),
+                                    this);
+}
+
+/* void setFileExtensions (in AUTF8String aExtensions); */
+NS_IMETHODIMP ProxyMIMEInfo::SetFileExtensions(const nsACString& aExtensions) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* boolean extensionExists (in AUTF8String aExtension); */
+NS_IMETHODIMP ProxyMIMEInfo::ExtensionExists(const nsACString& aExtension,
+                                             bool* _retval) {
+  *_retval = mProxyHandlerInfo->Extensions().Contains(
+      aExtension, nsCaseInsensitiveCStringArrayComparator());
+  return NS_OK;
+}
+
+/* void appendExtension (in AUTF8String aExtension); */
+NS_IMETHODIMP ProxyMIMEInfo::AppendExtension(const nsACString& aExtension) {
+  if (!aExtension.IsEmpty() &&
+      !mProxyHandlerInfo->Extensions().Contains(
+          aExtension, nsCaseInsensitiveCStringArrayComparator())) {
+    mProxyHandlerInfo->Extensions().AppendElement(aExtension);
+  }
+  return NS_OK;
+}
+
+/* attribute AUTF8String primaryExtension; */
+NS_IMETHODIMP ProxyMIMEInfo::GetPrimaryExtension(
+    nsACString& aPrimaryExtension) {
+  const auto& extensions = mProxyHandlerInfo->Extensions();
+  if (extensions.IsEmpty()) {
+    aPrimaryExtension.Truncate();
+    return NS_ERROR_FAILURE;
+  }
+  aPrimaryExtension = extensions[0];
+  return NS_OK;
+}
+
+NS_IMETHODIMP ProxyMIMEInfo::SetPrimaryExtension(
+    const nsACString& aPrimaryExtension) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* readonly attribute ACString MIMEType; */
+NS_IMETHODIMP ProxyMIMEInfo::GetMIMEType(nsACString& aMIMEType) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* boolean equals (in nsIMIMEInfo aMIMEInfo); */
+NS_IMETHODIMP ProxyMIMEInfo::Equals(nsIMIMEInfo* aMIMEInfo, bool* _retval) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* readonly attribute nsIArray possibleLocalHandlers; */
+NS_IMETHODIMP ProxyMIMEInfo::GetPossibleLocalHandlers(
+    nsIArray** aPossibleLocalHandlers) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* void launchWithFile (in nsIFile aFile); */
+NS_IMETHODIMP ProxyMIMEInfo::LaunchWithFile(nsIFile* aFile) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* boolean isCurrentAppOSDefault(); */
+NS_IMETHODIMP ProxyMIMEInfo::IsCurrentAppOSDefault(bool* _retval) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+static already_AddRefed<nsIHandlerInfo> WrapHandlerInfo(
+    const HandlerInfo& aHandlerInfo) {
+  nsCOMPtr<nsIHandlerInfo> info;
+  if (aHandlerInfo.isMIMEInfo()) {
+    info = new ProxyMIMEInfo(aHandlerInfo);
+  } else {
+    info = new ProxyHandlerInfo(aHandlerInfo);
+  }
+  return info.forget();
+}
+
+}  // anonymous namespace
+
+HandlerServiceParent::HandlerServiceParent() {}
+
+HandlerServiceParent::~HandlerServiceParent() {}
+
+mozilla::ipc::IPCResult HandlerServiceParent::RecvFillHandlerInfo(
+    const HandlerInfo& aHandlerInfoData, const nsCString& aOverrideType,
+    HandlerInfo* handlerInfoData) {
+  nsCOMPtr<nsIHandlerInfo> info(WrapHandlerInfo(aHandlerInfoData));
+  nsCOMPtr<nsIHandlerService> handlerSvc =
+      do_GetService(NS_HANDLERSERVICE_CONTRACTID);
+  handlerSvc->FillHandlerInfo(info, aOverrideType);
+  ContentHandlerService::nsIHandlerInfoToHandlerInfo(info, handlerInfoData);
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult HandlerServiceParent::RecvGetMIMEInfoFromOS(
+    const nsCString& aMIMEType, const nsCString& aExtension, nsresult* aRv,
+    HandlerInfo* aHandlerInfoData, bool* aFound) {
+  *aFound = false;
+  if (aMIMEType.Length() > MAX_MIMETYPE_LENGTH ||
+      aExtension.Length() > MAX_EXT_LENGTH) {
+    *aRv = NS_OK;
+    return IPC_OK();
+  }
+
+  nsCOMPtr<nsIMIMEService> mimeService =
+      do_GetService(NS_MIMESERVICE_CONTRACTID, aRv);
+  if (NS_WARN_IF(NS_FAILED(*aRv))) {
+    return IPC_OK();
+  }
+
+  nsCOMPtr<nsIMIMEInfo> mimeInfo;
+  *aRv = mimeService->GetMIMEInfoFromOS(aMIMEType, aExtension, aFound,
+                                        getter_AddRefs(mimeInfo));
+  if (NS_WARN_IF(NS_FAILED(*aRv))) {
+    return IPC_OK();
+  }
+
+  if (mimeInfo) {
+    ContentHandlerService::nsIHandlerInfoToHandlerInfo(mimeInfo,
+                                                       aHandlerInfoData);
+  }
+
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult HandlerServiceParent::RecvExists(
+    const HandlerInfo& aHandlerInfo, bool* exists) {
+  nsCOMPtr<nsIHandlerInfo> info(WrapHandlerInfo(aHandlerInfo));
+  nsCOMPtr<nsIHandlerService> handlerSvc =
+      do_GetService(NS_HANDLERSERVICE_CONTRACTID);
+  handlerSvc->Exists(info, exists);
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult HandlerServiceParent::RecvExistsForProtocolOS(
+    const nsCString& aProtocolScheme, bool* aHandlerExists) {
+  if (aProtocolScheme.Length() > MAX_SCHEME_LENGTH) {
+    *aHandlerExists = false;
+    return IPC_OK();
+  }
+#ifdef MOZ_WIDGET_GTK
+  // Check the GNOME registry for a protocol handler
+  *aHandlerExists = nsGNOMERegistry::HandlerExists(aProtocolScheme.get());
+#else
+  *aHandlerExists = false;
+#endif
+  return IPC_OK();
+}
+
+/*
+ * Check if a handler exists for the provided protocol. Check the datastore
+ * first and then fallback to checking the OS for a handler.
+ */
+mozilla::ipc::IPCResult HandlerServiceParent::RecvExistsForProtocol(
+    const nsCString& aProtocolScheme, bool* aHandlerExists) {
+  if (aProtocolScheme.Length() > MAX_SCHEME_LENGTH) {
+    *aHandlerExists = false;
+    return IPC_OK();
+  }
+  // Check the datastore and fallback to an OS check.
+  // ExternalProcotolHandlerExists() does the fallback.
+  nsresult rv;
+  nsCOMPtr<nsIExternalProtocolService> protoSvc =
+      do_GetService(NS_EXTERNALPROTOCOLSERVICE_CONTRACTID, &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    *aHandlerExists = false;
+    return IPC_OK();
+  }
+  rv = protoSvc->ExternalProtocolHandlerExists(aProtocolScheme.get(),
+                                               aHandlerExists);
+
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    *aHandlerExists = false;
+  }
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult HandlerServiceParent::RecvGetTypeFromExtension(
+    const nsCString& aFileExtension, nsCString* type) {
+  if (aFileExtension.Length() > MAX_EXT_LENGTH) {
+    return IPC_OK();
+  }
+
+  nsresult rv;
+  nsCOMPtr<nsIHandlerService> handlerSvc =
+      do_GetService(NS_HANDLERSERVICE_CONTRACTID, &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return IPC_OK();
+  }
+
+  rv = handlerSvc->GetTypeFromExtension(aFileExtension, *type);
+  mozilla::Unused << NS_WARN_IF(NS_FAILED(rv));
+
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult HandlerServiceParent::RecvGetApplicationDescription(
+    const nsCString& aScheme, nsresult* aRv, nsString* aDescription) {
+  if (aScheme.Length() > MAX_SCHEME_LENGTH) {
+    *aRv = NS_ERROR_NOT_AVAILABLE;
+    return IPC_OK();
+  }
+  nsCOMPtr<nsIExternalProtocolService> protoSvc =
+      do_GetService(NS_EXTERNALPROTOCOLSERVICE_CONTRACTID);
+  NS_ASSERTION(protoSvc, "No Helper App Service!");
+  *aRv = protoSvc->GetApplicationDescription(aScheme, *aDescription);
+  return IPC_OK();
+}
+
+void HandlerServiceParent::ActorDestroy(ActorDestroyReason aWhy) {}
diff --git a/uriloader/exthandler/moz.build b/uriloader/exthandler/moz.build
index 92647a9b34..fc5068cd20 100644
--- a/uriloader/exthandler/moz.build
+++ b/uriloader/exthandler/moz.build
@@ -83,7 +83,9 @@ else:
 
 if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
     UNIFIED_SOURCES += [
+        "unix/nsCommonRegistry.cpp",
         "unix/nsGNOMERegistry.cpp",
+        "unix/nsKDERegistry.cpp",
         "unix/nsMIMEInfoUnix.cpp",
     ]
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "android":
@@ -135,6 +137,7 @@ LOCAL_INCLUDES += [
     "/dom/ipc",
     "/netwerk/base",
     "/netwerk/protocol/http",
+    "/toolkit/xre",
 ]
 
 if CONFIG["MOZ_ENABLE_DBUS"]:
diff --git a/uriloader/exthandler/unix/nsCommonRegistry.cpp b/uriloader/exthandler/unix/nsCommonRegistry.cpp
new file mode 100644
index 0000000000..630ab6147d
--- /dev/null
+++ b/uriloader/exthandler/unix/nsCommonRegistry.cpp
@@ -0,0 +1,53 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsCommonRegistry.h"
+
+#include "nsGNOMERegistry.h"
+#include "nsKDERegistry.h"
+#include "nsString.h"
+#include "nsKDEUtils.h"
+
+/* static */ bool
+nsCommonRegistry::HandlerExists(const char *aProtocolScheme)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::HandlerExists( aProtocolScheme );
+    return nsGNOMERegistry::HandlerExists( aProtocolScheme );
+}
+
+/* static */ nsresult
+nsCommonRegistry::LoadURL(nsIURI *aURL)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::LoadURL( aURL );
+    return nsGNOMERegistry::LoadURL( aURL );
+}
+
+/* static */ void
+nsCommonRegistry::GetAppDescForScheme(const nsACString& aScheme,
+                                     nsAString& aDesc)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetAppDescForScheme( aScheme, aDesc );
+    return nsGNOMERegistry::GetAppDescForScheme( aScheme, aDesc );
+}
+
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsCommonRegistry::GetFromExtension(const nsACString& aFileExt)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetFromExtension( aFileExt );
+    return nsGNOMERegistry::GetFromExtension( aFileExt );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsCommonRegistry::GetFromType(const nsACString& aMIMEType)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetFromType( aMIMEType );
+    return nsGNOMERegistry::GetFromType( aMIMEType );
+}
diff --git a/uriloader/exthandler/unix/nsCommonRegistry.h b/uriloader/exthandler/unix/nsCommonRegistry.h
new file mode 100644
index 0000000000..85b3d9cee2
--- /dev/null
+++ b/uriloader/exthandler/unix/nsCommonRegistry.h
@@ -0,0 +1,28 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsCommonRegistry_h__
+#define nsCommonRegistry_h__
+
+#include "nsIURI.h"
+#include "nsCOMPtr.h"
+
+class nsMIMEInfoBase;
+
+class nsCommonRegistry
+{
+ public:
+  static bool HandlerExists(const char *aProtocolScheme);
+
+  static nsresult LoadURL(nsIURI *aURL);
+
+  static void GetAppDescForScheme(const nsACString& aScheme,
+                                  nsAString& aDesc);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromExtension(const nsACString& aFileExt);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromType(const nsACString& aMIMEType);
+};
+
+#endif
diff --git a/uriloader/exthandler/unix/nsKDERegistry.cpp b/uriloader/exthandler/unix/nsKDERegistry.cpp
new file mode 100644
index 0000000000..f78e64c7e9
--- /dev/null
+++ b/uriloader/exthandler/unix/nsKDERegistry.cpp
@@ -0,0 +1,89 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/StaticPrefs_browser.h"
+#include "nsKDERegistry.h"
+#include "prlink.h"
+#include "prmem.h"
+#include "nsString.h"
+#include "nsMIMEInfoUnix.h"
+#include "nsKDEUtils.h"
+
+/* static */ bool
+nsKDERegistry::HandlerExists(const char *aProtocolScheme)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( "HANDLEREXISTS"_ns );
+    command.AppendElement( nsAutoCString( aProtocolScheme ));
+    return nsKDEUtils::command( command );
+}
+
+/* static */ nsresult
+nsKDERegistry::LoadURL(nsIURI *aURL)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( "OPEN"_ns );
+    nsCString url;
+    aURL->GetSpec( url );
+    command.AppendElement( url );
+    bool rv = nsKDEUtils::command( command );
+    if (!rv)
+      return NS_ERROR_FAILURE;
+
+    return NS_OK;
+}
+
+/* static */ void
+nsKDERegistry::GetAppDescForScheme(const nsACString& aScheme,
+                                     nsAString& aDesc)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( "GETAPPDESCFORSCHEME"_ns );
+    command.AppendElement( aScheme );
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::command( command, &output ) && output.Length() == 1 )
+        CopyUTF8toUTF16( output[ 0 ], aDesc );
+}
+
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromExtension(const nsACString& aFileExt)
+{
+    NS_ASSERTION(aFileExt[0] != '.', "aFileExt shouldn't start with a dot");
+    nsTArray<nsCString> command;
+    command.AppendElement( "GETFROMEXTENSION"_ns );
+    command.AppendElement( aFileExt );
+    return GetFromHelper( command );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromType(const nsACString& aMIMEType)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( "GETFROMTYPE"_ns );
+    command.AppendElement( aMIMEType );
+    return GetFromHelper( command );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromHelper(const nsTArray<nsCString>& command)
+{
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::command( command, &output ) && output.Length() == 3 )
+        {
+        nsCString mimetype = output[ 0 ];
+        RefPtr<nsMIMEInfoUnix> mimeInfo = new nsMIMEInfoUnix( mimetype );
+        NS_ENSURE_TRUE(mimeInfo, nullptr);
+        nsCString description = output[ 1 ];
+        mimeInfo->SetDescription(NS_ConvertUTF8toUTF16(description));
+        nsCString handlerAppName = output[ 2 ];
+        mozilla::StaticPrefs::browser_download_improvements_to_download_panel()
+            ? mimeInfo->SetPreferredAction(nsIMIMEInfo::saveToDisk)
+            : mimeInfo->SetPreferredAction(nsIMIMEInfo::useSystemDefault);
+        mimeInfo->SetDefaultDescription(NS_ConvertUTF8toUTF16(handlerAppName));
+        return mimeInfo.forget();
+        }
+    return nullptr;
+}
diff --git a/uriloader/exthandler/unix/nsKDERegistry.h b/uriloader/exthandler/unix/nsKDERegistry.h
new file mode 100644
index 0000000000..5b07eebc6d
--- /dev/null
+++ b/uriloader/exthandler/unix/nsKDERegistry.h
@@ -0,0 +1,34 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsKDERegistry_h__
+#define nsKDERegistry_h__
+
+#include "nsIURI.h"
+#include "nsCOMPtr.h"
+#include "nsTArray.h"
+
+class nsMIMEInfoBase;
+//class nsAutoCString;
+//class nsCString;
+
+class nsKDERegistry
+{
+ public:
+  static bool HandlerExists(const char *aProtocolScheme);
+
+  static nsresult LoadURL(nsIURI *aURL);
+
+  static void GetAppDescForScheme(const nsACString& aScheme,
+                                  nsAString& aDesc);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromExtension(const nsACString& aFileExt);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromType(const nsACString& aMIMEType);
+ private:
+  static already_AddRefed<nsMIMEInfoBase> GetFromHelper(const nsTArray<nsCString>& command);
+
+};
+
+#endif //nsKDERegistry_h__
diff --git a/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp b/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
index 7cbefcce3e..84083348c8 100644
--- a/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
+++ b/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
@@ -5,16 +5,19 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsMIMEInfoUnix.h"
-#include "nsGNOMERegistry.h"
+#include "nsCommonRegistry.h"
 #include "nsIGIOService.h"
 #include "nsNetCID.h"
 #include "nsIIOService.h"
 #ifdef MOZ_ENABLE_DBUS
 #  include "nsDBusHandlerApp.h"
 #endif
+#if defined(XP_UNIX) && !defined(XP_MACOSX)
+#include "nsKDEUtils.h"
+#endif
 
 nsresult nsMIMEInfoUnix::LoadUriInternal(nsIURI* aURI) {
-  return nsGNOMERegistry::LoadURL(aURI);
+  return nsCommonRegistry::LoadURL(aURI);
 }
 
 NS_IMETHODIMP
@@ -27,15 +30,15 @@ nsMIMEInfoUnix::GetHasDefaultHandler(bool* _retval) {
   *_retval = false;
 
   if (mClass == eProtocolInfo) {
-    *_retval = nsGNOMERegistry::HandlerExists(mSchemeOrType.get());
+    *_retval = nsCommonRegistry::HandlerExists(mSchemeOrType.get());
   } else {
     RefPtr<nsMIMEInfoBase> mimeInfo =
-        nsGNOMERegistry::GetFromType(mSchemeOrType);
+        nsCommonRegistry::GetFromType(mSchemeOrType);
     if (!mimeInfo) {
       nsAutoCString ext;
       nsresult rv = GetPrimaryExtension(ext);
       if (NS_SUCCEEDED(rv)) {
-        mimeInfo = nsGNOMERegistry::GetFromExtension(ext);
+        mimeInfo = nsCommonRegistry::GetFromExtension(ext);
       }
     }
     if (mimeInfo) *_retval = true;
@@ -55,6 +58,23 @@ nsresult nsMIMEInfoUnix::LaunchDefaultWithFile(nsIFile* aFile) {
   nsAutoCString nativePath;
   aFile->GetNativePath(nativePath);
 
+  if( nsKDEUtils::kdeSupport()) {
+    bool supports;
+    if( NS_SUCCEEDED( GetHasDefaultHandler( &supports )) && supports ) {
+      nsTArray<nsCString> command;
+      command.AppendElement( "OPEN"_ns );
+      command.AppendElement( nativePath );
+      command.AppendElement( "MIMETYPE"_ns );
+      command.AppendElement( mSchemeOrType );
+      if( nsKDEUtils::command( command ))
+        return NS_OK;
+    }
+    if (!mDefaultApplication)
+      return NS_ERROR_FILE_NOT_FOUND;
+
+    return LaunchWithIProcess(mDefaultApplication, nativePath);
+  }
+
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
   if (!giovfs) {
     return NS_ERROR_FAILURE;
diff --git a/uriloader/exthandler/unix/nsOSHelperAppService.cpp b/uriloader/exthandler/unix/nsOSHelperAppService.cpp
index b9e7aed3cb..367ad9ee24 100644
--- a/uriloader/exthandler/unix/nsOSHelperAppService.cpp
+++ b/uriloader/exthandler/unix/nsOSHelperAppService.cpp
@@ -10,7 +10,7 @@
 #include "nsOSHelperAppService.h"
 #include "nsMIMEInfoUnix.h"
 #ifdef MOZ_WIDGET_GTK
-#  include "nsGNOMERegistry.h"
+#  include "nsCommonRegistry.h"
 #  ifdef MOZ_BUILD_APP_IS_BROWSER
 #    include "nsIToolkitShellService.h"
 #    include "nsIGNOMEShellService.h"
@@ -1030,7 +1030,7 @@ nsresult nsOSHelperAppService::OSProtocolHandlerExists(
   if (!XRE_IsContentProcess()) {
 #ifdef MOZ_WIDGET_GTK
     // Check the GNOME registry for a protocol handler
-    *aHandlerExists = nsGNOMERegistry::HandlerExists(aProtocolScheme);
+    *aHandlerExists = nsCommonRegistry::HandlerExists(aProtocolScheme);
 #else
     *aHandlerExists = false;
 #endif
@@ -1050,7 +1050,7 @@ nsresult nsOSHelperAppService::OSProtocolHandlerExists(
 NS_IMETHODIMP nsOSHelperAppService::GetApplicationDescription(
     const nsACString& aScheme, nsAString& _retval) {
 #ifdef MOZ_WIDGET_GTK
-  nsGNOMERegistry::GetAppDescForScheme(aScheme, _retval);
+  nsCommonRegistry::GetAppDescForScheme(aScheme, _retval);
   return _retval.IsEmpty() ? NS_ERROR_NOT_AVAILABLE : NS_OK;
 #else
   return NS_ERROR_NOT_AVAILABLE;
@@ -1153,7 +1153,7 @@ already_AddRefed<nsMIMEInfoBase> nsOSHelperAppService::GetFromExtension(
 #ifdef MOZ_WIDGET_GTK
     LOG(("Looking in GNOME registry\n"));
     RefPtr<nsMIMEInfoBase> gnomeInfo =
-        nsGNOMERegistry::GetFromExtension(aFileExt);
+        nsCommonRegistry::GetFromExtension(aFileExt);
     if (gnomeInfo) {
       LOG(("Got MIMEInfo from GNOME registry\n"));
       return gnomeInfo.forget();
@@ -1266,7 +1266,7 @@ already_AddRefed<nsMIMEInfoBase> nsOSHelperAppService::GetFromType(
 
 #ifdef MOZ_WIDGET_GTK
   if (handler.IsEmpty()) {
-    RefPtr<nsMIMEInfoBase> gnomeInfo = nsGNOMERegistry::GetFromType(aMIMEType);
+    RefPtr<nsMIMEInfoBase> gnomeInfo = nsCommonRegistry::GetFromType(aMIMEType);
     if (gnomeInfo) {
       LOG(
           ("Got MIMEInfo from GNOME registry without extensions; setting them "
diff --git a/widget/gtk/moz.build b/widget/gtk/moz.build
index bf64f7ebdc..f94b4e017e 100644
--- a/widget/gtk/moz.build
+++ b/widget/gtk/moz.build
@@ -169,6 +169,7 @@ LOCAL_INCLUDES += [
     "/layout/xul",
     "/other-licenses/atk-1.0",
     "/third_party/cups/include",
+    "/toolkit/xre",
     "/widget",
     "/widget/headless",
 ]
diff --git a/widget/gtk/nsFilePicker.cpp b/widget/gtk/nsFilePicker.cpp
index c73130496a..9e7b9aed56 100644
--- a/widget/gtk/nsFilePicker.cpp
+++ b/widget/gtk/nsFilePicker.cpp
@@ -5,6 +5,7 @@
 
 #include <dlfcn.h>
 #include <gtk/gtk.h>
+#include <gdk/gdkx.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -27,6 +28,8 @@
 #include "WidgetUtilsGtk.h"
 
 #include "nsFilePicker.h"
+#include "nsKDEUtils.h"
+#include "nsURLHelper.h"
 
 #undef LOG
 #ifdef MOZ_LOGGING
@@ -241,7 +244,9 @@ NS_IMETHODIMP
 nsFilePicker::AppendFilter(const nsAString& aTitle, const nsAString& aFilter) {
   if (aFilter.EqualsLiteral("..apps")) {
     // No platform specific thing we can do here, really....
-    return NS_OK;
+    // Unless it's KDE.
+    if( mMode != modeOpen || !nsKDEUtils::kdeSupport())
+      return NS_OK;
   }
 
   nsAutoCString filter, name;
@@ -351,6 +356,29 @@ nsFilePicker::Open(nsIFilePickerShownCallback* aCallback) {
   // Can't show two dialogs concurrently with the same filepicker
   if (mRunning) return NS_ERROR_NOT_AVAILABLE;
 
+  // KDE file picker is not handled via callback
+  if( nsKDEUtils::kdeSupport()) {
+    mCallback = aCallback;
+    mRunning = true;
+    NS_ADDREF_THIS();
+    g_idle_add([](gpointer data) -> gboolean {
+      nsFilePicker* queuedPicker = (nsFilePicker*) data;
+      int16_t result;
+      queuedPicker->kdeFileDialog(&result);
+      if (queuedPicker->mCallback) {
+        queuedPicker->mCallback->Done(result);
+        queuedPicker->mCallback = nullptr;
+      } else {
+        queuedPicker->mResult = result;
+      }
+      queuedPicker->mRunning = false;
+      NS_RELEASE(queuedPicker);
+      return G_SOURCE_REMOVE;
+    }, this);
+
+    return NS_OK;
+  }
+
   NS_ConvertUTF16toUTF8 title(mTitle);
 
   GtkWindow* parent_widget =
@@ -580,6 +608,234 @@ void nsFilePicker::Done(void* file_chooser, gint response) {
   NS_RELEASE_THIS();
 }
 
+nsCString nsFilePicker::kdeMakeFilter( int index )
+    {
+    nsCString buf = mFilters[ index ];
+    for( PRUint32 i = 0;
+         i < buf.Length();
+         ++i )
+        if( buf[ i ] == ';' ) // KDE separates just using spaces
+            buf.SetCharAt( ' ', i );
+    if (!mFilterNames[index].IsEmpty())
+        {
+        buf += "|";
+        buf += mFilterNames[index].get();
+        }
+    return buf;
+    }
+
+static PRInt32 windowToXid( nsIWidget* widget )
+    {
+    GtkWindow *parent_widget = GTK_WINDOW(widget->GetNativeData(NS_NATIVE_SHELLWIDGET));
+    GdkWindow* gdk_window = gtk_widget_get_window( gtk_widget_get_toplevel( GTK_WIDGET( parent_widget )));
+    return GDK_WINDOW_XID( gdk_window );
+    }
+
+NS_IMETHODIMP nsFilePicker::kdeFileDialog(PRInt16 *aReturn)
+    {
+    NS_ENSURE_ARG_POINTER(aReturn);
+
+    if( mMode == modeOpen && mFilters.Length() == 1 && mFilters[ 0 ].EqualsLiteral( "..apps" ))
+        return kdeAppsDialog( aReturn );
+
+    nsCString title;
+    title.Adopt(ToNewUTF8String(mTitle));
+
+    const char* arg = NULL;
+    if( mAllowURLs )
+        {
+        switch( mMode )
+            {
+            case nsIFilePicker::modeOpen:
+            case nsIFilePicker::modeOpenMultiple:
+                arg = "GETOPENURL";
+                break;
+            case nsIFilePicker::modeSave:
+                arg = "GETSAVEURL";
+                break;
+            case nsIFilePicker::modeGetFolder:
+                arg = "GETDIRECTORYURL";
+                break;
+            }
+        }
+    else
+        {
+        switch( mMode )
+            {
+            case nsIFilePicker::modeOpen:
+            case nsIFilePicker::modeOpenMultiple:
+                arg = "GETOPENFILENAME";
+                break;
+            case nsIFilePicker::modeSave:
+                arg = "GETSAVEFILENAME";
+                break;
+            case nsIFilePicker::modeGetFolder:
+                arg = "GETDIRECTORYFILENAME";
+                break;
+            }
+        }
+
+  nsAutoCString directory;
+  if (mDisplayDirectory) {
+    mDisplayDirectory->GetNativePath(directory);
+  } else if (mPrevDisplayDirectory) {
+    mPrevDisplayDirectory->GetNativePath(directory);
+  }
+
+    nsAutoCString startdir;
+  if (!directory.IsEmpty()) {
+    startdir = directory;
+  }
+  if (mMode == nsIFilePicker::modeSave) {
+    if( !startdir.IsEmpty())
+      {
+      startdir += "/";
+      startdir += ToNewUTF8String(mDefault);
+      }
+    else
+      startdir = ToNewUTF8String(mDefault);
+  }
+
+    nsAutoCString filters;
+    PRInt32 count = mFilters.Length();
+    if( count == 0 ) //just in case
+        filters = "*";
+    else
+        {
+        filters = kdeMakeFilter( 0 );
+        for (PRInt32 i = 1; i < count; ++i)
+            {
+            filters += "\n";
+            filters += kdeMakeFilter( i );
+            }
+        }
+
+    nsTArray<nsCString> command;
+    command.AppendElement( nsAutoCString( arg ));
+    command.AppendElement( startdir );
+    if( mMode != nsIFilePicker::modeGetFolder )
+        {
+        command.AppendElement( filters );
+        nsAutoCString selected;
+        selected.AppendInt( mSelectedType );
+        command.AppendElement( selected );
+        }
+    command.AppendElement( title );
+    if( mMode == nsIFilePicker::modeOpenMultiple )
+        command.AppendElement( "MULTIPLE"_ns );
+    if( PRInt32 xid = windowToXid( mParentWidget ))
+        {
+        command.AppendElement( "PARENT"_ns );
+        nsAutoCString parent;
+        parent.AppendInt( xid );
+        command.AppendElement( parent );
+        }
+
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::commandBlockUi( command, GTK_WINDOW(mParentWidget->GetNativeData(NS_NATIVE_SHELLWIDGET)), &output ))
+        {
+        *aReturn = nsIFilePicker::returnOK;
+        mFiles.Clear();
+        if( mMode != nsIFilePicker::modeGetFolder )
+            {
+            mSelectedType = atoi( output[ 0 ].get());
+            output.RemoveElementAt( 0 );
+            }
+        if (mMode == nsIFilePicker::modeOpenMultiple)
+            {
+            mFileURL.Truncate();
+            PRUint32 count = output.Length();
+            for( PRUint32 i = 0;
+                 i < count;
+                 ++i )
+                {
+                nsCOMPtr<nsIFile> localfile;
+                nsresult rv = NS_NewNativeLocalFile( output[ i ],
+                                      PR_FALSE,
+                                      getter_AddRefs(localfile));
+                if (NS_SUCCEEDED(rv))
+                    mFiles.AppendObject(localfile);
+                }
+            }
+        else
+            {
+            if( output.Length() == 0 )
+                mFileURL = nsCString();
+            else if( mAllowURLs )
+                mFileURL = output[ 0 ];
+            else // GetFile() actually requires it to be url even for local files :-/
+                {
+                nsCOMPtr<nsIFile> localfile;
+                nsresult rv = NS_NewNativeLocalFile( output[ 0 ],
+                                   PR_FALSE,
+                                   getter_AddRefs(localfile));
+                if (NS_SUCCEEDED(rv))
+                  rv = net_GetURLSpecFromActualFile(localfile, mFileURL);
+                }
+            }
+  // Remember last used directory.
+  nsCOMPtr<nsIFile> file;
+  GetFile(getter_AddRefs(file));
+  if (file) {
+    nsCOMPtr<nsIFile> dir;
+    file->GetParent(getter_AddRefs(dir));
+    nsCOMPtr<nsIFile> localDir(do_QueryInterface(dir));
+    if (localDir) {
+      localDir.swap(mPrevDisplayDirectory);
+    }
+  }
+        if (mMode == nsIFilePicker::modeSave)
+            {
+            nsCOMPtr<nsIFile> file;
+            GetFile(getter_AddRefs(file));
+            if (file)
+                {
+                bool exists = false;
+                file->Exists(&exists);
+                if (exists) // TODO do overwrite check in the helper app
+                    *aReturn = nsIFilePicker::returnReplace;
+                }
+            }
+        }
+    else
+        {
+        *aReturn = nsIFilePicker::returnCancel;
+        }
+    return NS_OK;
+    }
+
+
+NS_IMETHODIMP nsFilePicker::kdeAppsDialog(PRInt16 *aReturn)
+    {
+    NS_ENSURE_ARG_POINTER(aReturn);
+
+    nsCString title;
+    title.Adopt(ToNewUTF8String(mTitle));
+
+    nsTArray<nsCString> command;
+    command.AppendElement( "APPSDIALOG"_ns );
+    command.AppendElement( title );
+    if( PRInt32 xid = windowToXid( mParentWidget ))
+        {
+        command.AppendElement( "PARENT"_ns );
+        nsAutoCString parent;
+        parent.AppendInt( xid );
+        command.AppendElement( parent );
+        }
+
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::commandBlockUi( command, GTK_WINDOW(mParentWidget->GetNativeData(NS_NATIVE_SHELLWIDGET)), &output ))
+        {
+        *aReturn = nsIFilePicker::returnOK;
+        mFileURL = output.Length() > 0 ? output[ 0 ] : nsCString();
+        }
+    else
+        {
+        *aReturn = nsIFilePicker::returnCancel;
+        }
+    return NS_OK;
+    }
+
 // All below functions available as of GTK 3.20+
 void* nsFilePicker::GtkFileChooserNew(const gchar* title, GtkWindow* parent,
                                       GtkFileChooserAction action,
diff --git a/widget/gtk/nsFilePicker.h b/widget/gtk/nsFilePicker.h
index 9b3110aa00..be9d559c7b 100644
--- a/widget/gtk/nsFilePicker.h
+++ b/widget/gtk/nsFilePicker.h
@@ -72,6 +72,12 @@ class nsFilePicker : public nsBaseFilePicker {
  private:
   static nsIFile* mPrevDisplayDirectory;
 
+  bool kdeRunning();
+  bool getKdeRunning();
+  NS_IMETHODIMP kdeFileDialog(PRInt16 *aReturn);
+  NS_IMETHODIMP kdeAppsDialog(PRInt16 *aReturn);
+  nsCString kdeMakeFilter( int index );
+
   void* GtkFileChooserNew(const gchar* title, GtkWindow* parent,
                           GtkFileChooserAction action,
                           const gchar* accept_label);
diff --git a/xpcom/components/ManifestParser.cpp b/xpcom/components/ManifestParser.cpp
index f3d0055f2c..d13543ab52 100644
--- a/xpcom/components/ManifestParser.cpp
+++ b/xpcom/components/ManifestParser.cpp
@@ -43,6 +43,7 @@
 #include "nsIScriptError.h"
 #include "nsIXULAppInfo.h"
 #include "nsIXULRuntime.h"
+#include "nsKDEUtils.h"
 
 using namespace mozilla;
 
@@ -402,6 +403,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
   constexpr auto kOs = u"os"_ns;
   constexpr auto kOsVersion = u"osversion"_ns;
   constexpr auto kABI = u"abi"_ns;
+  constexpr auto kDesktop = u"desktop"_ns;
   constexpr auto kProcess = u"process"_ns;
 #if defined(MOZ_WIDGET_ANDROID)
   constexpr auto kTablet = u"tablet"_ns;
@@ -461,6 +463,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
   }
 
   nsAutoString osVersion;
+  nsAutoString desktop;
 #if defined(XP_WIN)
 #  pragma warning(push)
 #  pragma warning(disable : 4996)  // VC12+ deprecates GetVersionEx
@@ -469,14 +472,17 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
     nsTextFormatter::ssprintf(osVersion, u"%ld.%ld", info.dwMajorVersion,
                               info.dwMinorVersion);
   }
+  desktop = u"win"_ns;
 #  pragma warning(pop)
 #elif defined(MOZ_WIDGET_COCOA)
   SInt32 majorVersion = nsCocoaFeatures::macOSVersionMajor();
   SInt32 minorVersion = nsCocoaFeatures::macOSVersionMinor();
   nsTextFormatter::ssprintf(osVersion, u"%ld.%ld", majorVersion, minorVersion);
+  desktop = u"macosx"_ns);
 #elif defined(MOZ_WIDGET_GTK)
   nsTextFormatter::ssprintf(osVersion, u"%ld.%ld", gtk_major_version,
                             gtk_minor_version);
+  desktop = nsKDEUtils::kdeSession() ? u"kde"_ns : u"gnome"_ns;
 #elif defined(MOZ_WIDGET_ANDROID)
   bool isTablet = false;
   if (mozilla::AndroidBridge::Bridge()) {
@@ -484,6 +490,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
         "android/os/Build$VERSION", "RELEASE", osVersion);
     isTablet = java::GeckoAppShell::IsTablet();
   }
+  desktop = u"android"_ns;
 #endif
 
   if (XRE_IsContentProcess()) {
@@ -588,6 +595,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
                                     : eUnspecified;
 #endif
     int flags = 0;
+    TriState stDesktop = eUnspecified;
 
     while ((token = nsCRT::strtok(whitespace, kWhitespace, &whitespace)) &&
            ok) {
@@ -597,6 +605,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
       if (CheckStringFlag(kApplication, wtoken, appID, stApp) ||
           CheckOsFlag(kOs, wtoken, osTarget, stOs) ||
           CheckStringFlag(kABI, wtoken, abi, stABI) ||
+          CheckStringFlag(kDesktop, wtoken, desktop, stDesktop) ||
           CheckStringFlag(kProcess, wtoken, process, stProcess) ||
           CheckVersionFlag(kOsVersion, wtoken, osVersion, stOsVersion) ||
           CheckVersionFlag(kAppVersion, wtoken, appVersion, stAppVersion) ||
@@ -655,7 +664,7 @@ void ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
     }
 
     if (!ok || stApp == eBad || stAppVersion == eBad ||
-        stGeckoVersion == eBad || stOs == eBad || stOsVersion == eBad ||
+        stGeckoVersion == eBad || stOs == eBad || stOsVersion == eBad || stDesktop == eBad ||
 #ifdef MOZ_WIDGET_ANDROID
         stTablet == eBad ||
 #endif
diff --git a/xpcom/components/moz.build b/xpcom/components/moz.build
index 6cf78aa9be..dfcf9c7697 100644
--- a/xpcom/components/moz.build
+++ b/xpcom/components/moz.build
@@ -71,6 +71,7 @@ LOCAL_INCLUDES += [
     "/js/xpconnect/loader",
     "/layout/build",
     "/modules/libjar",
+    "/toolkit/xre",
 ]
 
 if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
diff --git a/xpcom/io/nsLocalFileUnix.cpp b/xpcom/io/nsLocalFileUnix.cpp
index 410fcc19e4..d7c976e0e4 100644
--- a/xpcom/io/nsLocalFileUnix.cpp
+++ b/xpcom/io/nsLocalFileUnix.cpp
@@ -59,6 +59,7 @@
 
 #ifdef MOZ_WIDGET_GTK
 #  include "nsIGIOService.h"
+#  include "nsKDEUtils.h"
 #endif
 
 #ifdef MOZ_WIDGET_COCOA
@@ -2102,10 +2103,19 @@ nsLocalFile::Reveal() {
   }
 
 #ifdef MOZ_WIDGET_GTK
+  nsAutoCString url;
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
-  if (!giovfs) {
-    return NS_ERROR_FAILURE;
+  url = mPath;
+  if(nsKDEUtils::kdeSupport()) {
+    nsTArray<nsCString> command;
+    command.AppendElement( "REVEAL"_ns );
+    command.AppendElement( mPath );
+    return nsKDEUtils::command( command ) ? NS_OK : NS_ERROR_FAILURE;
   }
+
+  if (!giovfs)
+    return NS_ERROR_FAILURE;
+
   return giovfs->RevealFile(this);
 #elif defined(MOZ_WIDGET_COCOA)
   CFURLRef url;
@@ -2127,6 +2137,13 @@ nsLocalFile::Launch() {
   }
 
 #ifdef MOZ_WIDGET_GTK
+  if( nsKDEUtils::kdeSupport()) {
+    nsTArray<nsCString> command;
+    command.AppendElement( "OPEN"_ns );
+    command.AppendElement( mPath );
+    return nsKDEUtils::command( command ) ? NS_OK : NS_ERROR_FAILURE;
+  }
+
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
   if (!giovfs) {
     return NS_ERROR_FAILURE;
diff --git a/xpcom/io/nsLocalFileUnix.cpp.orig b/xpcom/io/nsLocalFileUnix.cpp.orig
new file mode 100644
index 0000000000..410fcc19e4
--- /dev/null
+++ b/xpcom/io/nsLocalFileUnix.cpp.orig
@@ -0,0 +1,2824 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * Implementation of nsIFile for "unixy" systems.
+ */
+
+#include "nsLocalFile.h"
+
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/Attributes.h"
+#include "mozilla/CheckedInt.h"
+#include "mozilla/DebugOnly.h"
+#include "mozilla/Sprintf.h"
+#include "mozilla/FilePreferences.h"
+#include "prtime.h"
+
+#include <sys/fcntl.h>
+#include <sys/select.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <utime.h>
+#include <dirent.h>
+#include <ctype.h>
+#include <locale.h>
+
+#if defined(XP_MACOSX)
+#  include <sys/xattr.h>
+#endif
+
+#if defined(USE_LINUX_QUOTACTL)
+#  include <sys/mount.h>
+#  include <sys/quota.h>
+#  include <sys/sysmacros.h>
+#  ifndef BLOCK_SIZE
+#    define BLOCK_SIZE 1024 /* kernel block size */
+#  endif
+#endif
+
+#include "nsDirectoryServiceDefs.h"
+#include "nsCRT.h"
+#include "nsCOMPtr.h"
+#include "nsMemory.h"
+#include "nsIFile.h"
+#include "nsString.h"
+#include "nsReadableUtils.h"
+#include "prproces.h"
+#include "nsIDirectoryEnumerator.h"
+#include "nsSimpleEnumerator.h"
+#include "private/pprio.h"
+#include "prlink.h"
+
+#ifdef MOZ_WIDGET_GTK
+#  include "nsIGIOService.h"
+#endif
+
+#ifdef MOZ_WIDGET_COCOA
+#  include <Carbon/Carbon.h>
+#  include "CocoaFileUtils.h"
+#  include "prmem.h"
+#  include "plbase64.h"
+
+static nsresult MacErrorMapper(OSErr inErr);
+#endif
+
+#ifdef MOZ_WIDGET_ANDROID
+#  include "mozilla/java/GeckoAppShellWrappers.h"
+#  include "nsIMIMEService.h"
+#  include <linux/magic.h>
+#endif
+
+#include "nsNativeCharsetUtils.h"
+#include "nsTraceRefcnt.h"
+#include "nsHashKeys.h"
+
+/**
+ *  we need these for statfs()
+ */
+#ifdef HAVE_SYS_STATVFS_H
+#  if defined(__osf__) && defined(__DECCXX)
+extern "C" int statvfs(const char*, struct statvfs*);
+#  endif
+#  include <sys/statvfs.h>
+#endif
+
+#ifdef HAVE_SYS_STATFS_H
+#  include <sys/statfs.h>
+#endif
+
+#ifdef HAVE_SYS_VFS_H
+#  include <sys/vfs.h>
+#endif
+
+#ifdef HAVE_SYS_MOUNT_H
+#  include <sys/param.h>
+#  include <sys/mount.h>
+#endif
+
+#if defined(HAVE_STATVFS64) && (!defined(LINUX) && !defined(__osf__))
+#  define STATFS statvfs64
+#  define F_BSIZE f_frsize
+#elif defined(HAVE_STATVFS) && (!defined(LINUX) && !defined(__osf__))
+#  define STATFS statvfs
+#  define F_BSIZE f_frsize
+#elif defined(HAVE_STATFS64)
+#  define STATFS statfs64
+#  define F_BSIZE f_bsize
+#elif defined(HAVE_STATFS)
+#  define STATFS statfs
+#  define F_BSIZE f_bsize
+#endif
+
+using namespace mozilla;
+
+#define ENSURE_STAT_CACHE()                            \
+  do {                                                 \
+    if (!FillStatCache()) return NSRESULT_FOR_ERRNO(); \
+  } while (0)
+
+#define CHECK_mPath()                                     \
+  do {                                                    \
+    if (mPath.IsEmpty()) return NS_ERROR_NOT_INITIALIZED; \
+    if (!FilePreferences::IsAllowedPath(mPath))           \
+      return NS_ERROR_FILE_ACCESS_DENIED;                 \
+  } while (0)
+
+static PRTime TimespecToMillis(const struct timespec& aTimeSpec) {
+  return PRTime(aTimeSpec.tv_sec) * PR_MSEC_PER_SEC +
+         PRTime(aTimeSpec.tv_nsec) / PR_NSEC_PER_MSEC;
+}
+
+/* directory enumerator */
+class nsDirEnumeratorUnix final : public nsSimpleEnumerator,
+                                  public nsIDirectoryEnumerator {
+ public:
+  nsDirEnumeratorUnix();
+
+  // nsISupports interface
+  NS_DECL_ISUPPORTS_INHERITED
+
+  // nsISimpleEnumerator interface
+  NS_DECL_NSISIMPLEENUMERATOR
+
+  // nsIDirectoryEnumerator interface
+  NS_DECL_NSIDIRECTORYENUMERATOR
+
+  NS_IMETHOD Init(nsLocalFile* aParent, bool aIgnored);
+
+  NS_FORWARD_NSISIMPLEENUMERATORBASE(nsSimpleEnumerator::)
+
+  const nsID& DefaultInterface() override { return NS_GET_IID(nsIFile); }
+
+ private:
+  ~nsDirEnumeratorUnix() override;
+
+ protected:
+  NS_IMETHOD GetNextEntry();
+
+  DIR* mDir;
+  struct dirent* mEntry;
+  nsCString mParentPath;
+};
+
+nsDirEnumeratorUnix::nsDirEnumeratorUnix() : mDir(nullptr), mEntry(nullptr) {}
+
+nsDirEnumeratorUnix::~nsDirEnumeratorUnix() { Close(); }
+
+NS_IMPL_ISUPPORTS_INHERITED(nsDirEnumeratorUnix, nsSimpleEnumerator,
+                            nsIDirectoryEnumerator)
+
+NS_IMETHODIMP
+nsDirEnumeratorUnix::Init(nsLocalFile* aParent,
+                          bool aResolveSymlinks /*ignored*/) {
+  nsAutoCString dirPath;
+  if (NS_FAILED(aParent->GetNativePath(dirPath)) || dirPath.IsEmpty()) {
+    return NS_ERROR_FILE_INVALID_PATH;
+  }
+
+  // When enumerating the directory, the paths must have a slash at the end.
+  nsAutoCString dirPathWithSlash(dirPath);
+  dirPathWithSlash.Append('/');
+  if (!FilePreferences::IsAllowedPath(dirPathWithSlash)) {
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+
+  if (NS_FAILED(aParent->GetNativePath(mParentPath))) {
+    return NS_ERROR_FAILURE;
+  }
+
+  mDir = opendir(dirPath.get());
+  if (!mDir) {
+    return NSRESULT_FOR_ERRNO();
+  }
+  return GetNextEntry();
+}
+
+NS_IMETHODIMP
+nsDirEnumeratorUnix::HasMoreElements(bool* aResult) {
+  *aResult = mDir && mEntry;
+  if (!*aResult) {
+    Close();
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsDirEnumeratorUnix::GetNext(nsISupports** aResult) {
+  nsCOMPtr<nsIFile> file;
+  nsresult rv = GetNextFile(getter_AddRefs(file));
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+  if (!file) {
+    return NS_ERROR_FAILURE;
+  }
+  file.forget(aResult);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsDirEnumeratorUnix::GetNextEntry() {
+  do {
+    errno = 0;
+    mEntry = readdir(mDir);
+
+    // end of dir or error
+    if (!mEntry) {
+      return NSRESULT_FOR_ERRNO();
+    }
+
+    // keep going past "." and ".."
+  } while (mEntry->d_name[0] == '.' &&
+           (mEntry->d_name[1] == '\0' ||                                // .\0
+            (mEntry->d_name[1] == '.' && mEntry->d_name[2] == '\0')));  // ..\0
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsDirEnumeratorUnix::GetNextFile(nsIFile** aResult) {
+  nsresult rv;
+  if (!mDir || !mEntry) {
+    *aResult = nullptr;
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIFile> file = new nsLocalFile();
+
+  if (NS_FAILED(rv = file->InitWithNativePath(mParentPath)) ||
+      NS_FAILED(rv = file->AppendNative(nsDependentCString(mEntry->d_name)))) {
+    return rv;
+  }
+
+  file.forget(aResult);
+  return GetNextEntry();
+}
+
+NS_IMETHODIMP
+nsDirEnumeratorUnix::Close() {
+  if (mDir) {
+    closedir(mDir);
+    mDir = nullptr;
+  }
+  return NS_OK;
+}
+
+nsLocalFile::nsLocalFile() : mCachedStat() {}
+
+nsLocalFile::nsLocalFile(const nsACString& aFilePath) : mCachedStat() {
+  InitWithNativePath(aFilePath);
+}
+
+nsLocalFile::nsLocalFile(const nsLocalFile& aOther) : mPath(aOther.mPath) {}
+
+#ifdef MOZ_WIDGET_COCOA
+NS_IMPL_ISUPPORTS(nsLocalFile, nsILocalFileMac, nsIFile)
+#else
+NS_IMPL_ISUPPORTS(nsLocalFile, nsIFile)
+#endif
+
+nsresult nsLocalFile::nsLocalFileConstructor(const nsIID& aIID,
+                                             void** aInstancePtr) {
+  if (NS_WARN_IF(!aInstancePtr)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  *aInstancePtr = nullptr;
+
+  nsCOMPtr<nsIFile> inst = new nsLocalFile();
+  return inst->QueryInterface(aIID, aInstancePtr);
+}
+
+bool nsLocalFile::FillStatCache() {
+  if (!FilePreferences::IsAllowedPath(mPath)) {
+    errno = EACCES;
+    return false;
+  }
+
+  if (STAT(mPath.get(), &mCachedStat) == -1) {
+    // try lstat it may be a symlink
+    if (LSTAT(mPath.get(), &mCachedStat) == -1) {
+      return false;
+    }
+  }
+  return true;
+}
+
+NS_IMETHODIMP
+nsLocalFile::Clone(nsIFile** aFile) {
+  // Just copy-construct ourselves
+  RefPtr<nsLocalFile> copy = new nsLocalFile(*this);
+  copy.forget(aFile);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::InitWithNativePath(const nsACString& aFilePath) {
+  if (aFilePath.EqualsLiteral("~") ||
+      Substring(aFilePath, 0, 2).EqualsLiteral("~/")) {
+    nsCOMPtr<nsIFile> homeDir;
+    nsAutoCString homePath;
+    if (NS_FAILED(
+            NS_GetSpecialDirectory(NS_OS_HOME_DIR, getter_AddRefs(homeDir))) ||
+        NS_FAILED(homeDir->GetNativePath(homePath))) {
+      return NS_ERROR_FAILURE;
+    }
+
+    mPath = homePath;
+    if (aFilePath.Length() > 2) {
+      mPath.Append(Substring(aFilePath, 1, aFilePath.Length() - 1));
+    }
+  } else {
+    if (aFilePath.IsEmpty() || aFilePath.First() != '/') {
+      return NS_ERROR_FILE_UNRECOGNIZED_PATH;
+    }
+    mPath = aFilePath;
+  }
+
+  if (!FilePreferences::IsAllowedPath(mPath)) {
+    mPath.Truncate();
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+
+  // trim off trailing slashes
+  ssize_t len = mPath.Length();
+  while ((len > 1) && (mPath[len - 1] == '/')) {
+    --len;
+  }
+  mPath.SetLength(len);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::CreateAllAncestors(uint32_t aPermissions) {
+  if (!FilePreferences::IsAllowedPath(mPath)) {
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+
+  // <jband> I promise to play nice
+  char* buffer = mPath.BeginWriting();
+  char* slashp = buffer;
+  int mkdir_result = 0;
+  int mkdir_errno;
+
+#ifdef DEBUG_NSIFILE
+  fprintf(stderr, "nsIFile: before: %s\n", buffer);
+#endif
+
+  while ((slashp = strchr(slashp + 1, '/'))) {
+    /*
+     * Sequences of '/' are equivalent to a single '/'.
+     */
+    if (slashp[1] == '/') {
+      continue;
+    }
+
+    /*
+     * If the path has a trailing slash, don't make the last component,
+     * because we'll get EEXIST in Create when we try to build the final
+     * component again, and it's easier to condition the logic here than
+     * there.
+     */
+    if (slashp[1] == '\0') {
+      break;
+    }
+
+    /* Temporarily NUL-terminate here */
+    *slashp = '\0';
+#ifdef DEBUG_NSIFILE
+    fprintf(stderr, "nsIFile: mkdir(\"%s\")\n", buffer);
+#endif
+    mkdir_result = mkdir(buffer, aPermissions);
+    if (mkdir_result == -1) {
+      mkdir_errno = errno;
+      /*
+       * Always set |errno| to EEXIST if the dir already exists
+       * (we have to do this here since the errno value is not consistent
+       * in all cases - various reasons like different platform,
+       * automounter-controlled dir, etc. can affect it (see bug 125489
+       * for details)).
+       */
+      if (mkdir_errno != EEXIST && access(buffer, F_OK) == 0) {
+        mkdir_errno = EEXIST;
+      }
+#ifdef DEBUG_NSIFILE
+      fprintf(stderr, "nsIFile: errno: %d\n", mkdir_errno);
+#endif
+    }
+
+    /* Put the / back */
+    *slashp = '/';
+  }
+
+  /*
+   * We could get EEXIST for an existing file -- not directory --
+   * but that's OK: we'll get ENOTDIR when we try to make the final
+   * component of the path back in Create and error out appropriately.
+   */
+  if (mkdir_result == -1 && mkdir_errno != EEXIST) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::OpenNSPRFileDesc(int32_t aFlags, int32_t aMode,
+                              PRFileDesc** aResult) {
+  if (!FilePreferences::IsAllowedPath(mPath)) {
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+  *aResult = PR_Open(mPath.get(), aFlags, aMode);
+  if (!*aResult) {
+    return NS_ErrorAccordingToNSPR();
+  }
+
+  if (aFlags & DELETE_ON_CLOSE) {
+    PR_Delete(mPath.get());
+  }
+
+#if defined(HAVE_POSIX_FADVISE)
+  if (aFlags & OS_READAHEAD) {
+    posix_fadvise(PR_FileDesc2NativeHandle(*aResult), 0, 0,
+                  POSIX_FADV_SEQUENTIAL);
+  }
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::OpenANSIFileDesc(const char* aMode, FILE** aResult) {
+  if (!FilePreferences::IsAllowedPath(mPath)) {
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+  *aResult = fopen(mPath.get(), aMode);
+  if (!*aResult) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
+static int do_create(const char* aPath, int aFlags, mode_t aMode,
+                     PRFileDesc** aResult) {
+  *aResult = PR_Open(aPath, aFlags, aMode);
+  return *aResult ? 0 : -1;
+}
+
+static int do_mkdir(const char* aPath, int aFlags, mode_t aMode,
+                    PRFileDesc** aResult) {
+  *aResult = nullptr;
+  return mkdir(aPath, aMode);
+}
+
+nsresult nsLocalFile::CreateAndKeepOpen(uint32_t aType, int aFlags,
+                                        uint32_t aPermissions,
+                                        bool aSkipAncestors,
+                                        PRFileDesc** aResult) {
+  if (!FilePreferences::IsAllowedPath(mPath)) {
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+
+  if (aType != NORMAL_FILE_TYPE && aType != DIRECTORY_TYPE) {
+    return NS_ERROR_FILE_UNKNOWN_TYPE;
+  }
+
+  int (*createFunc)(const char*, int, mode_t, PRFileDesc**) =
+      (aType == NORMAL_FILE_TYPE) ? do_create : do_mkdir;
+
+  int result = createFunc(mPath.get(), aFlags, aPermissions, aResult);
+  if (result == -1 && errno == ENOENT && !aSkipAncestors) {
+    /*
+     * If we failed because of missing ancestor components, try to create
+     * them and then retry the original creation.
+     *
+     * Ancestor directories get the same permissions as the file we're
+     * creating, with the X bit set for each of (user,group,other) with
+     * an R bit in the original permissions.    If you want to do anything
+     * fancy like setgid or sticky bits, do it by hand.
+     */
+    int dirperm = aPermissions;
+    if (aPermissions & S_IRUSR) {
+      dirperm |= S_IXUSR;
+    }
+    if (aPermissions & S_IRGRP) {
+      dirperm |= S_IXGRP;
+    }
+    if (aPermissions & S_IROTH) {
+      dirperm |= S_IXOTH;
+    }
+
+#ifdef DEBUG_NSIFILE
+    fprintf(stderr, "nsIFile: perm = %o, dirperm = %o\n", aPermissions,
+            dirperm);
+#endif
+
+    if (NS_FAILED(CreateAllAncestors(dirperm))) {
+      return NS_ERROR_FAILURE;
+    }
+
+#ifdef DEBUG_NSIFILE
+    fprintf(stderr, "nsIFile: Create(\"%s\") again\n", mPath.get());
+#endif
+    result = createFunc(mPath.get(), aFlags, aPermissions, aResult);
+  }
+  return NSRESULT_FOR_RETURN(result);
+}
+
+NS_IMETHODIMP
+nsLocalFile::Create(uint32_t aType, uint32_t aPermissions,
+                    bool aSkipAncestors) {
+  if (!FilePreferences::IsAllowedPath(mPath)) {
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+
+  PRFileDesc* junk = nullptr;
+  nsresult rv = CreateAndKeepOpen(
+      aType, PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE | PR_EXCL, aPermissions,
+      aSkipAncestors, &junk);
+  if (junk) {
+    PR_Close(junk);
+  }
+  return rv;
+}
+
+NS_IMETHODIMP
+nsLocalFile::AppendNative(const nsACString& aFragment) {
+  if (aFragment.IsEmpty()) {
+    return NS_OK;
+  }
+
+  // only one component of path can be appended and cannot append ".."
+  nsACString::const_iterator begin, end;
+  if (aFragment.EqualsASCII("..") ||
+      FindCharInReadable('/', aFragment.BeginReading(begin),
+                         aFragment.EndReading(end))) {
+    return NS_ERROR_FILE_UNRECOGNIZED_PATH;
+  }
+
+  return AppendRelativeNativePath(aFragment);
+}
+
+NS_IMETHODIMP
+nsLocalFile::AppendRelativeNativePath(const nsACString& aFragment) {
+  if (aFragment.IsEmpty()) {
+    return NS_OK;
+  }
+
+  // No leading '/' and cannot be ".."
+  if (aFragment.First() == '/' || aFragment.EqualsASCII("..")) {
+    return NS_ERROR_FILE_UNRECOGNIZED_PATH;
+  }
+
+  if (aFragment.Contains('/')) {
+    // can't contain .. as a path component. Ensure that the valid components
+    // "foo..foo", "..foo", and "foo.." are not falsely detected,
+    // but the invalid paths "../", "foo/..", "foo/../foo",
+    // "../foo", etc are.
+    constexpr auto doubleDot = "/.."_ns;
+    nsACString::const_iterator start, end, offset;
+    aFragment.BeginReading(start);
+    aFragment.EndReading(end);
+    offset = end;
+    while (FindInReadable(doubleDot, start, offset)) {
+      if (offset == end || *offset == '/') {
+        return NS_ERROR_FILE_UNRECOGNIZED_PATH;
+      }
+      start = offset;
+      offset = end;
+    }
+
+    // catches the remaining cases of prefixes
+    if (StringBeginsWith(aFragment, "../"_ns)) {
+      return NS_ERROR_FILE_UNRECOGNIZED_PATH;
+    }
+  }
+
+  if (!mPath.EqualsLiteral("/")) {
+    mPath.Append('/');
+  }
+  mPath.Append(aFragment);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::Normalize() {
+  char resolved_path[PATH_MAX] = "";
+  char* resolved_path_ptr = nullptr;
+
+  if (!FilePreferences::IsAllowedPath(mPath)) {
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+
+  resolved_path_ptr = realpath(mPath.get(), resolved_path);
+
+  // if there is an error, the return is null.
+  if (!resolved_path_ptr) {
+    return NSRESULT_FOR_ERRNO();
+  }
+
+  mPath = resolved_path;
+  return NS_OK;
+}
+
+void nsLocalFile::LocateNativeLeafName(nsACString::const_iterator& aBegin,
+                                       nsACString::const_iterator& aEnd) {
+  // XXX perhaps we should cache this??
+
+  mPath.BeginReading(aBegin);
+  mPath.EndReading(aEnd);
+
+  nsACString::const_iterator it = aEnd;
+  nsACString::const_iterator stop = aBegin;
+  --stop;
+  while (--it != stop) {
+    if (*it == '/') {
+      aBegin = ++it;
+      return;
+    }
+  }
+  // else, the entire path is the leaf name (which means this
+  // isn't an absolute path... unexpected??)
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetNativeLeafName(nsACString& aLeafName) {
+  nsACString::const_iterator begin, end;
+  LocateNativeLeafName(begin, end);
+  aLeafName = Substring(begin, end);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::SetNativeLeafName(const nsACString& aLeafName) {
+  nsACString::const_iterator begin, end;
+  LocateNativeLeafName(begin, end);
+  mPath.Replace(begin.get() - mPath.get(), Distance(begin, end), aLeafName);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetDisplayName(nsAString& aLeafName) {
+  return GetLeafName(aLeafName);
+}
+
+nsCString nsLocalFile::NativePath() { return mPath; }
+
+nsresult nsIFile::GetNativePath(nsACString& aResult) {
+  aResult = NativePath();
+  return NS_OK;
+}
+
+nsCString nsIFile::HumanReadablePath() {
+  nsCString path;
+  DebugOnly<nsresult> rv = GetNativePath(path);
+  MOZ_ASSERT(NS_SUCCEEDED(rv));
+  return path;
+}
+
+nsresult nsLocalFile::GetNativeTargetPathName(nsIFile* aNewParent,
+                                              const nsACString& aNewName,
+                                              nsACString& aResult) {
+  nsresult rv;
+  nsCOMPtr<nsIFile> oldParent;
+
+  if (!aNewParent) {
+    if (NS_FAILED(rv = GetParent(getter_AddRefs(oldParent)))) {
+      return rv;
+    }
+    aNewParent = oldParent.get();
+  } else {
+    // check to see if our target directory exists
+    bool targetExists;
+    if (NS_FAILED(rv = aNewParent->Exists(&targetExists))) {
+      return rv;
+    }
+
+    if (!targetExists) {
+      // XXX create the new directory with some permissions
+      rv = aNewParent->Create(DIRECTORY_TYPE, 0755);
+      if (NS_FAILED(rv)) {
+        return rv;
+      }
+    } else {
+      // make sure that the target is actually a directory
+      bool targetIsDirectory;
+      if (NS_FAILED(rv = aNewParent->IsDirectory(&targetIsDirectory))) {
+        return rv;
+      }
+      if (!targetIsDirectory) {
+        return NS_ERROR_FILE_DESTINATION_NOT_DIR;
+      }
+    }
+  }
+
+  nsACString::const_iterator nameBegin, nameEnd;
+  if (!aNewName.IsEmpty()) {
+    aNewName.BeginReading(nameBegin);
+    aNewName.EndReading(nameEnd);
+  } else {
+    LocateNativeLeafName(nameBegin, nameEnd);
+  }
+
+  nsAutoCString dirName;
+  if (NS_FAILED(rv = aNewParent->GetNativePath(dirName))) {
+    return rv;
+  }
+
+  aResult = dirName + "/"_ns + Substring(nameBegin, nameEnd);
+  return NS_OK;
+}
+
+nsresult nsLocalFile::CopyDirectoryTo(nsIFile* aNewParent) {
+  nsresult rv;
+  /*
+   * dirCheck is used for various boolean test results such as from Equals,
+   * Exists, isDir, etc.
+   */
+  bool dirCheck, isSymlink;
+  uint32_t oldPerms;
+
+  if (NS_FAILED(rv = IsDirectory(&dirCheck))) {
+    return rv;
+  }
+  if (!dirCheck) {
+    return CopyToNative(aNewParent, ""_ns);
+  }
+
+  if (NS_FAILED(rv = Equals(aNewParent, &dirCheck))) {
+    return rv;
+  }
+  if (dirCheck) {
+    // can't copy dir to itself
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  if (NS_FAILED(rv = aNewParent->Exists(&dirCheck))) {
+    return rv;
+  }
+  // get the dirs old permissions
+  if (NS_FAILED(rv = GetPermissions(&oldPerms))) {
+    return rv;
+  }
+  if (!dirCheck) {
+    if (NS_FAILED(rv = aNewParent->Create(DIRECTORY_TYPE, oldPerms))) {
+      return rv;
+    }
+  } else {  // dir exists lets try to use leaf
+    nsAutoCString leafName;
+    if (NS_FAILED(rv = GetNativeLeafName(leafName))) {
+      return rv;
+    }
+    if (NS_FAILED(rv = aNewParent->AppendNative(leafName))) {
+      return rv;
+    }
+    if (NS_FAILED(rv = aNewParent->Exists(&dirCheck))) {
+      return rv;
+    }
+    if (dirCheck) {
+      return NS_ERROR_FILE_ALREADY_EXISTS;  // dest exists
+    }
+    if (NS_FAILED(rv = aNewParent->Create(DIRECTORY_TYPE, oldPerms))) {
+      return rv;
+    }
+  }
+
+  nsCOMPtr<nsIDirectoryEnumerator> dirIterator;
+  if (NS_FAILED(rv = GetDirectoryEntries(getter_AddRefs(dirIterator)))) {
+    return rv;
+  }
+
+  nsCOMPtr<nsIFile> entry;
+  while (NS_SUCCEEDED(dirIterator->GetNextFile(getter_AddRefs(entry))) &&
+         entry) {
+    if (NS_FAILED(rv = entry->IsSymlink(&isSymlink))) {
+      return rv;
+    }
+    if (NS_FAILED(rv = entry->IsDirectory(&dirCheck))) {
+      return rv;
+    }
+    if (dirCheck && !isSymlink) {
+      nsCOMPtr<nsIFile> destClone;
+      rv = aNewParent->Clone(getter_AddRefs(destClone));
+      if (NS_SUCCEEDED(rv)) {
+        if (NS_FAILED(rv = entry->CopyToNative(destClone, ""_ns))) {
+#ifdef DEBUG
+          nsresult rv2;
+          nsAutoCString pathName;
+          if (NS_FAILED(rv2 = entry->GetNativePath(pathName))) {
+            return rv2;
+          }
+          printf("Operation not supported: %s\n", pathName.get());
+#endif
+          if (rv == NS_ERROR_OUT_OF_MEMORY) {
+            return rv;
+          }
+          continue;
+        }
+      }
+    } else {
+      if (NS_FAILED(rv = entry->CopyToNative(aNewParent, ""_ns))) {
+#ifdef DEBUG
+        nsresult rv2;
+        nsAutoCString pathName;
+        if (NS_FAILED(rv2 = entry->GetNativePath(pathName))) {
+          return rv2;
+        }
+        printf("Operation not supported: %s\n", pathName.get());
+#endif
+        if (rv == NS_ERROR_OUT_OF_MEMORY) {
+          return rv;
+        }
+        continue;
+      }
+    }
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::CopyToNative(nsIFile* aNewParent, const nsACString& aNewName) {
+  nsresult rv;
+  // check to make sure that this has been initialized properly
+  CHECK_mPath();
+
+  // we copy the parent here so 'aNewParent' remains immutable
+  nsCOMPtr<nsIFile> workParent;
+  if (aNewParent) {
+    if (NS_FAILED(rv = aNewParent->Clone(getter_AddRefs(workParent)))) {
+      return rv;
+    }
+  } else {
+    if (NS_FAILED(rv = GetParent(getter_AddRefs(workParent)))) {
+      return rv;
+    }
+  }
+
+  // check to see if we are a directory or if we are a file
+  bool isDirectory;
+  if (NS_FAILED(rv = IsDirectory(&isDirectory))) {
+    return rv;
+  }
+
+  nsAutoCString newPathName;
+  if (isDirectory) {
+    if (!aNewName.IsEmpty()) {
+      if (NS_FAILED(rv = workParent->AppendNative(aNewName))) {
+        return rv;
+      }
+    } else {
+      if (NS_FAILED(rv = GetNativeLeafName(newPathName))) {
+        return rv;
+      }
+      if (NS_FAILED(rv = workParent->AppendNative(newPathName))) {
+        return rv;
+      }
+    }
+    if (NS_FAILED(rv = CopyDirectoryTo(workParent))) {
+      return rv;
+    }
+  } else {
+    rv = GetNativeTargetPathName(workParent, aNewName, newPathName);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+#ifdef DEBUG_blizzard
+    printf("nsLocalFile::CopyTo() %s -> %s\n", mPath.get(), newPathName.get());
+#endif
+
+    // actually create the file.
+    auto* newFile = new nsLocalFile();
+    nsCOMPtr<nsIFile> fileRef(newFile);  // release on exit
+
+    rv = newFile->InitWithNativePath(newPathName);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    // get the old permissions
+    uint32_t myPerms = 0;
+    rv = GetPermissions(&myPerms);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    // Create the new file with the old file's permissions, even if write
+    // permission is missing.  We can't create with write permission and
+    // then change back to myPerm on all filesystems (FAT on Linux, e.g.).
+    // But we can write to a read-only file on all Unix filesystems if we
+    // open it successfully for writing.
+
+    PRFileDesc* newFD;
+    rv = newFile->CreateAndKeepOpen(
+        NORMAL_FILE_TYPE, PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE, myPerms,
+        /* aSkipAncestors = */ false, &newFD);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    // open the old file, too
+    bool specialFile;
+    if (NS_FAILED(rv = IsSpecial(&specialFile))) {
+      PR_Close(newFD);
+      return rv;
+    }
+    if (specialFile) {
+#ifdef DEBUG
+      printf("Operation not supported: %s\n", mPath.get());
+#endif
+      // make sure to clean up properly
+      PR_Close(newFD);
+      return NS_OK;
+    }
+
+#if defined(XP_MACOSX)
+    bool quarantined = true;
+    (void)HasXAttr("com.apple.quarantine"_ns, &quarantined);
+#endif
+
+    PRFileDesc* oldFD;
+    rv = OpenNSPRFileDesc(PR_RDONLY, myPerms, &oldFD);
+    if (NS_FAILED(rv)) {
+      // make sure to clean up properly
+      PR_Close(newFD);
+      return rv;
+    }
+
+#ifdef DEBUG_blizzard
+    int32_t totalRead = 0;
+    int32_t totalWritten = 0;
+#endif
+    char buf[BUFSIZ];
+    int32_t bytesRead;
+
+    // record PR_Write() error for better error message later.
+    nsresult saved_write_error = NS_OK;
+    nsresult saved_read_error = NS_OK;
+    nsresult saved_read_close_error = NS_OK;
+    nsresult saved_write_close_error = NS_OK;
+
+    // DONE: Does PR_Read() return bytesRead < 0 for error?
+    // Yes., The errors from PR_Read are not so common and
+    // the value may not have correspondence in NS_ERROR_*, but
+    // we do catch it still, immediately after while() loop.
+    // We can differentiate errors pf PR_Read and PR_Write by
+    // looking at saved_write_error value. If PR_Write error occurs (and not
+    // PR_Read() error), save_write_error is not NS_OK.
+
+    while ((bytesRead = PR_Read(oldFD, buf, BUFSIZ)) > 0) {
+#ifdef DEBUG_blizzard
+      totalRead += bytesRead;
+#endif
+
+      // PR_Write promises never to do a short write
+      int32_t bytesWritten = PR_Write(newFD, buf, bytesRead);
+      if (bytesWritten < 0) {
+        saved_write_error = NSRESULT_FOR_ERRNO();
+        bytesRead = -1;
+        break;
+      }
+      NS_ASSERTION(bytesWritten == bytesRead, "short PR_Write?");
+
+#ifdef DEBUG_blizzard
+      totalWritten += bytesWritten;
+#endif
+    }
+
+    // TODO/FIXME: If CIFS (and NFS?) may force read/write to return EINTR,
+    // we are better off to prepare for retrying. But we need confirmation if
+    // EINTR is returned.
+
+    // Record error if PR_Read() failed.
+    // Must be done before any other I/O which may reset errno.
+    if (bytesRead < 0 && saved_write_error == NS_OK) {
+      saved_read_error = NSRESULT_FOR_ERRNO();
+    }
+
+#ifdef DEBUG_blizzard
+    printf("read %d bytes, wrote %d bytes\n", totalRead, totalWritten);
+#endif
+
+    // DONE: Errors of close can occur.  Read man page of
+    // close(2);
+    // This is likely to happen if the file system is remote file
+    // system (NFS, CIFS, etc.) and network outage occurs.
+    // At least, we should tell the user that filesystem/disk is
+    // hosed (possibly due to network error, hard disk failure,
+    // etc.) so that users can take remedial action.
+
+    // close the files
+    if (PR_Close(newFD) < 0) {
+      saved_write_close_error = NSRESULT_FOR_ERRNO();
+#if DEBUG
+      // This error merits printing.
+      fprintf(stderr, "ERROR: PR_Close(newFD) returned error. errno = %d\n",
+              errno);
+#endif
+    }
+#if defined(XP_MACOSX)
+    else if (!quarantined) {
+      // If the original file was not in quarantine, lift the quarantine that
+      // file creation added because of LSFileQuarantineEnabled.
+      (void)newFile->DelXAttr("com.apple.quarantine"_ns);
+    }
+#endif  // defined(XP_MACOSX)
+
+    if (PR_Close(oldFD) < 0) {
+      saved_read_close_error = NSRESULT_FOR_ERRNO();
+#if DEBUG
+      fprintf(stderr, "ERROR: PR_Close(oldFD) returned error. errno = %d\n",
+              errno);
+#endif
+    }
+
+    // Let us report the failure to write and read.
+    // check for write/read error after cleaning up
+    if (bytesRead < 0) {
+      if (saved_write_error != NS_OK) {
+        return saved_write_error;
+      }
+      if (saved_read_error != NS_OK) {
+        return saved_read_error;
+      }
+#if DEBUG
+      MOZ_ASSERT(0);
+#endif
+    }
+
+    if (saved_write_close_error != NS_OK) {
+      return saved_write_close_error;
+    }
+    if (saved_read_close_error != NS_OK) {
+      return saved_read_close_error;
+    }
+  }
+  return rv;
+}
+
+NS_IMETHODIMP
+nsLocalFile::CopyToFollowingLinksNative(nsIFile* aNewParent,
+                                        const nsACString& aNewName) {
+  return CopyToNative(aNewParent, aNewName);
+}
+
+NS_IMETHODIMP
+nsLocalFile::MoveToNative(nsIFile* aNewParent, const nsACString& aNewName) {
+  nsresult rv;
+
+  // check to make sure that this has been initialized properly
+  CHECK_mPath();
+
+  // check to make sure that we have a new parent
+  nsAutoCString newPathName;
+  rv = GetNativeTargetPathName(aNewParent, aNewName, newPathName);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  if (!FilePreferences::IsAllowedPath(newPathName)) {
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+
+  // try for atomic rename, falling back to copy/delete
+  if (rename(mPath.get(), newPathName.get()) < 0) {
+    if (errno == EXDEV) {
+      rv = CopyToNative(aNewParent, aNewName);
+      if (NS_SUCCEEDED(rv)) {
+        rv = Remove(true);
+      }
+    } else {
+      rv = NSRESULT_FOR_ERRNO();
+    }
+  }
+
+  if (NS_SUCCEEDED(rv)) {
+    // Adjust this
+    mPath = newPathName;
+  }
+  return rv;
+}
+
+NS_IMETHODIMP
+nsLocalFile::MoveToFollowingLinksNative(nsIFile* aNewParent,
+                                        const nsACString& aNewName) {
+  return MoveToNative(aNewParent, aNewName);
+}
+
+NS_IMETHODIMP
+nsLocalFile::Remove(bool aRecursive) {
+  CHECK_mPath();
+  ENSURE_STAT_CACHE();
+
+  bool isSymLink;
+
+  nsresult rv = IsSymlink(&isSymLink);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  if (isSymLink || !S_ISDIR(mCachedStat.st_mode)) {
+    return NSRESULT_FOR_RETURN(unlink(mPath.get()));
+  }
+
+  if (aRecursive) {
+    auto* dir = new nsDirEnumeratorUnix();
+
+    RefPtr<nsSimpleEnumerator> dirRef(dir);  // release on exit
+
+    rv = dir->Init(this, false);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    bool more;
+    while (NS_SUCCEEDED(dir->HasMoreElements(&more)) && more) {
+      nsCOMPtr<nsISupports> item;
+      rv = dir->GetNext(getter_AddRefs(item));
+      if (NS_FAILED(rv)) {
+        return NS_ERROR_FAILURE;
+      }
+
+      nsCOMPtr<nsIFile> file = do_QueryInterface(item, &rv);
+      if (NS_FAILED(rv)) {
+        return NS_ERROR_FAILURE;
+      }
+      rv = file->Remove(aRecursive);
+
+#ifdef ANDROID
+      // See bug 580434 - Bionic gives us just deleted files
+      if (rv == NS_ERROR_FILE_NOT_FOUND) {
+        continue;
+      }
+#endif
+      if (NS_FAILED(rv)) {
+        return rv;
+      }
+    }
+  }
+
+  return NSRESULT_FOR_RETURN(rmdir(mPath.get()));
+}
+
+nsresult nsLocalFile::GetLastModifiedTimeImpl(PRTime* aLastModTime,
+                                              bool aFollowLinks) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aLastModTime)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  using StatFn = int (*)(const char*, struct STAT*);
+  StatFn statFn = aFollowLinks ? &STAT : &LSTAT;
+
+  struct STAT fileStats {};
+  if (statFn(mPath.get(), &fileStats) < 0) {
+    return NSRESULT_FOR_ERRNO();
+  }
+
+#if (defined(__APPLE__) && defined(__MACH__))
+  *aLastModTime = TimespecToMillis(fileStats.st_mtimespec);
+#else
+  *aLastModTime = TimespecToMillis(fileStats.st_mtim);
+#endif
+
+  return NS_OK;
+}
+
+nsresult nsLocalFile::SetLastModifiedTimeImpl(PRTime aLastModTime,
+                                              bool aFollowLinks) {
+  CHECK_mPath();
+
+  using UtimesFn = int (*)(const char*, const timeval*);
+  UtimesFn utimesFn = &utimes;
+
+#if HAVE_LUTIMES
+  if (!aFollowLinks) {
+    utimesFn = &lutimes;
+  }
+#endif
+
+  int result;
+  if (aLastModTime != 0) {
+    ENSURE_STAT_CACHE();
+    timeval access{};
+#if (defined(__APPLE__) && defined(__MACH__))
+    access.tv_sec = mCachedStat.st_atimespec.tv_sec;
+    access.tv_usec = mCachedStat.st_atimespec.tv_nsec / 1000;
+#else
+    access.tv_sec = mCachedStat.st_atim.tv_sec;
+    access.tv_usec = mCachedStat.st_atim.tv_nsec / 1000;
+#endif
+    timeval modification{};
+    modification.tv_sec = aLastModTime / PR_MSEC_PER_SEC;
+    modification.tv_usec = (aLastModTime % PR_MSEC_PER_SEC) * PR_USEC_PER_MSEC;
+
+    timeval times[2];
+    times[0] = access;
+    times[1] = modification;
+    result = utimesFn(mPath.get(), times);
+  } else {
+    result = utimesFn(mPath.get(), nullptr);
+  }
+  return NSRESULT_FOR_RETURN(result);
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetLastModifiedTime(PRTime* aLastModTime) {
+  return GetLastModifiedTimeImpl(aLastModTime, /* follow links? */ true);
+}
+
+NS_IMETHODIMP
+nsLocalFile::SetLastModifiedTime(PRTime aLastModTime) {
+  return SetLastModifiedTimeImpl(aLastModTime, /* follow links ? */ true);
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetLastModifiedTimeOfLink(PRTime* aLastModTimeOfLink) {
+  return GetLastModifiedTimeImpl(aLastModTimeOfLink, /* follow link? */ false);
+}
+
+NS_IMETHODIMP
+nsLocalFile::SetLastModifiedTimeOfLink(PRTime aLastModTimeOfLink) {
+  return SetLastModifiedTimeImpl(aLastModTimeOfLink, /* follow links? */ false);
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetCreationTime(PRTime* aCreationTime) {
+  return GetCreationTimeImpl(aCreationTime, false);
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetCreationTimeOfLink(PRTime* aCreationTimeOfLink) {
+  return GetCreationTimeImpl(aCreationTimeOfLink, /* aFollowLinks = */ true);
+}
+
+nsresult nsLocalFile::GetCreationTimeImpl(PRTime* aCreationTime,
+                                          bool aFollowLinks) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aCreationTime)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+#if defined(_DARWIN_FEATURE_64_BIT_INODE)
+  using StatFn = int (*)(const char*, struct STAT*);
+  StatFn statFn = aFollowLinks ? &STAT : &LSTAT;
+
+  struct STAT fileStats {};
+  if (statFn(mPath.get(), &fileStats) < 0) {
+    return NSRESULT_FOR_ERRNO();
+  }
+
+  *aCreationTime = TimespecToMillis(fileStats.st_birthtimespec);
+  return NS_OK;
+#else
+  return NS_ERROR_NOT_IMPLEMENTED;
+#endif
+}
+
+/*
+ * Only send back permissions bits: maybe we want to send back the whole
+ * mode_t to permit checks against other file types?
+ */
+
+#define NORMALIZE_PERMS(mode) ((mode) & (S_IRWXU | S_IRWXG | S_IRWXO))
+
+NS_IMETHODIMP
+nsLocalFile::GetPermissions(uint32_t* aPermissions) {
+  if (NS_WARN_IF(!aPermissions)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  ENSURE_STAT_CACHE();
+  *aPermissions = NORMALIZE_PERMS(mCachedStat.st_mode);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetPermissionsOfLink(uint32_t* aPermissionsOfLink) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aPermissionsOfLink)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  struct STAT sbuf;
+  if (LSTAT(mPath.get(), &sbuf) == -1) {
+    return NSRESULT_FOR_ERRNO();
+  }
+  *aPermissionsOfLink = NORMALIZE_PERMS(sbuf.st_mode);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::SetPermissions(uint32_t aPermissions) {
+  CHECK_mPath();
+
+  /*
+   * Race condition here: we should use fchmod instead, there's no way to
+   * guarantee the name still refers to the same file.
+   */
+  if (chmod(mPath.get(), aPermissions) >= 0) {
+    return NS_OK;
+  }
+#if defined(ANDROID) && defined(STATFS)
+  // For the time being, this is restricted for use by Android, but we
+  // will figure out what to do for all platforms in bug 638503
+  struct STATFS sfs;
+  if (STATFS(mPath.get(), &sfs) < 0) {
+    return NSRESULT_FOR_ERRNO();
+  }
+
+  // if this is a FAT file system we can't set file permissions
+  if (sfs.f_type == MSDOS_SUPER_MAGIC) {
+    return NS_OK;
+  }
+#endif
+  return NSRESULT_FOR_ERRNO();
+}
+
+NS_IMETHODIMP
+nsLocalFile::SetPermissionsOfLink(uint32_t aPermissions) {
+  // There isn't a consistent mechanism for doing this on UNIX platforms. We
+  // might want to carefully implement this in the future though.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetFileSize(int64_t* aFileSize) {
+  if (NS_WARN_IF(!aFileSize)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  *aFileSize = 0;
+  ENSURE_STAT_CACHE();
+
+  if (!S_ISDIR(mCachedStat.st_mode)) {
+    *aFileSize = (int64_t)mCachedStat.st_size;
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::SetFileSize(int64_t aFileSize) {
+  CHECK_mPath();
+
+#if defined(ANDROID)
+  /* no truncate on bionic */
+  int fd = open(mPath.get(), O_WRONLY);
+  if (fd == -1) {
+    return NSRESULT_FOR_ERRNO();
+  }
+
+  int ret = ftruncate(fd, (off_t)aFileSize);
+  close(fd);
+
+  if (ret == -1) {
+    return NSRESULT_FOR_ERRNO();
+  }
+#elif defined(HAVE_TRUNCATE64)
+  if (truncate64(mPath.get(), (off64_t)aFileSize) == -1) {
+    return NSRESULT_FOR_ERRNO();
+  }
+#else
+  off_t size = (off_t)aFileSize;
+  if (truncate(mPath.get(), size) == -1) {
+    return NSRESULT_FOR_ERRNO();
+  }
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetFileSizeOfLink(int64_t* aFileSize) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aFileSize)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  struct STAT sbuf;
+  if (LSTAT(mPath.get(), &sbuf) == -1) {
+    return NSRESULT_FOR_ERRNO();
+  }
+
+  *aFileSize = (int64_t)sbuf.st_size;
+  return NS_OK;
+}
+
+#if defined(USE_LINUX_QUOTACTL)
+/*
+ * Searches /proc/self/mountinfo for given device (Major:Minor),
+ * returns exported name from /dev
+ *
+ * Fails when /proc/self/mountinfo or diven device don't exist.
+ */
+static bool GetDeviceName(unsigned int aDeviceMajor, unsigned int aDeviceMinor,
+                          nsACString& aDeviceName) {
+  bool ret = false;
+
+  const int kMountInfoLineLength = 200;
+  const int kMountInfoDevPosition = 6;
+
+  char mountinfoLine[kMountInfoLineLength];
+  char deviceNum[kMountInfoLineLength];
+
+  SprintfLiteral(deviceNum, "%u:%u", aDeviceMajor, aDeviceMinor);
+
+  FILE* f = fopen("/proc/self/mountinfo", "rt");
+  if (!f) {
+    return ret;
+  }
+
+  // Expects /proc/self/mountinfo in format:
+  // 'ID ID major:minor root mountpoint flags - type devicename flags'
+  while (fgets(mountinfoLine, kMountInfoLineLength, f)) {
+    char* p_dev = strstr(mountinfoLine, deviceNum);
+
+    for (int i = 0; i < kMountInfoDevPosition && p_dev; ++i) {
+      p_dev = strchr(p_dev, ' ');
+      if (p_dev) {
+        p_dev++;
+      }
+    }
+
+    if (p_dev) {
+      char* p_dev_end = strchr(p_dev, ' ');
+      if (p_dev_end) {
+        *p_dev_end = '\0';
+        aDeviceName.Assign(p_dev);
+        ret = true;
+        break;
+      }
+    }
+  }
+
+  fclose(f);
+  return ret;
+}
+#endif
+
+#if defined(USE_LINUX_QUOTACTL)
+template <typename StatInfoFunc, typename QuotaInfoFunc>
+nsresult nsLocalFile::GetDiskInfo(StatInfoFunc&& aStatInfoFunc,
+                                  QuotaInfoFunc&& aQuotaInfoFunc,
+                                  int64_t* aResult)
+#else
+template <typename StatInfoFunc>
+nsresult nsLocalFile::GetDiskInfo(StatInfoFunc&& aStatInfoFunc,
+                                  int64_t* aResult)
+#endif
+{
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  // These systems have the operations necessary to check disk space.
+
+#ifdef STATFS
+
+  // check to make sure that mPath is properly initialized
+  CHECK_mPath();
+
+  struct STATFS fs_buf;
+
+  /*
+   * Members of the STATFS struct that you should know about:
+   * F_BSIZE = block size on disk.
+   * f_bavail = number of free blocks available to a non-superuser.
+   * f_bfree = number of total free blocks in file system.
+   * f_blocks = number of total used or free blocks in file system.
+   */
+
+  if (STATFS(mPath.get(), &fs_buf) < 0) {
+    // The call to STATFS failed.
+#  ifdef DEBUG
+    printf("ERROR: GetDiskInfo: STATFS call FAILED. \n");
+#  endif
+    return NS_ERROR_FAILURE;
+  }
+
+  CheckedInt64 checkedResult;
+
+  checkedResult = std::forward<StatInfoFunc>(aStatInfoFunc)(fs_buf);
+  if (!checkedResult.isValid()) {
+    return NS_ERROR_FAILURE;
+  }
+
+  *aResult = checkedResult.value();
+
+#  ifdef DEBUG_DISK_SPACE
+  printf("DiskInfo: %lu bytes\n", *aResult);
+#  endif
+
+#  if defined(USE_LINUX_QUOTACTL)
+
+  if (!FillStatCache()) {
+    // Return info from statfs
+    return NS_OK;
+  }
+
+  nsCString deviceName;
+  if (!GetDeviceName(major(mCachedStat.st_dev), minor(mCachedStat.st_dev),
+                     deviceName)) {
+    return NS_OK;
+  }
+
+  struct dqblk dq;
+  if (!quotactl(QCMD(Q_GETQUOTA, USRQUOTA), deviceName.get(), getuid(),
+                (caddr_t)&dq)
+#    ifdef QIF_BLIMITS
+      && dq.dqb_valid & QIF_BLIMITS
+#    endif
+      && dq.dqb_bhardlimit) {
+    checkedResult = std::forward<QuotaInfoFunc>(aQuotaInfoFunc)(dq);
+    if (!checkedResult.isValid()) {
+      return NS_ERROR_FAILURE;
+    }
+
+    if (checkedResult.value() < *aResult) {
+      *aResult = checkedResult.value();
+    }
+  }
+#  endif
+
+  return NS_OK;
+
+#else
+  /*
+   * This platform doesn't have statfs or statvfs.  I'm sure that there's
+   * a way to check for free disk space and disk capacity on platforms that
+   * don't have statfs (I'm SURE they have df, for example).
+   *
+   * Until we figure out how to do that, lets be honest and say that this
+   * command isn't implemented properly for these platforms yet.
+   */
+#  ifdef DEBUG
+  printf("ERROR: GetDiskInfo: Not implemented for plaforms without statfs.\n");
+#  endif
+  return NS_ERROR_NOT_IMPLEMENTED;
+
+#endif /* STATFS */
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetDiskSpaceAvailable(int64_t* aDiskSpaceAvailable) {
+  return GetDiskInfo(
+      [](const struct STATFS& aStatInfo) {
+        return aStatInfo.f_bavail * static_cast<uint64_t>(aStatInfo.F_BSIZE);
+      },
+#if defined(USE_LINUX_QUOTACTL)
+      [](const struct dqblk& aQuotaInfo) -> uint64_t {
+        // dqb_bhardlimit is count of BLOCK_SIZE blocks, dqb_curspace is bytes
+        const uint64_t hardlimit = aQuotaInfo.dqb_bhardlimit * BLOCK_SIZE;
+        if (hardlimit > aQuotaInfo.dqb_curspace) {
+          return hardlimit - aQuotaInfo.dqb_curspace;
+        }
+        return 0;
+      },
+#endif
+      aDiskSpaceAvailable);
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetDiskCapacity(int64_t* aDiskCapacity) {
+  return GetDiskInfo(
+      [](const struct STATFS& aStatInfo) {
+        return aStatInfo.f_blocks * static_cast<uint64_t>(aStatInfo.F_BSIZE);
+      },
+#if defined(USE_LINUX_QUOTACTL)
+      [](const struct dqblk& aQuotaInfo) {
+        // dqb_bhardlimit is count of BLOCK_SIZE blocks
+        return aQuotaInfo.dqb_bhardlimit * BLOCK_SIZE;
+      },
+#endif
+      aDiskCapacity);
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetParent(nsIFile** aParent) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aParent)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  *aParent = nullptr;
+
+  // if '/' we are at the top of the volume, return null
+  if (mPath.EqualsLiteral("/")) {
+    return NS_OK;
+  }
+
+  // <brendan, after jband> I promise to play nice
+  char* buffer = mPath.BeginWriting();
+  // find the last significant slash in buffer
+  char* slashp = strrchr(buffer, '/');
+  NS_ASSERTION(slashp, "non-canonical path?");
+  if (!slashp) {
+    return NS_ERROR_FILE_INVALID_PATH;
+  }
+
+  // for the case where we are at '/'
+  if (slashp == buffer) {
+    slashp++;
+  }
+
+  // temporarily terminate buffer at the last significant slash
+  char c = *slashp;
+  *slashp = '\0';
+
+  nsCOMPtr<nsIFile> localFile;
+  nsresult rv = NS_NewNativeLocalFile(nsDependentCString(buffer), true,
+                                      getter_AddRefs(localFile));
+
+  // make buffer whole again
+  *slashp = c;
+
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  localFile.forget(aParent);
+  return NS_OK;
+}
+
+/*
+ * The results of Exists, isWritable and isReadable are not cached.
+ */
+
+NS_IMETHODIMP
+nsLocalFile::Exists(bool* aResult) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  *aResult = (access(mPath.get(), F_OK) == 0);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::IsWritable(bool* aResult) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  *aResult = (access(mPath.get(), W_OK) == 0);
+  if (*aResult || errno == EACCES) {
+    return NS_OK;
+  }
+  return NSRESULT_FOR_ERRNO();
+}
+
+NS_IMETHODIMP
+nsLocalFile::IsReadable(bool* aResult) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  *aResult = (access(mPath.get(), R_OK) == 0);
+  if (*aResult || errno == EACCES) {
+    return NS_OK;
+  }
+  return NSRESULT_FOR_ERRNO();
+}
+
+NS_IMETHODIMP
+nsLocalFile::IsExecutable(bool* aResult) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  // Check extension (bug 663899). On certain platforms, the file
+  // extension may cause the OS to treat it as executable regardless of
+  // the execute bit, such as .jar on Mac OS X. We borrow the code from
+  // nsLocalFileWin, slightly modified.
+
+  // Don't be fooled by symlinks.
+  bool symLink;
+  nsresult rv = IsSymlink(&symLink);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  nsAutoString path;
+  if (symLink) {
+    GetTarget(path);
+  } else {
+    GetPath(path);
+  }
+
+  int32_t dotIdx = path.RFindChar(char16_t('.'));
+  if (dotIdx != kNotFound) {
+    // Convert extension to lower case.
+    char16_t* p = path.BeginWriting();
+    for (p += dotIdx + 1; *p; ++p) {
+      *p += (*p >= L'A' && *p <= L'Z') ? 'a' - 'A' : 0;
+    }
+
+    // Search for any of the set of executable extensions.
+    static const char* const executableExts[] = {
+        "air",  // Adobe AIR installer
+#ifdef MOZ_WIDGET_COCOA
+        "fileloc",  // File location files can be used to point to other
+                    // files.
+        "inetloc",  // Shouldn't be able to do the same, but can, due to
+                    // macOS vulnerabilities.
+#endif
+        "jar"  // java application bundle
+    };
+    nsDependentSubstring ext = Substring(path, dotIdx + 1);
+    for (auto executableExt : executableExts) {
+      if (ext.EqualsASCII(executableExt)) {
+        // Found a match.  Set result and quit.
+        *aResult = true;
+        return NS_OK;
+      }
+    }
+  }
+
+  // On OS X, then query Launch Services.
+#ifdef MOZ_WIDGET_COCOA
+  // Certain Mac applications, such as Classic applications, which
+  // run under Rosetta, might not have the +x mode bit but are still
+  // considered to be executable by Launch Services (bug 646748).
+  CFURLRef url;
+  if (NS_FAILED(GetCFURL(&url))) {
+    return NS_ERROR_FAILURE;
+  }
+
+  LSRequestedInfo theInfoRequest = kLSRequestAllInfo;
+  LSItemInfoRecord theInfo;
+  OSStatus result = ::LSCopyItemInfoForURL(url, theInfoRequest, &theInfo);
+  ::CFRelease(url);
+  if (result == noErr) {
+    if ((theInfo.flags & kLSItemInfoIsApplication) != 0) {
+      *aResult = true;
+      return NS_OK;
+    }
+  }
+#endif
+
+  // Then check the execute bit.
+  *aResult = (access(mPath.get(), X_OK) == 0);
+#ifdef SOLARIS
+  // On Solaris, access will always return 0 for root user, however
+  // the file is only executable if S_IXUSR | S_IXGRP | S_IXOTH is set.
+  // See bug 351950, https://bugzilla.mozilla.org/show_bug.cgi?id=351950
+  if (*aResult) {
+    struct STAT buf;
+
+    *aResult = (STAT(mPath.get(), &buf) == 0);
+    if (*aResult || errno == EACCES) {
+      *aResult = *aResult && (buf.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH));
+      return NS_OK;
+    }
+
+    return NSRESULT_FOR_ERRNO();
+  }
+#endif
+  if (*aResult || errno == EACCES) {
+    return NS_OK;
+  }
+  return NSRESULT_FOR_ERRNO();
+}
+
+NS_IMETHODIMP
+nsLocalFile::IsDirectory(bool* aResult) {
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  *aResult = false;
+  ENSURE_STAT_CACHE();
+  *aResult = S_ISDIR(mCachedStat.st_mode);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::IsFile(bool* aResult) {
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  *aResult = false;
+  ENSURE_STAT_CACHE();
+  *aResult = S_ISREG(mCachedStat.st_mode);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::IsHidden(bool* aResult) {
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  nsACString::const_iterator begin, end;
+  LocateNativeLeafName(begin, end);
+  *aResult = (*begin == '.');
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::IsSymlink(bool* aResult) {
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  CHECK_mPath();
+
+  struct STAT symStat;
+  if (LSTAT(mPath.get(), &symStat) == -1) {
+    return NSRESULT_FOR_ERRNO();
+  }
+  *aResult = S_ISLNK(symStat.st_mode);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::IsSpecial(bool* aResult) {
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  ENSURE_STAT_CACHE();
+  *aResult = S_ISCHR(mCachedStat.st_mode) || S_ISBLK(mCachedStat.st_mode) ||
+#ifdef S_ISSOCK
+             S_ISSOCK(mCachedStat.st_mode) ||
+#endif
+             S_ISFIFO(mCachedStat.st_mode);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::Equals(nsIFile* aInFile, bool* aResult) {
+  if (NS_WARN_IF(!aInFile)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  *aResult = false;
+
+  nsAutoCString inPath;
+  nsresult rv = aInFile->GetNativePath(inPath);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  // We don't need to worry about "/foo/" vs. "/foo" here
+  // because trailing slashes are stripped on init.
+  *aResult = !strcmp(inPath.get(), mPath.get());
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::Contains(nsIFile* aInFile, bool* aResult) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aInFile)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  nsAutoCString inPath;
+  nsresult rv;
+
+  if (NS_FAILED(rv = aInFile->GetNativePath(inPath))) {
+    return rv;
+  }
+
+  *aResult = false;
+
+  ssize_t len = mPath.Length();
+  if (strncmp(mPath.get(), inPath.get(), len) == 0) {
+    // Now make sure that the |aInFile|'s path has a separator at len,
+    // which implies that it has more components after len.
+    if (inPath[len] == '/') {
+      *aResult = true;
+    }
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetNativeTarget(nsACString& aResult) {
+  CHECK_mPath();
+  aResult.Truncate();
+
+  struct STAT symStat;
+  if (LSTAT(mPath.get(), &symStat) == -1) {
+    return NSRESULT_FOR_ERRNO();
+  }
+
+  if (!S_ISLNK(symStat.st_mode)) {
+    return NS_ERROR_FILE_INVALID_PATH;
+  }
+
+  int32_t size = (int32_t)symStat.st_size;
+  nsAutoCString target;
+  if (!target.SetLength(size, mozilla::fallible)) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  if (readlink(mPath.get(), target.BeginWriting(), (size_t)size) < 0) {
+    return NSRESULT_FOR_ERRNO();
+  }
+
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIFile> self(this);
+  int32_t maxLinks = 40;
+  while (true) {
+    if (maxLinks-- == 0) {
+      rv = NS_ERROR_FILE_UNRESOLVABLE_SYMLINK;
+      break;
+    }
+
+    if (target[0] != '/') {
+      nsCOMPtr<nsIFile> parent;
+      if (NS_FAILED(rv = self->GetParent(getter_AddRefs(parent)))) {
+        break;
+      }
+      if (NS_FAILED(rv = parent->AppendRelativeNativePath(target))) {
+        break;
+      }
+      if (NS_FAILED(rv = parent->GetNativePath(aResult))) {
+        break;
+      }
+      self = parent;
+    } else {
+      aResult = target;
+    }
+
+    const nsPromiseFlatCString& flatRetval = PromiseFlatCString(aResult);
+
+    // Any failure in testing the current target we'll just interpret
+    // as having reached our destiny.
+    if (LSTAT(flatRetval.get(), &symStat) == -1) {
+      break;
+    }
+
+    // And of course we're done if it isn't a symlink.
+    if (!S_ISLNK(symStat.st_mode)) {
+      break;
+    }
+
+    int32_t newSize = (int32_t)symStat.st_size;
+    size = newSize;
+    nsAutoCString newTarget;
+    if (!newTarget.SetLength(size, mozilla::fallible)) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+      break;
+    }
+
+    int32_t linkLen =
+        readlink(flatRetval.get(), newTarget.BeginWriting(), size);
+    if (linkLen == -1) {
+      rv = NSRESULT_FOR_ERRNO();
+      break;
+    }
+    target = newTarget;
+  }
+
+  if (NS_FAILED(rv)) {
+    aResult.Truncate();
+  }
+  return rv;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetDirectoryEntriesImpl(nsIDirectoryEnumerator** aEntries) {
+  RefPtr<nsDirEnumeratorUnix> dir = new nsDirEnumeratorUnix();
+
+  nsresult rv = dir->Init(this, false);
+  if (NS_FAILED(rv)) {
+    *aEntries = nullptr;
+  } else {
+    dir.forget(aEntries);
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+nsLocalFile::Load(PRLibrary** aResult) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+  nsTraceRefcnt::SetActivityIsLegal(false);
+#endif
+
+  *aResult = PR_LoadLibrary(mPath.get());
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+  nsTraceRefcnt::SetActivityIsLegal(true);
+#endif
+
+  if (!*aResult) {
+    return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetPersistentDescriptor(nsACString& aPersistentDescriptor) {
+  return GetNativePath(aPersistentDescriptor);
+}
+
+NS_IMETHODIMP
+nsLocalFile::SetPersistentDescriptor(const nsACString& aPersistentDescriptor) {
+#ifdef MOZ_WIDGET_COCOA
+  if (aPersistentDescriptor.IsEmpty()) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  // Support pathnames as user-supplied descriptors if they begin with '/'
+  // or '~'.  These characters do not collide with the base64 set used for
+  // encoding alias records.
+  char first = aPersistentDescriptor.First();
+  if (first == '/' || first == '~') {
+    return InitWithNativePath(aPersistentDescriptor);
+  }
+
+  uint32_t dataSize = aPersistentDescriptor.Length();
+  char* decodedData = PL_Base64Decode(
+      PromiseFlatCString(aPersistentDescriptor).get(), dataSize, nullptr);
+  if (!decodedData) {
+    NS_ERROR("SetPersistentDescriptor was given bad data");
+    return NS_ERROR_FAILURE;
+  }
+
+  // Cast to an alias record and resolve.
+  AliasRecord aliasHeader = *(AliasPtr)decodedData;
+  int32_t aliasSize = ::GetAliasSizeFromPtr(&aliasHeader);
+  if (aliasSize >
+      ((int32_t)dataSize * 3) / 4) {  // be paranoid about having too few data
+    PR_Free(decodedData);             // PL_Base64Decode() uses PR_Malloc().
+    return NS_ERROR_FAILURE;
+  }
+
+  nsresult rv = NS_OK;
+
+  // Move the now-decoded data into the Handle.
+  // The size of the decoded data is 3/4 the size of the encoded data. See
+  // plbase64.h
+  Handle newHandle = nullptr;
+  if (::PtrToHand(decodedData, &newHandle, aliasSize) != noErr) {
+    rv = NS_ERROR_OUT_OF_MEMORY;
+  }
+  PR_Free(decodedData);  // PL_Base64Decode() uses PR_Malloc().
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  Boolean changed;
+  FSRef resolvedFSRef;
+  OSErr err = ::FSResolveAlias(nullptr, (AliasHandle)newHandle, &resolvedFSRef,
+                               &changed);
+
+  rv = MacErrorMapper(err);
+  DisposeHandle(newHandle);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  return InitWithFSRef(&resolvedFSRef);
+#else
+  return InitWithNativePath(aPersistentDescriptor);
+#endif
+}
+
+NS_IMETHODIMP
+nsLocalFile::Reveal() {
+  if (!FilePreferences::IsAllowedPath(mPath)) {
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+
+#ifdef MOZ_WIDGET_GTK
+  nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
+  if (!giovfs) {
+    return NS_ERROR_FAILURE;
+  }
+  return giovfs->RevealFile(this);
+#elif defined(MOZ_WIDGET_COCOA)
+  CFURLRef url;
+  if (NS_SUCCEEDED(GetCFURL(&url))) {
+    nsresult rv = CocoaFileUtils::RevealFileInFinder(url);
+    ::CFRelease(url);
+    return rv;
+  }
+  return NS_ERROR_FAILURE;
+#else
+  return NS_ERROR_FAILURE;
+#endif
+}
+
+NS_IMETHODIMP
+nsLocalFile::Launch() {
+  if (!FilePreferences::IsAllowedPath(mPath)) {
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+
+#ifdef MOZ_WIDGET_GTK
+  nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
+  if (!giovfs) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return giovfs->LaunchFile(mPath);
+#elif defined(MOZ_WIDGET_ANDROID)
+  // Not supported on GeckoView
+  return NS_ERROR_NOT_IMPLEMENTED;
+#elif defined(MOZ_WIDGET_COCOA)
+  CFURLRef url;
+  if (NS_SUCCEEDED(GetCFURL(&url))) {
+    nsresult rv = CocoaFileUtils::OpenURL(url);
+    ::CFRelease(url);
+    return rv;
+  }
+  return NS_ERROR_FAILURE;
+#else
+  return NS_ERROR_FAILURE;
+#endif
+}
+
+nsresult NS_NewNativeLocalFile(const nsACString& aPath, bool aFollowSymlinks,
+                               nsIFile** aResult) {
+  RefPtr<nsLocalFile> file = new nsLocalFile();
+
+  if (!aPath.IsEmpty()) {
+    nsresult rv = file->InitWithNativePath(aPath);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+  }
+  file.forget(aResult);
+  return NS_OK;
+}
+
+//-----------------------------------------------------------------------------
+// unicode support
+//-----------------------------------------------------------------------------
+
+#define SET_UCS(func, ucsArg)                          \
+  {                                                    \
+    nsAutoCString buf;                                 \
+    nsresult rv = NS_CopyUnicodeToNative(ucsArg, buf); \
+    if (NS_FAILED(rv)) return rv;                      \
+    return (func)(buf);                                \
+  }
+
+#define GET_UCS(func, ucsArg)                   \
+  {                                             \
+    nsAutoCString buf;                          \
+    nsresult rv = (func)(buf);                  \
+    if (NS_FAILED(rv)) return rv;               \
+    return NS_CopyNativeToUnicode(buf, ucsArg); \
+  }
+
+#define SET_UCS_2ARGS_2(func, opaqueArg, ucsArg)       \
+  {                                                    \
+    nsAutoCString buf;                                 \
+    nsresult rv = NS_CopyUnicodeToNative(ucsArg, buf); \
+    if (NS_FAILED(rv)) return rv;                      \
+    return (func)(opaqueArg, buf);                     \
+  }
+
+// Unicode interface Wrapper
+nsresult nsLocalFile::InitWithPath(const nsAString& aFilePath) {
+  SET_UCS(InitWithNativePath, aFilePath);
+}
+nsresult nsLocalFile::Append(const nsAString& aNode) {
+  SET_UCS(AppendNative, aNode);
+}
+nsresult nsLocalFile::AppendRelativePath(const nsAString& aNode) {
+  SET_UCS(AppendRelativeNativePath, aNode);
+}
+nsresult nsLocalFile::GetLeafName(nsAString& aLeafName) {
+  GET_UCS(GetNativeLeafName, aLeafName);
+}
+nsresult nsLocalFile::SetLeafName(const nsAString& aLeafName) {
+  SET_UCS(SetNativeLeafName, aLeafName);
+}
+nsresult nsLocalFile::GetPath(nsAString& aResult) {
+  return NS_CopyNativeToUnicode(mPath, aResult);
+}
+nsresult nsLocalFile::CopyTo(nsIFile* aNewParentDir,
+                             const nsAString& aNewName) {
+  SET_UCS_2ARGS_2(CopyToNative, aNewParentDir, aNewName);
+}
+nsresult nsLocalFile::CopyToFollowingLinks(nsIFile* aNewParentDir,
+                                           const nsAString& aNewName) {
+  SET_UCS_2ARGS_2(CopyToFollowingLinksNative, aNewParentDir, aNewName);
+}
+nsresult nsLocalFile::MoveTo(nsIFile* aNewParentDir,
+                             const nsAString& aNewName) {
+  SET_UCS_2ARGS_2(MoveToNative, aNewParentDir, aNewName);
+}
+NS_IMETHODIMP
+nsLocalFile::MoveToFollowingLinks(nsIFile* aNewParentDir,
+                                  const nsAString& aNewName) {
+  SET_UCS_2ARGS_2(MoveToFollowingLinksNative, aNewParentDir, aNewName);
+}
+
+NS_IMETHODIMP
+nsLocalFile::RenameTo(nsIFile* aNewParentDir, const nsAString& aNewName) {
+  SET_UCS_2ARGS_2(RenameToNative, aNewParentDir, aNewName);
+}
+
+NS_IMETHODIMP
+nsLocalFile::RenameToNative(nsIFile* aNewParentDir,
+                            const nsACString& aNewName) {
+  nsresult rv;
+
+  // check to make sure that this has been initialized properly
+  CHECK_mPath();
+
+  // check to make sure that we have a new parent
+  nsAutoCString newPathName;
+  rv = GetNativeTargetPathName(aNewParentDir, aNewName, newPathName);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  if (!FilePreferences::IsAllowedPath(newPathName)) {
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  }
+
+  // try for atomic rename
+  if (rename(mPath.get(), newPathName.get()) < 0) {
+    if (errno == EXDEV) {
+      rv = NS_ERROR_FILE_ACCESS_DENIED;
+    } else {
+      rv = NSRESULT_FOR_ERRNO();
+    }
+  }
+
+  return rv;
+}
+
+nsresult nsLocalFile::GetTarget(nsAString& aResult) {
+  GET_UCS(GetNativeTarget, aResult);
+}
+
+nsresult NS_NewLocalFile(const nsAString& aPath, bool aFollowLinks,
+                         nsIFile** aResult) {
+  nsAutoCString buf;
+  nsresult rv = NS_CopyUnicodeToNative(aPath, buf);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+  return NS_NewNativeLocalFile(buf, aFollowLinks, aResult);
+}
+
+// nsILocalFileMac
+
+#ifdef MOZ_WIDGET_COCOA
+
+NS_IMETHODIMP
+nsLocalFile::HasXAttr(const nsACString& aAttrName, bool* aHasAttr) {
+  NS_ENSURE_ARG_POINTER(aHasAttr);
+
+  nsAutoCString attrName{aAttrName};
+
+  ssize_t size = getxattr(mPath.get(), attrName.get(), nullptr, 0, 0, 0);
+  if (size == -1) {
+    if (errno == ENOATTR) {
+      *aHasAttr = false;
+    } else {
+      return NSRESULT_FOR_ERRNO();
+    }
+  } else {
+    *aHasAttr = true;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetXAttr(const nsACString& aAttrName,
+                      nsTArray<uint8_t>& aAttrValue) {
+  aAttrValue.Clear();
+
+  nsAutoCString attrName{aAttrName};
+
+  ssize_t size = getxattr(mPath.get(), attrName.get(), nullptr, 0, 0, 0);
+
+  if (size == -1) {
+    return NSRESULT_FOR_ERRNO();
+  }
+
+  for (;;) {
+    aAttrValue.SetCapacity(size);
+
+    // The attribute can change between our first call and this call, so we need
+    // to re-check the size and possibly call with a larger buffer.
+    ssize_t newSize = getxattr(mPath.get(), attrName.get(),
+                               aAttrValue.Elements(), size, 0, 0);
+    if (newSize == -1) {
+      return NSRESULT_FOR_ERRNO();
+    }
+
+    if (newSize <= size) {
+      aAttrValue.SetLength(newSize);
+      break;
+    } else {
+      size = newSize;
+    }
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::SetXAttr(const nsACString& aAttrName,
+                      const nsTArray<uint8_t>& aAttrValue) {
+  nsAutoCString attrName{aAttrName};
+
+  if (setxattr(mPath.get(), attrName.get(), aAttrValue.Elements(),
+               aAttrValue.Length(), 0, 0) == -1) {
+    return NSRESULT_FOR_ERRNO();
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::DelXAttr(const nsACString& aAttrName) {
+  nsAutoCString attrName{aAttrName};
+
+  // Ignore removing an attribute that does not exist.
+  if (removexattr(mPath.get(), attrName.get(), 0) == -1) {
+    return NSRESULT_FOR_ERRNO();
+  }
+
+  return NS_OK;
+}
+
+static nsresult MacErrorMapper(OSErr inErr) {
+  nsresult outErr;
+
+  switch (inErr) {
+    case noErr:
+      outErr = NS_OK;
+      break;
+
+    case fnfErr:
+    case afpObjectNotFound:
+    case afpDirNotFound:
+      outErr = NS_ERROR_FILE_NOT_FOUND;
+      break;
+
+    case dupFNErr:
+    case afpObjectExists:
+      outErr = NS_ERROR_FILE_ALREADY_EXISTS;
+      break;
+
+    case dskFulErr:
+    case afpDiskFull:
+      outErr = NS_ERROR_FILE_NO_DEVICE_SPACE;
+      break;
+
+    case fLckdErr:
+    case afpVolLocked:
+      outErr = NS_ERROR_FILE_IS_LOCKED;
+      break;
+
+    case afpAccessDenied:
+      outErr = NS_ERROR_FILE_ACCESS_DENIED;
+      break;
+
+    case afpDirNotEmpty:
+      outErr = NS_ERROR_FILE_DIR_NOT_EMPTY;
+      break;
+
+    // Can't find good map for some
+    case bdNamErr:
+      outErr = NS_ERROR_FAILURE;
+      break;
+
+    default:
+      outErr = NS_ERROR_FAILURE;
+      break;
+  }
+
+  return outErr;
+}
+
+static nsresult CFStringReftoUTF8(CFStringRef aInStrRef, nsACString& aOutStr) {
+  // first see if the conversion would succeed and find the length of the
+  // result
+  CFIndex usedBufLen, inStrLen = ::CFStringGetLength(aInStrRef);
+  CFIndex charsConverted = ::CFStringGetBytes(
+      aInStrRef, CFRangeMake(0, inStrLen), kCFStringEncodingUTF8, 0, false,
+      nullptr, 0, &usedBufLen);
+  if (charsConverted == inStrLen) {
+    // all characters converted, do the actual conversion
+    aOutStr.SetLength(usedBufLen);
+    if (aOutStr.Length() != (unsigned int)usedBufLen) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    UInt8* buffer = (UInt8*)aOutStr.BeginWriting();
+    ::CFStringGetBytes(aInStrRef, CFRangeMake(0, inStrLen),
+                       kCFStringEncodingUTF8, 0, false, buffer, usedBufLen,
+                       &usedBufLen);
+    return NS_OK;
+  }
+
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsLocalFile::InitWithCFURL(CFURLRef aCFURL) {
+  UInt8 path[PATH_MAX];
+  if (::CFURLGetFileSystemRepresentation(aCFURL, true, path, PATH_MAX)) {
+    nsDependentCString nativePath((char*)path);
+    return InitWithNativePath(nativePath);
+  }
+
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsLocalFile::InitWithFSRef(const FSRef* aFSRef) {
+  if (NS_WARN_IF(!aFSRef)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  CFURLRef newURLRef = ::CFURLCreateFromFSRef(kCFAllocatorDefault, aFSRef);
+  if (newURLRef) {
+    nsresult rv = InitWithCFURL(newURLRef);
+    ::CFRelease(newURLRef);
+    return rv;
+  }
+
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetCFURL(CFURLRef* aResult) {
+  CHECK_mPath();
+
+  bool isDir;
+  IsDirectory(&isDir);
+  *aResult = ::CFURLCreateFromFileSystemRepresentation(
+      kCFAllocatorDefault, (UInt8*)mPath.get(), mPath.Length(), isDir);
+
+  return (*aResult ? NS_OK : NS_ERROR_FAILURE);
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetFSRef(FSRef* aResult) {
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  nsresult rv = NS_ERROR_FAILURE;
+
+  CFURLRef url = nullptr;
+  if (NS_SUCCEEDED(GetCFURL(&url))) {
+    if (::CFURLGetFSRef(url, aResult)) {
+      rv = NS_OK;
+    }
+    ::CFRelease(url);
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetFSSpec(FSSpec* aResult) {
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  FSRef fsRef;
+  nsresult rv = GetFSRef(&fsRef);
+  if (NS_SUCCEEDED(rv)) {
+    OSErr err = ::FSGetCatalogInfo(&fsRef, kFSCatInfoNone, nullptr, nullptr,
+                                   aResult, nullptr);
+    return MacErrorMapper(err);
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetFileSizeWithResFork(int64_t* aFileSizeWithResFork) {
+  if (NS_WARN_IF(!aFileSizeWithResFork)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  FSRef fsRef;
+  nsresult rv = GetFSRef(&fsRef);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  FSCatalogInfo catalogInfo;
+  OSErr err =
+      ::FSGetCatalogInfo(&fsRef, kFSCatInfoDataSizes + kFSCatInfoRsrcSizes,
+                         &catalogInfo, nullptr, nullptr, nullptr);
+  if (err != noErr) {
+    return MacErrorMapper(err);
+  }
+
+  *aFileSizeWithResFork =
+      catalogInfo.dataLogicalSize + catalogInfo.rsrcLogicalSize;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetFileType(OSType* aFileType) {
+  CFURLRef url;
+  if (NS_SUCCEEDED(GetCFURL(&url))) {
+    nsresult rv = CocoaFileUtils::GetFileTypeCode(url, aFileType);
+    ::CFRelease(url);
+    return rv;
+  }
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsLocalFile::SetFileType(OSType aFileType) {
+  CFURLRef url;
+  if (NS_SUCCEEDED(GetCFURL(&url))) {
+    nsresult rv = CocoaFileUtils::SetFileTypeCode(url, aFileType);
+    ::CFRelease(url);
+    return rv;
+  }
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetFileCreator(OSType* aFileCreator) {
+  CFURLRef url;
+  if (NS_SUCCEEDED(GetCFURL(&url))) {
+    nsresult rv = CocoaFileUtils::GetFileCreatorCode(url, aFileCreator);
+    ::CFRelease(url);
+    return rv;
+  }
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsLocalFile::SetFileCreator(OSType aFileCreator) {
+  CFURLRef url;
+  if (NS_SUCCEEDED(GetCFURL(&url))) {
+    nsresult rv = CocoaFileUtils::SetFileCreatorCode(url, aFileCreator);
+    ::CFRelease(url);
+    return rv;
+  }
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsLocalFile::LaunchWithDoc(nsIFile* aDocToLoad, bool aLaunchInBackground) {
+  bool isExecutable;
+  nsresult rv = IsExecutable(&isExecutable);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+  if (!isExecutable) {
+    return NS_ERROR_FILE_EXECUTION_FAILED;
+  }
+
+  FSRef appFSRef, docFSRef;
+  rv = GetFSRef(&appFSRef);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  if (aDocToLoad) {
+    nsCOMPtr<nsILocalFileMac> macDoc = do_QueryInterface(aDocToLoad);
+    rv = macDoc->GetFSRef(&docFSRef);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+  }
+
+  LSLaunchFlags theLaunchFlags = kLSLaunchDefaults;
+  LSLaunchFSRefSpec thelaunchSpec;
+
+  if (aLaunchInBackground) {
+    theLaunchFlags |= kLSLaunchDontSwitch;
+  }
+  memset(&thelaunchSpec, 0, sizeof(LSLaunchFSRefSpec));
+
+  thelaunchSpec.appRef = &appFSRef;
+  if (aDocToLoad) {
+    thelaunchSpec.numDocs = 1;
+    thelaunchSpec.itemRefs = &docFSRef;
+  }
+  thelaunchSpec.launchFlags = theLaunchFlags;
+
+  OSErr err = ::LSOpenFromRefSpec(&thelaunchSpec, nullptr);
+  if (err != noErr) {
+    return MacErrorMapper(err);
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::OpenDocWithApp(nsIFile* aAppToOpenWith, bool aLaunchInBackground) {
+  FSRef docFSRef;
+  nsresult rv = GetFSRef(&docFSRef);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  if (!aAppToOpenWith) {
+    OSErr err = ::LSOpenFSRef(&docFSRef, nullptr);
+    return MacErrorMapper(err);
+  }
+
+  nsCOMPtr<nsILocalFileMac> appFileMac = do_QueryInterface(aAppToOpenWith, &rv);
+  if (!appFileMac) {
+    return rv;
+  }
+
+  bool isExecutable;
+  rv = appFileMac->IsExecutable(&isExecutable);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+  if (!isExecutable) {
+    return NS_ERROR_FILE_EXECUTION_FAILED;
+  }
+
+  FSRef appFSRef;
+  rv = appFileMac->GetFSRef(&appFSRef);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  LSLaunchFlags theLaunchFlags = kLSLaunchDefaults;
+  LSLaunchFSRefSpec thelaunchSpec;
+
+  if (aLaunchInBackground) {
+    theLaunchFlags |= kLSLaunchDontSwitch;
+  }
+  memset(&thelaunchSpec, 0, sizeof(LSLaunchFSRefSpec));
+
+  thelaunchSpec.appRef = &appFSRef;
+  thelaunchSpec.numDocs = 1;
+  thelaunchSpec.itemRefs = &docFSRef;
+  thelaunchSpec.launchFlags = theLaunchFlags;
+
+  OSErr err = ::LSOpenFromRefSpec(&thelaunchSpec, nullptr);
+  if (err != noErr) {
+    return MacErrorMapper(err);
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::IsPackage(bool* aResult) {
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  *aResult = false;
+
+  CFURLRef url;
+  nsresult rv = GetCFURL(&url);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  LSItemInfoRecord info;
+  OSStatus status =
+      ::LSCopyItemInfoForURL(url, kLSRequestBasicFlagsOnly, &info);
+
+  ::CFRelease(url);
+
+  if (status != noErr) {
+    return NS_ERROR_FAILURE;
+  }
+
+  *aResult = !!(info.flags & kLSItemInfoIsPackage);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetBundleDisplayName(nsAString& aOutBundleName) {
+  bool isPackage = false;
+  nsresult rv = IsPackage(&isPackage);
+  if (NS_FAILED(rv) || !isPackage) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsAutoString name;
+  rv = GetLeafName(name);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  int32_t length = name.Length();
+  if (Substring(name, length - 4, length).EqualsLiteral(".app")) {
+    // 4 characters in ".app"
+    aOutBundleName = Substring(name, 0, length - 4);
+  } else {
+    aOutBundleName = name;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetBundleIdentifier(nsACString& aOutBundleIdentifier) {
+  nsresult rv = NS_ERROR_FAILURE;
+
+  CFURLRef urlRef;
+  if (NS_SUCCEEDED(GetCFURL(&urlRef))) {
+    CFBundleRef bundle = ::CFBundleCreate(nullptr, urlRef);
+    if (bundle) {
+      CFStringRef bundleIdentifier = ::CFBundleGetIdentifier(bundle);
+      if (bundleIdentifier) {
+        rv = CFStringReftoUTF8(bundleIdentifier, aOutBundleIdentifier);
+      }
+      ::CFRelease(bundle);
+    }
+    ::CFRelease(urlRef);
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+nsLocalFile::GetBundleContentsLastModifiedTime(int64_t* aLastModTime) {
+  CHECK_mPath();
+  if (NS_WARN_IF(!aLastModTime)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  bool isPackage = false;
+  nsresult rv = IsPackage(&isPackage);
+  if (NS_FAILED(rv) || !isPackage) {
+    return GetLastModifiedTime(aLastModTime);
+  }
+
+  nsAutoCString infoPlistPath(mPath);
+  infoPlistPath.AppendLiteral("/Contents/Info.plist");
+  PRFileInfo64 info;
+  if (PR_GetFileInfo64(infoPlistPath.get(), &info) != PR_SUCCESS) {
+    return GetLastModifiedTime(aLastModTime);
+  }
+  int64_t modTime = int64_t(info.modifyTime);
+  if (modTime == 0) {
+    *aLastModTime = 0;
+  } else {
+    *aLastModTime = modTime / int64_t(PR_USEC_PER_MSEC);
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsLocalFile::InitWithFile(nsIFile* aFile) {
+  if (NS_WARN_IF(!aFile)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  nsAutoCString nativePath;
+  nsresult rv = aFile->GetNativePath(nativePath);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  return InitWithNativePath(nativePath);
+}
+
+nsresult NS_NewLocalFileWithFSRef(const FSRef* aFSRef, bool aFollowLinks,
+                                  nsILocalFileMac** aResult) {
+  RefPtr<nsLocalFile> file = new nsLocalFile();
+
+  nsresult rv = file->InitWithFSRef(aFSRef);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+  file.forget(aResult);
+  return NS_OK;
+}
+
+nsresult NS_NewLocalFileWithCFURL(const CFURLRef aURL, bool aFollowLinks,
+                                  nsILocalFileMac** aResult) {
+  RefPtr<nsLocalFile> file = new nsLocalFile();
+
+  nsresult rv = file->InitWithCFURL(aURL);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+  file.forget(aResult);
+  return NS_OK;
+}
+
+#endif
-- 
2.37.0

