
# HG changeset patch
# User stransky <stransky@redhat.com>
# Date 1654763840 0
# Node ID f9c796ae5117065116947d61b8fe2bcae1f6b78c
# Parent  12142d005f41be34d021ff2ae7ee01c565abef46
Bug 1735929 [Linux] Use EGL_MESA_image_dma_buf_export in SharedSurfaceDMABUF r=jgilbert,aosmond

- Update SharedSurfaceDMABUF for EGL_MESA_image_dma_buf_export DMABufSurface interface.
- Test surface export and import in SurfaceFactory_DMABUF::CanCreateSurface() to make sure it really works.

Depends on D147636

Differential Revision: https://phabricator.services.mozilla.com/D147637

diff --git a/gfx/gl/SharedSurfaceDMABUF.cpp b/gfx/gl/SharedSurfaceDMABUF.cpp
--- a/gfx/gl/SharedSurfaceDMABUF.cpp
+++ b/gfx/gl/SharedSurfaceDMABUF.cpp
@@ -7,32 +7,47 @@
 
 #include "gfxPlatform.h"
 #include "GLContextEGL.h"
 #include "MozFramebuffer.h"
 #include "mozilla/layers/LayersSurfaces.h"  // for SurfaceDescriptor, etc
 
 namespace mozilla::gl {
 
+static bool HasDmaBufExtensions(const GLContextEGL* gl) {
+  const auto& egl = *(gl->mEgl);
+  return egl.IsExtensionSupported(EGLExtension::EXT_image_dma_buf_import) &&
+         egl.IsExtensionSupported(
+             EGLExtension::EXT_image_dma_buf_import_modifiers) &&
+         egl.IsExtensionSupported(EGLExtension::MESA_image_dma_buf_export);
+}
+
 /*static*/
 UniquePtr<SharedSurface_DMABUF> SharedSurface_DMABUF::Create(
     const SharedSurfaceDesc& desc) {
-  const auto flags = static_cast<DMABufSurfaceFlags>(
-      DMABUF_TEXTURE | DMABUF_USE_MODIFIERS | DMABUF_ALPHA);
-  const RefPtr<DMABufSurface> surface = DMABufSurfaceRGBA::CreateDMABufSurface(
-      desc.size.width, desc.size.height, flags);
-  if (!surface || !surface->CreateTexture(desc.gl)) {
+  const auto& gle = GLContextEGL::Cast(desc.gl);
+  const auto& context = gle->mContext;
+  const auto& egl = *(gle->mEgl);
+
+  if (!HasDmaBufExtensions(gle)) {
     return nullptr;
   }
 
-  const auto tex = surface->GetTexture();
-  auto fb = MozFramebuffer::CreateForBacking(desc.gl, desc.size, 0, false,
-                                             LOCAL_GL_TEXTURE_2D, tex);
+  auto fb = MozFramebuffer::Create(desc.gl, desc.size, 0, false);
   if (!fb) return nullptr;
 
+  const auto buffer = reinterpret_cast<EGLClientBuffer>(fb->ColorTex());
+  const auto image =
+      egl.fCreateImage(context, LOCAL_EGL_GL_TEXTURE_2D, buffer, nullptr);
+  if (!image) return nullptr;
+
+  const RefPtr<DMABufSurface> surface = DMABufSurfaceRGBA::CreateDMABufSurface(
+      desc.gl, image, desc.size.width, desc.size.height);
+  if (!surface) return nullptr;
+
   return AsUnique(new SharedSurface_DMABUF(desc, std::move(fb), surface));
 }
 
 SharedSurface_DMABUF::SharedSurface_DMABUF(const SharedSurfaceDesc& desc,
                                            UniquePtr<MozFramebuffer> fb,
                                            const RefPtr<DMABufSurface> surface)
     : SharedSurface(desc, std::move(fb)), mSurface(surface) {}
 
@@ -56,23 +71,53 @@ Maybe<layers::SurfaceDescriptor> SharedS
 
 /*static*/
 UniquePtr<SurfaceFactory_DMABUF> SurfaceFactory_DMABUF::Create(GLContext& gl) {
   if (!widget::GetDMABufDevice()->IsDMABufWebGLEnabled()) {
     return nullptr;
   }
 
   auto dmabufFactory = MakeUnique<SurfaceFactory_DMABUF>(gl);
-  if (dmabufFactory->CanCreateSurface()) {
+  if (dmabufFactory->CanCreateSurface(gl)) {
     return dmabufFactory;
   }
 
   LOGDMABUF(
       ("SurfaceFactory_DMABUF::Create() failed, fallback to SW buffers.\n"));
   widget::GetDMABufDevice()->DisableDMABufWebGL();
   return nullptr;
 }
 
+bool SurfaceFactory_DMABUF::CanCreateSurface(GLContext& gl) {
+  UniquePtr<SharedSurface> test =
+      CreateShared(gfx::IntSize(1, 1), gfx::ColorSpace2::SRGB);
+  if (!test) {
+    LOGDMABUF((
+        "SurfaceFactory_DMABUF::CanCreateSurface() failed to create surface."));
+    return false;
+  }
+  auto desc = test->ToSurfaceDescriptor();
+  if (!desc) {
+    LOGDMABUF(
+        ("SurfaceFactory_DMABUF::CanCreateSurface() failed to serialize "
+         "surface."));
+    return false;
+  }
+  RefPtr<DMABufSurface> importedSurface =
+      DMABufSurface::CreateDMABufSurface(*desc);
+  if (!importedSurface) {
+    LOGDMABUF((
+        "SurfaceFactory_DMABUF::CanCreateSurface() failed to import surface."));
+    return false;
+  }
+  if (!importedSurface->CreateTexture(&gl)) {
+    LOGDMABUF(
+        ("SurfaceFactory_DMABUF::CanCreateSurface() failed to create texture "
+         "over surface."));
+    return false;
+  }
+  return true;
+}
+
 SurfaceFactory_DMABUF::SurfaceFactory_DMABUF(GLContext& gl)
     : SurfaceFactory({&gl, SharedSurfaceType::EGLSurfaceDMABUF,
                       layers::TextureType::DMABUF, true}) {}
-
 }  // namespace mozilla::gl
diff --git a/gfx/gl/SharedSurfaceDMABUF.h b/gfx/gl/SharedSurfaceDMABUF.h
--- a/gfx/gl/SharedSurfaceDMABUF.h
+++ b/gfx/gl/SharedSurfaceDMABUF.h
@@ -54,20 +54,16 @@ class SurfaceFactory_DMABUF : public Sur
   explicit SurfaceFactory_DMABUF(GLContext&);
 
  public:
   virtual UniquePtr<SharedSurface> CreateSharedImpl(
       const SharedSurfaceDesc& desc) override {
     return SharedSurface_DMABUF::Create(desc);
   }
 
-  bool CanCreateSurface() {
-    UniquePtr<SharedSurface> test =
-        CreateShared(gfx::IntSize(1, 1), gfx::ColorSpace2::SRGB);
-    return test != nullptr;
-  }
+  bool CanCreateSurface(GLContext& gl);
 };
 
 }  // namespace gl
 
 }  // namespace mozilla
 
 #endif /* SHARED_SURFACE_DMABUF_H_ */

